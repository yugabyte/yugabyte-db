/*
* Copyright 2022 YugaByte, Inc. and Contributors
*
* Licensed under the Polyform Free Trial License 1.0.0 (the "License"); you
* may not use this file except in compliance with the License. You
* may obtain a copy of the License at
*
http://github.com/YugaByte/yugabyte-db/blob/master/licenses/POLYFORM-FREE-TRIAL-LICENSE-1.0.0.txt
*/
package com.yugabyte.yw.common;

import com.google.common.base.Stopwatch;
import java.time.Duration;
import java.util.concurrent.CancellationException;
import java.util.function.Predicate;
import java.util.function.Supplier;

/**
 * This utility helps in retrying a task until a stop condition is met, or a timeout is reached,
 * whichever is earlier.
 */
public class RetryTaskUntilCondition<T> {
  private Supplier<T> task;
  private Predicate<T> stopCondition;

  public RetryTaskUntilCondition(Supplier<T> task, Predicate<T> stopCondition) {
    this.stopCondition = stopCondition;
    this.task = task;
  }

  // Retries the given task and finally returns true if the task stopped due to meeting the given
  // stop condition and not due to a timeout.
  public boolean retryUntilCond(long delayBetweenRetrySecs, long timeoutSecs) {
    T result = task.get();
    boolean stopRetry = stopCondition.test(result);

    long timeElapsedMs = System.currentTimeMillis() + (timeoutSecs * 1000);
    while (!stopRetry && System.currentTimeMillis() < timeElapsedMs) {
      try {
        Thread.sleep(delayBetweenRetrySecs * 1000);
      } catch (InterruptedException e) {
        throw new CancellationException(e.getMessage());
      }
      result = task.get();
      stopRetry = stopCondition.test(result);
    }

    return stopRetry;
  }

  /*
   * Returns a <T> object, performing a task until stop condition is met, performing an exponential
   *   backoff whenever stop condition is not met
   *
   * @param initialDelaySecs the initial timeout in seconds we wait before performing subsequent
   *    calls for the task
   * @param maxDelaySecs the maximum delay in seconds we wait before retrying the task
   * @param timeoutSecs the max timeout in seconds we wait before erroring out
   * @return the object T generated by the task
   */
  public T retryWithBackoff(long initialDelaySecs, long maxDelaySecs, long timeoutSecs) {
    int iterationNum = 0;
    T result;
    Stopwatch stopwatch = Stopwatch.createStarted();
    while (true) {
      Duration currentElapsedTime = stopwatch.elapsed();
      if (currentElapsedTime.compareTo(Duration.ofSeconds(timeoutSecs)) > 0) {
        throw new RuntimeException(
            String.format(
                "Timing out after %d iterations for a duration of %d seconds, greater than max "
                    + "timeout of %d secs. Failing...",
                iterationNum, currentElapsedTime.getSeconds(), timeoutSecs));
      }
      result = task.get();
      if (stopCondition.test(result)) {
        break;
      }
      try {
        Thread.sleep(
            Util.getExponentialBackoffDelayMs(
                initialDelaySecs * 1000, maxDelaySecs * 1000, iterationNum));
        iterationNum++;
      } catch (InterruptedException e) {
        throw new RuntimeException("Unexpected interrupt", e);
      }
    }
    return result;
  }
}
