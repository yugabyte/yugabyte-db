--
-- YB REINDEX test
--
\getenv abs_srcdir PG_ABS_SRCDIR
\set filename :abs_srcdir '/yb_commands/explainrun.sql'
\i :filename
-- A helper script to explain and run a query.  Use in regress tests by
-- defining :explain, :query, and optionally :hint#.
\set explain1 ':explain :hint1 :query;'
\set explain2 ':explain1 :explain :hint2 :query;'
\set explain3 ':explain2 :explain :hint3 :query;'
\set explain4 ':explain3 :explain :hint4 :query;'
\set explain5 ':explain4 :explain :hint5 :query;'
\set explain1run1 ':explain1; :hint1 :query;'
\set explain2run2 ':explain2; :hint1 :query; :hint2 :query;'
\set explain3run3 ':explain3; :hint1 :query; :hint2 :query; :hint3 :query;'
\set explain4run4 ':explain4; :hint1 :query; :hint2 :query; :hint3 :query; :hint4 :query;'
\set explain5run5 ':explain5; :hint1 :query; :hint2 :query; :hint3 :query; :hint4 :query; :hint5 :query;'
-- Default to no hints.
\set hint1 ''
\set hint2 ''
\set hint3 ''
\set hint4 ''
\set hint5 ''
\set explain 'EXPLAIN (costs off)'
--
-- PART 0: Init
--
SET yb_enable_create_with_table_oid TO on;
CREATE TABLE yb (i int PRIMARY KEY, j int) WITH (table_oid = 54321);
CREATE INDEX NONCONCURRENTLY ON yb (j);
UPDATE pg_index SET indisvalid = false
    WHERE indexrelid = 'pg_class_oid_index'::regclass;
UPDATE pg_index SET indisvalid = false
    WHERE indexrelid = 'pg_depend_depender_index'::regclass;
UPDATE pg_index SET indisvalid = false
    WHERE indexrelid = 'yb_j_idx'::regclass;
SELECT oid AS db_oid FROM pg_database WHERE datname = (
    SELECT CASE
        WHEN COUNT(*) = 1 THEN 'template1'
        ELSE current_database() END FROM pg_yb_catalog_version) \gset
SELECT
$force_cache_refresh$
SET yb_non_ddl_txn_for_sys_tables_allowed TO on;
UPDATE pg_yb_catalog_version
   SET current_version       = current_version + 1,
       last_breaking_version = current_version + 1
 WHERE db_oid = :db_oid;
RESET yb_non_ddl_txn_for_sys_tables_allowed;
DO
$$
BEGIN
    PERFORM pg_sleep(5);
END;
$$;
$force_cache_refresh$ AS force_cache_refresh \gset
-- Force cache refresh.  The UPDATE pg_yb_catalog_version trick doesn't seem to
-- work for pg_depend_depender_index, but updating the pg_yb_catalog_version
-- and then reconnecting does (simply reconnecting doesn't result in a cache
-- refresh when the tserver response cache is enabled). Since reconnecting
-- releases temp tables, do this refresh first before creating temp tables.
:force_cache_refresh
\c
CREATE TEMP TABLE tmp (i int PRIMARY KEY, j int);
CREATE INDEX ON tmp (j);
SELECT relname FROM pg_class c JOIN pg_index i on c.oid = i.indexrelid
    WHERE indisvalid = false;
         relname          
--------------------------
 pg_class_oid_index
 pg_depend_depender_index
 yb_j_idx
(3 rows)

--
-- PART 1: simple REINDEX on system catalog, temporary, and yb objects
--
-- REINDEX SYSTEM/DATABASE expects current database name.
SELECT current_database();
 current_database 
------------------
 yugabyte
(1 row)

REINDEX SYSTEM yugabyte; -- current database
ERROR:  REINDEX SCHEMA/DATABASE/SYSTEM not supported yet
LINE 1: REINDEX SYSTEM yugabyte;
        ^
HINT:  Please report the issue on https://github.com/YugaByte/yugabyte-db/issues
REINDEX SYSTEM template0; -- different database
ERROR:  REINDEX SCHEMA/DATABASE/SYSTEM not supported yet
LINE 1: REINDEX SYSTEM template0;
        ^
HINT:  Please report the issue on https://github.com/YugaByte/yugabyte-db/issues
REINDEX DATABASE yugabyte; -- current database
ERROR:  REINDEX SCHEMA/DATABASE/SYSTEM not supported yet
LINE 1: REINDEX DATABASE yugabyte;
        ^
HINT:  Please report the issue on https://github.com/YugaByte/yugabyte-db/issues
REINDEX DATABASE template0; -- different database
ERROR:  REINDEX SCHEMA/DATABASE/SYSTEM not supported yet
LINE 1: REINDEX DATABASE template0;
        ^
HINT:  Please report the issue on https://github.com/YugaByte/yugabyte-db/issues
REINDEX SCHEMA pg_catalog;
ERROR:  REINDEX SCHEMA/DATABASE/SYSTEM not supported yet
LINE 1: REINDEX SCHEMA pg_catalog;
        ^
HINT:  Please report the issue on https://github.com/YugaByte/yugabyte-db/issues
REINDEX SCHEMA pg_temp;
ERROR:  REINDEX SCHEMA/DATABASE/SYSTEM not supported yet
LINE 1: REINDEX SCHEMA pg_temp;
        ^
HINT:  Please report the issue on https://github.com/YugaByte/yugabyte-db/issues
REINDEX SCHEMA public;
ERROR:  REINDEX SCHEMA/DATABASE/SYSTEM not supported yet
LINE 1: REINDEX SCHEMA public;
        ^
HINT:  Please report the issue on https://github.com/YugaByte/yugabyte-db/issues
REINDEX TABLE pg_class; -- system table with pk
ERROR:  REINDEX TABLE not supported yet
LINE 1: REINDEX TABLE pg_class;
                ^
HINT:  Please report the issue on https://github.com/YugaByte/yugabyte-db/issues
REINDEX TABLE pg_depend; -- system table without pk
ERROR:  REINDEX TABLE not supported yet
LINE 1: REINDEX TABLE pg_depend;
                ^
HINT:  Please report the issue on https://github.com/YugaByte/yugabyte-db/issues
REINDEX TABLE tmp;
ERROR:  REINDEX TABLE not supported yet
LINE 1: REINDEX TABLE tmp;
                ^
HINT:  Please report the issue on https://github.com/YugaByte/yugabyte-db/issues
REINDEX TABLE yb;
ERROR:  REINDEX TABLE not supported yet
LINE 1: REINDEX TABLE yb;
                ^
HINT:  Please report the issue on https://github.com/YugaByte/yugabyte-db/issues
REINDEX INDEX pg_class_oid_index; -- system pk index
ERROR:  cannot reindex nontemporary pk indexes
DETAIL:  Primary key indexes share the same storage as their table for Yugabyte-backed relations.
REINDEX INDEX pg_depend_depender_index; -- system secondary index
REINDEX INDEX tmp_pkey;
REINDEX INDEX tmp_j_idx;
REINDEX INDEX yb_pkey;
ERROR:  cannot reindex nontemporary pk indexes
DETAIL:  Primary key indexes share the same storage as their table for Yugabyte-backed relations.
REINDEX INDEX yb_j_idx;
-- Any rebuilt indexes should now be public.
SELECT relname FROM pg_class c JOIN pg_index i on c.oid = i.indexrelid
    WHERE indisvalid = false;
      relname       
--------------------
 pg_class_oid_index
(1 row)

--
-- PART 2: scans before/after REINDEX
--
INSERT INTO yb SELECT g, -g FROM generate_series(1, 10) g;
INSERT INTO tmp SELECT g, -g FROM generate_series(1, 10) g;
-- 1. initial state
\set hint1 '/*+SeqScan(pg_depend) */'
\set hint2 '/*+IndexScan(pg_depend_depender_index) */'
SELECT $$
SELECT deptype FROM pg_depend
    WHERE classid = 'pg_class'::regclass and objid = 'yb'::regclass
$$ AS query \gset
:explain2run2
                               QUERY PLAN                               
------------------------------------------------------------------------
 Seq Scan on pg_depend
   Storage Filter: ((classid = '1259'::oid) AND (objid = '54321'::oid))
(2 rows)

                             QUERY PLAN                             
--------------------------------------------------------------------
 Index Scan using pg_depend_depender_index on pg_depend
   Index Cond: ((classid = '1259'::oid) AND (objid = '54321'::oid))
(2 rows)

 deptype 
---------
 n
(1 row)

 deptype 
---------
 n
(1 row)

\set hint1 '/*+SeqScan(tmp) */'
\set hint2 '/*+IndexScan(tmp_j_idx) Set(enable_bitmapscan on) */'
\set query 'SELECT i FROM tmp WHERE j = -5'
:explain2run2
          QUERY PLAN           
-------------------------------
 Seq Scan on tmp
   Filter: (j = '-5'::integer)
(2 rows)

               QUERY PLAN                
-----------------------------------------
 Bitmap Heap Scan on tmp
   Recheck Cond: (j = '-5'::integer)
   ->  Bitmap Index Scan on tmp_j_idx
         Index Cond: (j = '-5'::integer)
(4 rows)

 i 
---
 5
(1 row)

 i 
---
 5
(1 row)

\set hint1 '/*+SeqScan(yb) */'
\set hint2 '/*+IndexScan(yb_j_idx) */'
\set query 'SELECT i FROM yb WHERE j = -5'
:explain2run2
              QUERY PLAN               
---------------------------------------
 Seq Scan on yb
   Storage Filter: (j = '-5'::integer)
(2 rows)

            QUERY PLAN             
-----------------------------------
 Index Scan using yb_j_idx on yb
   Index Cond: (j = '-5'::integer)
(2 rows)

 i 
---
 5
(1 row)

 i 
---
 5
(1 row)

\set hint1
\set hint2
-- 2. corruption (for temp index)
--
-- Fully test the temp index first because system indexes require require a
-- reconnect, which releases the temp table.
--
-- Disable reads/writes to the index.
UPDATE pg_index SET indislive = false, indisready = false, indisvalid = false
    WHERE indexrelid = 'tmp_j_idx'::regclass;
--- Force cache refresh.
:force_cache_refresh
-- Do update that goes to table but doesn't go to index.
UPDATE tmp SET i = 11 WHERE j = -5;
-- Enable reads/writes to the index.
UPDATE pg_index SET indislive = true, indisready = true, indisvalid = true
    WHERE indexrelid = 'tmp_j_idx'::regclass;
--- Force cache refresh.
:force_cache_refresh
-- Show the corruption.
/*+SeqScan(tmp) */
SELECT i FROM tmp WHERE j = -5;
 i  
----
 11
(1 row)

/*+IndexScan(tmp_j_idx) */
SELECT i FROM tmp WHERE j = -5;
 i 
---
(0 rows)

-- Disable reads/writes to the index.
UPDATE pg_index SET indislive = false, indisready = false, indisvalid = false
    WHERE indexrelid = 'tmp_j_idx'::regclass;
--- Force cache refresh.
:force_cache_refresh
-- 3. reindex (for temp index)
REINDEX INDEX tmp_j_idx;
-- 4. verification (for temp index)
\set hint1 '/*+SeqScan(tmp) */'
-- Somehow, IndexScan hint plan fails to work at this point.  Force usage of
-- the index by setting enable_seqscan and enable_bitmapscan to off.
\set hint2 '/*+Set(enable_seqscan off) Set(enable_bitmapscan off) */'
\set query 'SELECT i FROM tmp WHERE j = -5'
:explain2run2
          QUERY PLAN           
-------------------------------
 Seq Scan on tmp
   Filter: (j = '-5'::integer)
(2 rows)

            QUERY PLAN             
-----------------------------------
 Index Scan using tmp_j_idx on tmp
   Index Cond: (j = '-5'::integer)
(2 rows)

 i  
----
 11
(1 row)

 i  
----
 11
(1 row)

\set hint1
\set hint2
-- 5. corruption (for YB indexes)
--
-- Now, test the YB-backed indexes.
--
-- Disable reads/writes to the indexes.
UPDATE pg_index SET indislive = false, indisready = false, indisvalid = false
    WHERE indexrelid = 'pg_depend_depender_index'::regclass;
UPDATE pg_index SET indislive = false, indisready = false, indisvalid = false
    WHERE indexrelid = 'yb_j_idx'::regclass;
-- Force cache refresh.
:force_cache_refresh
\c
-- Do updates that go to tables but don't go to indexes.
SET yb_non_ddl_txn_for_sys_tables_allowed TO on;
-- For non-pk tables, the ybctid cannot be changed through UPDATE.  Use the
-- following DELETE + INSERT instead.
WITH w AS (
    DELETE FROM pg_depend
    WHERE classid = 'pg_class'::regclass and objid = 'yb'::regclass
    RETURNING *)
INSERT INTO pg_depend SELECT * FROM w;
RESET yb_non_ddl_txn_for_sys_tables_allowed;
UPDATE yb SET i = 11 WHERE j = -5;
-- Enable reads/writes to the indexes.
UPDATE pg_index SET indislive = true, indisready = true, indisvalid = true
    WHERE indexrelid = 'pg_depend_depender_index'::regclass;
UPDATE pg_index SET indislive = true, indisready = true, indisvalid = true
    WHERE indexrelid = 'yb_j_idx'::regclass;
-- Force cache refresh.
:force_cache_refresh
\c
-- Show the corruptions.
/*+SeqScan(pg_depend) */
SELECT deptype FROM pg_depend
    WHERE classid = 'pg_class'::regclass and objid = 'yb'::regclass;
 deptype 
---------
 n
(1 row)

/*+IndexScan(pg_depend_depender_index) */
SELECT deptype FROM pg_depend
    WHERE classid = 'pg_class'::regclass and objid = 'yb'::regclass;
ERROR:  ybctid not found in indexed table
/*+SeqScan(yb) */
SELECT i FROM yb WHERE j = -5;
 i  
----
 11
(1 row)

/*+IndexScan(yb_j_idx) */
SELECT i FROM yb WHERE j = -5;
 i 
---
(0 rows)

-- Disable reads to the indexes.
UPDATE pg_index SET indisvalid = false
    WHERE indexrelid = 'pg_depend_depender_index'::regclass;
UPDATE pg_index SET indisvalid = false
    WHERE indexrelid = 'yb_j_idx'::regclass;
-- Force cache refresh.
:force_cache_refresh
\c
-- 6. reindex (for YB indexes)
REINDEX INDEX pg_depend_depender_index;
REINDEX INDEX yb_j_idx;
-- 7. verification (for YB indexes)
\set hint1 '/*+SeqScan(pg_depend) */'
\set hint2 '/*+IndexScan(pg_depend_depender_index) */'
SELECT $$
SELECT deptype FROM pg_depend
    WHERE classid = 'pg_class'::regclass and objid = 'yb'::regclass
$$ AS query \gset
:explain2run2
                               QUERY PLAN                               
------------------------------------------------------------------------
 Seq Scan on pg_depend
   Storage Filter: ((classid = '1259'::oid) AND (objid = '54321'::oid))
(2 rows)

                             QUERY PLAN                             
--------------------------------------------------------------------
 Index Scan using pg_depend_depender_index on pg_depend
   Index Cond: ((classid = '1259'::oid) AND (objid = '54321'::oid))
(2 rows)

 deptype 
---------
 n
(1 row)

 deptype 
---------
 n
(1 row)

\set hint1 '/*+SeqScan(yb) */'
\set hint2 '/*+IndexScan(yb_j_idx) */'
\set query 'SELECT i FROM yb WHERE j = -5'
:explain2run2
              QUERY PLAN               
---------------------------------------
 Seq Scan on yb
   Storage Filter: (j = '-5'::integer)
(2 rows)

            QUERY PLAN             
-----------------------------------
 Index Scan using yb_j_idx on yb
   Index Cond: (j = '-5'::integer)
(2 rows)

 i  
----
 11
(1 row)

 i  
----
 11
(1 row)

\set hint1
\set hint2
--
-- PART 3: misc
--
-- public index
REINDEX INDEX pg_depend_depender_index;
ERROR:  cannot reindex public indexes
DETAIL:  For safety, indexes should not be serving reads during REINDEX.
HINT:  Run UPDATE pg_index SET indisvalid = false WHERE indexrelid = '<index_name>'::regclass.
REINDEX INDEX yb_j_idx;
ERROR:  cannot reindex public indexes
DETAIL:  For safety, indexes should not be serving reads during REINDEX.
HINT:  Run UPDATE pg_index SET indisvalid = false WHERE indexrelid = '<index_name>'::regclass.
-- VERBOSE option
\set VERBOSITY terse
REINDEX (VERBOSE) SYSTEM yugabyte;
ERROR:  REINDEX SCHEMA/DATABASE/SYSTEM not supported yet at character 1
REINDEX (VERBOSE) DATABASE yugabyte;
ERROR:  REINDEX SCHEMA/DATABASE/SYSTEM not supported yet at character 1
REINDEX (VERBOSE) SCHEMA public;
ERROR:  REINDEX SCHEMA/DATABASE/SYSTEM not supported yet at character 1
REINDEX (VERBOSE) TABLE yb;
ERROR:  REINDEX TABLE not supported yet at character 19
UPDATE pg_index SET indisvalid = false
    WHERE indexrelid = 'yb_j_idx'::regclass;
\c
REINDEX (VERBOSE) INDEX yb_j_idx;
INFO:  index "yb_j_idx" was reindexed
\set VERBOSITY default
-- unsupported command/options
REINDEX INDEX CONCURRENTLY yb_j_idx;
ERROR:  REINDEX CONCURRENTLY not supported yet
LINE 1: REINDEX INDEX CONCURRENTLY yb_j_idx;
        ^
HINT:  Please report the issue on https://github.com/YugaByte/yugabyte-db/issues
REINDEX (VERBOSE) INDEX CONCURRENTLY yb_j_idx;
ERROR:  REINDEX CONCURRENTLY not supported yet
LINE 1: REINDEX (VERBOSE) INDEX CONCURRENTLY yb_j_idx;
        ^
HINT:  Please report the issue on https://github.com/YugaByte/yugabyte-db/issues
REINDEX (CONCURRENTLY) INDEX yb_j_idx;
ERROR:  only REINDEX with VERBOSE option is supported
REINDEX (tablespace somespace) INDEX yb_j_idx;
ERROR:  only REINDEX with VERBOSE option is supported
-- shared system index
REINDEX INDEX pg_database_datname_index; -- fail
ERROR:  cannot reindex shared system indexes
-- make sure index isn't broken after failure
/*+IndexOnlyScan(pg_database pg_database_datname_index)*/
SELECT datname from pg_database WHERE datname LIKE 'template%';
  datname  
-----------
 template0
 template1
(2 rows)

-- colocation (via tablegroup)
CREATE TABLEGROUP g;
CREATE TABLE ing (i int PRIMARY KEY, j int) TABLEGROUP g;
CREATE INDEX NONCONCURRENTLY ON ing (j ASC);
INSERT INTO ing SELECT g, -g FROM generate_series(1, 10) g;
\set hint1 '/*+IndexScan(ing_j_idx)*/'
\set query 'SELECT i FROM ing WHERE j < -8 ORDER BY i'
:explain1run1
               QUERY PLAN                
-----------------------------------------
 Sort
   Sort Key: i
   ->  Index Scan using ing_j_idx on ing
         Index Cond: (j < '-8'::integer)
(4 rows)

 i  
----
  9
 10
(2 rows)

UPDATE pg_index SET indisvalid = false
    WHERE indexrelid = 'ing_j_idx'::regclass;
\c
REINDEX INDEX ing_j_idx;
:explain1run1
               QUERY PLAN                
-----------------------------------------
 Sort
   Sort Key: i
   ->  Index Scan using ing_j_idx on ing
         Index Cond: (j < '-8'::integer)
(4 rows)

 i  
----
  9
 10
(2 rows)

\set query 'SELECT i FROM ing WHERE j = -9'
:explain1run1
            QUERY PLAN             
-----------------------------------
 Index Scan using ing_j_idx on ing
   Index Cond: (j = '-9'::integer)
(2 rows)

 i 
---
 9
(1 row)

\set hint1
DROP TABLE ing;
-- matview
CREATE MATERIALIZED VIEW mv AS SELECT * FROM yb;
CREATE INDEX NONCONCURRENTLY ON mv (j ASC);
\set hint1 '/*+IndexScan(mv_j_idx)*/'
\set query 'SELECT i FROM mv WHERE j > -3 ORDER BY i'
:explain1run1
               QUERY PLAN                
-----------------------------------------
 Sort
   Sort Key: i
   ->  Index Scan using mv_j_idx on mv
         Index Cond: (j > '-3'::integer)
(4 rows)

 i 
---
 1
 2
(2 rows)

UPDATE pg_index SET indisvalid = false
    WHERE indexrelid = 'mv_j_idx'::regclass;
\c
REINDEX INDEX mv_j_idx;
:explain1run1
               QUERY PLAN                
-----------------------------------------
 Sort
   Sort Key: i
   ->  Index Scan using mv_j_idx on mv
         Index Cond: (j > '-3'::integer)
(4 rows)

 i 
---
 1
 2
(2 rows)

\set hint1
DROP MATERIALIZED VIEW mv;
-- partitioned table
CREATE TABLE parted (i int, j int) PARTITION BY LIST (j);
CREATE INDEX NONCONCURRENTLY ON parted (i);
CREATE TABLE parted_odd PARTITION OF parted FOR VALUES IN (1, 3, 5, 7, 9);
CREATE TABLE parted_even PARTITION OF parted FOR VALUES IN (2, 4, 6, 8);
INSERT INTO parted SELECT (2 * g), g FROM generate_series(1, 9) g;
\set hint1 '/*+IndexOnlyScan(parted_i_idx)*/'
\set query 'SELECT i FROM parted WHERE i = (2 * 5)'
:explain1run1
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Append
   ->  Index Only Scan using parted_odd_i_idx on parted_odd parted_1
         Index Cond: (i = 10)
   ->  Index Only Scan using parted_even_i_idx on parted_even parted_2
         Index Cond: (i = 10)
(5 rows)

 i  
----
 10
(1 row)

\set hint1 '/*+IndexOnlyScan(parted_odd_i_idx)*/'
\set query 'SELECT i FROM parted_odd WHERE i = (2 * 5)'
:explain1run1
                      QUERY PLAN                      
------------------------------------------------------
 Index Only Scan using parted_odd_i_idx on parted_odd
   Index Cond: (i = 10)
(2 rows)

 i  
----
 10
(1 row)

\set hint1
-- REINDEX fails if not all child indexes are marked invalid
UPDATE pg_index SET indisvalid = false
    WHERE indexrelid = 'parted_i_idx'::regclass;
UPDATE pg_index SET indisvalid = false
    WHERE indexrelid = 'parted_odd_i_idx'::regclass;
\c
REINDEX INDEX parted_i_idx; -- fail
ERROR:  cannot reindex public indexes
DETAIL:  For safety, indexes should not be serving reads during REINDEX.
HINT:  Run UPDATE pg_index SET indisvalid = false WHERE indexrelid = '<index_name>'::regclass.
UPDATE pg_index SET indisvalid = false
    WHERE indexrelid = 'parted_even_i_idx'::regclass;
\c
REINDEX INDEX parted_i_idx; -- succeed
-- we can also reindex just a child index
UPDATE pg_index SET indisvalid = false
    WHERE indexrelid = 'parted_odd_i_idx'::regclass;
\c
REINDEX INDEX parted_odd_i_idx;
\set hint1 '/*+IndexOnlyScan(parted_i_idx)*/'
\set query 'SELECT i FROM parted WHERE i = (2 * 5)'
:explain1run1
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Append
   ->  Index Only Scan using parted_odd_i_idx on parted_odd parted_1
         Index Cond: (i = 10)
   ->  Index Only Scan using parted_even_i_idx on parted_even parted_2
         Index Cond: (i = 10)
(5 rows)

 i  
----
 10
(1 row)

\set hint1 '/*+IndexOnlyScan(parted_odd_i_idx)*/'
\set query 'SELECT i FROM parted_odd WHERE i = (2 * 5)'
:explain1run1
                      QUERY PLAN                      
------------------------------------------------------
 Index Only Scan using parted_odd_i_idx on parted_odd
   Index Cond: (i = 10)
(2 rows)

 i  
----
 10
(1 row)

\set hint1
DROP TABLE parted;
--
-- PART -1: cleanup
--
DROP TABLE yb;
