--
-- Colocation
--
-- CREATE TABLE on non-colocated database
CREATE TABLE tab_colo (a INT) WITH (colocation = true);
ERROR:  cannot set colocation true on a non-colocated database
CREATE TABLE tab_noco (a INT) WITH (colocation = false);
DROP TABLE tab_noco;
-- CREATE DATABASE colocated
CREATE DATABASE colocation_test colocation = true;
\c colocation_test
CREATE TABLE e (id int PRIMARY KEY, first_name TEXT) WITH (colocation = true) SPLIT INTO 10 TABLETS;
ERROR:  cannot create colocated table with split option
-- CREATE TABLE
CREATE TABLE tab_nonkey (a INT);
\d tab_nonkey
             Table "public.tab_nonkey"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 a      | integer |           |          |
Colocation: true

CREATE TABLE tab_key (a INT PRIMARY KEY);
\d tab_key
              Table "public.tab_key"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 a      | integer |           | not null |
Indexes:
    "tab_key_pkey" PRIMARY KEY, lsm (a ASC), colocation: true
Colocation: true

CREATE TABLE tab_range (a INT, PRIMARY KEY (a ASC));
CREATE TABLE tab_range_nonkey (a INT, b INT, PRIMARY KEY (a ASC));
-- opt out of using colocated tablet
CREATE TABLE tab_nonkey_noco (a INT) WITH (colocation = false);
-- colocated tables with no primary keys should not be hash partitioned
CREATE TABLE split_table ( a integer, b text ) SPLIT INTO 4 TABLETS;
ERROR:  cannot create colocated table with split option
-- multi column primary key table
CREATE TABLE tab_range_range (a INT, b INT, PRIMARY KEY (a, b DESC));
CREATE TABLE tab_range_colo (a INT, PRIMARY KEY (a ASC)) WITH (colocation = true);
INSERT INTO tab_range (a) VALUES (0), (1), (2);
INSERT INTO tab_range (a, b) VALUES (0, '0'); -- fail
ERROR:  column "b" of relation "tab_range" does not exist
LINE 1: INSERT INTO tab_range (a, b) VALUES (0, '0');
                                  ^
INSERT INTO tab_range_nonkey (a, b) VALUES (0, '0'), (1, '1');
INSERT INTO tab_nonkey_noco (a) VALUES (0), (1), (2), (3);
INSERT INTO tab_range_range (a, b) VALUES (0, 0), (0, 1), (1, 0), (1, 1);
INSERT INTO tab_range_colo (a) VALUES (0), (1), (2), (3);
SELECT * FROM tab_range;
 a
---
 0
 1
 2
(3 rows)

SELECT * FROM tab_range WHERE a = 2;
 a
---
 2
(1 row)

SELECT * FROM tab_range WHERE n = '0'; -- fail
ERROR:  column "n" does not exist
LINE 1: SELECT * FROM tab_range WHERE n = '0';
                                      ^
SELECT * FROM tab_range_nonkey;
 a | b
---+---
 0 | 0
 1 | 1
(2 rows)

SELECT * FROM tab_nonkey_noco ORDER BY a ASC;
 a
---
 0
 1
 2
 3
(4 rows)

SELECT * FROM tab_range_range;
 a | b
---+---
 0 | 1
 0 | 0
 1 | 1
 1 | 0
(4 rows)

SELECT * FROM tab_range_colo;
 a
---
 0
 1
 2
 3
(4 rows)

BEGIN;
INSERT INTO tab_range_colo VALUES (4);
SELECT * FROM tab_range_colo;
 a
---
 0
 1
 2
 3
 4
(5 rows)

ROLLBACK;
BEGIN;
INSERT INTO tab_range_colo VALUES (5);
COMMIT;
SELECT * FROM tab_range_colo;
 a
---
 0
 1
 2
 3
 5
(5 rows)

INSERT INTO tab_range_colo VALUES (6), (6);
ERROR:  duplicate key value violates unique constraint "tab_range_colo_pkey"
-- CREATE INDEX
-- table with index
CREATE TABLE tab_range_nonkey2 (a INT, b INT, PRIMARY KEY (a ASC));
CREATE INDEX idx_range ON tab_range_nonkey2 (a);
\d tab_range_nonkey2
         Table "public.tab_range_nonkey2"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 a      | integer |           | not null |
 b      | integer |           |          |
Indexes:
    "tab_range_nonkey2_pkey" PRIMARY KEY, lsm (a ASC), colocation: true
    "idx_range" lsm (a ASC), colocation: true
Colocation: true

INSERT INTO tab_range_nonkey2 (a, b) VALUES (0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5);
EXPLAIN (COSTS OFF) SELECT * FROM tab_range_nonkey2 WHERE a = 1;
                          QUERY PLAN
--------------------------------------------------------------
 Index Scan using tab_range_nonkey2_pkey on tab_range_nonkey2
   Index Cond: (a = 1)
(2 rows)

SELECT * FROM tab_range_nonkey2 WHERE a = 1;
 a | b
---+---
 1 | 1
(1 row)

/*+IndexScan(tab_range_nonkey2 idx_range)*/EXPLAIN (COSTS OFF) SELECT * FROM tab_range_nonkey2 WHERE a <= 3;
                   QUERY PLAN
-------------------------------------------------
 Index Scan using idx_range on tab_range_nonkey2
   Index Cond: (a <= 3)
(2 rows)

/*+IndexScan(tab_range_nonkey2 idx_range)*/SELECT * FROM tab_range_nonkey2 WHERE a <= 3;
 a | b
---+---
 0 | 0
 1 | 1
 2 | 2
 3 | 3
(4 rows)

UPDATE tab_range_nonkey2 SET b = b + 1 WHERE a > 3;
SELECT * FROM tab_range_nonkey2;
 a | b
---+---
 0 | 0
 1 | 1
 2 | 2
 3 | 3
 4 | 5
 5 | 6
(6 rows)

DELETE FROM tab_range_nonkey2 WHERE a > 3;
SELECT * FROM tab_range_nonkey2;
 a | b
---+---
 0 | 0
 1 | 1
 2 | 2
 3 | 3
(4 rows)

-- colocated table with non-colocated index
CREATE TABLE tab_range_nonkey3 (a INT, b INT, PRIMARY KEY (a ASC));
CREATE INDEX idx_range_colo ON tab_range_nonkey3 (a) WITH (colocation = true);
ERROR:  unrecognized parameter "colocation"
-- colocated table with colocated index
CREATE TABLE tab_range_nonkey4 (a INT, b INT, PRIMARY KEY (a ASC));
CREATE INDEX idx_range_noco ON tab_range_nonkey4 (a) WITH (colocation = false);
ERROR:  unrecognized parameter "colocation"
-- non-colocated table with index
CREATE TABLE tab_range_nonkey_noco (a INT, b INT, PRIMARY KEY (a ASC)) WITH (colocation = false);
CREATE INDEX idx_range2 ON tab_range_nonkey_noco (a);
INSERT INTO tab_range_nonkey_noco (a, b) VALUES (0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5);
EXPLAIN (COSTS OFF) SELECT * FROM tab_range_nonkey_noco WHERE a = 1;
                              QUERY PLAN
----------------------------------------------------------------------
 Index Scan using tab_range_nonkey_noco_pkey on tab_range_nonkey_noco
   Index Cond: (a = 1)
(2 rows)

SELECT * FROM tab_range_nonkey_noco WHERE a = 1;
 a | b
---+---
 1 | 1
(1 row)

EXPLAIN (COSTS OFF) SELECT * FROM tab_range_nonkey_noco WHERE a <= 3;
                              QUERY PLAN
----------------------------------------------------------------------
 Index Scan using tab_range_nonkey_noco_pkey on tab_range_nonkey_noco
   Index Cond: (a <= 3)
(2 rows)

SELECT * FROM tab_range_nonkey_noco WHERE a <= 3;
 a | b
---+---
 0 | 0
 1 | 1
 2 | 2
 3 | 3
(4 rows)

UPDATE tab_range_nonkey_noco SET b = b + 1 WHERE a > 3;
SELECT * FROM tab_range_nonkey_noco;
 a | b
---+---
 0 | 0
 1 | 1
 2 | 2
 3 | 3
 4 | 5
 5 | 6
(6 rows)

DELETE FROM tab_range_nonkey_noco WHERE a > 3;
SELECT * FROM tab_range_nonkey_noco;
 a | b
---+---
 0 | 0
 1 | 1
 2 | 2
 3 | 3
(4 rows)

create table p_out(a int);
insert into p_out values (1), (2), (3), (4);
create index on p_out(a asc);
create table p_in(a int, primary key(a asc));
insert into p_in values (4);
/*+Set(yb_prefer_bnl false) IndexScan(p_out) NestLoop(p_out p_in) Leading((p_out p_in))*/ explain (analyze, costs off, summary off, timing off, dist) select * from p_out, p_in where p_out.a = p_in.a limit 1;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Limit (actual rows=1 loops=1)
   ->  Nested Loop (actual rows=1 loops=1)
         ->  Index Scan using p_out_a_idx on p_out (actual rows=4 loops=1)
               Storage Table Rows Scanned: 4
               Storage Index Read Requests: 2
               Storage Index Rows Scanned: 4
         ->  Index Scan using p_in_pkey on p_in (actual rows=0 loops=4)
               Index Cond: (a = p_out.a)
               Storage Table Read Requests: 1
               Storage Table Rows Scanned: 0
(10 rows)

drop table p_out;
drop table p_in;
-- more tables and indexes
CREATE TABLE tab_range_nonkey_noco2 (a INT, b INT, PRIMARY KEY (a ASC)) WITH (colocation = false);
CREATE INDEX idx_range3 ON tab_range_nonkey_noco2 (a);
INSERT INTO tab_range_nonkey_noco2 (a, b) VALUES (0, 0);
CREATE TABLE tab_range_nonkey_noco3 (a INT, b INT, PRIMARY KEY (a ASC)) WITH (colocation = false);
CREATE INDEX idx_range4 ON tab_range_nonkey_noco3 (a);
CREATE TABLE tab_range_nonkey5 (a INT, b INT, PRIMARY KEY (a ASC));
CREATE INDEX idx_range5 ON tab_range_nonkey5 (a);
CREATE TABLE tbl (r1 INT, r2 INT, v1 INT, v2 INT,
PRIMARY KEY (r1, r2));
CREATE INDEX idx_hash1 on tbl (r1 HASH);
ERROR:  cannot colocate hash partitioned index
CREATE INDEX idx_hash2 on tbl ((r1, r2) HASH);
ERROR:  cannot colocate hash partitioned index
CREATE INDEX idx_hash3 on tbl (r1 HASH, r2 ASC);
ERROR:  cannot colocate hash partitioned index
CREATE UNIQUE INDEX unique_idx_hash1 on tbl (r1 HASH);
ERROR:  cannot colocate hash partitioned index
CREATE UNIQUE INDEX unique_idx_hash2 on tbl ((r1, r2) HASH);
ERROR:  cannot colocate hash partitioned index
CREATE UNIQUE INDEX unique_idx_hash3 on tbl (r1 HASH, r2 ASC);
ERROR:  cannot colocate hash partitioned index
\d tbl
                Table "public.tbl"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 r1     | integer |           | not null |
 r2     | integer |           | not null |
 v1     | integer |           |          |
 v2     | integer |           |          |
Indexes:
    "tbl_pkey" PRIMARY KEY, lsm (r1 ASC, r2 ASC), colocation: true
Colocation: true

-- Make sure nothing bad happens to UNIQUE constraints after disabling HASH columns
-- for colocated indexes
CREATE TABLE tbl2 (r1 int PRIMARY KEY, r2 int, v1 int, v2 int, UNIQUE(v1));
ALTER TABLE tbl2 ADD CONSTRAINT unique_v2_tbl2 UNIQUE(v2);
\d tbl2
                Table "public.tbl2"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 r1     | integer |           | not null |
 r2     | integer |           |          |
 v1     | integer |           |          |
 v2     | integer |           |          |
Indexes:
    "tbl2_pkey" PRIMARY KEY, lsm (r1 ASC), colocation: true
    "tbl2_v1_key" UNIQUE CONSTRAINT, lsm (v1 ASC), colocation: true
    "unique_v2_tbl2" UNIQUE CONSTRAINT, lsm (v2 ASC), colocation: true
Colocation: true

DROP TABLE tbl, tbl2;
-- colocated table with unique index
CREATE TABLE tab_nonkey2 (a INT) WITH (colocation = true);
CREATE UNIQUE INDEX idx_range6 ON tab_nonkey2 (a);
\dt
                 List of relations
 Schema |          Name          | Type  |  Owner
--------+------------------------+-------+----------
 public | tab_key                | table | yugabyte
 public | tab_nonkey             | table | yugabyte
 public | tab_nonkey2            | table | yugabyte
 public | tab_nonkey_noco        | table | yugabyte
 public | tab_range              | table | yugabyte
 public | tab_range_colo         | table | yugabyte
 public | tab_range_nonkey       | table | yugabyte
 public | tab_range_nonkey2      | table | yugabyte
 public | tab_range_nonkey3      | table | yugabyte
 public | tab_range_nonkey4      | table | yugabyte
 public | tab_range_nonkey5      | table | yugabyte
 public | tab_range_nonkey_noco  | table | yugabyte
 public | tab_range_nonkey_noco2 | table | yugabyte
 public | tab_range_nonkey_noco3 | table | yugabyte
 public | tab_range_range        | table | yugabyte
(15 rows)

\di
                                List of relations
 Schema |            Name             | Type  |  Owner   |         Table
--------+-----------------------------+-------+----------+------------------------
 public | idx_range                   | index | yugabyte | tab_range_nonkey2
 public | idx_range2                  | index | yugabyte | tab_range_nonkey_noco
 public | idx_range3                  | index | yugabyte | tab_range_nonkey_noco2
 public | idx_range4                  | index | yugabyte | tab_range_nonkey_noco3
 public | idx_range5                  | index | yugabyte | tab_range_nonkey5
 public | idx_range6                  | index | yugabyte | tab_nonkey2
 public | tab_key_pkey                | index | yugabyte | tab_key
 public | tab_range_colo_pkey         | index | yugabyte | tab_range_colo
 public | tab_range_nonkey2_pkey      | index | yugabyte | tab_range_nonkey2
 public | tab_range_nonkey3_pkey      | index | yugabyte | tab_range_nonkey3
 public | tab_range_nonkey4_pkey      | index | yugabyte | tab_range_nonkey4
 public | tab_range_nonkey5_pkey      | index | yugabyte | tab_range_nonkey5
 public | tab_range_nonkey_noco2_pkey | index | yugabyte | tab_range_nonkey_noco2
 public | tab_range_nonkey_noco3_pkey | index | yugabyte | tab_range_nonkey_noco3
 public | tab_range_nonkey_noco_pkey  | index | yugabyte | tab_range_nonkey_noco
 public | tab_range_nonkey_pkey       | index | yugabyte | tab_range_nonkey
 public | tab_range_pkey              | index | yugabyte | tab_range
 public | tab_range_range_pkey        | index | yugabyte | tab_range_range
(18 rows)

-- TRUNCATE TABLE
-- truncate colocated table with default index
TRUNCATE TABLE tab_range;
SELECT * FROM tab_range;
 a
---
(0 rows)

INSERT INTO tab_range VALUES (4);
SELECT * FROM tab_range;
 a
---
 4
(1 row)

INSERT INTO tab_range VALUES (1);
INSERT INTO tab_range VALUES (2), (5);
SELECT * FROM tab_range;
 a
---
 1
 2
 4
 5
(4 rows)

DELETE FROM tab_range WHERE a = 2;
TRUNCATE TABLE tab_range;
SELECT * FROM tab_range;
 a
---
(0 rows)

INSERT INTO tab_range VALUES (2);
SELECT * FROM tab_range;
 a
---
 2
(1 row)

TRUNCATE TABLE tab_range;
-- truncate non-colocated table without index
TRUNCATE TABLE tab_nonkey_noco;
SELECT * FROM tab_nonkey_noco;
 a
---
(0 rows)

-- truncate colocated table with explicit index
TRUNCATE TABLE tab_range_nonkey2;
SELECT * FROM tab_range_nonkey2;
 a | b
---+---
(0 rows)

-- truncate non-colocated table with explicit index
TRUNCATE TABLE tab_range_nonkey_noco2;
SELECT * FROM tab_range_nonkey_noco2;
 a | b
---+---
(0 rows)

-- insert and truncate colocated table with explicit index
INSERT INTO tab_nonkey2 VALUES (1), (2), (3);
EXPLAIN (COSTS OFF) SELECT a FROM tab_nonkey2 ORDER BY a;
                   QUERY PLAN
-------------------------------------------------
 Index Only Scan using idx_range6 on tab_nonkey2
(1 row)

SELECT a FROM tab_nonkey2 ORDER BY a;
 a
---
 1
 2
 3
(3 rows)

TRUNCATE TABLE tab_nonkey2;
SELECT a FROM tab_nonkey2 ORDER BY a;
 a
---
(0 rows)

INSERT INTO tab_nonkey2 VALUES (2), (4);
SELECT a FROM tab_nonkey2 ORDER BY a;
 a
---
 2
 4
(2 rows)

\dt
                 List of relations
 Schema |          Name          | Type  |  Owner
--------+------------------------+-------+----------
 public | tab_key                | table | yugabyte
 public | tab_nonkey             | table | yugabyte
 public | tab_nonkey2            | table | yugabyte
 public | tab_nonkey_noco        | table | yugabyte
 public | tab_range              | table | yugabyte
 public | tab_range_colo         | table | yugabyte
 public | tab_range_nonkey       | table | yugabyte
 public | tab_range_nonkey2      | table | yugabyte
 public | tab_range_nonkey3      | table | yugabyte
 public | tab_range_nonkey4      | table | yugabyte
 public | tab_range_nonkey5      | table | yugabyte
 public | tab_range_nonkey_noco  | table | yugabyte
 public | tab_range_nonkey_noco2 | table | yugabyte
 public | tab_range_nonkey_noco3 | table | yugabyte
 public | tab_range_range        | table | yugabyte
(15 rows)

\di
                                List of relations
 Schema |            Name             | Type  |  Owner   |         Table
--------+-----------------------------+-------+----------+------------------------
 public | idx_range                   | index | yugabyte | tab_range_nonkey2
 public | idx_range2                  | index | yugabyte | tab_range_nonkey_noco
 public | idx_range3                  | index | yugabyte | tab_range_nonkey_noco2
 public | idx_range4                  | index | yugabyte | tab_range_nonkey_noco3
 public | idx_range5                  | index | yugabyte | tab_range_nonkey5
 public | idx_range6                  | index | yugabyte | tab_nonkey2
 public | tab_key_pkey                | index | yugabyte | tab_key
 public | tab_range_colo_pkey         | index | yugabyte | tab_range_colo
 public | tab_range_nonkey2_pkey      | index | yugabyte | tab_range_nonkey2
 public | tab_range_nonkey3_pkey      | index | yugabyte | tab_range_nonkey3
 public | tab_range_nonkey4_pkey      | index | yugabyte | tab_range_nonkey4
 public | tab_range_nonkey5_pkey      | index | yugabyte | tab_range_nonkey5
 public | tab_range_nonkey_noco2_pkey | index | yugabyte | tab_range_nonkey_noco2
 public | tab_range_nonkey_noco3_pkey | index | yugabyte | tab_range_nonkey_noco3
 public | tab_range_nonkey_noco_pkey  | index | yugabyte | tab_range_nonkey_noco
 public | tab_range_nonkey_pkey       | index | yugabyte | tab_range_nonkey
 public | tab_range_pkey              | index | yugabyte | tab_range
 public | tab_range_range_pkey        | index | yugabyte | tab_range_range
(18 rows)

-- ALTER TABLE
INSERT INTO tab_range (a) VALUES (0), (1), (2);
INSERT INTO tab_range_nonkey2 (a, b) VALUES (0, 0), (1, 1);
SELECT * FROM tab_range;
 a
---
 0
 1
 2
(3 rows)

SELECT * FROM tab_range_nonkey2;
 a | b
---+---
 0 | 0
 1 | 1
(2 rows)

-- Alter colocated tables
ALTER TABLE tab_range ADD COLUMN x INT;
ALTER TABLE tab_range_nonkey2 DROP COLUMN b;
SELECT * FROM tab_range;
 a | x
---+---
 0 |
 1 |
 2 |
(3 rows)

SELECT * FROM tab_range_nonkey2;
 a
---
 0
 1
(2 rows)

ALTER TABLE tab_range_nonkey2 RENAME TO tab_range_nonkey2_renamed;
SELECT * FROM tab_range_nonkey2_renamed;
 a
---
 0
 1
(2 rows)

SELECT * FROM tab_range_nonkey2;
ERROR:  relation "tab_range_nonkey2" does not exist
LINE 1: SELECT * FROM tab_range_nonkey2;
                      ^
-- Alter colocated table ADD PRIMARY KEY
CREATE TABLE tbl_no_pk (k INT, v INT) WITH (colocation = true);
\d tbl_no_pk
             Table "public.tbl_no_pk"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 k      | integer |           |          |
 v      | integer |           |          |
Colocation: true

INSERT INTO tbl_no_pk (k, v) VALUES (1, 1), (2, 2), (3, 3);
ALTER TABLE tbl_no_pk ADD PRIMARY KEY (k ASC);
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
\d tbl_no_pk
             Table "public.tbl_no_pk"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 k      | integer |           | not null |
 v      | integer |           |          |
Indexes:
    "tbl_no_pk_pkey" PRIMARY KEY, lsm (k ASC), colocation: true
Colocation: true

SELECT * FROM tbl_no_pk ORDER BY k;
 k | v
---+---
 1 | 1
 2 | 2
 3 | 3
(3 rows)

-- Alter colocated table "DROP PRIMARY KEY"
ALTER TABLE tbl_no_pk DROP CONSTRAINT tbl_no_pk_pkey;
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
\d tbl_no_pk
             Table "public.tbl_no_pk"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 k      | integer |           | not null |
 v      | integer |           |          |
Colocation: true

SELECT * FROM tbl_no_pk ORDER BY k;
 k | v
---+---
 1 | 1
 2 | 2
 3 | 3
(3 rows)

DROP TABLE tbl_no_pk;
-- DROP TABLE
-- drop colocated table with default index
DROP TABLE tab_range;
SELECT * FROM tab_range;
ERROR:  relation "tab_range" does not exist
LINE 1: SELECT * FROM tab_range;
                      ^
-- drop non-colocated table without index
DROP TABLE tab_nonkey_noco;
SELECT * FROM tab_nonkey_noco;
ERROR:  relation "tab_nonkey_noco" does not exist
LINE 1: SELECT * FROM tab_nonkey_noco;
                      ^
--- drop colocated table with explicit index
DROP TABLE tab_range_nonkey2_renamed;
SELECT * FROM tab_range_nonkey2_renamed;
ERROR:  relation "tab_range_nonkey2_renamed" does not exist
LINE 1: SELECT * FROM tab_range_nonkey2_renamed;
                      ^
-- drop non-colocated table with explicit index
DROP TABLE tab_range_nonkey_noco2;
SELECT * FROM tab_range_nonkey_noco2;
ERROR:  relation "tab_range_nonkey_noco2" does not exist
LINE 1: SELECT * FROM tab_range_nonkey_noco2;
                      ^
-- DROP INDEX
-- drop index on non-colocated table
DROP INDEX idx_range2;
EXPLAIN (COSTS OFF) SELECT * FROM tab_range_nonkey_noco WHERE a = 1;
                              QUERY PLAN
----------------------------------------------------------------------
 Index Scan using tab_range_nonkey_noco_pkey on tab_range_nonkey_noco
   Index Cond: (a = 1)
(2 rows)

-- drop index on colocated table
DROP INDEX idx_range5;
EXPLAIN (COSTS OFF) SELECT * FROM tab_range_nonkey5 WHERE a = 1;
                          QUERY PLAN
--------------------------------------------------------------
 Index Scan using tab_range_nonkey5_pkey on tab_range_nonkey5
   Index Cond: (a = 1)
(2 rows)

\dt
                 List of relations
 Schema |          Name          | Type  |  Owner
--------+------------------------+-------+----------
 public | tab_key                | table | yugabyte
 public | tab_nonkey             | table | yugabyte
 public | tab_nonkey2            | table | yugabyte
 public | tab_range_colo         | table | yugabyte
 public | tab_range_nonkey       | table | yugabyte
 public | tab_range_nonkey3      | table | yugabyte
 public | tab_range_nonkey4      | table | yugabyte
 public | tab_range_nonkey5      | table | yugabyte
 public | tab_range_nonkey_noco  | table | yugabyte
 public | tab_range_nonkey_noco3 | table | yugabyte
 public | tab_range_range        | table | yugabyte
(11 rows)

\di
                                List of relations
 Schema |            Name             | Type  |  Owner   |         Table
--------+-----------------------------+-------+----------+------------------------
 public | idx_range4                  | index | yugabyte | tab_range_nonkey_noco3
 public | idx_range6                  | index | yugabyte | tab_nonkey2
 public | tab_key_pkey                | index | yugabyte | tab_key
 public | tab_range_colo_pkey         | index | yugabyte | tab_range_colo
 public | tab_range_nonkey3_pkey      | index | yugabyte | tab_range_nonkey3
 public | tab_range_nonkey4_pkey      | index | yugabyte | tab_range_nonkey4
 public | tab_range_nonkey5_pkey      | index | yugabyte | tab_range_nonkey5
 public | tab_range_nonkey_noco3_pkey | index | yugabyte | tab_range_nonkey_noco3
 public | tab_range_nonkey_noco_pkey  | index | yugabyte | tab_range_nonkey_noco
 public | tab_range_nonkey_pkey       | index | yugabyte | tab_range_nonkey
 public | tab_range_range_pkey        | index | yugabyte | tab_range_range
(11 rows)

-- Test colocated tables/indexes with SPLIT INTO/SPLIT AT
CREATE TABLE invalid_tbl_split_into (k INT) SPLIT INTO 10 TABLETS;
ERROR:  cannot create colocated table with split option
CREATE TABLE invalid_tbl_split_at (k INT) SPLIT AT VALUES ((100));
ERROR:  cannot create colocated table with split option
CREATE TABLE test_tbl (k INT);
CREATE INDEX invalid_idx_split_into ON test_tbl (k) SPLIT INTO 10 TABLETS;
ERROR:  cannot create colocated index with split option
CREATE INDEX invalid_idx_split_at ON test_tbl (k) SPLIT AT VALUES ((100));
ERROR:  cannot create colocated index with split option
DROP TABLE test_tbl;
-- Test colocated partitioned table and partition tables
CREATE TABLE partitioned_table (
    k1 INT,
    v1 INT,
    v2 TEXT
)
PARTITION BY HASH (k1)
WITH (colocation_id='123456');
SELECT * FROM yb_table_properties('partitioned_table'::regclass::oid);
 num_tablets | num_hash_key_columns | is_colocated | tablegroup_oid | colocation_id
-------------+----------------------+--------------+----------------+---------------
           1 |                    0 | t            |          16391 |        123456
(1 row)

CREATE TABLE table_partition PARTITION OF partitioned_table
FOR VALUES WITH (modulus 2, remainder 0)
WITH (colocation_id='234567');
SELECT * FROM yb_table_properties('table_partition'::regclass::oid);
 num_tablets | num_hash_key_columns | is_colocated | tablegroup_oid | colocation_id
-------------+----------------------+--------------+----------------+---------------
           1 |                    0 | t            |          16391 |        234567
(1 row)

-- drop database
\c yugabyte
DROP DATABASE colocation_test;
-- Test syntax change as a result of Colocation GA change
-- Fail: only one of 'colocation' and 'colocated' options can be specified in CREATE DATABASE
CREATE DATABASE colocation_test colocated = true colocation = true;
WARNING:  'colocated' syntax is deprecated and will be removed in a future release
LINE 1: CREATE DATABASE colocation_test colocated = true colocation ...
                                        ^
HINT:  Use 'colocation' instead of 'colocated'.
ERROR:  conflicting or redundant options
LINE 1: CREATE DATABASE colocation_test colocated = true colocation ...
                                                         ^
-- Succeed with deprecated warning: create a colocated database using old syntax
CREATE DATABASE colocation_test colocated = true;
WARNING:  'colocated' syntax is deprecated and will be removed in a future release
LINE 1: CREATE DATABASE colocation_test colocated = true;
                                        ^
HINT:  Use 'colocation' instead of 'colocated'.
DROP DATABASE colocation_test;
-- Succeed: create a colocated database using new syntax
CREATE DATABASE colocation_test colocation = true;
\c colocation_test
-- Fail: only one of 'colocation' and 'colocated' options can be specified in CREATE TABLE
CREATE TABLE tbl_colocated_colocation (k INT, v INT)
WITH (colocation = true, colocated = true);
ERROR:  cannot specify both of 'colocation' and 'colocated' options
HINT:  Use 'colocation' instead of 'colocated'.
-- Succeed with deprecated warning: create a colocated table using old syntax
CREATE TABLE tbl_colocated (k INT, v INT) WITH (colocated = true);
WARNING:  'colocated' syntax is deprecated and will be removed in a future release
HINT:  Use 'colocation' instead of 'colocated'.
-- Succeed: create a colocated table using new syntax
CREATE TABLE tbl_colocation (k INT, v INT) WITH (colocation = true);
-- Check colocated table footer
\d tbl_colocation
           Table "public.tbl_colocation"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 k      | integer |           |          |
 v      | integer |           |          |
Colocation: true

-- Create and describe a table opt out of colocation
CREATE TABLE tbl_no_colocation (k INT, v INT) WITH (colocation = false);
\d tbl_no_colocation
         Table "public.tbl_no_colocation"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 k      | integer |           |          |
 v      | integer |           |          |

-- Drop database
\c yugabyte
DROP DATABASE colocation_test;
-- Test Colocation GA special characteristics different from legacy colocated database
CREATE DATABASE colocation_test colocation = true;
\c colocation_test
-- Lazily create the default implicit tablegroup
SELECT * FROM pg_yb_tablegroup;
 oid | grpname | grpowner | grptablespace | grpacl | grpoptions
-----+---------+----------+---------------+--------+------------
(0 rows)

CREATE TABLE tbl (k INT, v INT);
SELECT * FROM pg_yb_tablegroup;
  oid  | grpname | grpowner | grptablespace | grpacl | grpoptions
-------+---------+----------+---------------+--------+------------
 16387 | default |       10 |             0 |        |
(1 row)

-- Check for dependency between colocated table and default tablegroup
SELECT * FROM pg_depend, pg_yb_tablegroup WHERE classid = 'pg_class'::regclass
AND objid = 'tbl'::regclass AND refclassid = 'pg_yb_tablegroup'::regclass
AND refobjid = pg_yb_tablegroup.oid AND grpname = 'default';
 classid | objid | objsubid | refclassid | refobjid | refobjsubid | deptype |  oid  | grpname | grpowner | grptablespace | grpacl | grpoptions
---------+-------+----------+------------+----------+-------------+---------+-------+---------+----------+---------------+--------+------------
    1259 | 16384 |        0 |       8036 |    16387 |           0 | n       | 16387 | default |       10 |             0 |        |
(1 row)

DROP TABLEGROUP "default";
ERROR:  cannot drop tablegroup default because other objects depend on it
DETAIL:  table tbl depends on tablegroup default
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
-- The default tablegroup cannot be dropped
DROP TABLEGROUP "default" CASCADE;
NOTICE:  drop cascades to table tbl
ERROR:  cannot drop an implicit tablegroup in a colocated database.
DROP TABLE tbl;
DROP TABLEGROUP "default";
ERROR:  cannot drop an implicit tablegroup in a colocated database.
-- Cannot set privileges of an implicit tablegroup
CREATE ROLE test_role;
GRANT CREATE ON TABLEGROUP "default" TO test_role;
ERROR:  cannot set privileges of an implicit tablegroup in a colocated database
REVOKE CREATE ON TABLEGROUP "default" FROM test_role;
ERROR:  cannot set privileges of an implicit tablegroup in a colocated database
-- Any user can create tables/indexes in an implicit tablegroup
GRANT CREATE ON SCHEMA public TO test_role;
SET SESSION AUTHORIZATION test_role;
CREATE TABLE test_role_table (k INT PRIMARY KEY, v TEXT);
SELECT * FROM pg_tables WHERE tablename = 'test_role_table';
 schemaname |    tablename    | tableowner | tablespace | hasindexes | hasrules | hastriggers | rowsecurity
------------+-----------------+------------+------------+------------+----------+-------------+-------------
 public     | test_role_table | test_role  |            | t          | f        | f           | f
(1 row)

CREATE UNIQUE INDEX unique_idx ON test_role_table(v);
SELECT rolname FROM pg_roles JOIN pg_class
ON pg_roles.oid = pg_class.relowner WHERE pg_class.relname = 'unique_idx';
  rolname
-----------
 test_role
(1 row)

RESET SESSION AUTHORIZATION;
-- The default tablegroup cannot be used explicitly
CREATE TABLE invalid_tbl (k int) TABLEGROUP "default";
ERROR:  cannot use tablegroups in a colocated database
-- Test distinct pushdown for colocated table
CREATE TABLE tbl_colo(r1 INT, r2 INT, r3 INT, r4 INT, r5 INT) WITH (colocation = TRUE);
CREATE INDEX ON tbl_colo(r1 asc, r3 asc, r5 asc);
INSERT INTO tbl_colo (SELECT 1, i, i, i, i FROM generate_series(1, 100) AS i);
INSERT INTO tbl_colo (SELECT 2, i, i, i, i FROM generate_series(1, 100) AS i);
INSERT INTO tbl_colo (SELECT 3, i, i, i, i FROM generate_series(1, 100) AS i);
EXPLAIN (COSTS OFF) SELECT DISTINCT r1 FROM tbl_colo WHERE r3 <= 1;
                               QUERY PLAN
------------------------------------------------------------------------
 Unique
   ->  Distinct Index Only Scan using tbl_colo_r1_r3_r5_idx on tbl_colo
         Index Cond: (r3 <= 1)
         Distinct Keys: r1
(4 rows)

SELECT DISTINCT r1 FROM tbl_colo WHERE r3 <= 1;
 r1
----
  1
  2
  3
(3 rows)

/*+Set(enable_hashagg false)*/ EXPLAIN (COSTS OFF) SELECT DISTINCT r1 FROM tbl_colo WHERE r3 <= 1;
                               QUERY PLAN
------------------------------------------------------------------------
 Unique
   ->  Distinct Index Only Scan using tbl_colo_r1_r3_r5_idx on tbl_colo
         Index Cond: (r3 <= 1)
         Distinct Keys: r1
(4 rows)

/*+Set(enable_hashagg false)*/ SELECT DISTINCT r1 FROM tbl_colo WHERE r3 <= 1;
 r1
----
  1
  2
  3
(3 rows)

-- Drop database
\c yugabyte
DROP DATABASE colocation_test;
-- Test Colocated Materialized View describe
CREATE DATABASE colocation_test WITH colocation = true;
\c colocation_test
CREATE TABLE t1 (a INT PRIMARY KEY);
CREATE MATERIALIZED VIEW m1 AS SELECT * FROM t1;
CREATE MATERIALIZED VIEW m2 with (colocation = true) AS SELECT * FROM t1;
CREATE MATERIALIZED VIEW m3 with (colocation = false) AS SELECT * FROM t1;
\d m1
           Materialized view "public.m1"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 a      | integer |           |          |
Colocation: true

\d m2
           Materialized view "public.m2"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 a      | integer |           |          |
Colocation: true

\d m3
           Materialized view "public.m3"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 a      | integer |           |          |

\c yugabyte
DROP DATABASE colocation_test;
-- Test Colocated Materialized View
CREATE DATABASE colocation_test WITH colocation = true;
\c colocation_test
CREATE TABLE t1 (a INT PRIMARY KEY) WITH (colocation = true);
CREATE TABLE t2 (b INT PRIMARY KEY) WITH (colocation = false);
CREATE MATERIALIZED VIEW m0 WITH (colocation = true) as SELECT * FROM t1;
CREATE MATERIALIZED VIEW m1 WITH (colocation = false) as SELECT * FROM t1;
CREATE MATERIALIZED VIEW m2 WITH (colocation = true) as SELECT * FROM t2;
CREATE MATERIALIZED VIEW m3 WITH (colocation = false) as SELECT * FROM t2;
CREATE MATERIALIZED VIEW m4 WITH (colocation = true) as SELECT * FROM t1, t2;
CREATE MATERIALIZED VIEW m5 WITH (colocation = false) as SELECT * FROM t1, t2;
select is_colocated from yb_table_properties('m0'::regclass);
 is_colocated
--------------
 t
(1 row)

select is_colocated from yb_table_properties('m1'::regclass);
 is_colocated
--------------
 f
(1 row)

select is_colocated from yb_table_properties('m2'::regclass);
 is_colocated
--------------
 t
(1 row)

select is_colocated from yb_table_properties('m3'::regclass);
 is_colocated
--------------
 f
(1 row)

select is_colocated from yb_table_properties('m4'::regclass);
 is_colocated
--------------
 t
(1 row)

select is_colocated from yb_table_properties('m5'::regclass);
 is_colocated
--------------
 f
(1 row)

-- Test yb_use_hash_splitting_by_default=false (Postgres compatibility)
CREATE OR REPLACE FUNCTION get_table_indexes(table_name text)
    RETURNS TABLE(
                     relname name,
                     indisprimary boolean,
                     indisunique boolean,
                     indexdef text,
                     constraintdef text
                 ) AS $$
BEGIN
    RETURN QUERY EXECUTE
        'SELECT c2.relname, i.indisprimary, i.indisunique, pg_catalog.pg_get_indexdef(i.indexrelid, 0, true), ' ||
        'pg_catalog.pg_get_constraintdef(con.oid, true) ' ||
        'FROM pg_catalog.pg_class c, pg_catalog.pg_class c2, pg_catalog.pg_index i ' ||
        'LEFT JOIN pg_catalog.pg_constraint con ON (conrelid = i.indrelid AND conindid = i.indexrelid AND contype IN (''p'',''u'',''x'')) ' ||
        'WHERE c.oid = ' || quote_literal(table_name) || '::regclass AND c.oid = i.indrelid AND i.indexrelid = c2.oid ' ||
        'ORDER BY i.indisprimary DESC, i.indisunique DESC, c2.relname';
END;
$$ LANGUAGE plpgsql;
-- With HASH as default, creating a colocated table or index with SPLIT AT should fail
CREATE INDEX ON t1 (b) SPLIT AT VALUES((10), (20), (30));
ERROR:  cannot create colocated index with split option
CREATE TABLE split_fail(a int primary key, b int) SPLIT AT VALUES ((1000),(2000),(3000));
ERROR:  cannot create colocated table with split option
SET yb_use_hash_splitting_by_default = false;
CREATE TABLE foo(a int primary key, b int, c int);
SELECT * FROM get_table_indexes('foo');
 relname  | indisprimary | indisunique |                       indexdef                        |  constraintdef
----------+--------------+-------------+-------------------------------------------------------+-----------------
 foo_pkey | t            | t           | CREATE UNIQUE INDEX foo_pkey ON foo USING lsm (a ASC) | PRIMARY KEY (a)
(1 row)

CREATE TABLE bar(a int, b int, c int, primary key(a, b));
SELECT * FROM get_table_indexes('bar');
 relname  | indisprimary | indisunique |                           indexdef                           |   constraintdef
----------+--------------+-------------+--------------------------------------------------------------+--------------------
 bar_pkey | t            | t           | CREATE UNIQUE INDEX bar_pkey ON bar USING lsm (a ASC, b ASC) | PRIMARY KEY (a, b)
(1 row)

CREATE TABLE baz(a int, b int, c int, primary key((a,b) HASH, c));
ERROR:  cannot colocate hash partitioned table
CREATE TABLE qux(a int, b int, c int);
ALTER TABLE qux ADD PRIMARY KEY(a);
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
SELECT * FROM get_table_indexes('qux');
 relname  | indisprimary | indisunique |                       indexdef                        |  constraintdef
----------+--------------+-------------+-------------------------------------------------------+-----------------
 qux_pkey | t            | t           | CREATE UNIQUE INDEX qux_pkey ON qux USING lsm (a ASC) | PRIMARY KEY (a)
(1 row)

ALTER TABLE qux DROP CONSTRAINT qux_pkey;
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
ALTER TABLE qux ADD PRIMARY KEY(a,b);
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
SELECT * FROM get_table_indexes('qux');
 relname  | indisprimary | indisunique |                           indexdef                           |   constraintdef
----------+--------------+-------------+--------------------------------------------------------------+--------------------
 qux_pkey | t            | t           | CREATE UNIQUE INDEX qux_pkey ON qux USING lsm (a ASC, b ASC) | PRIMARY KEY (a, b)
(1 row)

ALTER TABLE qux DROP CONSTRAINT qux_pkey;
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
ALTER TABLE qux ADD PRIMARY KEY(a,b ASC);
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
SELECT * FROM get_table_indexes('qux');
 relname  | indisprimary | indisunique |                           indexdef                           |   constraintdef
----------+--------------+-------------+--------------------------------------------------------------+--------------------
 qux_pkey | t            | t           | CREATE UNIQUE INDEX qux_pkey ON qux USING lsm (a ASC, b ASC) | PRIMARY KEY (a, b)
(1 row)

ALTER TABLE qux DROP CONSTRAINT qux_pkey;
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
ALTER TABLE qux ADD PRIMARY KEY(a,b HASH);
ERROR:  hash column not allowed after an ASC/DESC column
LINE 1: ALTER TABLE qux ADD PRIMARY KEY(a,b HASH);
                                          ^
CREATE INDEX ON qux (b);
CREATE INDEX ON qux (b HASH);
ERROR:  cannot colocate hash partitioned index
CREATE INDEX ON qux (c ASC);
CREATE INDEX ON qux ((a, c), b);
ERROR:  cannot colocate hash partitioned index
CREATE INDEX ON qux ((a, c));
ERROR:  cannot colocate hash partitioned index
CREATE INDEX ON qux (a, b);
CREATE INDEX ON qux (b, c ASC);
CREATE INDEX ON qux (b, c HASH);
ERROR:  hash column not allowed after an ASC/DESC column
LINE 1: CREATE INDEX ON qux (b, c HASH);
                                ^
SELECT * FROM get_table_indexes('qux');
   relname   | indisprimary | indisunique |                         indexdef                         | constraintdef
-------------+--------------+-------------+----------------------------------------------------------+---------------
 qux_a_b_idx | f            | f           | CREATE INDEX qux_a_b_idx ON qux USING lsm (a ASC, b ASC) |
 qux_b_c_idx | f            | f           | CREATE INDEX qux_b_c_idx ON qux USING lsm (b ASC, c ASC) |
 qux_b_idx   | f            | f           | CREATE INDEX qux_b_idx ON qux USING lsm (b ASC)          |
 qux_c_idx   | f            | f           | CREATE INDEX qux_c_idx ON qux USING lsm (c ASC)          |
(4 rows)

-- With ASC as default, creating a colocated table or index with SPLIT AT should fail
CREATE INDEX ON qux (b) SPLIT AT VALUES((10), (20), (30));
ERROR:  cannot create colocated index with split option
CREATE TABLE split_table(a int primary key, b int) SPLIT AT VALUES ((1000),(2000),(3000));
ERROR:  cannot create colocated table with split option
-- Test Table Rewrite operations with table colocation option
CREATE TABLE non_col_tbl_without_pk (k INT) WITH (colocation=0);
INSERT INTO non_col_tbl_without_pk SELECT generate_series(1, 100);
ALTER TABLE non_col_tbl_without_pk ADD PRIMARY KEY(k);
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
\d non_col_tbl_without_pk
       Table "public.non_col_tbl_without_pk"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 k      | integer |           | not null |
Indexes:
    "non_col_tbl_without_pk_pkey" PRIMARY KEY, lsm (k ASC)

SELECT min(k), max(k) FROM non_col_tbl_without_pk;
 min | max
-----+-----
   1 | 100
(1 row)

CREATE TABLE col_tbl_without_pk (k INT) WITH (colocation=1);
INSERT INTO col_tbl_without_pk SELECT generate_series(1, 10);
ALTER TABLE col_tbl_without_pk ADD PRIMARY KEY(k);
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
\d col_tbl_without_pk
         Table "public.col_tbl_without_pk"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 k      | integer |           | not null |
Indexes:
    "col_tbl_without_pk_pkey" PRIMARY KEY, lsm (k ASC), colocation: true
Colocation: true

SELECT sum(k) FROM col_tbl_without_pk;
 sum
-----
  55
(1 row)

CREATE MATERIALIZED VIEW non_col_mv WITH (colocation=0) AS SELECT * FROM col_tbl_without_pk WHERE k % 2 = 0;
CREATE MATERIALIZED VIEW col_mv WITH (colocation=1) AS SELECT * FROM col_tbl_without_pk WHERE k % 2 = 1;
SELECT sum(k) FROM non_col_mv;
 sum
-----
  30
(1 row)

SELECT sum(k) FROM col_mv;
 sum
-----
  25
(1 row)

INSERT INTO col_tbl_without_pk VALUES (11);
REFRESH MATERIALIZED VIEW non_col_mv;
REFRESH MATERIALIZED VIEW col_mv;
SELECT sum(k) FROM non_col_mv;
 sum
-----
  30
(1 row)

SELECT sum(k) FROM col_mv;
 sum
-----
  36
(1 row)

-- Test table partitions with colocation option
CREATE TABLE partitioned_table (k INT) PARTITION BY LIST (k);
CREATE TABLE col_table_partition PARTITION OF partitioned_table FOR VALUES IN (2) WITH (COLOCATION=TRUE);
\d col_table_partition
        Table "public.col_table_partition"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 k      | integer |           |          |
Partition of: partitioned_table FOR VALUES IN (2)
Colocation: true

CREATE TABLE non_col_table_partition PARTITION OF partitioned_table FOR VALUES IN (4) WITH (COLOCATION=FALSE);
\d non_col_table_partition
      Table "public.non_col_table_partition"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 k      | integer |           |          |
Partition of: partitioned_table FOR VALUES IN (4)

INSERT INTO partitioned_table VALUES (2), (4);
SELECT * FROM col_table_partition;
 k
---
 2
(1 row)

SELECT * FROM non_col_table_partition;
 k
---
 4
(1 row)

\c yugabyte
DROP DATABASE colocation_test;
