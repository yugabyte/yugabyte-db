--
-- YB_FEATURE_PARTITIONING Testsuite
--   An introduction on whether or not a feature is supported in YugaByte.
--   This test suite does not go in depth for each command.
--
-- Testing basic SPLIT AT functionalities.
--
\getenv abs_srcdir PG_ABS_SRCDIR
\set filename :abs_srcdir '/yb_commands/explainrun.sql'
\i :filename
-- A helper script to explain and run a query.  Use in regress tests by
-- defining :explain, :query, and optionally :hint#.
\set explain1 ':explain :hint1 :query;'
\set explain2 ':explain1 :explain :hint2 :query;'
\set explain3 ':explain2 :explain :hint3 :query;'
\set explain4 ':explain3 :explain :hint4 :query;'
\set explain5 ':explain4 :explain :hint5 :query;'
\set explain1run1 ':explain1; :hint1 :query;'
\set explain2run2 ':explain2; :hint1 :query; :hint2 :query;'
\set explain3run3 ':explain3; :hint1 :query; :hint2 :query; :hint3 :query;'
\set explain4run4 ':explain4; :hint1 :query; :hint2 :query; :hint3 :query; :hint4 :query;'
\set explain5run5 ':explain5; :hint1 :query; :hint2 :query; :hint3 :query; :hint4 :query; :hint5 :query;'
-- Default to no hints.
\set hint1 ''
\set hint2 ''
\set hint3 ''
\set hint4 ''
\set hint5 ''
\set explain 'EXPLAIN (COSTS OFF)'
--
-- Table with RANGE primary key.
--
CREATE TABLE feature_pk_split (
		col_integer INTEGER,
		col_varchar VARCHAR(100),
		col_text TEXT,
		col_double DOUBLE PRECISION,
		PRIMARY KEY (col_integer ASC, col_varchar ASC))
	SPLIT AT VALUES ((1, 'a'), (10, 'e'), (100, 'i'), (1000, 'o'), (10000, 'u'));
--
-- Secondary index for some of the splits.
-- This work needs optimization.
--
CREATE INDEX idx_small ON feature_pk_split (col_double ASC) WHERE col_double <= 9;
CREATE INDEX idx_large ON feature_pk_split (col_double ASC) WHERE col_double >= 10;
--
-- INSERT at least 1 row for each partition.
--
INSERT INTO feature_pk_split
	VALUES  ( -1, '-', 'partition 1', 1 ),
			( 0, 'm', 'partition 1', 2 ),
			( 1, '9', 'partition 1', 3 ),
			( 1, 'a', 'partition 2', 4 ),
			( 5, 'm', 'partition 2', 5 ),
			( 10, 'd', 'partition 2', 6 ),
			( 10, 'e', 'partition 3', 7 ),
			( 50, 'a', 'partition 3', 8 ),
			( 100, 'h', 'partition 3', 9 ),
			( 100, 'i', 'partition 4', 10 ),
			( 500, 'm', 'partition 4', 11 ),
			( 1000, 'n', 'partition 4', 12 ),
			( 1000, 'o', 'partition 5', 13 ),
			( 5000, 'm', 'partition 5', 14 ),
			( 10000, 't', 'partition 5', 15 ),
			( 10000, 'u', 'partition 6', 16 ),
			( 50000, 'm', 'partition 6', 17 ),
			( 100000, 'z', 'partition 6', 18 );
--
-- Full scan.
--
\set query 'SELECT * FROM feature_pk_split'
:explain1run1
          QUERY PLAN          
------------------------------
 Seq Scan on feature_pk_split
(1 row)

 col_integer | col_varchar |  col_text   | col_double 
-------------+-------------+-------------+------------
          -1 | -           | partition 1 |          1
           0 | m           | partition 1 |          2
           1 | 9           | partition 1 |          3
           1 | a           | partition 2 |          4
           5 | m           | partition 2 |          5
          10 | d           | partition 2 |          6
          10 | e           | partition 3 |          7
          50 | a           | partition 3 |          8
         100 | h           | partition 3 |          9
         100 | i           | partition 4 |         10
         500 | m           | partition 4 |         11
        1000 | n           | partition 4 |         12
        1000 | o           | partition 5 |         13
        5000 | m           | partition 5 |         14
       10000 | t           | partition 5 |         15
       10000 | u           | partition 6 |         16
       50000 | m           | partition 6 |         17
      100000 | z           | partition 6 |         18
(18 rows)

--
-- Full scan with conditional operators.
--
-- Operator `=`
SELECT $$
SELECT * FROM feature_pk_split WHERE col_text = 'partition 3'
$$ AS query \gset
:explain1run1
                     QUERY PLAN                     
----------------------------------------------------
 Seq Scan on feature_pk_split
   Storage Filter: (col_text = 'partition 3'::text)
(2 rows)

 col_integer | col_varchar |  col_text   | col_double 
-------------+-------------+-------------+------------
          10 | e           | partition 3 |          7
          50 | a           | partition 3 |          8
         100 | h           | partition 3 |          9
(3 rows)

-- Operator `IN`
SELECT $$
SELECT * FROM feature_pk_split WHERE col_text IN ('partition 2', 'partition 5')
$$ AS query \gset
:explain1run1
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Seq Scan on feature_pk_split
   Storage Filter: (col_text = ANY ('{"partition 2","partition 5"}'::text[]))
(2 rows)

 col_integer | col_varchar |  col_text   | col_double 
-------------+-------------+-------------+------------
           1 | a           | partition 2 |          4
           5 | m           | partition 2 |          5
          10 | d           | partition 2 |          6
        1000 | o           | partition 5 |         13
        5000 | m           | partition 5 |         14
       10000 | t           | partition 5 |         15
(6 rows)

-- Operator `<=`
\set query 'SELECT * FROM feature_pk_split WHERE col_double <= 10'
:explain1run1
                        QUERY PLAN                        
----------------------------------------------------------
 Seq Scan on feature_pk_split
   Storage Filter: (col_double <= '10'::double precision)
(2 rows)

 col_integer | col_varchar |  col_text   | col_double 
-------------+-------------+-------------+------------
          -1 | -           | partition 1 |          1
           0 | m           | partition 1 |          2
           1 | 9           | partition 1 |          3
           1 | a           | partition 2 |          4
           5 | m           | partition 2 |          5
          10 | d           | partition 2 |          6
          10 | e           | partition 3 |          7
          50 | a           | partition 3 |          8
         100 | h           | partition 3 |          9
         100 | i           | partition 4 |         10
(10 rows)

-- Operator `AND`
SELECT $$
SELECT * FROM feature_pk_split WHERE col_text >= 'partition 3' AND col_double <= 10
$$ AS query \gset
:explain1run1
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Seq Scan on feature_pk_split
   Storage Filter: ((col_text >= 'partition 3'::text) AND (col_double <= '10'::double precision))
(2 rows)

 col_integer | col_varchar |  col_text   | col_double 
-------------+-------------+-------------+------------
          10 | e           | partition 3 |          7
          50 | a           | partition 3 |          8
         100 | h           | partition 3 |          9
         100 | i           | partition 4 |         10
(4 rows)

--
-- Full scan with aggregate functions.
--
\set query 'SELECT COUNT(*) FROM feature_pk_split'
:explain1run1
             QUERY PLAN             
------------------------------------
 Finalize Aggregate
   ->  Seq Scan on feature_pk_split
         Partial Aggregate: true
(3 rows)

 count 
-------
    18
(1 row)

\set query 'SELECT MAX(col_integer) FROM feature_pk_split'
:explain1run1
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Result
   InitPlan 1 (returns $0)
     ->  Limit
           ->  Index Scan Backward using feature_pk_split_pkey on feature_pk_split
                 Index Cond: (col_integer IS NOT NULL)
(5 rows)

  max   
--------
 100000
(1 row)

\set query 'SELECT MIN(col_varchar) FROM feature_pk_split'
:explain1run1
             QUERY PLAN             
------------------------------------
 Aggregate
   ->  Seq Scan on feature_pk_split
(2 rows)

 min 
-----
 -
(1 row)

\set query 'SELECT AVG(col_double) FROM feature_pk_split'
:explain1run1
             QUERY PLAN             
------------------------------------
 Aggregate
   ->  Seq Scan on feature_pk_split
(2 rows)

 avg 
-----
 9.5
(1 row)

--
-- Primary key scan.
-- This work needs to be optimized.
--
SELECT $$
SELECT * FROM feature_pk_split WHERE col_integer = 50 AND col_varchar = 'a'
$$ AS query \gset
:explain1run1
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Index Scan using feature_pk_split_pkey on feature_pk_split
   Index Cond: ((col_integer = 50) AND ((col_varchar)::text = 'a'::text))
(2 rows)

 col_integer | col_varchar |  col_text   | col_double 
-------------+-------------+-------------+------------
          50 | a           | partition 3 |          8
(1 row)

SELECT $$
SELECT * FROM feature_pk_split
	WHERE col_integer >= 500 AND col_integer <= 5000 AND
		  col_varchar >= 'a' AND col_varchar <= 'n'
	ORDER BY col_integer, col_varchar
$$ AS query \gset
:explain1run1
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using feature_pk_split_pkey on feature_pk_split
   Index Cond: ((col_integer >= 500) AND (col_integer <= 5000) AND ((col_varchar)::text >= 'a'::text) AND ((col_varchar)::text <= 'n'::text))
(2 rows)

 col_integer | col_varchar |  col_text   | col_double 
-------------+-------------+-------------+------------
         500 | m           | partition 4 |         11
        1000 | n           | partition 4 |         12
        5000 | m           | partition 5 |         14
(3 rows)

SELECT $$
SELECT COUNT(*) FROM feature_pk_split WHERE col_integer = 50 AND col_varchar = 'a'
$$ AS query \gset
:explain1run1
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Finalize Aggregate
   ->  Index Scan using feature_pk_split_pkey on feature_pk_split
         Index Cond: ((col_integer = 50) AND ((col_varchar)::text = 'a'::text))
         Partial Aggregate: true
(4 rows)

 count 
-------
     1
(1 row)

SELECT $$
SELECT COUNT(*) FROM feature_pk_split
	WHERE col_integer >= 500 AND col_integer <= 5000 AND
		  col_varchar >= 'a' AND col_varchar <= 'n'
$$ AS query \gset
:explain1run1
                                                                     QUERY PLAN                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------
 Finalize Aggregate
   ->  Index Scan using feature_pk_split_pkey on feature_pk_split
         Index Cond: ((col_integer >= 500) AND (col_integer <= 5000) AND ((col_varchar)::text >= 'a'::text) AND ((col_varchar)::text <= 'n'::text))
         Partial Aggregate: true
(4 rows)

 count 
-------
     3
(1 row)

--
-- Secondary key scan.
-- This work needs to be optimized.
--
-- Scan one tablet.
\set query 'SELECT * FROM feature_pk_split WHERE col_double < 2'
:explain1run1
                     QUERY PLAN                     
----------------------------------------------------
 Index Scan using idx_small on feature_pk_split
   Index Cond: (col_double < '2'::double precision)
(2 rows)

 col_integer | col_varchar |  col_text   | col_double 
-------------+-------------+-------------+------------
          -1 | -           | partition 1 |          1
(1 row)

-- Scan two tablets.
\set query 'SELECT * FROM feature_pk_split WHERE col_double <= 5'
:explain1run1
                     QUERY PLAN                      
-----------------------------------------------------
 Index Scan using idx_small on feature_pk_split
   Index Cond: (col_double <= '5'::double precision)
(2 rows)

 col_integer | col_varchar |  col_text   | col_double 
-------------+-------------+-------------+------------
          -1 | -           | partition 1 |          1
           0 | m           | partition 1 |          2
           1 | 9           | partition 1 |          3
           1 | a           | partition 2 |          4
           5 | m           | partition 2 |          5
(5 rows)

-- Scan three tablets.
\set query 'SELECT * FROM feature_pk_split WHERE col_double <= 8'
:explain1run1
                     QUERY PLAN                      
-----------------------------------------------------
 Index Scan using idx_small on feature_pk_split
   Index Cond: (col_double <= '8'::double precision)
(2 rows)

 col_integer | col_varchar |  col_text   | col_double 
-------------+-------------+-------------+------------
          -1 | -           | partition 1 |          1
           0 | m           | partition 1 |          2
           1 | 9           | partition 1 |          3
           1 | a           | partition 2 |          4
           5 | m           | partition 2 |          5
          10 | d           | partition 2 |          6
          10 | e           | partition 3 |          7
          50 | a           | partition 3 |          8
(8 rows)

-- Scan four tablets.
\set query 'SELECT * FROM feature_pk_split WHERE col_double <= 11'
:explain1run1
                        QUERY PLAN                        
----------------------------------------------------------
 Seq Scan on feature_pk_split
   Storage Filter: (col_double <= '11'::double precision)
(2 rows)

 col_integer | col_varchar |  col_text   | col_double 
-------------+-------------+-------------+------------
          -1 | -           | partition 1 |          1
           0 | m           | partition 1 |          2
           1 | 9           | partition 1 |          3
           1 | a           | partition 2 |          4
           5 | m           | partition 2 |          5
          10 | d           | partition 2 |          6
          10 | e           | partition 3 |          7
          50 | a           | partition 3 |          8
         100 | h           | partition 3 |          9
         100 | i           | partition 4 |         10
         500 | m           | partition 4 |         11
(11 rows)

-- Scan five tablets.
\set query 'SELECT * FROM feature_pk_split WHERE col_double <= 14'
:explain1run1
                        QUERY PLAN                        
----------------------------------------------------------
 Seq Scan on feature_pk_split
   Storage Filter: (col_double <= '14'::double precision)
(2 rows)

 col_integer | col_varchar |  col_text   | col_double 
-------------+-------------+-------------+------------
          -1 | -           | partition 1 |          1
           0 | m           | partition 1 |          2
           1 | 9           | partition 1 |          3
           1 | a           | partition 2 |          4
           5 | m           | partition 2 |          5
          10 | d           | partition 2 |          6
          10 | e           | partition 3 |          7
          50 | a           | partition 3 |          8
         100 | h           | partition 3 |          9
         100 | i           | partition 4 |         10
         500 | m           | partition 4 |         11
        1000 | n           | partition 4 |         12
        1000 | o           | partition 5 |         13
        5000 | m           | partition 5 |         14
(14 rows)

-- Scan six tablets.
\set query 'SELECT * FROM feature_pk_split WHERE col_double <= 17'
:explain1run1
                        QUERY PLAN                        
----------------------------------------------------------
 Seq Scan on feature_pk_split
   Storage Filter: (col_double <= '17'::double precision)
(2 rows)

 col_integer | col_varchar |  col_text   | col_double 
-------------+-------------+-------------+------------
          -1 | -           | partition 1 |          1
           0 | m           | partition 1 |          2
           1 | 9           | partition 1 |          3
           1 | a           | partition 2 |          4
           5 | m           | partition 2 |          5
          10 | d           | partition 2 |          6
          10 | e           | partition 3 |          7
          50 | a           | partition 3 |          8
         100 | h           | partition 3 |          9
         100 | i           | partition 4 |         10
         500 | m           | partition 4 |         11
        1000 | n           | partition 4 |         12
        1000 | o           | partition 5 |         13
        5000 | m           | partition 5 |         14
       10000 | t           | partition 5 |         15
       10000 | u           | partition 6 |         16
       50000 | m           | partition 6 |         17
(17 rows)

-- Scan all tablets.
\set query 'SELECT * FROM feature_pk_split WHERE col_double <= 100'
:explain1run1
                        QUERY PLAN                         
-----------------------------------------------------------
 Seq Scan on feature_pk_split
   Storage Filter: (col_double <= '100'::double precision)
(2 rows)

 col_integer | col_varchar |  col_text   | col_double 
-------------+-------------+-------------+------------
          -1 | -           | partition 1 |          1
           0 | m           | partition 1 |          2
           1 | 9           | partition 1 |          3
           1 | a           | partition 2 |          4
           5 | m           | partition 2 |          5
          10 | d           | partition 2 |          6
          10 | e           | partition 3 |          7
          50 | a           | partition 3 |          8
         100 | h           | partition 3 |          9
         100 | i           | partition 4 |         10
         500 | m           | partition 4 |         11
        1000 | n           | partition 4 |         12
        1000 | o           | partition 5 |         13
        5000 | m           | partition 5 |         14
       10000 | t           | partition 5 |         15
       10000 | u           | partition 6 |         16
       50000 | m           | partition 6 |         17
      100000 | z           | partition 6 |         18
(18 rows)

-- Index only scan.
\set query 'SELECT col_double FROM feature_pk_split WHERE col_double <= 8'
:explain1run1
                     QUERY PLAN                      
-----------------------------------------------------
 Index Only Scan using idx_small on feature_pk_split
   Index Cond: (col_double <= '8'::double precision)
(2 rows)

 col_double 
------------
          1
          2
          3
          4
          5
          6
          7
          8
(8 rows)

--
-- Table that has min & max split values.
-- * Using 3 splits: (1, MAX), (10, MIN), and (100, MIN).
-- * Unspecified split values are defaulted to MINVALUE.
--     SPLIT (10) is (10, MIN)
--
CREATE TABLE feature_pk_split_min_max (
		col_integer INTEGER,
		col_varchar VARCHAR(100),
		col_text TEXT,
		col_double DOUBLE PRECISION,
		PRIMARY KEY (col_integer ASC, col_varchar ASC))
	SPLIT AT VALUES ((1, MAXVALUE), (10), (100, MINVALUE));
--
-- INSERT 2 rows to each partition.
--
INSERT INTO feature_pk_split_min_max
	VALUES  ( 0, '-', 'partition 1', 2 ),
			( 1, 'z', 'partition 1', 2 ),
			( 2, '-', 'partition 2', 3 ),
			( 3, '-', 'partition 2', 3 ),
			( 9, 'z', 'partition 2', 3 ),
			( 10, '-', 'partition 3', 4 ),
			( 20, '-', 'partition 3', 4 ),
			( 30, '-', 'partition 3', 4),
			( 99, 'z', 'partition 3', 4 ),
			( 100, '-', 'partition 4', 5 ),
			( 200, '-', 'partition 4', 5 ),
			( 300, '-', 'partition 4', 5 ),
			( 400, '-', 'partition 4', 5 ),
			( 999, 'z', 'partition 4', 5 );
--
-- SELECT from each partition.
-- TODO(neil) To complete this test, server must provide a method to track tablet information for
-- each row. Currently, this is verified by tracking number rows per tablet during development.
--
-- All rows must be from partition 1: (nan) < PKey < (1, max)
SELECT * FROM feature_pk_split_min_max WHERE col_integer <= 1;
 col_integer | col_varchar |  col_text   | col_double 
-------------+-------------+-------------+------------
           0 | -           | partition 1 |          2
           1 | z           | partition 1 |          2
(2 rows)

-- All rows must be from partition 2: (1, max) <= PKey < (10, min)
SELECT * FROM feature_pk_split_min_max WHERE col_integer > 1 AND col_integer < 10;
 col_integer | col_varchar |  col_text   | col_double 
-------------+-------------+-------------+------------
           2 | -           | partition 2 |          3
           3 | -           | partition 2 |          3
           9 | z           | partition 2 |          3
(3 rows)

-- All rows must be from partition3: (10, min) <= PKey < (100, min)
SELECT * FROM feature_pk_split_min_max WHERE col_integer >= 10 AND col_integer < 100;
 col_integer | col_varchar |  col_text   | col_double 
-------------+-------------+-------------+------------
          10 | -           | partition 3 |          4
          20 | -           | partition 3 |          4
          30 | -           | partition 3 |          4
          99 | z           | partition 3 |          4
(4 rows)

-- All rows must be from partition 4: (100, min) <= PKey < (nan)
SELECT * FROM feature_pk_split_min_max WHERE col_integer >= 100;
 col_integer | col_varchar |  col_text   | col_double 
-------------+-------------+-------------+------------
         100 | -           | partition 4 |          5
         200 | -           | partition 4 |          5
         300 | -           | partition 4 |          5
         400 | -           | partition 4 |          5
         999 | z           | partition 4 |          5
(5 rows)

