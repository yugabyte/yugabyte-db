-- This file contains tests that use EXPLAIN in conjunction with INSERT ... ON CONFLICT.
-- The mapping between this test's output and outfiles is as follows:
--  > yb.orig.insert_on_conflict_with_explain.out: INSERT ... ON CONFLICT read batching disabled.
--  > yb.orig.insert_on_conflict_with_explain_1.out: INSERT ... ON CONFLICT read batching enabled, batch size = 1.
--  > yb.orig.insert_on_conflict_with_explain_2.out: INSERT ... ON CONFLICT read batching enabled, batch size = 2.
--  > yb.orig.insert_on_conflict_with_explain_3.out: INSERT ... ON CONFLICT read batching enabled, batch size > 2.
--- GH-28234: IndexOnlyScan support for INSERT ... ON CONFLICT ... DO NOTHING
CREATE TABLE t_ios (k INT PRIMARY KEY, v1 INT, v2 INT);
CREATE UNIQUE INDEX NONCONCURRENTLY t_ios_v1 ON t_ios (v1);
INSERT INTO t_ios (k, v1, v2) (SELECT i, 10 - i, i FROM generate_series(1, 10) AS i);
-- No conflict with either index.
EXPLAIN (ANALYZE, DIST, COSTS OFF) INSERT INTO t_ios VALUES (11, 11, 11), (12, 12, 12) ON CONFLICT DO NOTHING;
                       QUERY PLAN                        
---------------------------------------------------------
 Insert on t_ios (actual rows=0 loops=1)
   Conflict Resolution: NOTHING
   Tuples Inserted: 2
   Conflicting Tuples: 0
   ->  Values Scan on "*VALUES*" (actual rows=2 loops=1)
         Storage Table Read Requests: 2
         Storage Table Read Ops: 2
         Storage Index Read Requests: 2
         Storage Index Read Ops: 2
         Storage Table Write Requests: 2
         Storage Index Write Requests: 2
         Storage Flush Requests: 1
 Storage Read Requests: 4
 Storage Read Ops: 4
 Storage Rows Scanned: 0
 Storage Write Requests: 4
 Storage Flush Requests: 2
(17 rows)

-- Conflict with exactly one index.
EXPLAIN (ANALYZE, DIST, COSTS OFF) INSERT INTO t_ios VALUES (1, 13, 100), (2, 14, 101) ON CONFLICT DO NOTHING;
                       QUERY PLAN                        
---------------------------------------------------------
 Insert on t_ios (actual rows=0 loops=1)
   Conflict Resolution: NOTHING
   Tuples Inserted: 0
   Conflicting Tuples: 2
   ->  Values Scan on "*VALUES*" (actual rows=2 loops=1)
         Storage Table Read Requests: 2
         Storage Table Read Ops: 2
         Storage Table Rows Scanned: 2
 Storage Read Requests: 2
 Storage Read Ops: 2
 Storage Rows Scanned: 2
 Storage Write Requests: 0
 Storage Flush Requests: 0
(13 rows)

EXPLAIN (ANALYZE, DIST, COSTS OFF) INSERT INTO t_ios VALUES (1, 13, 100), (2, 14, 101) ON CONFLICT (k) DO NOTHING;
                       QUERY PLAN                        
---------------------------------------------------------
 Insert on t_ios (actual rows=0 loops=1)
   Conflict Resolution: NOTHING
   Conflict Arbiter Indexes: t_ios_pkey
   Tuples Inserted: 0
   Conflicting Tuples: 2
   ->  Values Scan on "*VALUES*" (actual rows=2 loops=1)
         Storage Table Read Requests: 2
         Storage Table Read Ops: 2
         Storage Table Rows Scanned: 2
 Storage Read Requests: 2
 Storage Read Ops: 2
 Storage Rows Scanned: 2
 Storage Write Requests: 0
 Storage Flush Requests: 0
(14 rows)

EXPLAIN (ANALYZE, DIST, COSTS OFF) INSERT INTO t_ios VALUES (1, 13, 100), (2, 14, 101) ON CONFLICT (v1) DO NOTHING;
ERROR:  duplicate key value violates unique constraint "t_ios_pkey"
EXPLAIN (ANALYZE, DIST, COSTS OFF) INSERT INTO t_ios VALUES (13, 1, 100), (14, 2, 101) ON CONFLICT DO NOTHING;
                       QUERY PLAN                        
---------------------------------------------------------
 Insert on t_ios (actual rows=0 loops=1)
   Conflict Resolution: NOTHING
   Tuples Inserted: 0
   Conflicting Tuples: 2
   ->  Values Scan on "*VALUES*" (actual rows=2 loops=1)
         Storage Table Read Requests: 2
         Storage Table Read Ops: 2
         Storage Index Read Requests: 2
         Storage Index Read Ops: 2
         Storage Index Rows Scanned: 2
 Storage Read Requests: 4
 Storage Read Ops: 4
 Storage Rows Scanned: 2
 Storage Write Requests: 0
 Storage Flush Requests: 0
(15 rows)

EXPLAIN (ANALYZE, DIST, COSTS OFF) INSERT INTO t_ios VALUES (13, 1, 100), (14, 2, 101) ON CONFLICT (v1) DO NOTHING;
                       QUERY PLAN                        
---------------------------------------------------------
 Insert on t_ios (actual rows=0 loops=1)
   Conflict Resolution: NOTHING
   Conflict Arbiter Indexes: t_ios_v1
   Tuples Inserted: 0
   Conflicting Tuples: 2
   ->  Values Scan on "*VALUES*" (actual rows=2 loops=1)
         Storage Index Read Requests: 2
         Storage Index Read Ops: 2
         Storage Index Rows Scanned: 2
 Storage Read Requests: 2
 Storage Read Ops: 2
 Storage Rows Scanned: 2
 Storage Write Requests: 0
 Storage Flush Requests: 0
(14 rows)

EXPLAIN (ANALYZE, DIST, COSTS OFF) INSERT INTO t_ios VALUES (13, 1, 100), (14, 2, 101) ON CONFLICT (k) DO NOTHING;
ERROR:  duplicate key value violates unique constraint "t_ios_v1"
-- Conflict with different rows in both indexes.
EXPLAIN (ANALYZE, DIST, COSTS OFF) INSERT INTO t_ios VALUES (1, 1, 100), (2, 2, 101) ON CONFLICT DO NOTHING;
                       QUERY PLAN                        
---------------------------------------------------------
 Insert on t_ios (actual rows=0 loops=1)
   Conflict Resolution: NOTHING
   Tuples Inserted: 0
   Conflicting Tuples: 2
   ->  Values Scan on "*VALUES*" (actual rows=2 loops=1)
         Storage Table Read Requests: 2
         Storage Table Read Ops: 2
         Storage Table Rows Scanned: 2
 Storage Read Requests: 2
 Storage Read Ops: 2
 Storage Rows Scanned: 2
 Storage Write Requests: 0
 Storage Flush Requests: 0
(13 rows)

DROP INDEX t_ios_v1;
CREATE UNIQUE INDEX NONCONCURRENTLY t_ios_v1_v2 ON t_ios (v1, v2);
-- The IndexOnlyScan should also work with multi-column indexes.
-- No conflict with multi-column index.
EXPLAIN (ANALYZE, DIST, COSTS OFF) INSERT INTO t_ios VALUES (100, 5, 100), (101, 100, 5) ON CONFLICT (v1, v2) DO NOTHING;
                       QUERY PLAN                        
---------------------------------------------------------
 Insert on t_ios (actual rows=0 loops=1)
   Conflict Resolution: NOTHING
   Conflict Arbiter Indexes: t_ios_v1_v2
   Tuples Inserted: 2
   Conflicting Tuples: 0
   ->  Values Scan on "*VALUES*" (actual rows=2 loops=1)
         Storage Index Read Requests: 2
         Storage Index Read Ops: 2
         Storage Table Write Requests: 2
         Storage Index Write Requests: 2
         Storage Flush Requests: 1
 Storage Read Requests: 2
 Storage Read Ops: 2
 Storage Rows Scanned: 0
 Storage Write Requests: 4
 Storage Flush Requests: 2
(16 rows)

-- Conflict with multi-column index.
EXPLAIN (ANALYZE, DIST, COSTS OFF) INSERT INTO t_ios VALUES (102, 3, 7) ON CONFLICT (v1, v2) DO NOTHING;
                  QUERY PLAN                   
-----------------------------------------------
 Insert on t_ios (actual rows=0 loops=1)
   Conflict Resolution: NOTHING
   Conflict Arbiter Indexes: t_ios_v1_v2
   Tuples Inserted: 0
   Conflicting Tuples: 1
   ->  Result *RESULT* (actual rows=1 loops=1)
         Storage Index Read Requests: 1
         Storage Index Read Ops: 1
         Storage Index Rows Scanned: 1
 Storage Read Requests: 1
 Storage Read Ops: 1
 Storage Rows Scanned: 1
 Storage Write Requests: 0
 Storage Flush Requests: 0
(14 rows)

EXPLAIN (ANALYZE, DIST, COSTS OFF) INSERT INTO t_ios VALUES (102, 3, 7) ON CONFLICT DO NOTHING;
                  QUERY PLAN                   
-----------------------------------------------
 Insert on t_ios (actual rows=0 loops=1)
   Conflict Resolution: NOTHING
   Tuples Inserted: 0
   Conflicting Tuples: 1
   ->  Result *RESULT* (actual rows=1 loops=1)
         Storage Table Read Requests: 1
         Storage Table Read Ops: 1
         Storage Index Read Requests: 1
         Storage Index Read Ops: 1
         Storage Index Rows Scanned: 1
 Storage Read Requests: 2
 Storage Read Ops: 2
 Storage Rows Scanned: 1
 Storage Write Requests: 0
 Storage Flush Requests: 0
(15 rows)

-- Conflict with non-arbiter index
EXPLAIN (ANALYZE, DIST, COSTS OFF) INSERT INTO t_ios VALUES (1, 1, 100) ON CONFLICT (v1, v2) DO NOTHING;
ERROR:  duplicate key value violates unique constraint "t_ios_pkey"
EXPLAIN (ANALYZE, DIST, COSTS OFF) INSERT INTO t_ios VALUES (1, 1, 100) ON CONFLICT DO NOTHING;
                  QUERY PLAN                   
-----------------------------------------------
 Insert on t_ios (actual rows=0 loops=1)
   Conflict Resolution: NOTHING
   Tuples Inserted: 0
   Conflicting Tuples: 1
   ->  Result *RESULT* (actual rows=1 loops=1)
         Storage Table Read Requests: 1
         Storage Table Read Ops: 1
         Storage Table Rows Scanned: 1
 Storage Read Requests: 1
 Storage Read Ops: 1
 Storage Rows Scanned: 1
 Storage Write Requests: 0
 Storage Flush Requests: 0
(13 rows)

SELECT * FROM t_ios ORDER BY k;
  k  | v1  | v2  
-----+-----+-----
   1 |   9 |   1
   2 |   8 |   2
   3 |   7 |   3
   4 |   6 |   4
   5 |   5 |   5
   6 |   4 |   6
   7 |   3 |   7
   8 |   2 |   8
   9 |   1 |   9
  10 |   0 |  10
  11 |  11 |  11
  12 |  12 |  12
 100 |   5 | 100
 101 | 100 |   5
(14 rows)

-- IndexOnlyScan for INSERT ... ON CONFLICT ... DO NOTHING should also work
-- with partitioned tables.
CREATE TABLE t_ios_base (k INT PRIMARY KEY, v1 INT) PARTITION BY RANGE (k);
CREATE TABLE t_ios_p1 PARTITION OF t_ios_base FOR VALUES FROM (0) TO (10);
CREATE TABLE t_ios_p2 PARTITION OF t_ios_base FOR VALUES FROM (10) TO (20);
INSERT INTO t_ios_base VALUES (1, 1), (2, 2), (11, 11), (12, 12);
CREATE UNIQUE INDEX idx_ios_p1_v1 ON t_ios_p1 (k, v1);
-- Query should error out when not all partitions have an arbiter index.
EXPLAIN (ANALYZE, DIST, COSTS OFF) INSERT INTO t_ios_base VALUES (1, 1), (11, 11) ON CONFLICT (k, v1) DO NOTHING;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
-- Query should also error out when the indexes on the partition are not part of the same heirarchy.
CREATE UNIQUE INDEX idx_ios_p2_v1 ON t_ios_p2 (k, v1);
EXPLAIN (ANALYZE, DIST, COSTS OFF) INSERT INTO t_ios_base VALUES (1, 1), (11, 11) ON CONFLICT (k, v1) DO NOTHING;
ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
DROP INDEX idx_ios_p1_v1;
DROP INDEX idx_ios_p2_v1;
-- IndexOnlyScan should be performed when all partitions share an arbiter index that is part of the same heirarchy.
CREATE UNIQUE INDEX idx_ios_base_v1 ON t_ios_base (k, v1);
EXPLAIN (ANALYZE, DIST, COSTS OFF) INSERT INTO t_ios_base VALUES (1, 1), (11, 11) ON CONFLICT (k, v1) DO NOTHING;
                       QUERY PLAN                        
---------------------------------------------------------
 Insert on t_ios_base (actual rows=0 loops=1)
   Conflict Resolution: NOTHING
   Conflict Arbiter Indexes: idx_ios_base_v1
   Tuples Inserted: 0
   Conflicting Tuples: 2
   ->  Values Scan on "*VALUES*" (actual rows=2 loops=1)
         Storage Index Read Requests: 2
         Storage Index Read Ops: 2
         Storage Index Rows Scanned: 2
 Storage Read Requests: 2
 Storage Read Ops: 2
 Storage Rows Scanned: 2
 Storage Write Requests: 0
 Storage Flush Requests: 0
(14 rows)

