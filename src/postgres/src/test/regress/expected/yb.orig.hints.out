\set ECHO all
SET client_min_messages = warning;
drop schema if exists yb_hints cascade;
create schema yb_hints;
reset all;
set search_path to yb_hints;
-- Turn on internal hint generation testing. For all query without hints,
-- hints will be generated and used to generate a plan that should be
-- identical (in terms on plan shape and access/join methods) to the one
-- the planner returned for the query originally.
set pg_hint_plan.yb_enable_internal_hint_test to on;
-- Want to issue a warning if we find bad hints.
set pg_hint_plan.yb_bad_hint_mode to warn;
create  table t0 (a0 int, b0 int, c0 int, d0 int, e0 int, f0 int, g0 int, h0 int, i0 int, j0 int, k0 int, ch0 char(5), vch0 varchar(5), unn0 int unique not null, primary key(unn0));
insert into t0 values(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '00000', '00000', 0);
insert into t0 values(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '11111', '11111', 1);
insert into t0 values(2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, '22222', '22222', 2);
insert into t0 values(3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, '33333', '33333', 3);
insert into t0 values(3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, '3333', '3333', 4);
insert into t0 values(null, null, null, null, null, null, null, null, null, null, null, null, null, 5);
insert into t0 values(6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, '66666', '66666', 6);
insert into t0 values(7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, '77777', '77777', 7);
insert into t0 values(7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, '7777', '7777', 8);
insert into t0 values(null, null, null, null, null, null, null, null, null, null, null, null, null, 9);
create  table t1 (a1 int, b1 int, c1 int, d1 int, ch1 char(5), vch1 varchar(5), unn1 int unique not null, primary key(unn1));
insert into t1 select a0, b0, c0, d0, ch0, vch0, unn0 from t0;
insert into t1 select a0, b0, c0, d0, ch0, vch0, unn0+10 from t0;
create index t1_a1_asc_idx on t1(a1);
create index t1_a1_asc_b1_asc_idx on t1(a1 asc, b1 asc);
create index t1_a1_desc_idx on t1(a1 desc);
create  table t2 (a2 int, b2 int, c2 int, d2 int, ch2 char(5), vch2 varchar(5), unn2 int unique not null, primary key(unn2));
create index t2_a2_idx on t2(a2) ;
insert into t2 select * from t1;
insert into t2 select a1, b1, c1, d1, ch1, vch1, unn1+20 from t1;
insert into t2 select a1, null, c1, null, ch1, vch1, unn1+40 from t1;
insert into t2 select null, b1, null, d1, ch1, vch1, unn1+60 from t1;
create  table t3 (a3 int, b3 int, c3 int, d3 int, ch3 char(5), vch3 varchar(5), unn3 int unique not null, primary key(unn3));
insert into t3 select * from t2;
insert into t3 select a0, b0, c0, d0, ch0, vch0, unn0+80 from t0;
create  table t4 (a4 int, b4 int, c4 int, d4 int, ch4 char(5), vch4 varchar(5), unn4 int unique not null, primary key(unn4));
insert into t4 select * from t3;
insert into t4 select a0, b0, c0, d0, ch0, vch0, unn0+90 from t0;
create  table t5 (a5 int, b5 int, c5 int, d5 int, ch5 char(5), vch5 varchar(5), unn5 int unique not null, primary key(unn5));
insert into t5 select * from t4;
insert into t5 select a0, b0, c0, d0, ch0, vch0, unn0+100 from t0;
create  table t6 (a6 int, b6 int, c6 int, d6 int, ch6 char(5), vch6 varchar(5), unn6 int unique not null, primary key(unn6));
insert into t6 select * from t5;
insert into t6 select a0, b0, c0, d0, ch0, vch0, unn0+110 from t0;
create  table t7 (a7 int, b7 int, c7 int, d7 int, ch7 char(5), vch7 varchar(5), unn7 int unique not null, primary key(unn7));
insert into t7 select * from t6;
insert into t7 select a0, b0, c0, d0, ch0, vch0, unn0+120 from t0;
create  table t8 (a8 int, b8 int, c8 int, d8 int, ch8 char(5), vch8 varchar(5), unn8 int unique not null, primary key(unn8));
insert into t8 select * from t7;
insert into t8 select a0, b0, c0, d0, ch0, vch0, unn0+130 from t0;
create  table t9 (a9 int, b9 int, c9 int, d9 int, ch9 char(5), vch9 varchar(5), unn9 int unique not null, primary key(unn9));
insert into t9 select * from t8;
insert into t9 select a0, b0, c0, d0, ch0, vch0, unn0+140 from t0;
create  table t10 (a10 int, b10 int, c10 int, d10 int, ch10 char(5), vch10 varchar(5), unn10 int unique not null, primary key(unn10));
insert into t10 select * from t9;
insert into t10 select a0, b0, c0, d0, ch0, vch0, unn0+150 from t0;
CREATE TABLE prt1 (a int, b int, c varchar) PARTITION BY RANGE(a);
CREATE TABLE prt1_p1 PARTITION OF prt1 FOR VALUES FROM (0) TO (250);
CREATE TABLE prt1_p3 PARTITION OF prt1 FOR VALUES FROM (500) TO (600);
CREATE TABLE prt1_p2 PARTITION OF prt1 FOR VALUES FROM (250) TO (500);
INSERT INTO prt1 SELECT i, i % 25, to_char(i, 'FM0000') FROM generate_series(0, 599) i WHERE i % 2 = 0;
CREATE INDEX iprt1_p1_a on prt1_p1(a);
CREATE INDEX iprt1_p1_a_asc on prt1_p1(a asc);
CREATE INDEX iprt1_p2_a on prt1_p2(a);
CREATE INDEX iprt1_p3_a on prt1_p3(a);
CREATE TABLE prt2 (a int, b int, c varchar) PARTITION BY RANGE(b);
CREATE TABLE prt2_p1 PARTITION OF prt2 FOR VALUES FROM (0) TO (250);
CREATE TABLE prt2_p2 PARTITION OF prt2 FOR VALUES FROM (250) TO (500);
CREATE TABLE prt2_p3 PARTITION OF prt2 FOR VALUES FROM (500) TO (600);
INSERT INTO prt2 SELECT i % 25, i, to_char(i, 'FM0000') FROM generate_series(0, 599) i WHERE i % 3 = 0;
CREATE INDEX iprt2_p1_b on prt2_p1(b);
CREATE INDEX iprt2_p1_b_desc on prt2_p1(b desc);
CREATE INDEX iprt2_p2_b on prt2_p2(b);
CREATE INDEX iprt2_p3_b on prt2_p3(b);
CREATE TABLE tbl (c1 INT, c2 INT, PRIMARY KEY (c1 ASC, c2 ASC));
analyze t0 ;
analyze t1 ;
analyze t2 ;
analyze t3 ;
analyze t4 ;
analyze t5 ;
analyze t6 ;
analyze t7 ;
analyze t8 ;
analyze t9 ;
analyze t10 ;
ANALYZE prt1;
ANALYZE prt2;
ANALYZE tbl;
-- Simple query.
explain (hints on, costs off) select * from t1 where a1=1;
                                                                                                                                                                                                                                                                    QUERY PLAN                                                                                                                                                                                                                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Seq Scan on t1
   Storage Filter: (a1 = 1)
 Generated hints: /*+ SeqScan(t1) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(3 rows)

-- Simple join query.
explain (hints on, costs on) select * from t1, t2 where a1<5 and b1=b2 order by a1 asc;
                                                                                                                                                                                                                                                                                                       QUERY PLAN                                                                                                                                                                                                                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=9.78..9.78 rows=1 width=136)
   Sort Key: t1.a1
   ->  YB Batched Nested Loop Join  (cost=0.01..9.77 rows=1 width=136)
         Join Filter: (t1.b1 = t2.b2)
         ->  Seq Scan on t2  (cost=0.00..8.00 rows=80 width=68)
         ->  Memoize  (cost=0.01..0.09 rows=0 width=68)
               Cache Key: t2.b2
               Cache Mode: logical
               ->  Index Scan using t1_a1_asc_b1_asc_idx on t1  (cost=0.00..0.08 rows=0 width=68)
                     Index Cond: ((b1 = ANY (ARRAY[t2.b2, $1, $2, ..., $1023])) AND (a1 < 5))
 Generated hints: /*+ Leading((t2 t1)) SeqScan(t2) IndexScan(t1 t1_a1_asc_b1_asc_idx) YbBatchedNL(t1 t2) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(11 rows)

-- Force an index and change the join order.
/*+ Leading((t1 t2)) SeqScan(t2) IndexScan(t1 t1_a1_desc_idx) NestLoop(t2 t1) */ explain (hints on, costs off) select * from t1, t2 where a1<5 and b1=b2 order by a1 asc;
                                                                                                                                                                                                                                                                                                   QUERY PLAN                                                                                                                                                                                                                                                                                                   
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Join Filter: (t1.b1 = t2.b2)
   ->  Index Scan Backward using t1_a1_desc_idx on t1
         Index Cond: (a1 < 5)
   ->  Seq Scan on t2
 Generated hints: /*+ Leading((t1 t2)) IndexScan(t1 t1_a1_desc_idx) SeqScan(t2) NestLoop(t1 t2) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(6 rows)

-- OK since t1 and t2 do not have to be directly joined. Should not generate warnings.
/*+ noNestLoop(t1 t2) */ explain (costs off) select max(a1) from t1 join t2 on a1<a2 join t3 on a1=a3;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Aggregate
   ->  Nested Loop
         Join Filter: (t1.a1 < t2.a2)
         ->  YB Batched Nested Loop Join
               Join Filter: (t1.a1 = t3.a3)
               ->  Seq Scan on t3
               ->  Memoize
                     Cache Key: t3.a3
                     Cache Mode: logical
                     ->  Index Only Scan using t1_a1_desc_idx on t1
                           Index Cond: (a1 = ANY (ARRAY[t3.a3, $1, $2, ..., $1023]))
         ->  Materialize
               ->  Seq Scan on t2
(13 rows)

-- Force t0-t1 join to be first. Should see no warnings/errors.
/*+ Leading(((t0 t1) t2)) */ explain (hints on, costs off) select count(*) from t0 left join t1 on a0=a1 inner join t2 on b0=b2 where unn2=1;
                                                                                                                                                                                                                                                                                                                 QUERY PLAN                                                                                                                                                                                                                                                                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Hash Join
         Hash Cond: (t0.b0 = t2.b2)
         ->  Hash Left Join
               Hash Cond: (t0.a0 = t1.a1)
               ->  Seq Scan on t0
               ->  Hash
                     ->  Seq Scan on t1
         ->  Hash
               ->  Index Scan using t2_pkey on t2
                     Index Cond: (unn2 = 1)
 Generated hints: /*+ Leading(((t0 t1) t2)) SeqScan(t0) SeqScan(t1) HashJoin(t0 t1) IndexScan(t2 t2_pkey) HashJoin(t0 t1 t2) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(12 rows)

-- Force t2-t0 join first and make this inner input to hash join with t1. Should see no errors/warnings.
/*+ Leading((t1 (t2 t0))) hashJoin(t0 t1 t2)  */ explain (hints on, costs off) select count(*) from t0 left join t1 on a0=a1 inner join t2 on b0=b2 where unn2=1;
                                                                                                                                                                                                                                                                                                                 QUERY PLAN                                                                                                                                                                                                                                                                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Hash Right Join
         Hash Cond: (t1.a1 = t0.a0)
         ->  Seq Scan on t1
         ->  Hash
               ->  Nested Loop
                     Join Filter: (t0.b0 = t2.b2)
                     ->  Index Scan using t2_pkey on t2
                           Index Cond: (unn2 = 1)
                     ->  Seq Scan on t0
 Generated hints: /*+ Leading((t1 (t2 t0))) SeqScan(t1) IndexScan(t2 t2_pkey) SeqScan(t0) NestLoop(t0 t2) HashJoin(t0 t1 t2) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(11 rows)

-- 'dt' should appear in the EXPLAIN since a subquery scan is required. No warnings/errors expected.
explain (hints on, costs off) select count(*) from t1, t2, t3, (select b4 from t4, t5 where a4=a5 group by b4, b5) dt where t1.a1=t2.a2 and a1=a3 and a1=b4;
                                                                                                                                                                                                                                                                                                                                                                            QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  YB Batched Nested Loop Join
         Join Filter: (t1.a1 = t2.a2)
         ->  YB Batched Nested Loop Join
               Join Filter: (t3.a3 = t1.a1)
               ->  Hash Join
                     Hash Cond: (t3.a3 = dt.b4)
                     ->  Seq Scan on t3
                     ->  Hash
                           ->  Subquery Scan on dt
                                 ->  HashAggregate
                                       Group Key: t4.b4, t5.b5
                                       ->  Hash Join
                                             Hash Cond: (t5.a5 = t4.a4)
                                             ->  Seq Scan on t5
                                             ->  Hash
                                                   ->  Seq Scan on t4
               ->  Memoize
                     Cache Key: t3.a3
                     Cache Mode: logical
                     ->  Index Only Scan using t1_a1_desc_idx on t1
                           Index Cond: (a1 = ANY (ARRAY[t3.a3, $1, $2, ..., $1023]))
         ->  Memoize
               Cache Key: t3.a3
               Cache Mode: logical
               ->  Index Only Scan using t2_a2_idx on t2
                     Index Cond: (a2 = ANY (ARRAY[t3.a3, $1025, $1026, ..., $2047]))
 Generated hints: /*+ Leading((((t3 dt) t1) t2)) SeqScan(t3) HashJoin(dt t3) IndexOnlyScan(t1 t1_a1_desc_idx) YbBatchedNL(dt t1 t3) IndexOnlyScan(t2 t2_a2_idx) YbBatchedNL(dt t1 t2 t3)  Leading((t5 t4)) SeqScan(t5) SeqScan(t4) HashJoin(t4 t5) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(28 rows)

-- 'dt' will not appear in the EXPLAIN since a subquery scan is not required. (Removed a GROUP BY column so simple subquery scan is removed).
explain (costs off) select count(*) from t1, t2, t3, (select b4 from t4, t5 where a4=a5 group by b4) dt where t1.a1=t2.a2 and a1=a3 and a1=b4;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Aggregate
   ->  YB Batched Nested Loop Join
         Join Filter: (t1.a1 = t2.a2)
         ->  YB Batched Nested Loop Join
               Join Filter: (t3.a3 = t1.a1)
               ->  Hash Join
                     Hash Cond: (t3.a3 = t4.b4)
                     ->  Seq Scan on t3
                     ->  Hash
                           ->  HashAggregate
                                 Group Key: t4.b4
                                 ->  Hash Join
                                       Hash Cond: (t5.a5 = t4.a4)
                                       ->  Seq Scan on t5
                                       ->  Hash
                                             ->  Seq Scan on t4
               ->  Memoize
                     Cache Key: t3.a3
                     Cache Mode: logical
                     ->  Index Only Scan using t1_a1_desc_idx on t1
                           Index Cond: (a1 = ANY (ARRAY[t3.a3, $1, $2, ..., $1023]))
         ->  Memoize
               Cache Key: t3.a3
               Cache Mode: logical
               ->  Index Only Scan using t2_a2_idx on t2
                     Index Cond: (a2 = ANY (ARRAY[t3.a3, $1025, $1026, ..., $2047]))
(26 rows)

-- Turn hints on for previous query. 'dt' will now appear in the EXPLAIN as 'Hint Alias'. No warnings/errors expected.
explain (hints on, costs off) select count(*) from t1, t2, t3, (select b4 from t4, t5 where a4=a5 group by b4) dt where t1.a1=t2.a2 and a1=a3 and a1=b4;
                                                                                                                                                                                                                                                                                                                                                                            QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  YB Batched Nested Loop Join
         Join Filter: (t1.a1 = t2.a2)
         ->  YB Batched Nested Loop Join
               Join Filter: (t3.a3 = t1.a1)
               ->  Hash Join
                     Hash Cond: (t3.a3 = t4.b4)
                     ->  Seq Scan on t3
                     ->  Hash
                           ->  HashAggregate (Hint Alias : dt)
                                 Group Key: t4.b4
                                 ->  Hash Join
                                       Hash Cond: (t5.a5 = t4.a4)
                                       ->  Seq Scan on t5
                                       ->  Hash
                                             ->  Seq Scan on t4
               ->  Memoize
                     Cache Key: t3.a3
                     Cache Mode: logical
                     ->  Index Only Scan using t1_a1_desc_idx on t1
                           Index Cond: (a1 = ANY (ARRAY[t3.a3, $1, $2, ..., $1023]))
         ->  Memoize
               Cache Key: t3.a3
               Cache Mode: logical
               ->  Index Only Scan using t2_a2_idx on t2
                     Index Cond: (a2 = ANY (ARRAY[t3.a3, $1025, $1026, ..., $2047]))
 Generated hints: /*+ Leading((((t3 dt) t1) t2)) SeqScan(t3) HashJoin(dt t3) IndexOnlyScan(t1 t1_a1_desc_idx) YbBatchedNL(dt t1 t3) IndexOnlyScan(t2 t2_a2_idx) YbBatchedNL(dt t1 t2 t3)  Leading((t5 t4)) SeqScan(t5) SeqScan(t4) HashJoin(t4 t5) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(27 rows)

-- Force a bushy plan.
/*+ Leading(((t3 dt) (t1 t2))) */ explain (costs off) select count(*) from t1, t2, t3, (select b4 from t4, t5 where a4=a5 group by b4) dt where t1.a1=t2.a2 and a1=a3 and a1=b4;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Aggregate
   ->  Hash Join
         Hash Cond: (t3.a3 = t1.a1)
         ->  Hash Join
               Hash Cond: (t3.a3 = t4.b4)
               ->  Seq Scan on t3
               ->  Hash
                     ->  HashAggregate
                           Group Key: t4.b4
                           ->  Hash Join
                                 Hash Cond: (t5.a5 = t4.a4)
                                 ->  Seq Scan on t5
                                 ->  Hash
                                       ->  Seq Scan on t4
         ->  Hash
               ->  YB Batched Nested Loop Join
                     Join Filter: (t1.a1 = t2.a2)
                     ->  Seq Scan on t1
                     ->  Memoize
                           Cache Key: t1.a1
                           Cache Mode: logical
                           ->  Index Only Scan using t2_a2_idx on t2
                                 Index Cond: (a2 = ANY (ARRAY[t1.a1, $1, $2, ..., $1023]))
(23 rows)

-- Change top join method to NLJ.
/*+ Leading(((t3 dt) (t1 t2))) NestLoop(t2 dt t3 t1) */ explain (costs off) select count(*) from t1, t2, t3, (select b4 from t4, t5 where a4=a5 group by b4) dt where t1.a1=t2.a2 and a1=a3 and a1=b4;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Aggregate
   ->  Nested Loop
         Join Filter: (t1.a1 = t3.a3)
         ->  Hash Join
               Hash Cond: (t3.a3 = t4.b4)
               ->  Seq Scan on t3
               ->  Hash
                     ->  HashAggregate
                           Group Key: t4.b4
                           ->  Hash Join
                                 Hash Cond: (t5.a5 = t4.a4)
                                 ->  Seq Scan on t5
                                 ->  Hash
                                       ->  Seq Scan on t4
         ->  Materialize
               ->  YB Batched Nested Loop Join
                     Join Filter: (t1.a1 = t2.a2)
                     ->  Seq Scan on t1
                     ->  Memoize
                           Cache Key: t1.a1
                           Cache Mode: logical
                           ->  Index Only Scan using t2_a2_idx on t2
                                 Index Cond: (a2 = ANY (ARRAY[t1.a1, $1, $2, ..., $1023]))
(23 rows)

-- Hint generation for WHERE subqueries.
explain (hints on, costs off) select count(*) from t1, t2, t3 where a1=a2 and a1=a3 and b1 in (select a4 from t4 group by a4, b4) and b2 in (select a5 from t5 group by a5, b5);
                                                                                                                                                                                                                                                                                                                                                                                                        QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                                                         
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Hash Join
         Hash Cond: (t3.a3 = t1.a1)
         ->  Seq Scan on t3
         ->  Hash
               ->  Hash Semi Join
                     Hash Cond: (t2.b2 = "ANY_subquery_1".a5)
                     ->  YB Batched Nested Loop Join
                           Join Filter: (t1.a1 = t2.a2)
                           ->  Hash Semi Join
                                 Hash Cond: (t1.b1 = "ANY_subquery".a4)
                                 ->  Seq Scan on t1
                                 ->  Hash
                                       ->  Subquery Scan on "ANY_subquery"
                                             ->  HashAggregate
                                                   Group Key: t4.a4, t4.b4
                                                   ->  Seq Scan on t4
                           ->  Memoize
                                 Cache Key: t1.a1
                                 Cache Mode: logical
                                 ->  Index Scan using t2_a2_idx on t2
                                       Index Cond: (a2 = ANY (ARRAY[t1.a1, $1, $2, ..., $1023]))
                     ->  Hash
                           ->  Subquery Scan on "ANY_subquery_1"
                                 ->  HashAggregate
                                       Group Key: t5.a5, t5.b5
                                       ->  Seq Scan on t5
 Generated hints: /*+ Leading((t3 (((t1 ANY_subquery) t2) ANY_subquery_1))) SeqScan(t3) SeqScan(t1) HashJoin(ANY_subquery t1) IndexScan(t2 t2_a2_idx) YbBatchedNL(ANY_subquery t1 t2) HashJoin(ANY_subquery ANY_subquery_1 t1 t2) HashJoin(ANY_subquery ANY_subquery_1 t1 t2 t3)  SeqScan(t4)  SeqScan(t5) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(28 rows)

-- Change join order and use all merge joins.
/*+ Leading((((t1 ANY_subquery) ANY_subquery_1) t2)) MergeJoin(t1 ANY_subquery) MergeJoin(t1 ANY_subquery ANY_subquery_1) MergeJoin(ANY_subquery ANY_subquery_1 t1 t2) */ explain (hints on, costs off) select count(*) from t1, t2 where a1=a2 and b1 in (select a4 from t4 group by a4, b4) and b2 in (select a5 from t5 group by a5, b5);
                                                                                                                                                                                                                                                                                                                                                                        QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Merge Join
         Merge Cond: ((t1.a1 = t2.a2) AND (t5.a5 = t2.b2))
         ->  Sort
               Sort Key: t1.a1, t5.a5
               ->  Nested Loop
                     ->  Merge Semi Join
                           Merge Cond: (t1.b1 = "ANY_subquery".a4)
                           ->  Sort
                                 Sort Key: t1.b1
                                 ->  Seq Scan on t1
                           ->  Sort
                                 Sort Key: "ANY_subquery".a4
                                 ->  Subquery Scan on "ANY_subquery"
                                       ->  HashAggregate
                                             Group Key: t4.a4, t4.b4
                                             ->  Seq Scan on t4
                     ->  HashAggregate
                           Group Key: t5.a5
                           ->  HashAggregate (Hint Alias : ANY_subquery_1)
                                 Group Key: t5.a5, t5.b5
                                 ->  Seq Scan on t5
         ->  Sort
               Sort Key: t2.a2, t2.b2
               ->  Seq Scan on t2
 Generated hints: /*+ Leading((((t1 ANY_subquery) ANY_subquery_1) t2)) SeqScan(t1) MergeJoin(ANY_subquery t1) NestLoop(ANY_subquery ANY_subquery_1 t1) SeqScan(t2) MergeJoin(ANY_subquery ANY_subquery_1 t1 t2)  SeqScan(t4)  SeqScan(t5) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(26 rows)

-- Hint generation for VALUES clause(s). Should see no errors/warnings.
explain (hints on, costs off) select val1.c1 from (values(1, 1), (2, 2), (3, 3)) val1(c0, c1), t0, t1, (values(1, 1), (2, 2), (3, 3)) val2(c0, c1)  where val1.c1=a0 and a0=a1 and val2.c1=val1.c1;
                                                                                                                                                                                                                                                                                                                                                         QUERY PLAN                                                                                                                                                                                                                                                                                                                                                         
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: ("*VALUES*".column2 = t1.a1)
   ->  Hash Join
         Hash Cond: (t0.a0 = "*VALUES*".column2)
         ->  Hash Join
               Hash Cond: (t0.a0 = "*VALUES*_1".column2)
               ->  Seq Scan on t0
               ->  Hash
                     ->  Values Scan on "*VALUES*_1"
         ->  Hash
               ->  Values Scan on "*VALUES*"
   ->  Index Only Scan using t1_a1_desc_idx on t1
         Index Cond: (a1 = ANY (ARRAY[t0.a0, $1, $2, ..., $1023]))
 Generated hints: /*+ Leading((((t0 *VALUES*_1) *VALUES*) t1)) SeqScan(t0) HashJoin(*VALUES*_1 t0) HashJoin(*VALUES* *VALUES*_1 t0) IndexOnlyScan(t1 t1_a1_desc_idx) YbBatchedNL(*VALUES* *VALUES*_1 t0 t1) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(14 rows)

-- Change query and force cross join between VALUES derived tables. Should work fine.
/*+ Leading((((*VALUES* *VALUES*_1) t1) t0)) */ explain (hints on, costs off) select val1.c1 from (values(1, 1), (2, 2), (3, 3)) val1(c0, c1), t0, t1, (values(1, 1), (2, 2), (3, 3)) val2(c0, c1)  where val1.c1=a0 and a0=a1 and b0=b1;
                                                                                                                                                                                                                                                                                                                                                QUERY PLAN                                                                                                                                                                                                                                                                                                                                                
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (("*VALUES*".column2 = t0.a0) AND (t1.b1 = t0.b0))
   ->  Hash Join
         Hash Cond: ("*VALUES*".column2 = t1.a1)
         ->  Nested Loop
               ->  Values Scan on "*VALUES*"
               ->  Materialize
                     ->  Values Scan on "*VALUES*_1"
         ->  Hash
               ->  Seq Scan on t1
   ->  Hash
         ->  Seq Scan on t0
 Generated hints: /*+ Leading((((*VALUES* *VALUES*_1) t1) t0)) NestLoop(*VALUES* *VALUES*_1) SeqScan(t1) HashJoin(*VALUES* *VALUES*_1 t1) SeqScan(t0) HashJoin(*VALUES* *VALUES*_1 t0 t1) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(13 rows)

-- Disable all join methods but hint the query. Should still give plan defined by hints.
set enable_mergejoin to 0; set enable_hashjoin to 0; set enable_nestloop to 0;
/*+ Leading(((t2 t1) dt)) SeqScan(t2) IndexScan(t1 t1_a1_asc_b1_asc_idx) YbBatchedNL(t1 t2) NestLoop(dt t1 t2)  Leading((t4 (t3 t5))) SeqScan(t4) SeqScan(t3) IndexScan(t5 t5_pkey) HashJoin(t3 t5) HashJoin(t3 t4 t5) */ explain (hints on, costs off) select * from t1, t2, (select a3 from t3 join t4 on a3=a4 join t5 on a3=a5 where unn5=1 group by a3) dt where a1=1 and b1=b2 and b1=a3;
                                                                                                                                                                                                                                                                                                                                                                       QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Join Filter: (t1.b1 = t3.a3)
   ->  YB Batched Nested Loop Join
         Join Filter: (t1.b1 = t2.b2)
         ->  Seq Scan on t2
         ->  Memoize
               Cache Key: t2.b2
               Cache Mode: logical
               ->  Index Scan using t1_a1_asc_b1_asc_idx on t1
                     Index Cond: ((b1 = ANY (ARRAY[t2.b2, $1, $2, ..., $1023])) AND (a1 = 1))
   ->  HashAggregate (Hint Alias : dt)
         Group Key: t3.a3
         ->  Hash Join
               Hash Cond: (t4.a4 = t3.a3)
               ->  Seq Scan on t4
               ->  Hash
                     ->  Hash Join
                           Hash Cond: (t3.a3 = t5.a5)
                           ->  Seq Scan on t3
                           ->  Hash
                                 ->  Index Scan using t5_pkey on t5
                                       Index Cond: (unn5 = 1)
 Generated hints: /*+ Leading(((t2 t1) dt)) SeqScan(t2) IndexScan(t1 t1_a1_asc_b1_asc_idx) YbBatchedNL(t1 t2) NestLoop(dt t1 t2)  Leading((t4 (t3 t5))) SeqScan(t4) SeqScan(t3) IndexScan(t5 t5_pkey) HashJoin(t3 t5) HashJoin(t3 t4 t5) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(23 rows)

reset enable_mergejoin; reset enable_hashjoin; reset enable_nestloop;
-- Hint a cross join with ROWS. Should work.
/*+ Leading(((((t5 t4) t1) t3) t2)) Rows(t4 t5 #10000) */ explain (hints on, costs off) select count(*) from t1, t2, t3, t4, t5 where a2=a3 and a2=a4 and a2=a5;
                                                                                                                                                                                                                                                                                                                                                              QUERY PLAN                                                                                                                                                                                                                                                                                                                                                               
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  YB Batched Nested Loop Join
         Join Filter: (t3.a3 = t2.a2)
         ->  Hash Join
               Hash Cond: (t4.a4 = t3.a3)
               ->  Nested Loop
                     ->  Hash Join
                           Hash Cond: (t5.a5 = t4.a4)
                           ->  Seq Scan on t5
                           ->  Hash
                                 ->  Seq Scan on t4
                     ->  Materialize
                           ->  Seq Scan on t1
               ->  Hash
                     ->  Seq Scan on t3
         ->  Memoize
               Cache Key: t5.a5
               Cache Mode: logical
               ->  Index Only Scan using t2_a2_idx on t2
                     Index Cond: (a2 = ANY (ARRAY[t5.a5, $1, $2, ..., $1023]))
 Generated hints: /*+ Leading(((((t5 t4) t1) t3) t2)) SeqScan(t5) SeqScan(t4) HashJoin(t4 t5) SeqScan(t1) NestLoop(t1 t4 t5) SeqScan(t3) HashJoin(t1 t3 t4 t5) IndexOnlyScan(t2 t2_a2_idx) YbBatchedNL(t1 t2 t3 t4 t5) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(21 rows)

-- Query with derived tables but no actual tables. Will have *RESULT* type names in generated hints.
explain (hints on, costs off) SELECT * FROM
( SELECT 1 as key1 ) sub1
LEFT JOIN
( SELECT sub3.key3, sub4.value2, COALESCE(sub4.value2, 66) as value3 FROM
    ( SELECT 1 as key3 ) sub3
    LEFT JOIN
    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM
        ( SELECT 1 as key5 ) sub5
        LEFT JOIN
        ( SELECT 2 as key6, 42 as value1 ) sub6
        ON sub5.key5 = sub6.key6
    ) sub4
    ON sub4.key5 = sub3.key3
) sub2
ON sub1.key1 = sub2.key3;
                                                                                                                                                                                                                                                                                                                                                          QUERY PLAN                                                                                                                                                                                                                                                                                                                                                          
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop Left Join
   ->  Result *RESULT*
   ->  Nested Loop Left Join
         ->  Result *RESULT*_1
         ->  Nested Loop Left Join
               Join Filter: false
               ->  Result *RESULT*_2
               ->  Result *RESULT*_3
                     One-Time Filter: false
 Generated hints: /*+ Leading((*RESULT* (*RESULT*_1 (*RESULT*_2 *RESULT*_3)))) NestLoop(*RESULT*_2 *RESULT*_3) NestLoop(*RESULT*_1 *RESULT*_2 *RESULT*_3) NestLoop(*RESULT* *RESULT*_1 *RESULT*_2 *RESULT*_3) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(10 rows)

-- Lateral join
explain (hints on, costs off)
select * from
  t1 as i41,
  lateral
    (select 1 as x from
      (select i41.a1 as lat,
              i42.a1 as loc from
         t2 as i81, t1 as i42) as ss1
      right join t1 as i43 on (i43.a1 > 1)
      where ss1.loc = ss1.lat) as ss2
where i41.a1 > 0;
                                                                                                                                                                                                                                                                                                                                                           QUERY PLAN                                                                                                                                                                                                                                                                                                                                                            
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   ->  Index Scan using t1_a1_desc_idx on t1 i41
         Index Cond: (a1 > 0)
   ->  Nested Loop
         Join Filter: (i41.a1 = i42.a1)
         ->  Seq Scan on t2 i81
         ->  Materialize
               ->  Nested Loop
                     ->  Index Only Scan using t1_a1_desc_idx on t1 i43
                           Index Cond: (a1 > 1)
                     ->  Seq Scan on t1 i42
 Generated hints: /*+ Leading((i41 (i81 (i43 i42)))) IndexScan(i41 t1_a1_desc_idx) SeqScan(i81) IndexOnlyScan(i43 t1_a1_desc_idx) SeqScan(i42) NestLoop(i42 i43) NestLoop(i42 i43 i81) NestLoop(i41 i42 i43 i81) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(12 rows)

-- Outer joins and VALUES clause.
explain (costs off, hints on)
select a1, b1, a2, b2 from
  t1
  inner join t2
    left join (select v1.x2, v2.y1, 11 AS d1
               from (values(1,0)) v1(x1,x2)
               left join (values(3,1)) v2(y1,y2)
               on v1.x1 = v2.y2) subq1
    on b2 = subq1.x2
  on unn1 = subq1.d1
  left join t3
  on subq1.y1 = unn2
where unn1 < 4 and ch1 > ch2;
                                                                                                                                                                                                                                                                                                                                      QUERY PLAN                                                                                                                                                                                                                                                                                                                                      
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop Left Join
   Join Filter: ((3) = t2.unn2)
   ->  Hash Join
         Hash Cond: ((11) = t1.unn1)
         Join Filter: (t1.ch1 > t2.ch2)
         ->  Nested Loop Left Join
               Join Filter: (t2.b2 = 0)
               ->  Seq Scan on t2
               ->  Materialize
                     ->  Result *RESULT*
         ->  Hash
               ->  Seq Scan on t1
                     Storage Filter: (unn1 < 4)
   ->  Materialize
         ->  Seq Scan on t3
 Generated hints: /*+ Leading((((t2 *RESULT*) t1) t3)) SeqScan(t2) NestLoop(*RESULT* t2) SeqScan(t1) HashJoin(*RESULT* t1 t2) SeqScan(t3) NestLoop(*RESULT* t1 t2 t3) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(16 rows)

-- Hints with CTEs. Should work.
/*+ Leading((y x)) Leading(((t2 t1) t0)) */ explain (hints on, costs off) with cte1 as (select a0, a1 from t0, t1, t2 where a0=a1 and a0=a2) select count(*) from cte1 x, cte1 y where x.a0=y.a0 and x.a1<y.a1;
                                                                                                                                                                                                                                                                                                                                       QUERY PLAN                                                                                                                                                                                                                                                                                                                                       
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   CTE cte1
     ->  Hash Join
           Hash Cond: (t1.a1 = t0.a0)
           ->  YB Batched Nested Loop Join
                 Join Filter: (t1.a1 = t2.a2)
                 ->  Seq Scan on t2
                 ->  Memoize
                       Cache Key: t2.a2
                       Cache Mode: logical
                       ->  Index Only Scan using t1_a1_desc_idx on t1
                             Index Cond: (a1 = ANY (ARRAY[t2.a2, $1, $2, ..., $1023]))
           ->  Hash
                 ->  Seq Scan on t0
   ->  Hash Join
         Hash Cond: (y.a0 = x.a0)
         Join Filter: (x.a1 < y.a1)
         ->  CTE Scan on cte1 y
         ->  Hash
               ->  CTE Scan on cte1 x
 Generated hints: /*+ Leading((y x)) HashJoin(x y) Leading(((t2 t1) t0)) SeqScan(t2) IndexOnlyScan(t1 t1_a1_desc_idx) YbBatchedNL(t1 t2) SeqScan(t0) HashJoin(t0 t1 t2) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(21 rows)

-- Complex query;
explain (hints on, costs off) select count(*) from t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, (select a1 x from t1, t2, t3, t4, t5, t6, t7, t8, t9, t10 where a1=a2 and a1=a3 and a1=a4 and a1=a5 and a5=a6 and a5=a7 and a5=a8 and a5=a9 and b7=1) dt where a1=a2 and a1=a3 and a1=a4 and a1=a5 and a5=a6 and a5=a7 and a5=a8 and a5=a9 and b7=1 and a1=x;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  YB Batched Nested Loop Join
         Join Filter: (t2.a2 = t1.a1)
         ->  YB Batched Nested Loop Join
               Join Filter: (t3.a3 = t2.a2)
               ->  Hash Join
                     Hash Cond: (t1_1.a1 = t3.a3)
                     ->  Nested Loop
                           ->  Seq Scan on t10
                           ->  YB Batched Nested Loop Join
                                 Join Filter: (t2_1.a2 = t1_1.a1)
                                 ->  YB Batched Nested Loop Join
                                       Join Filter: (t3_1.a3 = t2_1.a2)
                                       ->  Hash Join
                                             Hash Cond: (t3_1.a3 = t9_1.a9)
                                             ->  Hash Join
                                                   Hash Cond: (t3_1.a3 = t4_1.a4)
                                                   ->  Hash Join
                                                         Hash Cond: (t3_1.a3 = t8_1.a8)
                                                         ->  Hash Join
                                                               Hash Cond: (t3_1.a3 = t6_1.a6)
                                                               ->  Hash Join
                                                                     Hash Cond: (t7_1.a7 = t3_1.a3)
                                                                     ->  Seq Scan on t7 t7_1
                                                                           Storage Filter: (b7 = 1)
                                                                     ->  Hash
                                                                           ->  Seq Scan on t3 t3_1
                                                               ->  Hash
                                                                     ->  Seq Scan on t6 t6_1
                                                         ->  Hash
                                                               ->  Seq Scan on t8 t8_1
                                                   ->  Hash
                                                         ->  Hash Join
                                                               Hash Cond: (t5_1.a5 = t4_1.a4)
                                                               ->  Seq Scan on t5 t5_1
                                                               ->  Hash
                                                                     ->  Seq Scan on t4 t4_1
                                             ->  Hash
                                                   ->  Nested Loop
                                                         ->  Seq Scan on t10 t10_1
                                                         ->  Materialize
                                                               ->  Seq Scan on t9 t9_1
                                       ->  Memoize
                                             Cache Key: t9_1.a9
                                             Cache Mode: logical
                                             ->  Index Only Scan using t2_a2_idx on t2 t2_1
                                                   Index Cond: (a2 = ANY (ARRAY[t9_1.a9, $1, $2, ..., $1023]))
                                 ->  Memoize
                                       Cache Key: t9_1.a9
                                       Cache Mode: logical
                                       ->  Index Only Scan using t1_a1_desc_idx on t1 t1_1
                                             Index Cond: (a1 = ANY (ARRAY[t9_1.a9, $1025, $1026, ..., $2047]))
                     ->  Hash
                           ->  Hash Join
                                 Hash Cond: (t3.a3 = t4.a4)
                                 ->  Hash Join
                                       Hash Cond: (t3.a3 = t5.a5)
                                       ->  Hash Join
                                             Hash Cond: (t3.a3 = t8.a8)
                                             ->  Hash Join
                                                   Hash Cond: (t9.a9 = t3.a3)
                                                   ->  Seq Scan on t9
                                                   ->  Hash
                                                         ->  Seq Scan on t3
                                             ->  Hash
                                                   ->  Seq Scan on t8
                                       ->  Hash
                                             ->  Hash Join
                                                   Hash Cond: (t6.a6 = t5.a5)
                                                   ->  Seq Scan on t6
                                                   ->  Hash
                                                         ->  Seq Scan on t5
                                 ->  Hash
                                       ->  Hash Join
                                             Hash Cond: (t7.a7 = t4.a4)
                                             ->  Seq Scan on t7
                                                   Storage Filter: (b7 = 1)
                                             ->  Hash
                                                   ->  Seq Scan on t4
               ->  Memoize
                     Cache Key: t9.a9
                     Cache Mode: logical
                     ->  Index Only Scan using t2_a2_idx on t2
                           Index Cond: (a2 = ANY (ARRAY[t9.a9, $2049, $2050, ..., $3071]))
         ->  Memoize
               Cache Key: t9.a9
               Cache Mode: logical
               ->  Index Only Scan using t1_a1_desc_idx on t1
                     Index Cond: (a1 = ANY (ARRAY[t9.a9, $3073, $3074, ..., $4095]))
 Generated hints: /*+ Leading(((((t10 (((((((t7_1 t3_1) t6_1) t8_1) (t5_1 t4_1)) (t10_1 t9_1)) t2_1) t1_1)) ((((t9 t3) t8) (t6 t5)) (t7 t4))) t2) t1)) SeqScan(t10) SeqScan(t7_1) SeqScan(t3_1) HashJoin(t3_1 t7_1) SeqScan(t6_1) HashJoin(t3_1 t6_1 t7_1) SeqScan(t8_1) HashJoin(t3_1 t6_1 t7_1 t8_1) SeqScan(t5_1) SeqScan(t4_1) HashJoin(t4_1 t5_1) HashJoin(t3_1 t4_1 t5_1 t6_1 t7_1 t8_1) SeqScan(t10_1) SeqScan(t9_1) NestLoop(t10_1 t9_1) HashJoin(t10_1 t3_1 t4_1 t5_1 t6_1 t7_1 t8_1 t9_1) IndexOnlyScan(t2_1 t2_a2_idx) YbBatchedNL(t10_1 t2_1 t3_1 t4_1 t5_1 t6_1 t7_1 t8_1 t9_1) IndexOnlyScan(t1_1 t1_a1_desc_idx) YbBatchedNL(t10_1 t1_1 t2_1 t3_1 t4_1 t5_1 t6_1 t7_1 t8_1 t9_1) NestLoop(t10 t10_1 t1_1 t2_1 t3_1 t4_1 t5_1 t6_1 t7_1 t8_1 t9_1) SeqScan(t9) SeqScan(t3) HashJoin(t3 t9) SeqScan(t8) HashJoin(t3 t8 t9) SeqScan(t6) SeqScan(t5) HashJoin(t5 t6) HashJoin(t3 t5 t6 t8 t9) SeqScan(t7) SeqScan(t4) HashJoin(t4 t7) HashJoin(t3 t4 t5 t6 t7 t8 t9) HashJoin(t10 t10_1 t1_1 t2_1 t3 t3_1 t4 t4_1 t5 t5_1 t6 t6_1 t7 t7_1 t8 t8_1 t9 t9_1) IndexOnlyScan(t2 t2_a2_idx) YbBatchedNL(t10 t10_1 t1_1 t2 t2_1 t3 t3_1 t4 t4_1 t5 t5_1 t6 t6_1 t7 t7_1 t8 t8_1 t9 t9_1) IndexOnlyScan(t1 t1_a1_desc_idx) YbBatchedNL(t1 t10 t10_1 t1_1 t2 t2_1 t3 t3_1 t4 t4_1 t5 t5_1 t6 t6_1 t7 t7_1 t8 t8_1 t9 t9_1) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 20) Set(join_collapse_limit 20) Set(geqo false) */
(90 rows)

/*+ Leading(((((t10 (((((((t7_1 t3_1) t6_1) t8_1) (t5_1 t4_1)) (t10_1 t9_1)) t2_1) t1_1)) ((((t9 t3) t8) (t6 t5)) (t7 t4))) t2) t1)) SeqScan(t10) SeqScan(t7_1) SeqScan(t3_1) HashJoin(t3_1 t7_1) SeqScan(t6_1) HashJoin(t3_1 t6_1 t7_1) SeqScan(t8_1) HashJoin(t3_1 t6_1 t7_1 t8_1) SeqScan(t5_1) SeqScan(t4_1) HashJoin(t4_1 t5_1) HashJoin(t3_1 t4_1 t5_1 t6_1 t7_1 t8_1) SeqScan(t10_1) SeqScan(t9_1) NestLoop(t10_1 t9_1) HashJoin(t10_1 t3_1 t4_1 t5_1 t6_1 t7_1 t8_1 t9_1) IndexOnlyScan(t2_1 t2_a2_idx) YbBatchedNL(t10_1 t2_1 t3_1 t4_1 t5_1 t6_1 t7_1 t8_1 t9_1) IndexOnlyScan(t1_1 t1_a1_asc_idx) YbBatchedNL(t10_1 t1_1 t2_1 t3_1 t4_1 t5_1 t6_1 t7_1 t8_1 t9_1) NestLoop(t10 t10_1 t1_1 t2_1 t3_1 t4_1 t5_1 t6_1 t7_1 t8_1 t9_1) SeqScan(t9) SeqScan(t3) HashJoin(t3 t9) SeqScan(t8) HashJoin(t3 t8 t9) SeqScan(t6) SeqScan(t5) HashJoin(t5 t6) HashJoin(t3 t5 t6 t8 t9) SeqScan(t7) SeqScan(t4) HashJoin(t4 t7) HashJoin(t3 t4 t5 t6 t7 t8 t9) HashJoin(t10 t10_1 t1_1 t2_1 t3 t3_1 t4 t4_1 t5 t5_1 t6 t6_1 t7 t7_1 t8 t8_1 t9 t9_1) IndexOnlyScan(t2 t2_a2_idx) YbBatchedNL(t10 t10_1 t1_1 t2 t2_1 t3 t3_1 t4 t4_1 t5 t5_1 t6 t6_1 t7 t7_1 t8 t8_1 t9 t9_1) IndexOnlyScan(t1 t1_a1_asc_idx) YbBatchedNL(t1 t10 t10_1 t1_1 t2 t2_1 t3 t3_1 t4 t4_1 t5 t5_1 t6 t6_1 t7 t7_1 t8 t8_1 t9 t9_1) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 20) Set(join_collapse_limit 20) Set(geqo false) */ explain (hints on, costs off) select count(*) from t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, (select a1 x from t1, t2, t3, t4, t5, t6, t7, t8, t9, t10 where a1=a2 and a1=a3 and a1=a4 and a1=a5 and a5=a6 and a5=a7 and a5=a8 and a5=a9 and b7=1) dt where a1=a2 and a1=a3 and a1=a4 and a1=a5 and a5=a6 and a5=a7 and a5=a8 and a5=a9 and b7=1 and a1=x;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  YB Batched Nested Loop Join
         Join Filter: (t2.a2 = t1.a1)
         ->  YB Batched Nested Loop Join
               Join Filter: (t3.a3 = t2.a2)
               ->  Hash Join
                     Hash Cond: (t1_1.a1 = t3.a3)
                     ->  Nested Loop
                           ->  Seq Scan on t10
                           ->  Materialize
                                 ->  YB Batched Nested Loop Join
                                       Join Filter: (t2_1.a2 = t1_1.a1)
                                       ->  YB Batched Nested Loop Join
                                             Join Filter: (t3_1.a3 = t2_1.a2)
                                             ->  Hash Join
                                                   Hash Cond: (t3_1.a3 = t9_1.a9)
                                                   ->  Hash Join
                                                         Hash Cond: (t3_1.a3 = t4_1.a4)
                                                         ->  Hash Join
                                                               Hash Cond: (t3_1.a3 = t8_1.a8)
                                                               ->  Hash Join
                                                                     Hash Cond: (t3_1.a3 = t6_1.a6)
                                                                     ->  Hash Join
                                                                           Hash Cond: (t7_1.a7 = t3_1.a3)
                                                                           ->  Seq Scan on t7 t7_1
                                                                                 Storage Filter: (b7 = 1)
                                                                           ->  Hash
                                                                                 ->  Seq Scan on t3 t3_1
                                                                     ->  Hash
                                                                           ->  Seq Scan on t6 t6_1
                                                               ->  Hash
                                                                     ->  Seq Scan on t8 t8_1
                                                         ->  Hash
                                                               ->  Hash Join
                                                                     Hash Cond: (t5_1.a5 = t4_1.a4)
                                                                     ->  Seq Scan on t5 t5_1
                                                                     ->  Hash
                                                                           ->  Seq Scan on t4 t4_1
                                                   ->  Hash
                                                         ->  Nested Loop
                                                               ->  Seq Scan on t10 t10_1
                                                               ->  Materialize
                                                                     ->  Seq Scan on t9 t9_1
                                             ->  Memoize
                                                   Cache Key: t9_1.a9
                                                   Cache Mode: logical
                                                   ->  Index Only Scan using t2_a2_idx on t2 t2_1
                                                         Index Cond: (a2 = ANY (ARRAY[t9_1.a9, $1, $2, ..., $1023]))
                                       ->  Memoize
                                             Cache Key: t9_1.a9
                                             Cache Mode: logical
                                             ->  Index Only Scan using t1_a1_asc_idx on t1 t1_1
                                                   Index Cond: (a1 = ANY (ARRAY[t9_1.a9, $1025, $1026, ..., $2047]))
                     ->  Hash
                           ->  Hash Join
                                 Hash Cond: (t3.a3 = t4.a4)
                                 ->  Hash Join
                                       Hash Cond: (t3.a3 = t5.a5)
                                       ->  Hash Join
                                             Hash Cond: (t3.a3 = t8.a8)
                                             ->  Hash Join
                                                   Hash Cond: (t9.a9 = t3.a3)
                                                   ->  Seq Scan on t9
                                                   ->  Hash
                                                         ->  Seq Scan on t3
                                             ->  Hash
                                                   ->  Seq Scan on t8
                                       ->  Hash
                                             ->  Hash Join
                                                   Hash Cond: (t6.a6 = t5.a5)
                                                   ->  Seq Scan on t6
                                                   ->  Hash
                                                         ->  Seq Scan on t5
                                 ->  Hash
                                       ->  Hash Join
                                             Hash Cond: (t7.a7 = t4.a4)
                                             ->  Seq Scan on t7
                                                   Storage Filter: (b7 = 1)
                                             ->  Hash
                                                   ->  Seq Scan on t4
               ->  Memoize
                     Cache Key: t9.a9
                     Cache Mode: logical
                     ->  Index Only Scan using t2_a2_idx on t2
                           Index Cond: (a2 = ANY (ARRAY[t9.a9, $2049, $2050, ..., $3071]))
         ->  Memoize
               Cache Key: t9.a9
               Cache Mode: logical
               ->  Index Only Scan using t1_a1_asc_idx on t1
                     Index Cond: (a1 = ANY (ARRAY[t9.a9, $3073, $3074, ..., $4095]))
 Generated hints: /*+ Leading(((((t10 (((((((t7_1 t3_1) t6_1) t8_1) (t5_1 t4_1)) (t10_1 t9_1)) t2_1) t1_1)) ((((t9 t3) t8) (t6 t5)) (t7 t4))) t2) t1)) SeqScan(t10) SeqScan(t7_1) SeqScan(t3_1) HashJoin(t3_1 t7_1) SeqScan(t6_1) HashJoin(t3_1 t6_1 t7_1) SeqScan(t8_1) HashJoin(t3_1 t6_1 t7_1 t8_1) SeqScan(t5_1) SeqScan(t4_1) HashJoin(t4_1 t5_1) HashJoin(t3_1 t4_1 t5_1 t6_1 t7_1 t8_1) SeqScan(t10_1) SeqScan(t9_1) NestLoop(t10_1 t9_1) HashJoin(t10_1 t3_1 t4_1 t5_1 t6_1 t7_1 t8_1 t9_1) IndexOnlyScan(t2_1 t2_a2_idx) YbBatchedNL(t10_1 t2_1 t3_1 t4_1 t5_1 t6_1 t7_1 t8_1 t9_1) IndexOnlyScan(t1_1 t1_a1_asc_idx) YbBatchedNL(t10_1 t1_1 t2_1 t3_1 t4_1 t5_1 t6_1 t7_1 t8_1 t9_1) NestLoop(t10 t10_1 t1_1 t2_1 t3_1 t4_1 t5_1 t6_1 t7_1 t8_1 t9_1) SeqScan(t9) SeqScan(t3) HashJoin(t3 t9) SeqScan(t8) HashJoin(t3 t8 t9) SeqScan(t6) SeqScan(t5) HashJoin(t5 t6) HashJoin(t3 t5 t6 t8 t9) SeqScan(t7) SeqScan(t4) HashJoin(t4 t7) HashJoin(t3 t4 t5 t6 t7 t8 t9) HashJoin(t10 t10_1 t1_1 t2_1 t3 t3_1 t4 t4_1 t5 t5_1 t6 t6_1 t7 t7_1 t8 t8_1 t9 t9_1) IndexOnlyScan(t2 t2_a2_idx) YbBatchedNL(t10 t10_1 t1_1 t2 t2_1 t3 t3_1 t4 t4_1 t5 t5_1 t6 t6_1 t7 t7_1 t8 t8_1 t9 t9_1) IndexOnlyScan(t1 t1_a1_asc_idx) YbBatchedNL(t1 t10 t10_1 t1_1 t2 t2_1 t3 t3_1 t4 t4_1 t5 t5_1 t6 t6_1 t7 t7_1 t8 t8_1 t9 t9_1) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 20) Set(join_collapse_limit 20) Set(geqo false) */
(91 rows)

-- Correlated subquery with multiple blocks. Should not give any warnings/errors.
explain (hints on, costs off) select * from t1 left join t2 on a1=a2 or b1+b2 not in (select b3 from t3, t4, t5 where a3=a4 and a3=a5 and c3 != c1-c2) where a1 < (select max(a4) from t4, t5 where a4 != a5);
                                                                                                                                                                                                                                                                                                                                                                                    QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                                    
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop Left Join
   Join Filter: ((t1.a1 = t2.a2) OR (NOT (SubPlan 1)))
   InitPlan 2 (returns $3)
     ->  Aggregate
           ->  Nested Loop
                 Join Filter: (t4_1.a4 <> t5_1.a5)
                 ->  Seq Scan on t5 t5_1
                 ->  Materialize
                       ->  Seq Scan on t4 t4_1
   ->  Index Scan using t1_a1_desc_idx on t1
         Index Cond: (a1 < $3)
   ->  Seq Scan on t2
   SubPlan 1
     ->  Hash Join
           Hash Cond: (t3.a3 = t5.a5)
           ->  Hash Join
                 Hash Cond: (t4.a4 = t3.a3)
                 ->  Seq Scan on t4
                 ->  Hash
                       ->  Seq Scan on t3
                             Storage Filter: (c3 <> (t1.c1 - t2.c2))
           ->  Hash
                 ->  Seq Scan on t5
 Generated hints: /*+ Leading((t1 t2)) IndexScan(t1 t1_a1_desc_idx) SeqScan(t2) NestLoop(t1 t2) Leading(((t4 t3) t5)) SeqScan(t4) SeqScan(t3) HashJoin(t3 t4) SeqScan(t5) HashJoin(t3 t4 t5) Leading((t5_1 t4_1)) SeqScan(t5_1) SeqScan(t4_1) NestLoop(t4_1 t5_1) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(24 rows)

-- Try a view that is a security barrier. Should see an inherited hint alias.
create temporary view v1(x, y, z) with(security_barrier) as select a1, a2, a3 from t1 right join t2 on a1+1=a2 join t3 on b2=b3;
explain (hints on, costs off) select sum(a1+x) from v1, t1, t2 where x=a1 and x=y and y=z and z=unn2;
                                                                                                                                                                                                                                                                                                                                                                                     QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                                     
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  YB Batched Nested Loop Join
         Join Filter: (t1_1.a1 = t2.unn2)
         ->  Hash Join
               Hash Cond: (t1_1.a1 = t1.a1)
               ->  YB Batched Nested Loop Join (Hint Alias : v1)
                     Join Filter: (t2_1.a2 = t1_1.a1)
                     ->  Nested Loop
                           ->  Seq Scan on t3
                           ->  Memoize
                                 Cache Key: t3.a3, t3.b3
                                 Cache Mode: logical
                                 ->  Index Scan using t2_a2_idx on t2 t2_1
                                       Index Cond: (a2 = t3.a3)
                                       Storage Filter: (t3.b3 = b2)
                     ->  Memoize
                           Cache Key: t3.a3
                           Cache Mode: logical
                           ->  Index Only Scan using t1_a1_desc_idx on t1 t1_1
                                 Index Cond: (a1 = ANY (ARRAY[t3.a3, $3, $4, ..., $1025]))
                                 Storage Filter: ((a1 + 1) = a1)
               ->  Hash
                     ->  Seq Scan on t1
         ->  Memoize
               Cache Key: t1.a1
               Cache Mode: logical
               ->  Index Scan using t2_pkey on t2
                     Index Cond: (unn2 = ANY (ARRAY[t1.a1, $1027, $1028, ..., $2049]))
 Generated hints: /*+ Leading(((v1 t1) t2)) SeqScan(t1) HashJoin(t1 v1) IndexScan(t2 t2_pkey) YbBatchedNL(t1 t2 v1)  Leading(((t3 t2_1) t1_1)) SeqScan(t3) IndexScan(t2_1 t2_a2_idx) NestLoop(t2_1 t3) IndexOnlyScan(t1_1 t1_a1_desc_idx) YbBatchedNL(t1_1 t2_1 t3) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(29 rows)

-- View on a view. Should see 2 inherited hint aliases and no warnings/errors.
create temporary view v2(x, y, z) as select x, y, z from v1 where x<5 group by x, y, z ;
explain (hints on, costs off) select sum(a1+x) from v2, t1, t2 where x=a1 and x=y and y=z and z=unn2;
                                                                                                                                                                                                                                                                                                                                                                                     QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                                      
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  YB Batched Nested Loop Join
         Join Filter: (t1_1.a1 = t2.unn2)
         ->  Nested Loop
               Join Filter: (t1_1.a1 = t1.a1)
               ->  Group (Hint Alias : v2)
                     Group Key: t1_1.a1, t2_1.a2, t3.a3
                     ->  Sort
                           Sort Key: t1_1.a1
                           ->  Nested Loop (Hint Alias : v1)
                                 Join Filter: (t1_1.a1 = t2_1.a2)
                                 ->  YB Batched Nested Loop Join
                                       Join Filter: (t1_1.a1 = t3.a3)
                                       ->  Seq Scan on t3
                                       ->  Memoize
                                             Cache Key: t3.a3
                                             Cache Mode: logical
                                             ->  Index Only Scan using t1_a1_desc_idx on t1 t1_1
                                                   Index Cond: ((a1 = ANY (ARRAY[t3.a3, $1, $2, ..., $1023])) AND (a1 < 5))
                                                   Storage Filter: ((a1 + 1) = a1)
                                 ->  Index Scan using t2_a2_idx on t2 t2_1
                                       Index Cond: (a2 = t3.a3)
                                       Storage Filter: (t3.b3 = b2)
               ->  Seq Scan on t1
         ->  Index Scan using t2_pkey on t2
               Index Cond: (unn2 = ANY (ARRAY[t1.a1, $1027, $1028, ..., $2049]))
 Generated hints: /*+ Leading(((v2 t1) t2)) SeqScan(t1) NestLoop(t1 v2) IndexScan(t2 t2_pkey) YbBatchedNL(t1 t2 v2)   Leading(((t3 t1_1) t2_1)) SeqScan(t3) IndexOnlyScan(t1_1 t1_a1_desc_idx) YbBatchedNL(t1_1 t3) IndexScan(t2_1 t2_a2_idx) NestLoop(t1_1 t2_1 t3) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(27 rows)

-- Views with set ops. Should get no warnings/errors.
create temporary view v3 as select a7, a8, a9 z from t7, t8, t9 where a7=a8 and a7=a9 union select a7, a8, a9 from t7, t8, t9 where a7=a8 and a7=a9;
explain (hints on, costs off) select * from v3, t9 where z=a9;
                                                                                                                                                                                                                                                                                                                                                                                                  QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                                                  
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (t9.a9 = t9_1.a9)
   ->  Seq Scan on t9
   ->  Hash
         ->  HashAggregate (Hint Alias : v3)
               Group Key: t7.a7, t8.a8, t9_1.a9
               ->  Append
                     ->  Hash Join
                           Hash Cond: (t7.a7 = t8.a8)
                           ->  Hash Join
                                 Hash Cond: (t9_1.a9 = t7.a7)
                                 ->  Seq Scan on t9 t9_1
                                 ->  Hash
                                       ->  Seq Scan on t7
                           ->  Hash
                                 ->  Seq Scan on t8
                     ->  Hash Join
                           Hash Cond: (t7_1.a7 = t8_1.a8)
                           ->  Hash Join
                                 Hash Cond: (t9_2.a9 = t7_1.a7)
                                 ->  Seq Scan on t9 t9_2
                                 ->  Hash
                                       ->  Seq Scan on t7 t7_1
                           ->  Hash
                                 ->  Seq Scan on t8 t8_1
 Generated hints: /*+ Leading((t9 v3)) SeqScan(t9) HashJoin(t9 v3)   Leading(((t9_1 t7) t8)) SeqScan(t9_1) SeqScan(t7) HashJoin(t7 t9_1) SeqScan(t8) HashJoin(t7 t8 t9_1)  Leading(((t9_2 t7_1) t8_1)) SeqScan(t9_2) SeqScan(t7_1) HashJoin(t7_1 t9_2) SeqScan(t8_1) HashJoin(t7_1 t8_1 t9_2) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(26 rows)

create temporary view v4 as select a7, a8, a9 z from t7, t8, t9 where a7=a8 and a7=a9 intersect all select a7, a8, a9 from t7, t8, t9 where a7=a8 and a7=a9;
explain (hints on, costs off) select * from v4, t9 where z=a9;
                                                                                                                                                                                                                                                                                                                                                                                                   QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                                                   
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (t9.a9 = v4.z)
   ->  Seq Scan on t9
   ->  Hash
         ->  Subquery Scan on v4
               ->  HashSetOp Intersect All
                     ->  Append
                           ->  Subquery Scan on "*SELECT* 1"
                                 ->  Hash Join
                                       Hash Cond: (t7.a7 = t8.a8)
                                       ->  Hash Join
                                             Hash Cond: (t9_1.a9 = t7.a7)
                                             ->  Seq Scan on t9 t9_1
                                             ->  Hash
                                                   ->  Seq Scan on t7
                                       ->  Hash
                                             ->  Seq Scan on t8
                           ->  Subquery Scan on "*SELECT* 2"
                                 ->  Hash Join
                                       Hash Cond: (t7_1.a7 = t8_1.a8)
                                       ->  Hash Join
                                             Hash Cond: (t9_2.a9 = t7_1.a7)
                                             ->  Seq Scan on t9 t9_2
                                             ->  Hash
                                                   ->  Seq Scan on t7 t7_1
                                       ->  Hash
                                             ->  Seq Scan on t8 t8_1
 Generated hints: /*+ Leading((t9 v4)) SeqScan(t9) HashJoin(t9 v4)    Leading(((t9_1 t7) t8)) SeqScan(t9_1) SeqScan(t7) HashJoin(t7 t9_1) SeqScan(t8) HashJoin(t7 t8 t9_1)   Leading(((t9_2 t7_1) t8_1)) SeqScan(t9_2) SeqScan(t7_1) HashJoin(t7_1 t9_2) SeqScan(t8_1) HashJoin(t7_1 t8_1 t9_2) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(28 rows)

create temporary view v5 as select a7, a8, a9 z from t7, t8, t9 where a7=a8 and a7=a9 except all select a7, a8, a9 from t7, t8, t9 where a7=a8 and a7=a9;
explain (hints on, costs off) select * from v5, t9 where z=a9;
                                                                                                                                                                                                                                                                                                                                                                                                   QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                                                   
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (t9.a9 = v5.z)
   ->  Seq Scan on t9
   ->  Hash
         ->  Subquery Scan on v5
               ->  HashSetOp Except All
                     ->  Append
                           ->  Subquery Scan on "*SELECT* 1"
                                 ->  Hash Join
                                       Hash Cond: (t7.a7 = t8.a8)
                                       ->  Hash Join
                                             Hash Cond: (t9_1.a9 = t7.a7)
                                             ->  Seq Scan on t9 t9_1
                                             ->  Hash
                                                   ->  Seq Scan on t7
                                       ->  Hash
                                             ->  Seq Scan on t8
                           ->  Subquery Scan on "*SELECT* 2"
                                 ->  Hash Join
                                       Hash Cond: (t7_1.a7 = t8_1.a8)
                                       ->  Hash Join
                                             Hash Cond: (t9_2.a9 = t7_1.a7)
                                             ->  Seq Scan on t9 t9_2
                                             ->  Hash
                                                   ->  Seq Scan on t7 t7_1
                                       ->  Hash
                                             ->  Seq Scan on t8 t8_1
 Generated hints: /*+ Leading((t9 v5)) SeqScan(t9) HashJoin(t9 v5)    Leading(((t9_1 t7) t8)) SeqScan(t9_1) SeqScan(t7) HashJoin(t7 t9_1) SeqScan(t8) HashJoin(t7 t8 t9_1)   Leading(((t9_2 t7_1) t8_1)) SeqScan(t9_2) SeqScan(t7_1) HashJoin(t7_1 t9_2) SeqScan(t8_1) HashJoin(t7_1 t8_1 t9_2) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(28 rows)

CREATE OR REPLACE FUNCTION func1(integer, integer) RETURNS integer
    AS 'select count(*) from t1, t2 where a1<$1 and b2>$2 and a1=a2;'
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;
-- Scalar function should be OK.
explain (hints on, costs off) select * from t1, t2, t3 where a1<a2 and a1=a3 and a1=func1(1, 2);
                                                                                                                                                                                                                                                                                                                     QUERY PLAN                                                                                                                                                                                                                                                                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   ->  Seq Scan on t3
         Storage Filter: (a3 = 0)
   ->  Materialize
         ->  Nested Loop
               ->  Seq Scan on t2
               ->  Memoize
                     Cache Key: t2.a2
                     Cache Mode: binary
                     ->  Index Scan using t1_a1_desc_idx on t1
                           Index Cond: ((a1 < t2.a2) AND (a1 = 0))
 Generated hints: /*+ Leading((t3 (t2 t1))) SeqScan(t3) SeqScan(t2) IndexScan(t1 t1_a1_desc_idx) NestLoop(t1 t2) NestLoop(t1 t2 t3) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(12 rows)

CREATE OR REPLACE FUNCTION func2(integer, integer) RETURNS TABLE(f1 int, f2 text)
     AS '/*+ Leading((t2 t1)) MergeJoin(t1 t2) */ select a1, a2 from t1, t2 where a1<$1 and b2>$2 and a1=a2;'
    LANGUAGE SQL;
-- Table function should be OK.
explain (hints on, costs off) select f2 from t1, t2, t3, func2(1, 2) funky where a1<a2 and a1=a3 and a3=f1 ;
                                                                                                                                                                                                                                                                                                                                       QUERY PLAN                                                                                                                                                                                                                                                                                                                                        
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (t3.a3 = t1.a1)
   ->  Hash Join
         Hash Cond: (t3.a3 = funky.f1)
         ->  Seq Scan on t3
         ->  Hash
               ->  Function Scan on func2 funky
   ->  Hash
         ->  Nested Loop
               ->  Seq Scan on t2
               ->  Memoize
                     Cache Key: t2.a2
                     Cache Mode: binary
                     ->  Index Only Scan using t1_a1_desc_idx on t1
                           Index Cond: (a1 < t2.a2)
 Generated hints: /*+ Leading(((t3 funky) (t2 t1))) SeqScan(t3) HashJoin(funky t3) SeqScan(t2) IndexOnlyScan(t1 t1_a1_desc_idx) NestLoop(t1 t2) HashJoin(funky t1 t2 t3) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(16 rows)

-- Make sure uniqueness can be proved using indices for hinted query generated for internal hint test.
explain (hints on, costs off) select 1 from t2, t3, t1 where a1=a2 and a1=a3 and unn1=1;
                                                                                                                                                                                                                                                                                                                                QUERY PLAN                                                                                                                                                                                                                                                                                                                                
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a1 = t2.a2)
   ->  YB Batched Nested Loop Join
         Join Filter: (t3.a3 = t1.a1)
         ->  Seq Scan on t3
         ->  Memoize
               Cache Key: t3.a3
               Cache Mode: logical
               ->  Index Scan using t1_a1_desc_idx on t1
                     Index Cond: (a1 = ANY (ARRAY[t3.a3, $1, $2, ..., $1023]))
                     Storage Filter: (unn1 = 1)
   ->  Memoize
         Cache Key: t1.a1
         Cache Mode: logical
         ->  Index Only Scan using t2_a2_idx on t2
               Index Cond: (a2 = ANY (ARRAY[t1.a1, $1025, $1026, ..., $2047]))
 Generated hints: /*+ Leading(((t3 t1) t2)) SeqScan(t3) IndexScan(t1 t1_a1_desc_idx) YbBatchedNL(t1 t3) IndexOnlyScan(t2 t2_a2_idx) YbBatchedNL(t1 t2 t3) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(17 rows)

-- Check hint generation for partitioned tables.
explain (hints on, costs off) select count(*) from prt1 p1 join prt2 p2 on p1.a=p2.a;
                                                                                                                                                                                                                                                                                QUERY PLAN                                                                                                                                                                                                                                                                                
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  YB Batched Nested Loop Join
         Join Filter: (p1.a = p2.a)
         ->  Append
               ->  Seq Scan on prt2_p1 p2_1
               ->  Seq Scan on prt2_p2 p2_2
               ->  Seq Scan on prt2_p3 p2_3
         ->  Memoize
               Cache Key: p2.a
               Cache Mode: logical
               ->  Append
                     ->  Index Only Scan using iprt1_p1_a_asc on prt1_p1 p1_1
                           Index Cond: (a = ANY (ARRAY[p2.a, $1, $2, ..., $1023]))
                     ->  Index Only Scan using iprt1_p2_a on prt1_p2 p1_2
                           Index Cond: (a = ANY (ARRAY[p2.a, $1, $2, ..., $1023]))
                     ->  Index Only Scan using iprt1_p3_a on prt1_p3 p1_3
                           Index Cond: (a = ANY (ARRAY[p2.a, $1, $2, ..., $1023]))
 Generated hints: /*+ Leading((p2 p1)) YbBatchedNL(p1 p2) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(18 rows)

-- Partitioned table where all partition-wise joins are forced to be merge joins. Should give no warnings/errors.
SET enable_partitionwise_join to true;
/*+ Mergejoin(t1 t2) */ explain (hints on, costs off) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1, prt2 t2 WHERE t1.a = t2.b AND t1.b = 0 ORDER BY t1.a, t2.b;
                 QUERY PLAN                  
---------------------------------------------
 Merge Append
   Sort Key: t1.a
   ->  Merge Join
         Merge Cond: (t1_1.a = t2_1.b)
         ->  Sort
               Sort Key: t1_1.a
               ->  Seq Scan on prt1_p1 t1_1
                     Storage Filter: (b = 0)
         ->  Sort
               Sort Key: t2_1.b
               ->  Seq Scan on prt2_p1 t2_1
   ->  Merge Join
         Merge Cond: (t1_2.a = t2_2.b)
         ->  Sort
               Sort Key: t1_2.a
               ->  Seq Scan on prt1_p2 t1_2
                     Storage Filter: (b = 0)
         ->  Sort
               Sort Key: t2_2.b
               ->  Seq Scan on prt2_p2 t2_2
   ->  Merge Join
         Merge Cond: (t1_3.a = t2_3.b)
         ->  Sort
               Sort Key: t1_3.a
               ->  Seq Scan on prt1_p3 t1_3
                     Storage Filter: (b = 0)
         ->  Sort
               Sort Key: t2_3.b
               ->  Seq Scan on prt2_p3 t2_3
 Generated hints: none
(30 rows)

-- Hint/join 2 partitions individually and union results. Should be OK.
/*+ NestLoop(t1_1 t2_1) Leading(t2_1 t1_1) MergeJoin(t1 t2) Leading((t1 t2)) IndexScan(t1 iprt1_p1_a) IndexScan(t2_1 iprt2_p2_b) */ explain (hints on, costs off) select count(*) from (select *
 from prt1_p1 t1, prt2_p1 t2 where t1.a+1=t2.b and t1.a=5 union all select * from prt1_p2 t1, prt2_p2 t2 where t1.a=t2.b and t1.a=10) dt;
                                                                                                                                                                                                                                                                                                                                                     QUERY PLAN                                                                                                                                                                                                                                                                                                                                                     
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Append
         ->  Subquery Scan on "*SELECT* 1"
               ->  Merge Join
                     Merge Cond: (((t1.a + 1)) = t2.b)
                     ->  Sort
                           Sort Key: ((t1.a + 1))
                           ->  Index Scan using iprt1_p1_a on prt1_p1 t1
                                 Index Cond: (a = 5)
                     ->  Sort
                           Sort Key: t2.b
                           ->  Seq Scan on prt2_p1 t2
         ->  Subquery Scan on "*SELECT* 2"
               ->  Nested Loop
                     ->  Index Scan using iprt2_p2_b on prt2_p2 t2_1
                           Index Cond: (b = 10)
                     ->  Index Only Scan using iprt1_p2_a on prt1_p2 t1_1
                           Index Cond: (a = 10)
 Generated hints: /*+   Leading((t1 t2)) IndexScan(t1 iprt1_p1_a) SeqScan(t2) MergeJoin(t1 t2)   Leading((t2_1 t1_1)) IndexScan(t2_1 iprt2_p2_b) IndexOnlyScan(t1_1 iprt1_p2_a) NestLoop(t1_1 t2_1) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(19 rows)

-- Turn off join partitioning and try hinting. Should work fine.
SET enable_partitionwise_join to false;
/*+ Leading((t2 t1)) HashJoin(t1 t2) */ explain (hints on, costs off) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1, prt2 t2 WHERE t1.a = t2.b AND t1.b = 0 ORDER BY t1.a, t2.b;
                                                                                                                                                                                                                                                                              QUERY PLAN                                                                                                                                                                                                                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Hash Join
         Hash Cond: (t2.b = t1.a)
         ->  Append
               ->  Seq Scan on prt2_p1 t2_1
               ->  Seq Scan on prt2_p2 t2_2
               ->  Seq Scan on prt2_p3 t2_3
         ->  Hash
               ->  Append
                     ->  Seq Scan on prt1_p1 t1_1
                           Storage Filter: (b = 0)
                     ->  Seq Scan on prt1_p2 t1_2
                           Storage Filter: (b = 0)
                     ->  Seq Scan on prt1_p3 t1_3
                           Storage Filter: (b = 0)
 Generated hints: /*+ Leading((t2 t1)) HashJoin(t1 t2) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(17 rows)

-- Make sure the internal hint test passes.
explain (hints on, costs off) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1, prt2 t2 WHERE t1.a = t2.b AND t1.b = 0 ORDER BY t1.a, t2.b;
                                                                                                                                                                                                                                                                              QUERY PLAN                                                                                                                                                                                                                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Hash Join
         Hash Cond: (t1.a = t2.b)
         ->  Append
               ->  Seq Scan on prt1_p1 t1_1
                     Storage Filter: (b = 0)
               ->  Seq Scan on prt1_p2 t1_2
                     Storage Filter: (b = 0)
               ->  Seq Scan on prt1_p3 t1_3
                     Storage Filter: (b = 0)
         ->  Hash
               ->  Append
                     ->  Seq Scan on prt2_p1 t2_1
                     ->  Seq Scan on prt2_p2 t2_2
                     ->  Seq Scan on prt2_p3 t2_3
 Generated hints: /*+ Leading((t1 t2)) HashJoin(t1 t2) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(17 rows)

-- Test hint table using query id instead of query text.
create extension if not exists pg_hint_plan;
set pg_hint_plan.enable_hint_table to on;
set pg_hint_plan.yb_use_query_id_for_hinting to on;
delete from hint_plan.hints;
-- Query id is expected to be 662787253122415527 for 'select * from information_schema.columns'.
INSERT INTO hint_plan.hints (norm_query_string, application_name, hints) VALUES ('6627872531224155272', '', 'Leading(((dep seq) ((co nco) (nt (((((c a) t) (bt nbt)) ad) nc))))) set(yb_prefer_bnl false) set(yb_enable_batchednl false) Set(from_collapse_limit 12) Set(join_collapse_limit 12) Set(geqo false)');
select * from hint_plan.hints;
 id |  norm_query_string  | application_name |                                                                                                hints                                                                                                
----+---------------------+------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  1 | 6627872531224155272 |                  | Leading(((dep seq) ((co nco) (nt (((((c a) t) (bt nbt)) ad) nc))))) set(yb_prefer_bnl false) set(yb_enable_batchednl false) Set(from_collapse_limit 12) Set(join_collapse_limit 12) Set(geqo false)
(1 row)

explain (hints on, costs off, verbose on) select * from information_schema.columns;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Right Join
   Output: (current_database())::information_schema.sql_identifier, (nc.nspname)::information_schema.sql_identifier, (c.relname)::information_schema.sql_identifier, (a.attname)::information_schema.sql_identifier, (a.attnum)::information_schema.cardinal_number, (CASE WHEN (a.attgenerated = ''::"char") THEN pg_get_expr(ad.adbin, ad.adrelid) ELSE NULL::text END)::information_schema.character_data, (CASE WHEN (a.attnotnull OR ((t.typtype = 'd'::"char") AND t.typnotnull)) THEN 'NO'::text ELSE 'YES'::text END)::information_schema.yes_or_no, (CASE WHEN (t.typtype = 'd'::"char") THEN CASE WHEN ((bt.typelem <> '0'::oid) AND (bt.typlen = '-1'::integer)) THEN 'ARRAY'::text WHEN (nbt.nspname = 'pg_catalog'::name) THEN format_type(t.typbasetype, NULL::integer) ELSE 'USER-DEFINED'::text END ELSE CASE WHEN ((t.typelem <> '0'::oid) AND (t.typlen = '-1'::integer)) THEN 'ARRAY'::text WHEN (nt.nspname = 'pg_catalog'::name) THEN format_type(a.atttypid, NULL::integer) ELSE 'USER-DEFINED'::text END END)::information_schema.character_data, (information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number, (information_schema._pg_char_octet_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number, (information_schema._pg_numeric_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number, (information_schema._pg_numeric_precision_radix(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number, (information_schema._pg_numeric_scale(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number, (information_schema._pg_datetime_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number, (information_schema._pg_interval_type(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.character_data, (NULL::integer)::information_schema.cardinal_number, NULL::information_schema.sql_identifier, NULL::information_schema.sql_identifier, NULL::information_schema.sql_identifier, (CASE WHEN (nco.nspname IS NOT NULL) THEN current_database() ELSE NULL::name END)::information_schema.sql_identifier, (nco.nspname)::information_schema.sql_identifier, (co.collname)::information_schema.sql_identifier, (CASE WHEN (t.typtype = 'd'::"char") THEN current_database() ELSE NULL::name END)::information_schema.sql_identifier, (CASE WHEN (t.typtype = 'd'::"char") THEN nt.nspname ELSE NULL::name END)::information_schema.sql_identifier, (CASE WHEN (t.typtype = 'd'::"char") THEN t.typname ELSE NULL::name END)::information_schema.sql_identifier, (current_database())::information_schema.sql_identifier, (COALESCE(nbt.nspname, nt.nspname))::information_schema.sql_identifier, (COALESCE(bt.typname, t.typname))::information_schema.sql_identifier, NULL::information_schema.sql_identifier, NULL::information_schema.sql_identifier, NULL::information_schema.sql_identifier, (NULL::integer)::information_schema.cardinal_number, (a.attnum)::information_schema.sql_identifier, ('NO'::character varying(3))::information_schema.yes_or_no, (CASE WHEN (a.attidentity = ANY ('{a,d}'::"char"[])) THEN 'YES'::text ELSE 'NO'::text END)::information_schema.yes_or_no, (CASE a.attidentity WHEN 'a'::"char" THEN 'ALWAYS'::text WHEN 'd'::"char" THEN 'BY DEFAULT'::text ELSE NULL::text END)::information_schema.character_data, (seq.seqstart)::information_schema.character_data, (seq.seqincrement)::information_schema.character_data, (seq.seqmax)::information_schema.character_data, (seq.seqmin)::information_schema.character_data, (CASE WHEN seq.seqcycle THEN 'YES'::text ELSE 'NO'::text END)::information_schema.yes_or_no, (CASE WHEN (a.attgenerated <> ''::"char") THEN 'ALWAYS'::text ELSE 'NEVER'::text END)::information_schema.character_data, (CASE WHEN (a.attgenerated <> ''::"char") THEN pg_get_expr(ad.adbin, ad.adrelid) ELSE NULL::text END)::information_schema.character_data, (CASE WHEN ((c.relkind = ANY ('{r,p}'::"char"[])) OR ((c.relkind = ANY ('{v,f}'::"char"[])) AND pg_column_is_updatable((c.oid)::regclass, a.attnum, false))) THEN 'YES'::text ELSE 'NO'::text END)::information_schema.yes_or_no
   Hash Cond: ((dep.refobjid = c.oid) AND (dep.refobjsubid = a.attnum))
   ->  Hash Join
         Output: dep.refobjid, dep.refobjsubid, seq.seqstart, seq.seqincrement, seq.seqmax, seq.seqmin, seq.seqcycle
         Inner Unique: true
         Hash Cond: (dep.objid = seq.seqrelid)
         ->  Index Scan using pg_depend_reference_index on pg_catalog.pg_depend dep
               Output: dep.objid, dep.refobjid, dep.refobjsubid
               Index Cond: (dep.refclassid = '1259'::oid)
               Storage Filter: ((dep.classid = '1259'::oid) AND (dep.deptype = 'i'::"char"))
         ->  Hash
               Output: seq.seqstart, seq.seqincrement, seq.seqmax, seq.seqmin, seq.seqcycle, seq.seqrelid
               ->  Seq Scan on pg_catalog.pg_sequence seq
                     Output: seq.seqstart, seq.seqincrement, seq.seqmax, seq.seqmin, seq.seqcycle, seq.seqrelid
   ->  Hash
         Output: a.attname, a.attnum, a.attgenerated, a.attnotnull, a.atttypid, a.*, a.attidentity, c.relname, c.relkind, c.oid, t.typtype, t.typnotnull, t.typbasetype, t.typelem, t.typlen, t.*, t.typname, bt.typelem, bt.typlen, bt.typname, nbt.nspname, ad.adbin, ad.adrelid, nc.nspname, co.collname, nco.nspname, nt.nspname
         ->  Merge Right Join
               Output: a.attname, a.attnum, a.attgenerated, a.attnotnull, a.atttypid, a.*, a.attidentity, c.relname, c.relkind, c.oid, t.typtype, t.typnotnull, t.typbasetype, t.typelem, t.typlen, t.*, t.typname, bt.typelem, bt.typlen, bt.typname, nbt.nspname, ad.adbin, ad.adrelid, nc.nspname, co.collname, nco.nspname, nt.nspname
               Merge Cond: (co.oid = a.attcollation)
               ->  Nested Loop
                     Output: co.collname, co.oid, nco.nspname
                     Inner Unique: true
                     Join Filter: ((co.collnamespace = nco.oid) AND ((nco.nspname <> 'pg_catalog'::name) OR (co.collname <> 'default'::name)))
                     ->  Index Scan using pg_collation_oid_index on pg_catalog.pg_collation co
                           Output: co.collname, co.collnamespace, co.oid
                     ->  Materialize
                           Output: nco.nspname, nco.oid
                           ->  Seq Scan on pg_catalog.pg_namespace nco
                                 Output: nco.nspname, nco.oid
               ->  Sort
                     Output: a.attname, a.attnum, a.attgenerated, a.attnotnull, a.atttypid, a.*, a.attidentity, a.attcollation, c.relname, c.relkind, c.oid, t.typtype, t.typnotnull, t.typbasetype, t.typelem, t.typlen, t.*, t.typname, bt.typelem, bt.typlen, bt.typname, nbt.nspname, ad.adbin, ad.adrelid, nc.nspname, nt.nspname
                     Sort Key: a.attcollation
                     ->  Hash Join
                           Output: a.attname, a.attnum, a.attgenerated, a.attnotnull, a.atttypid, a.*, a.attidentity, a.attcollation, c.relname, c.relkind, c.oid, t.typtype, t.typnotnull, t.typbasetype, t.typelem, t.typlen, t.*, t.typname, bt.typelem, bt.typlen, bt.typname, nbt.nspname, ad.adbin, ad.adrelid, nc.nspname, nt.nspname
                           Hash Cond: (nt.oid = t.typnamespace)
                           ->  Seq Scan on pg_catalog.pg_namespace nt
                                 Output: nt.nspname, nt.oid
                           ->  Hash
                                 Output: a.attname, a.attnum, a.attgenerated, a.attnotnull, a.atttypid, a.*, a.attidentity, a.attcollation, c.relname, c.relkind, c.oid, t.typtype, t.typnotnull, t.typbasetype, t.typelem, t.typlen, t.*, t.typname, t.typnamespace, bt.typelem, bt.typlen, bt.typname, nbt.nspname, ad.adbin, ad.adrelid, nc.nspname
                                 ->  Hash Join
                                       Output: a.attname, a.attnum, a.attgenerated, a.attnotnull, a.atttypid, a.*, a.attidentity, a.attcollation, c.relname, c.relkind, c.oid, t.typtype, t.typnotnull, t.typbasetype, t.typelem, t.typlen, t.*, t.typname, t.typnamespace, bt.typelem, bt.typlen, bt.typname, nbt.nspname, ad.adbin, ad.adrelid, nc.nspname
                                       Inner Unique: true
                                       Hash Cond: (c.relnamespace = nc.oid)
                                       ->  Hash Left Join
                                             Output: a.attname, a.attnum, a.attgenerated, a.attnotnull, a.atttypid, a.*, a.attidentity, a.attcollation, c.relname, c.relkind, c.oid, c.relnamespace, t.typtype, t.typnotnull, t.typbasetype, t.typelem, t.typlen, t.*, t.typname, t.typnamespace, bt.typelem, bt.typlen, bt.typname, nbt.nspname, ad.adbin, ad.adrelid
                                             Inner Unique: true
                                             Hash Cond: ((a.attrelid = ad.adrelid) AND (a.attnum = ad.adnum))
                                             ->  Nested Loop Left Join
                                                   Output: a.attname, a.attnum, a.attgenerated, a.attnotnull, a.atttypid, a.*, a.attidentity, a.attrelid, a.attcollation, c.relname, c.relkind, c.oid, c.relnamespace, t.typtype, t.typnotnull, t.typbasetype, t.typelem, t.typlen, t.*, t.typname, t.typnamespace, bt.typelem, bt.typlen, bt.typname, nbt.nspname
                                                   Join Filter: (t.typtype = 'd'::"char")
                                                   ->  Nested Loop
                                                         Output: a.attname, a.attnum, a.attgenerated, a.attnotnull, a.atttypid, a.*, a.attidentity, a.attrelid, a.attcollation, c.relname, c.relkind, c.oid, c.relnamespace, t.typtype, t.typnotnull, t.typbasetype, t.typelem, t.typlen, t.*, t.typname, t.typnamespace
                                                         Inner Unique: true
                                                         ->  Nested Loop
                                                               Output: a.attname, a.attnum, a.attgenerated, a.attnotnull, a.atttypid, a.*, a.attidentity, a.attrelid, a.attcollation, c.relname, c.relkind, c.oid, c.relnamespace
                                                               ->  Seq Scan on pg_catalog.pg_class c
                                                                     Output: c.relname, c.relkind, c.oid, c.relnamespace, c.relowner
                                                                     Storage Filter: (c.relkind = ANY ('{r,v,f,p}'::"char"[]))
                                                               ->  Index Scan using pg_attribute_relid_attnum_index on pg_catalog.pg_attribute a
                                                                     Output: a.attname, a.attnum, a.attgenerated, a.attnotnull, a.atttypid, a.*, a.attidentity, a.attrelid, a.attcollation
                                                                     Index Cond: ((a.attrelid = c.oid) AND (a.attnum > 0))
                                                                     Storage Filter: (NOT a.attisdropped)
                                                                     Filter: (pg_has_role(c.relowner, 'USAGE'::text) OR has_column_privilege(c.oid, a.attnum, 'SELECT, INSERT, UPDATE, REFERENCES'::text))
                                                         ->  Memoize
                                                               Output: t.typtype, t.typnotnull, t.typbasetype, t.typelem, t.typlen, t.*, t.typname, t.typnamespace, t.oid
                                                               Cache Key: a.atttypid
                                                               Cache Mode: logical
                                                               ->  Index Scan using pg_type_oid_index on pg_catalog.pg_type t
                                                                     Output: t.typtype, t.typnotnull, t.typbasetype, t.typelem, t.typlen, t.*, t.typname, t.typnamespace, t.oid
                                                                     Index Cond: (t.oid = a.atttypid)
                                                   ->  Nested Loop
                                                         Output: bt.typelem, bt.typlen, bt.typname, bt.oid, nbt.nspname
                                                         Inner Unique: true
                                                         ->  Index Scan using pg_type_oid_index on pg_catalog.pg_type bt
                                                               Output: bt.typelem, bt.typlen, bt.typname, bt.typnamespace, bt.oid
                                                               Index Cond: (bt.oid = t.typbasetype)
                                                         ->  Index Scan using pg_namespace_oid_index on pg_catalog.pg_namespace nbt
                                                               Output: nbt.nspname, nbt.oid
                                                               Index Cond: (nbt.oid = bt.typnamespace)
                                             ->  Hash
                                                   Output: ad.adbin, ad.adrelid, ad.adnum
                                                   ->  Seq Scan on pg_catalog.pg_attrdef ad
                                                         Output: ad.adbin, ad.adrelid, ad.adnum
                                       ->  Hash
                                             Output: nc.nspname, nc.oid
                                             ->  Seq Scan on pg_catalog.pg_namespace nc
                                                   Output: nc.nspname, nc.oid
                                                   Filter: (NOT pg_is_other_temp_schema(nc.oid))
 Generated hints: /*+ Leading(((dep seq) ((co nco) (nt (((((c a) t) (bt nbt)) ad) nc))))) IndexScan(dep pg_depend_reference_index) SeqScan(seq) HashJoin(dep seq) IndexScan(co pg_collation_oid_index) SeqScan(nco) NestLoop(co nco) SeqScan(nt) SeqScan(c) IndexScan(a pg_attribute_relid_attnum_index) NestLoop(a c) IndexScan(t pg_type_oid_index) NestLoop(a c t) IndexScan(bt pg_type_oid_index) IndexScan(nbt pg_namespace_oid_index) NestLoop(bt nbt) NestLoop(a bt c nbt t) SeqScan(ad) HashJoin(a ad bt c nbt t) SeqScan(nc) HashJoin(a ad bt c nbt nc t) HashJoin(a ad bt c nbt nc nt t) MergeJoin(a ad bt c co nbt nc nco nt t) HashJoin(a ad bt c co dep nbt nc nco nt seq t) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 12) Set(join_collapse_limit 12) Set(geqo false) */
(90 rows)

delete from hint_plan.hints;
reset pg_hint_plan.enable_hint_table;
reset pg_hint_plan.yb_use_query_id_for_hinting;
-- Test Leading semantics. Since this form of Leading allows (((t1 t2) t3)) or (((t2 t1) t3)) the following
-- 2 queries should give the same plan.
/*+ leading(t1 t2 t3) hashjoin(t1 t2) */ explain (hints on, costs off) select 1 from t1, t2, t3 where a1=a2 and a1=a3 and unn1=1;
                                                                                                                                                                                                                                                                                                            QUERY PLAN                                                                                                                                                                                                                                                                                                             
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (t3.a3 = t1.a1)
   ->  Seq Scan on t3
   ->  Hash
         ->  Hash Join
               Hash Cond: (t2.a2 = t1.a1)
               ->  Seq Scan on t2
               ->  Hash
                     ->  Seq Scan on t1
                           Storage Filter: (unn1 = 1)
 Generated hints: /*+ Leading((t3 (t2 t1))) SeqScan(t3) SeqScan(t2) SeqScan(t1) HashJoin(t1 t2) HashJoin(t1 t2 t3) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(11 rows)

/*+ leading(t2 t1 t3) hashjoin(t1 t2) */ explain (hints on, costs off) select 1 from t1, t2, t3 where a1=a2 and a1=a3 and unn1=1;
                                                                                                                                                                                                                                                                                                            QUERY PLAN                                                                                                                                                                                                                                                                                                             
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (t3.a3 = t1.a1)
   ->  Seq Scan on t3
   ->  Hash
         ->  Hash Join
               Hash Cond: (t2.a2 = t1.a1)
               ->  Seq Scan on t2
               ->  Hash
                     ->  Seq Scan on t1
                           Storage Filter: (unn1 = 1)
 Generated hints: /*+ Leading((t3 (t2 t1))) SeqScan(t3) SeqScan(t2) SeqScan(t1) HashJoin(t1 t2) HashJoin(t1 t2 t3) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(11 rows)

set pg_hint_plan.yb_bad_hint_mode to error;
-- Update statement with correlated subquery and duplicate name 'dt'. Must resolve conflict on 't1' also as with Insert. Should work.
/*+ Leading(((t3 t1_1) (t2 dt))) Leading((t4 dt_1)) */ explain (hints on, costs off) update t1 set a1=1 where exists (select 1 from t1, t2, t3, (select b4 from t4, t5 dt where a4=a5 and b5=b1 group by b4, b5) dt where t1.a1=t2.a2 and a1=a3 and a1=b4);
                                                                                                                                                                                                                                                                                                                                                                              QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Update on t1
   ->  Seq Scan on t1
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Nested Loop
                 Join Filter: (t1_1.a1 = t2.a2)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t1_1.a1 = t3.a3)
                       ->  Seq Scan on t3
                       ->  Memoize
                             Cache Key: t3.a3
                             Cache Mode: logical
                             ->  Index Only Scan using t1_a1_desc_idx on t1 t1_1
                                   Index Cond: (a1 = ANY (ARRAY[t3.a3, $2, $3, ..., $1024]))
                 ->  Materialize
                       ->  Hash Join
                             Hash Cond: (t2.a2 = dt.b4)
                             ->  Seq Scan on t2
                             ->  Hash
                                   ->  Subquery Scan on dt
                                         ->  HashAggregate
                                               Group Key: t4.b4, dt_1.b5
                                               ->  Hash Join
                                                     Hash Cond: (t4.a4 = dt_1.a5)
                                                     ->  Seq Scan on t4
                                                     ->  Hash
                                                           ->  Seq Scan on t5 dt_1
                                                                 Storage Filter: (b5 = t1.b1)
 Generated hints: /*+ SeqScan(t1) Leading(((t3 t1_1) (t2 dt))) SeqScan(t3) IndexOnlyScan(t1_1 t1_a1_desc_idx) YbBatchedNL(t1_1 t3) SeqScan(t2) HashJoin(dt t2) NestLoop(dt t1_1 t2 t3)  Leading((t4 dt_1)) SeqScan(t4) SeqScan(dt_1) HashJoin(dt_1 t4) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(29 rows)

-- Should get no error.
/*+ Leading((((t3 t1_1) t2) dt)) Leading((t4 t1_2)) */ explain (hints on, costs off) delete from t1 where a1 not in (select b1 from t1, t2, t3, (select b4 from t4, t5 t1 where a4=a5 group by b4, b5) dt where t1.a1=t2.a2 and a1=a3 and a1=b4);
                                                                                                                                                                                                                                                                                                                                                                                        QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                                         
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Delete on t1
   ->  Seq Scan on t1
         Filter: (NOT (hashed SubPlan 1))
         SubPlan 1
           ->  Hash Join
                 Hash Cond: (t1_1.a1 = dt.b4)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t1_1.a1 = t2.a2)
                       ->  YB Batched Nested Loop Join
                             Join Filter: (t1_1.a1 = t3.a3)
                             ->  Seq Scan on t3
                             ->  Memoize
                                   Cache Key: t3.a3
                                   Cache Mode: logical
                                   ->  Index Scan using t1_a1_desc_idx on t1 t1_1
                                         Index Cond: (a1 = ANY (ARRAY[t3.a3, $1, $2, ..., $1023]))
                       ->  Memoize
                             Cache Key: t3.a3
                             Cache Mode: logical
                             ->  Index Only Scan using t2_a2_idx on t2
                                   Index Cond: (a2 = ANY (ARRAY[t3.a3, $1025, $1026, ..., $2047]))
                 ->  Hash
                       ->  Subquery Scan on dt
                             ->  HashAggregate
                                   Group Key: t4.b4, t1_2.b5
                                   ->  Hash Join
                                         Hash Cond: (t4.a4 = t1_2.a5)
                                         ->  Seq Scan on t4
                                         ->  Hash
                                               ->  Seq Scan on t5 t1_2
 Generated hints: /*+ SeqScan(t1) Leading((((t3 t1_1) t2) dt)) SeqScan(t3) IndexScan(t1_1 t1_a1_desc_idx) YbBatchedNL(t1_1 t3) IndexOnlyScan(t2 t2_a2_idx) YbBatchedNL(t1_1 t2 t3) HashJoin(dt t1_1 t2 t3)  Leading((t4 t1_2)) SeqScan(t4) SeqScan(t1_2) HashJoin(t1_2 t4) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(31 rows)

-- Simple delete with index hint. Should work.
/*+ IndexScan(t1 t1_a1_asc_b1_asc_idx) */ explain (hints on, costs off) delete from t1 where a1=5;
                                                                                                                                                                                                                                                                               QUERY PLAN                                                                                                                                                                                                                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Delete on t1
   ->  Index Scan using t1_a1_asc_b1_asc_idx on t1
         Index Cond: (a1 = 5)
 Generated hints: /*+ IndexScan(t1 t1_a1_asc_b1_asc_idx) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(4 rows)

-- Use alias for t1. Should work.
/*+ IndexScan(x t1_a1_asc_b1_asc_idx) */ explain (hints on, costs off) delete from t1 as x where a1=5;
                                                                                                                                                                                                                                                                               QUERY PLAN                                                                                                                                                                                                                                                                               
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Delete on t1 x
   ->  Index Scan using t1_a1_asc_b1_asc_idx on t1 x
         Index Cond: (a1 = 5)
 Generated hints: /*+ IndexScan(x t1_a1_asc_b1_asc_idx) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(4 rows)

CREATE OR REPLACE FUNCTION dummy(OUT a integer, OUT b integer)
RETURNS SETOF record
LANGUAGE sql
IMMUTABLE PARALLEL SAFE STRICT
AS 'SELECT 1, 1';
set pg_hint_plan.yb_bad_hint_mode to warn;
-- Hint generation should work.
EXPLAIN (costs off, hints on) SELECT 1 FROM pg_type t, (SELECT dummy() as x) AS ss WHERE t.oid = (ss.x).a;
                                                                                                                                                                                                                                                                                   QUERY PLAN                                                                                                                                                                                                                                                                                   
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: ((((dummy())).a)::oid = t.oid)
   ->  ProjectSet (Hint Alias : ss)
         ->  Result *RESULT*
   ->  Hash
         ->  Seq Scan on pg_type t
 Generated hints: /*+ Leading((ss t)) SeqScan(t) HashJoin(ss t) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(7 rows)

-- Hint generation should work.
EXPLAIN (costs off, hints on) SELECT 1 FROM tbl, (SELECT dummy() as x) AS ss, (SELECT dummy() as x2) AS ss2 WHERE tbl.c1 = (ss.x).a AND tbl.c2 = (ss2.x2).a;
                                                                                                                                                                                                                                                                                                   QUERY PLAN                                                                                                                                                                                                                                                                                                    
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (((dummy())).a = tbl.c2)
   ->  ProjectSet (Hint Alias : ss2)
         ->  Result *RESULT*_1
   ->  Hash
         ->  Hash Join
               Hash Cond: (((dummy())).a = tbl.c1)
               ->  ProjectSet (Hint Alias : ss)
                     ->  Result *RESULT*
               ->  Hash
                     ->  Seq Scan on tbl
 Generated hints: /*+ Leading((ss2 (ss tbl))) SeqScan(tbl) HashJoin(ss tbl) HashJoin(ss ss2 tbl) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(12 rows)

-- Insert should work using t1_1 as alias.
/*+ Leading((((t3 t1_1) t2) dt)) */ explain (hints on, costs off) insert into t1 select t1.* from t1, t2, t3, (select b4 from t4, t5 dt where a4=a5 group by b4, b5) dt where t1.a1=t2.a2 and a1=a3 and a1=b4;
                                                                                                                                                                                                                                                                                                                                                                                  QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Insert on t1
   ->  Hash Join
         Hash Cond: (t1_1.a1 = dt.b4)
         ->  YB Batched Nested Loop Join
               Join Filter: (t1_1.a1 = t2.a2)
               ->  YB Batched Nested Loop Join
                     Join Filter: (t1_1.a1 = t3.a3)
                     ->  Seq Scan on t3
                     ->  Memoize
                           Cache Key: t3.a3
                           Cache Mode: logical
                           ->  Index Scan using t1_a1_desc_idx on t1 t1_1
                                 Index Cond: (a1 = ANY (ARRAY[t3.a3, $2, $3, ..., $1024]))
               ->  Memoize
                     Cache Key: t3.a3
                     Cache Mode: logical
                     ->  Index Only Scan using t2_a2_idx on t2
                           Index Cond: (a2 = ANY (ARRAY[t3.a3, $1026, $1027, ..., $2048]))
         ->  Hash
               ->  Subquery Scan on dt
                     ->  HashAggregate
                           Group Key: t4.b4, dt_1.b5
                           ->  Hash Join
                                 Hash Cond: (dt_1.a5 = t4.a4)
                                 ->  Seq Scan on t5 dt_1
                                 ->  Hash
                                       ->  Seq Scan on t4
 Generated hints: /*+ Leading((((t3 t1_1) t2) dt)) SeqScan(t3) IndexScan(t1_1 t1_a1_desc_idx) YbBatchedNL(t1_1 t3) IndexOnlyScan(t2 t2_a2_idx) YbBatchedNL(t1_1 t2 t3) HashJoin(dt t1_1 t2 t3)  Leading((dt_1 t4)) SeqScan(dt_1) SeqScan(t4) HashJoin(dt_1 t4) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(28 rows)

-- Should work since we are forcing a cross join t2-t3 (planner would not normally try this join).
/*+ noNestLoop(t1 t2) noNestLoop(t1 t3) Leading(t2 t3) */ explain (costs off, uids on) select max(a1) from t1 join t2 on a1<a2 join t3 on a1>a3;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Aggregate (UID 61)
   ->  Nested Loop (UID 57)
         Join Filter: (t1.a1 < t2.a2)
         ->  Nested Loop (UID 52)
               ->  Seq Scan on t3 (UID 29)
               ->  Materialize (UID 51)
                     ->  Seq Scan on t2 (UID 26)
         ->  Memoize (UID 56)
               Cache Key: t3.a3
               Cache Mode: binary
               ->  Index Only Scan using t1_a1_desc_idx on t1 (UID 8)
                     Index Cond: (a1 > t3.a3)
(12 rows)

-- NEGATIVE TESTS
-- Try to use a bad index. Should get warnings.
/*+ Leading((t2 t1)) SeqScan(t2) IndexScan(t1 badIndex) YbBatchedNL(t2 t1) */ explain (hints off, costs off) select * from t1, t2 where a1=1 and b1=b2;
WARNING:  bad index hint name "badIndex" for table t1
WARNING:  unused hint: IndexScan(t1 badIndex)
WARNING:  unused hints, and/or hints causing errors, exist
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.b1 = t2.b2)
   ->  Seq Scan on t2
   ->  Memoize
         Cache Key: t2.b2
         Cache Mode: logical
         ->  Index Scan using t1_a1_asc_b1_asc_idx on t1
               Index Cond: ((b1 = ANY (ARRAY[t2.b2, $1, $2, ..., $1023])) AND (a1 = 1))
(8 rows)

-- Specify a bad index with a valid one. Should get warnings.
/*+ Leading((t2 t1)) SeqScan(t2) IndexScan(t1 t1_a1_asc_b1_asc_idx badIndex) YbBatchedNL(t2 t1) */ explain (hints off, costs off) select * from t1, t2 where a1=1 and b1=b2;
WARNING:  bad index hint name "badIndex" for table t1
WARNING:  unused hints, and/or hints causing errors, exist
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.b1 = t2.b2)
   ->  Seq Scan on t2
   ->  Memoize
         Cache Key: t2.b2
         Cache Mode: logical
         ->  Index Scan using t1_a1_asc_b1_asc_idx on t1
               Index Cond: ((b1 = ANY (ARRAY[t2.b2, $1, $2, ..., $1023])) AND (a1 = 1))
(8 rows)

-- Specify a bad index with a valid one but bad name comes first. Should get warnings.
/*+ Leading((t2 t1)) SeqScan(t2) IndexScan(t1 badIndex t1_a1_asc_b1_asc_idx) YbBatchedNL(t2 t1) */ explain (hints off, costs off) select * from t1, t2 where a1=1 and b1=b2;
WARNING:  bad index hint name "badIndex" for table t1
WARNING:  unused hints, and/or hints causing errors, exist
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.b1 = t2.b2)
   ->  Seq Scan on t2
   ->  Memoize
         Cache Key: t2.b2
         Cache Mode: logical
         ->  Index Scan using t1_a1_asc_b1_asc_idx on t1
               Index Cond: ((b1 = ANY (ARRAY[t2.b2, $1, $2, ..., $1023])) AND (a1 = 1))
(8 rows)

-- Make index invalid for read and try to use it. Should get a warning (same as a missing index).
set yb_non_ddl_txn_for_sys_tables_allowed = true;
update pg_index set indisready=true, indisvalid = false where indrelid = 't1'::regclass;
/*+ IndexScan(t1 t1_a1_desc_idx) */ explain (costs off) select * from t1 where a1<5;
WARNING:  bad index hint name "t1_a1_desc_idx" for table t1
WARNING:  unused hint: IndexScan(t1 t1_a1_desc_idx)
WARNING:  unused hints, and/or hints causing errors, exist
         QUERY PLAN         
----------------------------
 Seq Scan on t1
   Storage Filter: (a1 < 5)
(2 rows)

update pg_index set indisready=true, indisvalid = true where indrelid = 't1'::regclass;
set yb_non_ddl_txn_for_sys_tables_allowed = false;
-- Turn on replanning. Now should see warnings for bad index and replanning message.
set pg_hint_plan.yb_bad_hint_mode to replan;
/*+ Leading((t1 t2)) SeqScan(t2) IndexScan(t1 badIndex) NestLoop(t2 t1) */ explain (hints on, costs off) select * from t1, t2 where a1<5 and b1=b2 order by a1 asc;
WARNING:  bad index hint name "badIndex" for table t1
WARNING:  unused hint: IndexScan(t1 badIndex)
WARNING:  unused hints, and/or hints causing errors, exist
WARNING:  replanning without hints
                                                                                                                                                                                                                                                                                                       QUERY PLAN                                                                                                                                                                                                                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: t1.a1
   ->  YB Batched Nested Loop Join
         Join Filter: (t1.b1 = t2.b2)
         ->  Seq Scan on t2
         ->  Memoize
               Cache Key: t2.b2
               Cache Mode: logical
               ->  Index Scan using t1_a1_asc_b1_asc_idx on t1
                     Index Cond: ((b1 = ANY (ARRAY[t2.b2, $1, $2, ..., $1023])) AND (a1 < 5))
 Generated hints: /*+ Leading((t2 t1)) SeqScan(t2) IndexScan(t1 t1_a1_asc_b1_asc_idx) YbBatchedNL(t1 t2) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(11 rows)

set pg_hint_plan.yb_bad_hint_mode to warn;
-- Bad table name 'x'. Should generate warnings.
/*+ Leading((t2 t1)) SeqScan(t2) IndexScan(t1 t1_a1_asc_b1_asc_idx) YbBatchedNL(t2 x) */ explain (hints on, costs off) select * from t1, t2 where a1=1 and b1=b2;
WARNING:  unused hint: YbBatchedNL(t2 x)
WARNING:  bad relation name "x" in join hint: YbBatchedNL(t2 x) (use alias name from EXPLAIN)
WARNING:  unused hints, and/or hints causing errors, exist
                                                                                                                                                                                                                                                                                                       QUERY PLAN                                                                                                                                                                                                                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.b1 = t2.b2)
   ->  Seq Scan on t2
   ->  Memoize
         Cache Key: t2.b2
         Cache Mode: logical
         ->  Index Scan using t1_a1_asc_b1_asc_idx on t1
               Index Cond: ((b1 = ANY (ARRAY[t2.b2, $1, $2, ..., $1023])) AND (a1 = 1))
 Generated hints: /*+ Leading((t2 t1)) SeqScan(t2) IndexScan(t1 t1_a1_asc_b1_asc_idx) YbBatchedNL(t1 t2) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(9 rows)

-- No plan can be found using the hint. Should generate warnings.
/*+ noSeqScan(tab) */ explain (hints on, costs off) select count(*) from t2 tab where b2<10;
WARNING:  hinting led to no path being found for relation "tab"
WARNING:  no valid access method found for relation "tab"
WARNING:  unused hints, and/or hints causing errors, exist
                                                                                                                                                                                                                                                                    QUERY PLAN                                                                                                                                                                                                                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Finalize Aggregate
   ->  Seq Scan on t2 tab
         Storage Filter: (b2 < 10)
         Partial Aggregate: true
 Generated hints: /*+ SeqScan(tab) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(5 rows)

-- No plan can be found using the hint. Should generate warnings.
/*+ set(enable_seqscan off) */ explain (hints on, costs off) select count(*) from t2 tab where b2<10;
WARNING:  no valid access method found for relation "tab"
WARNING:  unused hints, and/or hints causing errors, exist
                                                                                                                                                                                                                                                                    QUERY PLAN                                                                                                                                                                                                                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Finalize Aggregate
   ->  Seq Scan on t2 tab
         Storage Filter: (b2 < 10)
         Partial Aggregate: true
 Generated hints: /*+ SeqScan(tab) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(5 rows)

-- This hint makes sense but currently there cannot be > 1 join method hint for the same set of tables so will give warnings/errors.
/*+ noNestLoop(t1 t2) NoYbBatchedNL(t1 t2) */ explain (hints on, costs off) select max(a1) from t1 join t2 on a1=a2;
INFO:  pg_hint_plan: hint syntax error at or near "noNestLoop(t1 t2) NoYbBatchedNL(t1 t2) "
DETAIL:  Conflict join method hint.
WARNING:  errors found in hints
WARNING:  unused hints, and/or hints causing errors, exist
                                                                                                                                                                                                                                                                                                    QUERY PLAN                                                                                                                                                                                                                                                                                                    
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  YB Batched Nested Loop Join
         Join Filter: (t1.a1 = t2.a2)
         ->  Seq Scan on t1
         ->  Memoize
               Cache Key: t1.a1
               Cache Mode: logical
               ->  Index Only Scan using t2_a2_idx on t2
                     Index Cond: (a2 = ANY (ARRAY[t1.a1, $1, $2, ..., $1023]))
 Generated hints: /*+ Leading((t1 t2)) SeqScan(t1) IndexOnlyScan(t2 t2_a2_idx) YbBatchedNL(t1 t2) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(10 rows)

-- Try to force t0-t1 join. Should see errors/warnings since this is not a legal join order.
/*+ Leading(((t0 t1) t2)) */ explain (hints on, costs off, uids on) select count(*) from t0 left join (t1 join t2 on a1=a2) on a0=a1;
WARNING:  no valid method found for join with UID 75
WARNING:  unused hints, and/or hints causing errors, exist
                                                                                                                                                                                                                                                                                                                                   QUERY PLAN                                                                                                                                                                                                                                                                                                                                    
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate (UID 96)
   ->  Nested Loop Left Join (UID 95)
         Join Filter: (t0.a0 = t1.a1)
         ->  Seq Scan on t0 (UID 1)
         ->  Materialize (UID 91)
               ->  YB Batched Nested Loop Join (UID 75)
                     Join Filter: (t1.a1 = t2.a2)
                     Sort Keys: t1.a1
                     ->  Index Only Scan using t1_a1_asc_b1_asc_idx on t1 (UID 19)
                     ->  Memoize (UID 74)
                           Cache Key: t1.a1
                           Cache Mode: logical
                           ->  Index Only Scan using t2_a2_idx on t2 (UID 44)
                                 Index Cond: (a2 = ANY (ARRAY[t1.a1, $1, $2, ..., $1023]))
 Generated hints: /*+ Leading((t0 (t1 t2))) SeqScan(t0) IndexOnlyScan(t1 t1_a1_asc_b1_asc_idx) IndexOnlyScan(t2 t2_a2_idx) YbBatchedNL(t1 t2) NestLoop(t0 t1 t2) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(15 rows)

-- Syntax error. Should see warnings/error.
/*+ nestLoop(t4 t5 */ explain (hints on, costs off) select count(*) from t4 full join t5 on a4=a5;
INFO:  pg_hint_plan: hint syntax error at or near ""
DETAIL:  Closing parenthesis is necessary.
WARNING:  no valid hints found, planning query without hints
                                                                                                                                                                                                                                                                                          QUERY PLAN                                                                                                                                                                                                                                                                                           
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Hash Full Join
         Hash Cond: (t5.a5 = t4.a4)
         ->  Seq Scan on t5
         ->  Hash
               ->  Seq Scan on t4
 Generated hints: /*+ Leading((t5 t4)) SeqScan(t5) SeqScan(t4) HashJoin(t4 t5) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(7 rows)

-- Fix the syntax error and try again. No joy since NLJ cannot be used for FULL join. Will give warnings.
/*+ nestLoop(t4 t5) */ explain (hints on, costs off, uids on) select count(*) from t4 full join t5 on a4=a5;
WARNING:  no valid method found for join with UID 6
WARNING:  unused hints, and/or hints causing errors, exist
                                                                                                                                                                                                                                                                                          QUERY PLAN                                                                                                                                                                                                                                                                                           
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate (UID 7)
   ->  Hash Full Join (UID 6)
         Hash Cond: (t5.a5 = t4.a4)
         ->  Seq Scan on t5 (UID 2)
         ->  Hash (UID 8)
               ->  Seq Scan on t4 (UID 1)
 Generated hints: /*+ Leading((t5 t4)) SeqScan(t5) SeqScan(t4) HashJoin(t4 t5) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(7 rows)

-- Cannot do a ROJ so should get a warning.
/*+ leading((t4 t5)) nestLoop(t4 t5) */ explain (costs on, uids on) select count(*) from t4 right join t5 on a4=a5;
WARNING:  no valid method found for join with UID 5
WARNING:  unused hints, and/or hints causing errors, exist
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Aggregate  (cost=10000000188.41..10000000188.42 rows=1 width=8) (UID 6)
   ->  Nested Loop Left Join  (cost=10000000000.00..10000000186.25 rows=864 width=0) (UID 5)
         Join Filter: (t4.a4 = t5.a5)
         ->  Seq Scan on t5  (cost=0.00..11.00 rows=110 width=4) (UID 2)
         ->  Materialize  (cost=0.00..10.50 rows=100 width=4) (UID 3)
               ->  Seq Scan on t4  (cost=0.00..10.00 rows=100 width=4) (UID 1)
(6 rows)

-- Try to use hash join without an equality predicate. Should get an error, re-plan, and get first 5 rows.
set pg_hint_plan.yb_bad_hint_mode to replan;
/*+ hashJoin(t3 t4) */ select unn3, unn4 from t3 join t4 on a3<a4 order by unn3, unn4 limit 5;
WARNING:  no valid method found for join with UID 5
WARNING:  unused hints, and/or hints causing errors, exist
WARNING:  replanning without hints
 unn3 | unn4 
------+------
    0 |    1
    0 |    2
    0 |    3
    0 |    4
    0 |    6
(5 rows)

set pg_hint_plan.yb_bad_hint_mode to warn;
-- Hint a cross join with bad ROWS hint syntax error. Should get warnings/errors.
/*+ Leading(((((t5 t4) t1) t3) t2)) Rows(t4 t5 !10000) */ explain (hints on, costs off) select count(*) from t1, t2, t3, t4, t5 where a2=a3 and a2=a4 and a2=a5;
INFO:  pg_hint_plan: hint syntax error at or near "!10000"
DETAIL:  Unrecognized rows value type notation.
WARNING:  errors found in hints
WARNING:  error in hint: Rows(t4 t5 !10000)
WARNING:  unused hints, and/or hints causing errors, exist
                                                                                                                                                                                                                                                                                                                                                              QUERY PLAN                                                                                                                                                                                                                                                                                                                                                               
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  YB Batched Nested Loop Join
         Join Filter: (t3.a3 = t2.a2)
         ->  Hash Join
               Hash Cond: (t4.a4 = t3.a3)
               ->  Nested Loop
                     ->  Hash Join
                           Hash Cond: (t5.a5 = t4.a4)
                           ->  Seq Scan on t5
                           ->  Hash
                                 ->  Seq Scan on t4
                     ->  Materialize
                           ->  Seq Scan on t1
               ->  Hash
                     ->  Seq Scan on t3
         ->  Memoize
               Cache Key: t5.a5
               Cache Mode: logical
               ->  Index Only Scan using t2_a2_idx on t2
                     Index Cond: (a2 = ANY (ARRAY[t5.a5, $1, $2, ..., $1023]))
 Generated hints: /*+ Leading(((((t5 t4) t1) t3) t2)) SeqScan(t5) SeqScan(t4) HashJoin(t4 t5) SeqScan(t1) NestLoop(t1 t4 t5) SeqScan(t3) HashJoin(t1 t3 t4 t5) IndexOnlyScan(t2 t2_a2_idx) YbBatchedNL(t1 t2 t3 t4 t5) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(21 rows)

-- Hint a cross join with bad table name ROWS hint. Should get warnings/errors.
/*+ Leading(((((t5 t4) t1) t3) t2)) Rows(t4 t0 #10000) */ explain (hints on, costs off) select count(*) from t1, t2, t3, t4, t5 where a2=a3 and a2=a4 and a2=a5;
WARNING:  unused hint: Rows(t0 t4 #10000)
WARNING:  bad relation name "t0" in rows hint: Rows(t0 t4 #10000) (use alias name from EXPLAIN)
WARNING:  unused hints, and/or hints causing errors, exist
                                                                                                                                                                                                                                                                                                                                                              QUERY PLAN                                                                                                                                                                                                                                                                                                                                                               
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  YB Batched Nested Loop Join
         Join Filter: (t3.a3 = t2.a2)
         ->  Hash Join
               Hash Cond: (t4.a4 = t3.a3)
               ->  Nested Loop
                     ->  Hash Join
                           Hash Cond: (t5.a5 = t4.a4)
                           ->  Seq Scan on t5
                           ->  Hash
                                 ->  Seq Scan on t4
                     ->  Materialize
                           ->  Seq Scan on t1
               ->  Hash
                     ->  Seq Scan on t3
         ->  Memoize
               Cache Key: t5.a5
               Cache Mode: logical
               ->  Index Only Scan using t2_a2_idx on t2
                     Index Cond: (a2 = ANY (ARRAY[t5.a5, $1, $2, ..., $1023]))
 Generated hints: /*+ Leading(((((t5 t4) t1) t3) t2)) SeqScan(t5) SeqScan(t4) HashJoin(t4 t5) SeqScan(t1) NestLoop(t1 t4 t5) SeqScan(t3) HashJoin(t1 t3 t4 t5) IndexOnlyScan(t2 t2_a2_idx) YbBatchedNL(t1 t2 t3 t4 t5) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(21 rows)

-- Syntax error in parallel hint. Should get warnings/errors.
/*+ Parallel(t1 3 hrd) */ explain (hints on, costs off) select count(*) from t1;
INFO:  pg_hint_plan: hint syntax error at or near "hrd"
DETAIL:  enforcement must be soft or hard: Parallel
WARNING:  errors found in hints
WARNING:  error in hint: Parallel(t1 3 soft)
WARNING:  unused hints, and/or hints causing errors, exist
                                                                                                                                                                                                                                                                    QUERY PLAN                                                                                                                                                                                                                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Finalize Aggregate
   ->  Seq Scan on t1
         Partial Aggregate: true
 Generated hints: /*+ SeqScan(t1) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(4 rows)

-- Bad table name in parallel hint. Should get warnings/errors.
/*+ Parallel(t11 3 hard) */ explain (hints on, costs off) select count(*) from t1;
WARNING:  unused hint: Parallel(t11 3 hard)
WARNING:  bad relation name "t11" in parallel hint: Parallel(t11 3 hard) (use alias name from EXPLAIN)
WARNING:  unused hints, and/or hints causing errors, exist
                                                                                                                                                                                                                                                                    QUERY PLAN                                                                                                                                                                                                                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Finalize Aggregate
   ->  Seq Scan on t1
         Partial Aggregate: true
 Generated hints: /*+ SeqScan(t1) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(4 rows)

-- Use bad name 't22' in hint. Should get warnings and whatever plan was found without the bad leading hint.
/*+ Leading(((((t5 t4) t1) t3) t22)) */ explain (hints on, costs off) select count(*) from t1, t2, t3, t4, t5 where a2=a3 and a2=a4 and a2=a5;
WARNING:  unused hint: Leading(((((t5 t4) t1) t3) t22))
WARNING:  bad relation name "t22" in leading hint: Leading(((((t5 t4) t1) t3) t22)) (use alias name from EXPLAIN)
WARNING:  unused hints, and/or hints causing errors, exist
                                                                                                                                                                                                                                                                                                                                                             QUERY PLAN                                                                                                                                                                                                                                                                                                                                                             
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  YB Batched Nested Loop Join
         Join Filter: (t3.a3 = t2.a2)
         ->  Hash Join
               Hash Cond: (t5.a5 = t3.a3)
               ->  Nested Loop
                     ->  Seq Scan on t5
                     ->  Materialize
                           ->  Seq Scan on t1
               ->  Hash
                     ->  Hash Join
                           Hash Cond: (t4.a4 = t3.a3)
                           ->  Seq Scan on t4
                           ->  Hash
                                 ->  Seq Scan on t3
         ->  Memoize
               Cache Key: t5.a5
               Cache Mode: logical
               ->  Index Only Scan using t2_a2_idx on t2
                     Index Cond: (a2 = ANY (ARRAY[t5.a5, $1, $2, ..., $1023]))
 Generated hints: /*+ Leading((((t5 t1) (t4 t3)) t2)) SeqScan(t5) SeqScan(t1) NestLoop(t1 t5) SeqScan(t4) SeqScan(t3) HashJoin(t3 t4) HashJoin(t1 t3 t4 t5) IndexOnlyScan(t2 t2_a2_idx) YbBatchedNL(t1 t2 t3 t4 t5) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(21 rows)

-- Turn on flag to force failure on bad hint and try query. Should get an error.
set pg_hint_plan.yb_bad_hint_mode to error;
/*+ Leading(((((t5 t4) t1) t3) t22)) */ explain (hints on, costs off) select count(*) from t1, t2, t3, t4, t5 where a2=a3 and a2=a4 and a2=a5;
WARNING:  unused hint: Leading(((((t5 t4) t1) t3) t22))
WARNING:  bad relation name "t22" in leading hint: Leading(((((t5 t4) t1) t3) t22)) (use alias name from EXPLAIN)
WARNING:  unused hints, and/or hints causing errors, exist
ERROR:  errors found in hints, will fail
-- Turn on replanning flag and try query again.
set pg_hint_plan.yb_bad_hint_mode to replan;
/*+ Leading(((((t5 t4) t1) t3) t22)) */ explain (hints on, costs off) select count(*) from t1, t2, t3, t4, t5 where a2=a3 and a2=a4 and a2=a5;
WARNING:  unused hint: Leading(((((t5 t4) t1) t3) t22))
WARNING:  bad relation name "t22" in leading hint: Leading(((((t5 t4) t1) t3) t22)) (use alias name from EXPLAIN)
WARNING:  unused hints, and/or hints causing errors, exist
WARNING:  replanning without hints
                                                                                                                                                                                                                                                                                                                                                             QUERY PLAN                                                                                                                                                                                                                                                                                                                                                             
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  YB Batched Nested Loop Join
         Join Filter: (t3.a3 = t2.a2)
         ->  Hash Join
               Hash Cond: (t5.a5 = t3.a3)
               ->  Nested Loop
                     ->  Seq Scan on t5
                     ->  Materialize
                           ->  Seq Scan on t1
               ->  Hash
                     ->  Hash Join
                           Hash Cond: (t4.a4 = t3.a3)
                           ->  Seq Scan on t4
                           ->  Hash
                                 ->  Seq Scan on t3
         ->  Memoize
               Cache Key: t5.a5
               Cache Mode: logical
               ->  Index Only Scan using t2_a2_idx on t2
                     Index Cond: (a2 = ANY (ARRAY[t5.a5, $1, $2, ..., $1023]))
 Generated hints: /*+ Leading((((t5 t1) (t4 t3)) t2)) SeqScan(t5) SeqScan(t1) NestLoop(t1 t5) SeqScan(t4) SeqScan(t3) HashJoin(t3 t4) HashJoin(t1 t3 t4 t5) IndexOnlyScan(t2 t2_a2_idx) YbBatchedNL(t1 t2 t3 t4 t5) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(21 rows)

set pg_hint_plan.yb_bad_hint_mode to error;
-- Try Insert statement. Should give an error since 't1' is used for the target relation.
/*+ Leading((((t3 t1) t2) dt)) */ explain (hints on, costs off) insert into t1 select t1.* from t1, t2, t3, (select b4 from t4, t5 dt where a4=a5 group by b4, b5) dt where t1.a1=t2.a2 and a1=a3 and a1=b4;
WARNING:  unused hint: Leading((((t3 t1) t2) dt))
WARNING:  bad relation name "t1" in leading hint: Leading((((t3 t1) t2) dt)) (use alias name from EXPLAIN)
WARNING:  unused hints, and/or hints causing errors, exist
ERROR:  errors found in hints, will fail
-- Delete statement with wrong relation 't1_3' in the hint. Should give error.
/*+ Leading((((t3 t1_1) t2) dt)) Leading((t4 t1_3)) */ explain (hints on, costs off) delete from t1 where a1 not in (select b1 from t1, t2, t3, (select b4 from t4, t5 t1 where a4=a5 group by b4, b5) dt where t1.a1=t2.a2 and a1=a3 and a1=b4);
WARNING:  unused hint: Leading((t4 t1_3))
WARNING:  bad relation name "t1_3" in leading hint: Leading((t4 t1_3)) (use alias name from EXPLAIN)
WARNING:  unused hints, and/or hints causing errors, exist
ERROR:  errors found in hints, will fail
-- Should fail because alias is not used.
/*+ IndexScan(t1 t1_a1_asc_b1_asc_idx) */ explain (hints on, costs off) delete from t1 as x where a1=5;
WARNING:  unused hint: IndexScan(t1 t1_a1_asc_b1_asc_idx)
WARNING:  bad relation name "t1" in scan hint: IndexScan(t1 t1_a1_asc_b1_asc_idx) (use alias name from EXPLAIN)
WARNING:  unused hints, and/or hints causing errors, exist
ERROR:  errors found in hints, will fail
-- Try to join subqueries first. This is illegal because they are semijoined so should see warnings.
set pg_hint_plan.yb_bad_hint_mode to warn;
/*+ Leading((((ANY_subquery ANY_subquery_1) t1) t2)) */ explain (hints on, costs off, uids on) select count(*) from t1, t2 where a1=a2 and b1 in (select a4 from t4 group by a4, b4) and b2 in (select a5 from t5 group by a5, b5);
WARNING:  no valid method found for join with UID 68
WARNING:  unused hints, and/or hints causing errors, exist
                                                                                                                                                                                                                                                                                                                                                                                      QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                                      
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate (UID 140)
   ->  Nested Loop Semi Join (UID 126)
         Join Filter: (t2.b2 = "ANY_subquery_1".a5)
         ->  YB Batched Nested Loop Join (UID 105)
               Join Filter: (t1.a1 = t2.a2)
               ->  Nested Loop Semi Join (UID 68)
                     Join Filter: (t1.b1 = "ANY_subquery".a4)
                     ->  Index Only Scan using t1_a1_asc_b1_asc_idx on t1 (UID 20)
                     ->  Materialize (UID 64)
                           ->  Subquery Scan on "ANY_subquery" (UID 5)
                                 ->  HashAggregate (UID 4)
                                       Group Key: t4.a4, t4.b4
                                       ->  Seq Scan on t4 (UID 1)
               ->  Memoize (UID 104)
                     Cache Key: t1.a1
                     Cache Mode: logical
                     ->  Index Scan using t2_a2_idx on t2 (UID 32)
                           Index Cond: (a2 = ANY (ARRAY[t1.a1, $1, $2, ..., $1023]))
         ->  Materialize (UID 124)
               ->  Subquery Scan on "ANY_subquery_1" (UID 11)
                     ->  HashAggregate (UID 10)
                           Group Key: t5.a5, t5.b5
                           ->  Seq Scan on t5 (UID 7)
 Generated hints: /*+ Leading((((t1 ANY_subquery) t2) ANY_subquery_1)) IndexOnlyScan(t1 t1_a1_asc_b1_asc_idx) NestLoop(ANY_subquery t1) IndexScan(t2 t2_a2_idx) YbBatchedNL(ANY_subquery t1 t2) NestLoop(ANY_subquery ANY_subquery_1 t1 t2)  SeqScan(t4)  SeqScan(t5) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(24 rows)

set pg_hint_plan.yb_bad_hint_mode to replan;
-- Not OK since forcing t1 and t2 to be directly joined. Should generate warnings and replan.
/*+ Leading(((t1 t2) t3)) noNestLoop(t1 t2) */ explain (hints on, costs off, uids on) select max(a1) from t1 join t2 on a1<a2 join t3 on a1=a3;
WARNING:  no valid method found for join with UID 44
WARNING:  unused hints, and/or hints causing errors, exist
WARNING:  replanning without hints
                                                                                                                                                                                                                                                                                                                       QUERY PLAN                                                                                                                                                                                                                                                                                                                       
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate (UID 71)
   ->  Hash Join (UID 63)
         Hash Cond: (t1.a1 = t3.a3)
         ->  Nested Loop (UID 48)
               ->  Seq Scan on t2 (UID 36)
               ->  Memoize (UID 47)
                     Cache Key: t2.a2
                     Cache Mode: binary
                     ->  Index Only Scan using t1_a1_desc_idx on t1 (UID 6)
                           Index Cond: (a1 < t2.a2)
         ->  Hash (UID 72)
               ->  Seq Scan on t3 (UID 39)
 Generated hints: /*+ Leading(((t2 t1) t3)) SeqScan(t2) IndexOnlyScan(t1 t1_a1_desc_idx) NestLoop(t1 t2) SeqScan(t3) HashJoin(t1 t2 t3) Set(yb_enable_optimizer_statistics off) Set(yb_enable_base_scans_cost_model off) Set(enable_hashagg on) Set(enable_material on) Set(enable_memoize on) Set(enable_sort on) Set(enable_incremental_sort on) Set(max_parallel_workers_per_gather 2) Set(parallel_tuple_cost 0.10) Set(parallel_setup_cost 1000.00) Set(min_parallel_table_scan_size 1024) Set(yb_prefer_bnl on) Set(yb_bnl_batch_size 1024) Set(yb_fetch_row_limit 1024) Set(from_collapse_limit 8) Set(join_collapse_limit 8) Set(geqo false) */
(13 rows)

set pg_hint_plan.yb_bad_hint_mode to warn;
-- Should warn since planner will not try joining t2-t3.
/*+ noNestLoop(t1 t2) noNestLoop(t1 t3) */ explain (costs off, uids on) select max(a1) from t1 join t2 on a1<a2 join t3 on a1>a3;
WARNING:  no valid method found for join with UID 37
WARNING:  unused hints, and/or hints causing errors, exist
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Aggregate (UID 58)
   ->  Nested Loop (UID 50)
         Join Filter: (t1.a1 > t3.a3)
         ->  Nested Loop (UID 37)
               ->  Seq Scan on t2 (UID 26)
               ->  Memoize (UID 36)
                     Cache Key: t2.a2
                     Cache Mode: binary
                     ->  Index Only Scan using t1_a1_desc_idx on t1 (UID 4)
                           Index Cond: (a1 < t2.a2)
         ->  Materialize (UID 48)
               ->  Seq Scan on t3 (UID 29)
(12 rows)

drop schema yb_hints cascade;
NOTICE:  drop cascades to 22 other objects
DETAIL:  drop cascades to function dummy()
drop cascades to function func1(integer,integer)
drop cascades to function func2(integer,integer)
drop cascades to table prt1
drop cascades to table prt2
drop cascades to table t0
drop cascades to table t1
drop cascades to table t10
drop cascades to table t2
drop cascades to table t3
drop cascades to table t4
drop cascades to table t5
drop cascades to table t6
drop cascades to table t7
drop cascades to table t8
drop cascades to table t9
drop cascades to table tbl
drop cascades to view v1
drop cascades to view v2
drop cascades to view v3
drop cascades to view v4
drop cascades to view v5
-- Test fix for incorrect pruning of joins.
drop schema if exists yb26670 cascade;
NOTICE:  schema "yb26670" does not exist, skipping
create schema yb26670;
set search_path to yb26670;
create table t0(c0 int4range , c1 BIT VARYING(40) );
create table t1(c0 DECIMAL );
create table t2(c0 bytea , c1 REAL );
create table t3(c0 inet , c1 int4range ) WITHOUT OIDS ;
create table t4(c0 TEXT );
create temporary view v6(c0) AS (SELECT '132.63.53.50' FROM t2*, t1*, t3, t4*, t0* WHERE lower_inf(((((t0.c0)*(t3.c1)))+(((t3.c1)+(t3.c1))))) LIMIT 2444285747789238479);
-- Can't generate hints here because the final plan has a join replaced by a RESULT node.
explain (hints on) SELECT MAX((0.6002056)::MONEY) FROM t1*, ONLY t0, ONLY v6 LEFT OUTER JOIN t4* ON TRUE RIGHT OUTER JOIN t2* ON FALSE GROUP BY - (+ (strpos(t4.c0, v6.c0)));
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 HashAggregate  (cost=27512815.00..27513515.00 rows=40000 width=12)
   Group Key: (- (+ strpos(c0, c0)))
   ->  Nested Loop  (cost=0.00..20012815.00 rows=1000000000 width=4)
         ->  Nested Loop  (cost=0.00..12712.50 rows=1000000 width=64)
               ->  Nested Loop Left Join  (cost=0.00..110.00 rows=1000 width=64)
                     Join Filter: false
                     ->  Seq Scan on t2  (cost=0.00..100.00 rows=1000 width=0)
                     ->  Result  (cost=0.00..0.00 rows=0 width=64)
                           One-Time Filter: false
               ->  Materialize  (cost=0.00..105.00 rows=1000 width=0)
                     ->  Seq Scan on t1  (cost=0.00..100.00 rows=1000 width=0)
         ->  Materialize  (cost=0.00..105.00 rows=1000 width=0)
               ->  Seq Scan on t0  (cost=0.00..100.00 rows=1000 width=0)
 Generated hints: none
(14 rows)

SELECT MAX((0.6002056)::MONEY) FROM t1*, ONLY t0, ONLY v6 LEFT OUTER JOIN t4* ON TRUE RIGHT OUTER JOIN t2* ON FALSE GROUP BY - (+ (strpos(t4.c0, v6.c0)));
 max 
-----
(0 rows)

drop schema yb26670 cascade;
NOTICE:  drop cascades to 6 other objects
DETAIL:  drop cascades to table t0
drop cascades to table t1
drop cascades to table t2
drop cascades to table t3
drop cascades to table t4
drop cascades to view v6
\set ECHO none
WARNING:  there is no transaction in progress
