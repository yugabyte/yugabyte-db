-- Test that data from multiple tables is returned
CREATE TABLE test_table_1 (k INT PRIMARY KEY, v INT) SPLIT INTO 2 TABLETS;
CREATE TABLE test_table_2 (k INT, v INT, PRIMARY KEY (k asc));
SELECT
    relname,
    db_name,
    start_hash_code,
    end_hash_code
FROM yb_tablet_metadata WHERE relname IN ('test_table_1', 'test_table_2')
ORDER BY start_hash_code NULLS FIRST;
   relname    | db_name  | start_hash_code | end_hash_code 
--------------+----------+-----------------+---------------
 test_table_2 | yugabyte |                 |              
 test_table_1 | yugabyte |               0 |         32768
 test_table_1 | yugabyte |           32768 |         65536
(3 rows)

-- Test that attributes column is present with correct type and structure
SELECT
    relname,
    pg_typeof(attributes) AS attr_type,
    jsonb_typeof(attributes->'replicas') AS replicas_type,
    (SELECT count(*) FROM jsonb_object_keys(attributes->'replicas'))::int
        = array_length(replicas, 1) AS key_count_match
FROM yb_tablet_metadata
WHERE relname = 'test_table_1'
ORDER BY start_hash_code NULLS FIRST
LIMIT 1;
   relname    | attr_type | replicas_type | key_count_match 
--------------+-----------+---------------+-----------------
 test_table_1 | jsonb     | object        | t
(1 row)

-- Test that all size values are non-negative for each replica
SELECT replica, (attrs->>'active_sst_sizes')::bigint AS active_sst_sizes,
                (attrs->>'wal_sizes')::bigint AS wal_sizes
FROM yb_tablet_metadata tm,
     unnest(tm.replicas) AS replica,
     LATERAL (SELECT tm.attributes->'replicas'->replica AS attrs) a
WHERE tm.relname = 'test_table_1'
  AND ((attrs->>'active_sst_sizes')::bigint < 0
    OR (attrs->>'wal_sizes')::bigint < 0);
 replica | active_sst_sizes | wal_sizes 
---------+------------------+-----------
(0 rows)

-- Test that every replica in the replicas array has an entry in attributes
SELECT replica
FROM yb_tablet_metadata tm, unnest(tm.replicas) AS replica
WHERE tm.relname = 'test_table_1'
  AND NOT (tm.attributes->'replicas' ? replica);
 replica 
---------
(0 rows)

-- Test that every replica address corresponds to a live tserver
SELECT unnest(replicas) AS orphan_replica
FROM yb_tablet_metadata
WHERE relname = 'test_table_1'
EXCEPT
SELECT host || ':' || port FROM yb_servers();
 orphan_replica 
----------------
(0 rows)

-- Test that we are able to join with yb_servers()
SELECT
    ytm.relname,
    ytm.db_name,
    ytm.start_hash_code,
    ytm.end_hash_code,
    ys.cloud,
    ys.region,
    ys.zone
FROM yb_tablet_metadata ytm
JOIN yb_servers() ys
    ON split_part(ytm.leader, ':', 1) = ys.host
    AND split_part(ytm.leader, ':', 2)::int = ys.port
WHERE ytm.relname IN ('test_table_1', 'test_table_2')
ORDER BY ytm.start_hash_code NULLS FIRST;
   relname    | db_name  | start_hash_code | end_hash_code | cloud  |   region    | zone  
--------------+----------+-----------------+---------------+--------+-------------+-------
 test_table_2 | yugabyte |                 |               | cloud1 | datacenter1 | rack1
 test_table_1 | yugabyte |               0 |         32768 | cloud1 | datacenter1 | rack1
 test_table_1 | yugabyte |           32768 |         65536 | cloud1 | datacenter1 | rack1
(3 rows)

-- Test that data from multiple databases is returned
CREATE DATABASE test_db;
\c test_db
CREATE TABLE test_table_1 (k INT PRIMARY KEY, v INT) SPLIT INTO 2 TABLETS;
CREATE TABLE test_table_2 (k INT, v INT, PRIMARY KEY (k asc));
SELECT
    relname,
    db_name,
    start_hash_code,
    end_hash_code
FROM yb_tablet_metadata
WHERE
    relname IN ('test_table_1', 'test_table_2')
    AND db_name IN ('test_db', 'yugabyte')
ORDER BY db_name, start_hash_code NULLS FIRST;
   relname    | db_name  | start_hash_code | end_hash_code 
--------------+----------+-----------------+---------------
 test_table_2 | test_db  |                 |              
 test_table_1 | test_db  |               0 |         32768
 test_table_1 | test_db  |           32768 |         65536
 test_table_2 | yugabyte |                 |              
 test_table_1 | yugabyte |               0 |         32768
 test_table_1 | yugabyte |           32768 |         65536
(6 rows)

-- Test that data from colocated tables is returned
CREATE DATABASE colocated_db WITH COLOCATION = true;
\c colocated_db
CREATE TABLE test_table_1 (k INT PRIMARY KEY, v INT);
CREATE TABLE test_table_2 (k INT, v INT, PRIMARY KEY (k asc));
CREATE TABLE test_table_3 (k INT PRIMARY KEY, v INT) WITH (COLOCATION = false) SPLIT INTO 2 TABLETS;
SELECT
    relname,
    db_name,
    start_hash_code,
    end_hash_code
FROM yb_tablet_metadata
WHERE
    relname IN ('test_table_1', 'test_table_2', 'test_table_3')
    AND db_name = 'colocated_db'
ORDER BY start_hash_code NULLS FIRST;
   relname    |   db_name    | start_hash_code | end_hash_code 
--------------+--------------+-----------------+---------------
 test_table_1 | colocated_db |                 |              
 test_table_2 | colocated_db |                 |              
 test_table_3 | colocated_db |               0 |         32768
 test_table_3 | colocated_db |           32768 |         65536
(4 rows)

