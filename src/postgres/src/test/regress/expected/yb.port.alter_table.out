--
-- ALTER_TABLE
--
-- Clean up in case a prior regression run failed
SET client_min_messages TO 'warning';
DROP ROLE IF EXISTS regress_alter_table_user1;
RESET client_min_messages;
CREATE USER regress_alter_table_user1;
--
-- add attribute
--
CREATE TABLE attmp (initial int4);
COMMENT ON TABLE attmp_wrong IS 'table comment';
ERROR:  relation "attmp_wrong" does not exist
COMMENT ON TABLE attmp IS 'table comment';
COMMENT ON TABLE attmp IS NULL;
ALTER TABLE attmp ADD COLUMN xmin integer; -- fails
ERROR:  column name "xmin" conflicts with a system column name
ALTER TABLE attmp ADD COLUMN a int4 default 3;
ALTER TABLE attmp ADD COLUMN b name;
ALTER TABLE attmp ADD COLUMN c text;
ALTER TABLE attmp ADD COLUMN d float8;
ALTER TABLE attmp ADD COLUMN e float4;
ALTER TABLE attmp ADD COLUMN f int2;
ALTER TABLE attmp ADD COLUMN g polygon;
ALTER TABLE attmp ADD COLUMN i char;
ALTER TABLE attmp ADD COLUMN k int4;
ALTER TABLE attmp ADD COLUMN l tid;
ALTER TABLE attmp ADD COLUMN m xid;
ALTER TABLE attmp ADD COLUMN n oidvector;
--ALTER TABLE attmp ADD COLUMN o lock;
ALTER TABLE attmp ADD COLUMN p boolean;
ALTER TABLE attmp ADD COLUMN q point;
ALTER TABLE attmp ADD COLUMN r lseg;
ALTER TABLE attmp ADD COLUMN s path;
ALTER TABLE attmp ADD COLUMN t box;
ALTER TABLE attmp ADD COLUMN v timestamp;
ALTER TABLE attmp ADD COLUMN w interval;
ALTER TABLE attmp ADD COLUMN x float8[];
ALTER TABLE attmp ADD COLUMN y float4[];
ALTER TABLE attmp ADD COLUMN z int2[];
INSERT INTO attmp (a, b, c, d, e, f, g,    i,    k, l, m, n, p, q, r, s, t,
	v, w, x, y, z)
   VALUES (4, 'name', 'text', 4.1, 4.1, 2, '(4.1,4.1,3.1,3.1)',
	'c',
	314159, '(1,1)', '512',
	'1 2 3 4 5 6 7 8', true, '(1.1,1.1)', '(4.1,4.1,3.1,3.1)',
	'(0,2,4.1,4.1,3.1,3.1)', '(4.1,4.1,3.1,3.1)',
	'epoch', '01:00:10', '{1.0,2.0,3.0,4.0}', '{1.0,2.0,3.0,4.0}', '{1,2,3,4}');
SELECT * FROM attmp;
 initial | a |  b   |  c   |  d  |  e  | f |           g           | i |   k    |   l   |  m  |        n        | p |     q     |           r           |              s              |          t          |            v             |        w         |     x     |     y     |     z     
---------+---+------+------+-----+-----+---+-----------------------+---+--------+-------+-----+-----------------+---+-----------+-----------------------+-----------------------------+---------------------+--------------------------+------------------+-----------+-----------+-----------
         | 4 | name | text | 4.1 | 4.1 | 2 | ((4.1,4.1),(3.1,3.1)) | c | 314159 | (1,1) | 512 | 1 2 3 4 5 6 7 8 | t | (1.1,1.1) | [(4.1,4.1),(3.1,3.1)] | ((0,2),(4.1,4.1),(3.1,3.1)) | (4.1,4.1),(3.1,3.1) | Thu Jan 01 00:00:00 1970 | @ 1 hour 10 secs | {1,2,3,4} | {1,2,3,4} | {1,2,3,4}
(1 row)

DROP TABLE attmp;
-- the wolf bug - schema mods caused inconsistent row descriptors
CREATE TABLE attmp (
	initial 	int4
);
ALTER TABLE attmp ADD COLUMN a int4;
ALTER TABLE attmp ADD COLUMN b name;
ALTER TABLE attmp ADD COLUMN c text;
ALTER TABLE attmp ADD COLUMN d float8;
ALTER TABLE attmp ADD COLUMN e float4;
ALTER TABLE attmp ADD COLUMN f int2;
ALTER TABLE attmp ADD COLUMN g polygon;
ALTER TABLE attmp ADD COLUMN i char;
ALTER TABLE attmp ADD COLUMN k int4;
ALTER TABLE attmp ADD COLUMN l tid;
ALTER TABLE attmp ADD COLUMN m xid;
ALTER TABLE attmp ADD COLUMN n oidvector;
--ALTER TABLE attmp ADD COLUMN o lock;
ALTER TABLE attmp ADD COLUMN p boolean;
ALTER TABLE attmp ADD COLUMN q point;
ALTER TABLE attmp ADD COLUMN r lseg;
ALTER TABLE attmp ADD COLUMN s path;
ALTER TABLE attmp ADD COLUMN t box;
ALTER TABLE attmp ADD COLUMN v timestamp;
ALTER TABLE attmp ADD COLUMN w interval;
ALTER TABLE attmp ADD COLUMN x float8[];
ALTER TABLE attmp ADD COLUMN y float4[];
ALTER TABLE attmp ADD COLUMN z int2[];
INSERT INTO attmp (a, b, c, d, e, f, g,    i,   k, l, m, n, p, q, r, s, t,
	v, w, x, y, z)
   VALUES (4, 'name', 'text', 4.1, 4.1, 2, '(4.1,4.1,3.1,3.1)',
        'c',
	314159, '(1,1)', '512',
	'1 2 3 4 5 6 7 8', true, '(1.1,1.1)', '(4.1,4.1,3.1,3.1)',
	'(0,2,4.1,4.1,3.1,3.1)', '(4.1,4.1,3.1,3.1)',
	'epoch', '01:00:10', '{1.0,2.0,3.0,4.0}', '{1.0,2.0,3.0,4.0}', '{1,2,3,4}');
SELECT * FROM attmp;
 initial | a |  b   |  c   |  d  |  e  | f |           g           | i |   k    |   l   |  m  |        n        | p |     q     |           r           |              s              |          t          |            v             |        w         |     x     |     y     |     z     
---------+---+------+------+-----+-----+---+-----------------------+---+--------+-------+-----+-----------------+---+-----------+-----------------------+-----------------------------+---------------------+--------------------------+------------------+-----------+-----------+-----------
         | 4 | name | text | 4.1 | 4.1 | 2 | ((4.1,4.1),(3.1,3.1)) | c | 314159 | (1,1) | 512 | 1 2 3 4 5 6 7 8 | t | (1.1,1.1) | [(4.1,4.1),(3.1,3.1)] | ((0,2),(4.1,4.1),(3.1,3.1)) | (4.1,4.1),(3.1,3.1) | Thu Jan 01 00:00:00 1970 | @ 1 hour 10 secs | {1,2,3,4} | {1,2,3,4} | {1,2,3,4}
(1 row)

CREATE INDEX attmp_idx ON attmp (a, (d + e), b);
ALTER INDEX attmp_idx ALTER COLUMN 0 SET STATISTICS 1000;
ERROR:  column number must be in range from 1 to 32767
LINE 1: ALTER INDEX attmp_idx ALTER COLUMN 0 SET STATISTICS 1000;
                                           ^
ALTER INDEX attmp_idx ALTER COLUMN 1 SET STATISTICS 1000;
ERROR:  cannot alter statistics on non-expression column "a" of index "attmp_idx"
HINT:  Alter statistics on table column instead.
ALTER INDEX attmp_idx ALTER COLUMN 2 SET STATISTICS 1000;
\d+ attmp_idx
                        Index "public.attmp_idx"
 Column |       Type       | Key? | Definition | Storage | Stats target
--------+------------------+------+------------+---------+--------------
 a      | integer          | yes  | a          | plain   |
 expr   | double precision | yes  | (d + e)    | plain   | 1000
 b      | name             | yes  | b          | plain   |
lsm, for table "public.attmp"

ALTER INDEX attmp_idx ALTER COLUMN 3 SET STATISTICS 1000;
ERROR:  cannot alter statistics on non-expression column "b" of index "attmp_idx"
HINT:  Alter statistics on table column instead.
ALTER INDEX attmp_idx ALTER COLUMN 4 SET STATISTICS 1000;
ERROR:  column number 4 of relation "attmp_idx" does not exist
ALTER INDEX attmp_idx ALTER COLUMN 2 SET STATISTICS -1;
DROP TABLE attmp;
--
-- rename - check on both non-temp and temp tables
--
CREATE TABLE attmp (regtable int);
CREATE TEMP TABLE attmp (attmptable int);
ALTER TABLE attmp RENAME TO attmp_new;
SELECT * FROM attmp;
 regtable
----------
(0 rows)

SELECT * FROM attmp_new;
 attmptable
------------
(0 rows)

ALTER TABLE attmp RENAME TO attmp_new2;
SELECT * FROM attmp;		-- should fail
ERROR:  relation "attmp" does not exist
LINE 1: SELECT * FROM attmp;
                      ^
SELECT * FROM attmp_new;
 attmptable
------------
(0 rows)

SELECT * FROM attmp_new2;
 regtable
----------
(0 rows)

DROP TABLE attmp_new;
DROP TABLE attmp_new2;
-- check rename of partitioned tables and indexes also
CREATE TABLE part_attmp (a int primary key) partition by range (a);
CREATE TABLE part_attmp1 PARTITION OF part_attmp FOR VALUES FROM (0) TO (100);
ALTER INDEX part_attmp_pkey RENAME TO part_attmp_index;
ALTER INDEX part_attmp1_pkey RENAME TO part_attmp1_index;
ALTER TABLE part_attmp RENAME TO part_at2tmp;
ALTER TABLE part_attmp1 RENAME TO part_at2tmp1;
SET ROLE regress_alter_table_user1;
ALTER INDEX part_attmp_index RENAME TO fail;
ERROR:  must be owner of index part_attmp_index
ALTER INDEX part_attmp1_index RENAME TO fail;
ERROR:  must be owner of index part_attmp1_index
ALTER TABLE part_at2tmp RENAME TO fail;
ERROR:  must be owner of table part_at2tmp
ALTER TABLE part_at2tmp1 RENAME TO fail;
ERROR:  must be owner of table part_at2tmp1
RESET ROLE;
DROP TABLE part_at2tmp;
--
-- check renaming to a table's array type's autogenerated name
-- (the array type's name should get out of the way)
--
CREATE TABLE attmp_array (id int);
CREATE TABLE attmp_array2 (id int);
SELECT typname FROM pg_type WHERE oid = 'attmp_array[]'::regtype;
   typname    
--------------
 _attmp_array
(1 row)

SELECT typname FROM pg_type WHERE oid = 'attmp_array2[]'::regtype;
    typname    
---------------
 _attmp_array2
(1 row)

ALTER TABLE attmp_array2 RENAME TO _attmp_array;
SELECT typname FROM pg_type WHERE oid = 'attmp_array[]'::regtype;
    typname    
---------------
 __attmp_array
(1 row)

SELECT typname FROM pg_type WHERE oid = '_attmp_array[]'::regtype;
    typname     
----------------
 ___attmp_array
(1 row)

DROP TABLE _attmp_array;
DROP TABLE attmp_array;
-- renaming to table's own array type's name is an interesting corner case
CREATE TABLE attmp_array (id int);
SELECT typname FROM pg_type WHERE oid = 'attmp_array[]'::regtype;
   typname    
--------------
 _attmp_array
(1 row)

ALTER TABLE attmp_array RENAME TO _attmp_array;
SELECT typname FROM pg_type WHERE oid = '_attmp_array[]'::regtype;
    typname    
---------------
 __attmp_array
(1 row)

DROP TABLE _attmp_array;
-- ALTER TABLE ... RENAME on non-table relations
-- renaming indexes (FIXME: this should probably test the index's functionality)
ALTER INDEX IF EXISTS __onek_unique1 RENAME TO attmp_onek_unique1;
NOTICE:  relation "__onek_unique1" does not exist, skipping
ALTER INDEX IF EXISTS __attmp_onek_unique1 RENAME TO onek_unique1;
NOTICE:  relation "__attmp_onek_unique1" does not exist, skipping
ALTER INDEX onek_unique1 RENAME TO attmp_onek_unique1;
ALTER INDEX attmp_onek_unique1 RENAME TO onek_unique1;
SET ROLE regress_alter_table_user1;
ALTER INDEX onek_unique1 RENAME TO fail;  -- permission denied
ERROR:  must be owner of index onek_unique1
RESET ROLE;
-- renaming index should rename constraint as well
ALTER TABLE onek ADD CONSTRAINT onek_unique1_constraint UNIQUE (unique1);
ALTER INDEX onek_unique1_constraint RENAME TO onek_unique1_constraint_foo;
ALTER TABLE onek DROP CONSTRAINT onek_unique1_constraint_foo;
-- renaming constraint
ALTER TABLE onek ADD CONSTRAINT onek_check_constraint CHECK (unique1 >= 0);
ALTER TABLE onek RENAME CONSTRAINT onek_check_constraint TO onek_check_constraint_foo;
ALTER TABLE onek DROP CONSTRAINT onek_check_constraint_foo;
-- renaming constraint should rename index as well
ALTER TABLE onek ADD CONSTRAINT onek_unique1_constraint UNIQUE (unique1);
DROP INDEX onek_unique1_constraint;  -- to see whether it's there
ERROR:  cannot drop index onek_unique1_constraint because constraint onek_unique1_constraint on table onek requires it
HINT:  You can drop constraint onek_unique1_constraint on table onek instead.
ALTER TABLE onek RENAME CONSTRAINT onek_unique1_constraint TO onek_unique1_constraint_foo;
DROP INDEX onek_unique1_constraint_foo;  -- to see whether it's there
ERROR:  cannot drop index onek_unique1_constraint_foo because constraint onek_unique1_constraint_foo on table onek requires it
HINT:  You can drop constraint onek_unique1_constraint_foo on table onek instead.
ALTER TABLE onek DROP CONSTRAINT onek_unique1_constraint_foo;
-- renaming constraints vs. inheritance
CREATE TABLE constraint_rename_test (a int CONSTRAINT con1 CHECK (a > 0), b int, c int);
\d constraint_rename_test
       Table "public.constraint_rename_test"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 a      | integer |           |          |
 b      | integer |           |          |
 c      | integer |           |          |
Check constraints:
    "con1" CHECK (a > 0)

CREATE TABLE constraint_rename_test2 (a int CONSTRAINT con1 CHECK (a > 0), d int) INHERITS (constraint_rename_test);
ERROR:  INHERITS not supported yet
LINE 1: ...est2 (a int CONSTRAINT con1 CHECK (a > 0), d int) INHERITS (...
                                                             ^
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/1129. React with thumbs up to raise its priority
/*
TODO: Uncomment when inheritance is supported (https://github.com/yugabyte/yugabyte-db/issues/1129).
\d constraint_rename_test2
ALTER TABLE constraint_rename_test2 RENAME CONSTRAINT con1 TO con1foo; -- fail
ALTER TABLE ONLY constraint_rename_test RENAME CONSTRAINT con1 TO con1foo; -- fail
ALTER TABLE constraint_rename_test RENAME CONSTRAINT con1 TO con1foo; -- ok
\d constraint_rename_test
\d constraint_rename_test2
ALTER TABLE constraint_rename_test ADD CONSTRAINT con2 CHECK (b > 0) NO INHERIT;
ALTER TABLE ONLY constraint_rename_test RENAME CONSTRAINT con2 TO con2foo; -- ok
ALTER TABLE constraint_rename_test RENAME CONSTRAINT con2foo TO con2bar; -- ok
\d constraint_rename_test
\d constraint_rename_test2
ALTER TABLE constraint_rename_test ADD CONSTRAINT con3 PRIMARY KEY (a);
ALTER TABLE constraint_rename_test RENAME CONSTRAINT con3 TO con3foo; -- ok
\d constraint_rename_test
\d constraint_rename_test2
DROP TABLE constraint_rename_test2;
DROP TABLE constraint_rename_test;
ALTER TABLE IF EXISTS constraint_not_exist RENAME CONSTRAINT con3 TO con3foo; -- ok
ALTER TABLE IF EXISTS constraint_rename_test ADD CONSTRAINT con4 UNIQUE (a);
*/
-- renaming constraints with cache reset of target relation
CREATE TABLE constraint_rename_cache (a int,
  CONSTRAINT chk_a CHECK (a > 0),
  PRIMARY KEY (a));
ALTER TABLE constraint_rename_cache
  RENAME CONSTRAINT chk_a TO chk_a_new;
ALTER TABLE constraint_rename_cache
  RENAME CONSTRAINT constraint_rename_cache_pkey TO constraint_rename_pkey_new;
CREATE TABLE like_constraint_rename_cache
  (LIKE constraint_rename_cache INCLUDING ALL);
\d like_constraint_rename_cache
    Table "public.like_constraint_rename_cache"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 a      | integer |           | not null |
Indexes:
    "like_constraint_rename_cache_pkey" PRIMARY KEY, lsm (a ASC)
Check constraints:
    "chk_a_new" CHECK (a > 0)

DROP TABLE constraint_rename_cache;
DROP TABLE like_constraint_rename_cache;
-- FOREIGN KEY CONSTRAINT adding TEST
CREATE TABLE attmp2 (a int primary key);
CREATE TABLE attmp3 (a int, b int);
CREATE TABLE attmp4 (a int, b int, unique(a,b));
CREATE TABLE attmp5 (a int, b int);
-- Insert rows into attmp2 (pktable)
INSERT INTO attmp2 values (1);
INSERT INTO attmp2 values (2);
INSERT INTO attmp2 values (3);
INSERT INTO attmp2 values (4);
-- Insert rows into attmp3
INSERT INTO attmp3 values (1,10);
INSERT INTO attmp3 values (1,20);
INSERT INTO attmp3 values (5,50);
-- Try (and fail) to add constraint due to invalid source columns
ALTER TABLE attmp3 add constraint attmpconstr foreign key(c) references attmp2 match full;
ERROR:  column "c" referenced in foreign key constraint does not exist
-- Try (and fail) to add constraint due to invalid destination columns explicitly given
ALTER TABLE attmp3 add constraint attmpconstr foreign key(a) references attmp2(b) match full;
ERROR:  column "b" referenced in foreign key constraint does not exist
-- Try (and fail) to add constraint due to invalid data
ALTER TABLE attmp3 add constraint attmpconstr foreign key (a) references attmp2 match full;
ERROR:  insert or update on table "attmp3" violates foreign key constraint "attmpconstr"
DETAIL:  Key (a)=(5) is not present in table "attmp2".
-- Delete failing row
DELETE FROM attmp3 where a=5;
-- Try (and succeed)
ALTER TABLE attmp3 add constraint attmpconstr foreign key (a) references attmp2 match full;
ALTER TABLE attmp3 drop constraint attmpconstr;
INSERT INTO attmp3 values (5,50);
-- Try NOT VALID and then VALIDATE CONSTRAINT, but fails. Delete failure then re-validate
ALTER TABLE attmp3 add constraint attmpconstr foreign key (a) references attmp2 match full NOT VALID;
ALTER TABLE attmp3 validate constraint attmpconstr;
ERROR:  insert or update on table "attmp3" violates foreign key constraint "attmpconstr"
DETAIL:  Key (a)=(5) is not present in table "attmp2".
-- Delete failing row
DELETE FROM attmp3 where a=5;
-- Try (and succeed) and repeat to show it works on already valid constraint
ALTER TABLE attmp3 validate constraint attmpconstr;
ALTER TABLE attmp3 validate constraint attmpconstr;
-- Try a non-verified CHECK constraint
ALTER TABLE attmp3 ADD CONSTRAINT b_greater_than_ten CHECK (b > 10); -- fail
ERROR:  check constraint "b_greater_than_ten" of relation "attmp3" is violated by some row
ALTER TABLE attmp3 ADD CONSTRAINT b_greater_than_ten CHECK (b > 10) NOT VALID; -- succeeds
ALTER TABLE attmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- fails
ERROR:  check constraint "b_greater_than_ten" of relation "attmp3" is violated by some row
DELETE FROM attmp3 WHERE NOT b > 10;
ALTER TABLE attmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- succeeds
ALTER TABLE attmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- succeeds
-- test inheritance
create table renameColumn (a int);
create table renameColumnChild (b int) inherits (renameColumn);
ERROR:  INHERITS not supported yet
LINE 1: create table renameColumnChild (b int) inherits (renameColum...
                                               ^
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/1129. React with thumbs up to raise its priority
/* YB: uncomment when INHERITS is supported
create table renameColumnAnother (c int) inherits (renameColumnChild);

-- these three should fail
alter table renameColumnChild rename column a to d;
alter table only renameColumnChild rename column a to d;
alter table only renameColumn rename column a to d;
*/ -- YB
-- these should work
alter table renameColumn rename column a to d;
/* YB: uncomment when INHERITS is supported
alter table renameColumnChild rename column b to a;
*/ -- YB
-- these should work
alter table if exists doesnt_exist_tab rename column a to d;
NOTICE:  relation "doesnt_exist_tab" does not exist, skipping
alter table if exists doesnt_exist_tab rename column b to a;
NOTICE:  relation "doesnt_exist_tab" does not exist, skipping
-- this should work
alter table renameColumn add column w int;
--
-- lock levels
--
drop type lockmodes;
ERROR:  type "lockmodes" does not exist
create type lockmodes as enum (
 'SIReadLock'
,'AccessShareLock'
,'RowShareLock'
,'RowExclusiveLock'
,'ShareUpdateExclusiveLock'
,'ShareLock'
,'ShareRowExclusiveLock'
,'ExclusiveLock'
,'AccessExclusiveLock'
);
drop view my_locks;
ERROR:  view "my_locks" does not exist
create or replace view my_locks as
select case when c.relname like 'pg_toast%' then 'pg_toast' else c.relname end, max(mode::lockmodes) as max_lockmode
from pg_locks l join pg_class c on l.relation = c.oid
where virtualtransaction = (
        select virtualtransaction
        from pg_locks)
and locktype = 'relation'
and relnamespace != (select oid from pg_namespace where nspname = 'pg_catalog')
and c.relname != 'my_locks'
group by c.relname;
create table alterlock (f1 int primary key, f2 text);
insert into alterlock values (1, 'foo');
create table alterlock2 (f3 int primary key, f1 int);
insert into alterlock2 values (1, 1);
begin; alter table alterlock alter column f2 set statistics 150;
select * from my_locks order by 1;
 relname | max_lockmode
---------+--------------
(0 rows)

rollback;
begin; alter table alterlock cluster on alterlock_pkey;
ERROR:  ALTER action CLUSTER ON not supported yet
LINE 1: alter table alterlock cluster on alterlock_pkey;
                              ^
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/1124. React with thumbs up to raise its priority
select * from my_locks order by 1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
commit;
begin; alter table alterlock set without cluster;
ERROR:  ALTER action SET WITHOUT CLUSTER not supported yet
LINE 1: alter table alterlock set without cluster;
                              ^
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/1124. React with thumbs up to raise its priority
select * from my_locks order by 1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
commit;
begin; alter table alterlock set (fillfactor = 100);
NOTICE:  storage parameters are currently ignored in YugabyteDB
select * from my_locks order by 1;
 relname | max_lockmode
---------+--------------
(0 rows)

commit;
begin; alter table alterlock reset (fillfactor);
NOTICE:  storage parameters are currently ignored in YugabyteDB
select * from my_locks order by 1;
 relname | max_lockmode
---------+--------------
(0 rows)

commit;
begin; alter table alterlock set (toast.autovacuum_enabled = off);
NOTICE:  storage parameters are currently ignored in YugabyteDB
select * from my_locks order by 1;
 relname | max_lockmode
---------+--------------
(0 rows)

commit;
begin; alter table alterlock set (autovacuum_enabled = off);
NOTICE:  storage parameters are currently ignored in YugabyteDB
select * from my_locks order by 1;
 relname | max_lockmode
---------+--------------
(0 rows)

commit;
begin; alter table alterlock alter column f2 set (n_distinct = 1);
ERROR:  ALTER action ALTER COLUMN ... SET not supported yet
LINE 1: alter table alterlock alter column f2 set (n_distinct = 1);
                              ^
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/1124. React with thumbs up to raise its priority
select * from my_locks order by 1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
rollback;
-- test that mixing options with different lock levels works as expected
begin; alter table alterlock set (autovacuum_enabled = off, fillfactor = 80);
NOTICE:  storage parameters are currently ignored in YugabyteDB
select * from my_locks order by 1;
 relname | max_lockmode
---------+--------------
(0 rows)

commit;
begin; alter table alterlock alter column f2 set storage extended;
ERROR:  ALTER action ALTER COLUMN ... SET STORAGE not supported yet
LINE 1: alter table alterlock alter column f2 set storage extended;
                              ^
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/1124. React with thumbs up to raise its priority
select * from my_locks order by 1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
rollback;
-- TODO(jason): uncomment when doing issue #9106
-- begin; alter table alterlock alter column f2 set default 'x';
-- select * from my_locks order by 1;
-- rollback;
--
-- alter object set schema
--
create schema alter1;
create schema alter2;
create table alter1.t1(f1 serial primary key, f2 int check (f2 > 0));
create text search parser alter1.prs(start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype);
create text search configuration alter1.cfg(parser = alter1.prs);
alter table alter1.t1 set schema alter1; -- no-op, same schema
alter table alter1.t1 set schema alter2;
alter text search parser alter1.prs set schema alter2;
alter text search configuration alter1.cfg set schema alter2;
-- clean up
drop schema alter2 cascade;
NOTICE:  drop cascades to 3 other objects
DETAIL:  drop cascades to table alter2.t1
drop cascades to text search configuration alter2.cfg
drop cascades to text search parser alter2.prs
--
-- typed tables: OF / NOT OF
--
CREATE TYPE tt_t0 AS (z inet, x int, y numeric(8,2));
ALTER TYPE tt_t0 DROP ATTRIBUTE z;
ERROR:  ALTER TYPE DROP ATTRIBUTE not supported yet
LINE 1: ALTER TYPE tt_t0 DROP ATTRIBUTE z;
                         ^
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/1893. React with thumbs up to raise its priority
-- YB: since we can't ALTER TYPE yet, work around by recreating the type.
DROP TYPE tt_t0;
CREATE TYPE tt_t0 AS (x int, y numeric(8,2));
CREATE TABLE tt0 (x int NOT NULL, y numeric(8,2));	-- OK
CREATE TABLE tt1 (x int, y bigint);					-- wrong base type
CREATE TABLE tt2 (x int, y numeric(9,2));			-- wrong typmod
CREATE TABLE tt3 (y numeric(8,2), x int);			-- wrong column order
CREATE TABLE tt4 (x int);							-- too few columns
CREATE TABLE tt5 (x int, y numeric(8,2), z int);	-- too few columns
CREATE TABLE tt6 () INHERITS (tt0);					-- can't have a parent
ERROR:  INHERITS not supported yet
LINE 1: CREATE TABLE tt6 () INHERITS (tt0);
                            ^
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/1129. React with thumbs up to raise its priority
CREATE TABLE tt7 (x int, q text, y numeric(8,2));
ALTER TABLE tt7 DROP q;								-- OK
ALTER TABLE tt0 OF tt_t0;
ALTER TABLE tt1 OF tt_t0;
ERROR:  table "tt1" has different type for column "y"
ALTER TABLE tt2 OF tt_t0;
ERROR:  table "tt2" has different type for column "y"
ALTER TABLE tt3 OF tt_t0;
ERROR:  table has column "y" where type requires "x"
ALTER TABLE tt4 OF tt_t0;
ERROR:  table is missing column "y"
ALTER TABLE tt5 OF tt_t0;
ERROR:  table has extra column "z"
ALTER TABLE tt6 OF tt_t0;
ERROR:  relation "tt6" does not exist
ALTER TABLE tt7 OF tt_t0;
CREATE TYPE tt_t1 AS (x int, y numeric(8,2));
ALTER TABLE tt7 OF tt_t1;			-- reassign an already-typed table
ALTER TABLE tt7 NOT OF;
\d tt7
                   Table "public.tt7"
 Column |     Type     | Collation | Nullable | Default 
--------+--------------+-----------+----------+---------
 x      | integer      |           |          | 
 y      | numeric(8,2) |           |          | 

--
-- ATTACH PARTITION
--
-- check that target table is partitioned
CREATE TABLE unparted (
	a int
);
CREATE TABLE fail_part (like unparted);
ALTER TABLE unparted ATTACH PARTITION fail_part FOR VALUES IN ('a');
ERROR:  table "unparted" is not partitioned
DROP TABLE unparted, fail_part;
-- check that partition bound is compatible
CREATE TABLE list_parted (
	a int NOT NULL,
	b char(2) COLLATE "C",
	CONSTRAINT check_a CHECK (a > 0)
) PARTITION BY LIST (a);
CREATE TABLE fail_part (LIKE list_parted);
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES FROM (1) TO (10);
ERROR:  invalid bound specification for a list partition
LINE 1: ...list_parted ATTACH PARTITION fail_part FOR VALUES FROM (1) T...
                                                             ^
DROP TABLE fail_part;
-- check that the table being attached exists
ALTER TABLE list_parted ATTACH PARTITION nonexistent FOR VALUES IN (1);
ERROR:  relation "nonexistent" does not exist
-- check ownership of the source table
CREATE ROLE regress_test_me;
CREATE ROLE regress_test_not_me;
CREATE TABLE not_owned_by_me (LIKE list_parted);
ALTER TABLE not_owned_by_me OWNER TO regress_test_not_me;
SET SESSION AUTHORIZATION regress_test_me;
CREATE TABLE owned_by_me (
	a int
) PARTITION BY LIST (a);
ALTER TABLE owned_by_me ATTACH PARTITION not_owned_by_me FOR VALUES IN (1);
ERROR:  must be owner of table not_owned_by_me
RESET SESSION AUTHORIZATION;
DROP TABLE owned_by_me, not_owned_by_me;
DROP ROLE regress_test_not_me;
DROP ROLE regress_test_me;
-- check that the table being attached is not part of regular inheritance
CREATE TABLE parent (LIKE list_parted);
CREATE TABLE child () INHERITS (parent);
ERROR:  INHERITS not supported yet
LINE 1: CREATE TABLE child () INHERITS (parent);
                              ^
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/1129. React with thumbs up to raise its priority
-- Uncomment the following when INHERITS is supported #5956.
/*
ALTER TABLE list_parted ATTACH PARTITION child FOR VALUES IN (1);
ALTER TABLE list_parted ATTACH PARTITION parent FOR VALUES IN (1);
*/
DROP TABLE parent CASCADE;
-- check any TEMP-ness
CREATE TEMP TABLE temp_parted (a int) PARTITION BY LIST (a);
CREATE TABLE perm_part (a int);
ALTER TABLE temp_parted ATTACH PARTITION perm_part FOR VALUES IN (1);
ERROR:  cannot attach a permanent relation as partition of temporary relation "temp_parted"
DROP TABLE temp_parted, perm_part;
-- check that the table being attached is not a typed table
CREATE TYPE mytype AS (a int);
CREATE TABLE fail_part OF mytype;
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
ERROR:  cannot attach a typed table as partition
DROP TYPE mytype CASCADE;
NOTICE:  drop cascades to table fail_part
-- check that the table being attached has only columns present in the parent
CREATE TABLE fail_part (like list_parted, c int);
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
ERROR:  table "fail_part" contains column "c" not found in parent "list_parted"
DETAIL:  The new partition may contain only the columns present in parent.
DROP TABLE fail_part;
-- check that the table being attached has every column of the parent
CREATE TABLE fail_part (a int NOT NULL);
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
ERROR:  child table is missing column "b"
DROP TABLE fail_part;
-- check that columns match in type, collation and NOT NULL status
CREATE TABLE fail_part (
	b char(3),
	a int NOT NULL
);
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
ERROR:  child table "fail_part" has different type for column "b"
ALTER TABLE fail_part ALTER b TYPE char (2) COLLATE "POSIX";
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
-- Uncomment when ALTER TABLE COLLATE is supported (#1013)
-- ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
DROP TABLE fail_part;
-- check that the table being attached has all constraints of the parent
CREATE TABLE fail_part (
	b char(2) COLLATE "C",
	a int NOT NULL
);
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
ERROR:  child table is missing constraint "check_a"
-- check that the constraint matches in definition with parent's constraint
ALTER TABLE fail_part ADD CONSTRAINT check_a CHECK (a >= 0);
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
ERROR:  child table "fail_part" has different definition for check constraint "check_a"
DROP TABLE fail_part;
-- check the attributes and constraints after partition is attached
CREATE TABLE part_1 (
	a int NOT NULL,
	b char(2) COLLATE "C",
	CONSTRAINT check_a CHECK (a > 0)
);
ALTER TABLE list_parted ATTACH PARTITION part_1 FOR VALUES IN (1);
-- attislocal and conislocal are always false for merged attributes and constraints respectively.
SELECT attislocal, attinhcount FROM pg_attribute WHERE attrelid = 'part_1'::regclass AND attnum > 0;
 attislocal | attinhcount
------------+-------------
 f          |           1
 f          |           1
(2 rows)

SELECT conislocal, coninhcount FROM pg_constraint WHERE conrelid = 'part_1'::regclass AND conname = 'check_a';
 conislocal | coninhcount
------------+-------------
 f          |           1
(1 row)

-- check that the new partition won't overlap with an existing partition
CREATE TABLE fail_part (LIKE part_1 INCLUDING CONSTRAINTS);
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
ERROR:  partition "fail_part" would overlap partition "part_1"
LINE 1: ...LE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
                                                                    ^
DROP TABLE fail_part;
-- check that an existing table can be attached as a default partition
CREATE TABLE def_part (LIKE list_parted INCLUDING CONSTRAINTS);
ALTER TABLE list_parted ATTACH PARTITION def_part DEFAULT;
-- check attaching default partition fails if a default partition already
-- exists
CREATE TABLE fail_def_part (LIKE part_1 INCLUDING CONSTRAINTS);
ALTER TABLE list_parted ATTACH PARTITION fail_def_part DEFAULT;
ERROR:  partition "fail_def_part" conflicts with existing default partition "def_part"
LINE 1: ...ER TABLE list_parted ATTACH PARTITION fail_def_part DEFAULT;
                                                               ^
-- check validation when attaching list partitions
CREATE TABLE list_parted2 (
	a int,
	b char
) PARTITION BY LIST (a);
-- check that violating rows are correctly reported
CREATE TABLE part_2 (LIKE list_parted2);
INSERT INTO part_2 VALUES (3, 'a');
ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2);
ERROR:  partition constraint of relation "part_2" is violated by some row
-- should be ok after deleting the bad row
DELETE FROM part_2;
ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2);
-- check partition cannot be attached if default has some row for its values
CREATE TABLE list_parted2_def PARTITION OF list_parted2 DEFAULT;
INSERT INTO list_parted2_def VALUES (11, 'z');
CREATE TABLE part_3 (LIKE list_parted2);
ALTER TABLE list_parted2 ATTACH PARTITION part_3 FOR VALUES IN (11);
ERROR:  updated partition constraint for default partition "list_parted2_def" would be violated by some row
-- should be ok after deleting the bad row
DELETE FROM list_parted2_def WHERE a = 11;
ALTER TABLE list_parted2 ATTACH PARTITION part_3 FOR VALUES IN (11);
-- adding constraints that describe the desired partition constraint
-- (or more restrictive) will help skip the validation scan
CREATE TABLE part_3_4 (
	LIKE list_parted2,
	CONSTRAINT check_a CHECK (a IN (3))
);
-- however, if a list partition does not accept nulls, there should be
-- an explicit NOT NULL constraint on the partition key column for the
-- validation scan to be skipped;
ALTER TABLE list_parted2 ATTACH PARTITION part_3_4 FOR VALUES IN (3, 4);
-- adding a NOT NULL constraint will cause the scan to be skipped
ALTER TABLE list_parted2 DETACH PARTITION part_3_4;
ALTER TABLE part_3_4 ALTER a SET NOT NULL;
ALTER TABLE list_parted2 ATTACH PARTITION part_3_4 FOR VALUES IN (3, 4);
-- check if default partition scan skipped
ALTER TABLE list_parted2_def ADD CONSTRAINT check_a CHECK (a IN (5, 6));
CREATE TABLE part_55_66 PARTITION OF list_parted2 FOR VALUES IN (55, 66);
-- check validation when attaching range partitions
CREATE TABLE range_parted (
	a int,
	b int
) PARTITION BY RANGE (a, b);
-- check that violating rows are correctly reported
CREATE TABLE part1 (
	a int NOT NULL CHECK (a = 1),
	b int NOT NULL CHECK (b >= 1 AND b <= 10)
);
INSERT INTO part1 VALUES (1, 10);
-- Remember the TO bound is exclusive
ALTER TABLE range_parted ATTACH PARTITION part1 FOR VALUES FROM (1, 1) TO (1, 10);
ERROR:  partition constraint of relation "part1" is violated by some row
-- should be ok after deleting the bad row
DELETE FROM part1;
ALTER TABLE range_parted ATTACH PARTITION part1 FOR VALUES FROM (1, 1) TO (1, 10);
-- adding constraints that describe the desired partition constraint
-- (or more restrictive) will help skip the validation scan
CREATE TABLE part2 (
	a int NOT NULL CHECK (a = 1),
	b int NOT NULL CHECK (b >= 10 AND b < 18)
);
ALTER TABLE range_parted ATTACH PARTITION part2 FOR VALUES FROM (1, 10) TO (1, 20);
-- Create default partition
CREATE TABLE partr_def1 PARTITION OF range_parted DEFAULT;
-- Only one default partition is allowed, hence, following should give error
CREATE TABLE partr_def2 (LIKE part1 INCLUDING CONSTRAINTS);
ALTER TABLE range_parted ATTACH PARTITION partr_def2 DEFAULT;
ERROR:  partition "partr_def2" conflicts with existing default partition "partr_def1"
LINE 1: ...LTER TABLE range_parted ATTACH PARTITION partr_def2 DEFAULT;
                                                               ^
-- Overlapping partitions cannot be attached, hence, following should give error
INSERT INTO partr_def1 VALUES (2, 10);
CREATE TABLE part3 (LIKE range_parted);
ALTER TABLE range_parted ATTACH partition part3 FOR VALUES FROM (2, 10) TO (2, 20);
ERROR:  updated partition constraint for default partition "partr_def1" would be violated by some row
-- Attaching partitions should be successful when there are no overlapping rows
ALTER TABLE range_parted ATTACH partition part3 FOR VALUES FROM (3, 10) TO (3, 20);
-- check that leaf partitions are scanned when attaching a partitioned
-- table
CREATE TABLE part_5 (
	LIKE list_parted2
) PARTITION BY LIST (b);
-- check that violating rows are correctly reported
CREATE TABLE part_5_a PARTITION OF part_5 FOR VALUES IN ('a');
INSERT INTO part_5_a (a, b) VALUES (6, 'a');
ALTER TABLE list_parted2 ATTACH PARTITION part_5 FOR VALUES IN (5);
ERROR:  partition constraint of relation "part_5_a" is violated by some row
-- delete the faulting row and also add a constraint to skip the scan
DELETE FROM part_5_a WHERE a NOT IN (3);
ALTER TABLE part_5 ADD CONSTRAINT check_a CHECK (a IS NOT NULL AND a = 5);
ALTER TABLE list_parted2 ATTACH PARTITION part_5 FOR VALUES IN (5);
ALTER TABLE list_parted2 DETACH PARTITION part_5;
ALTER TABLE part_5 DROP CONSTRAINT check_a;
-- scan should again be skipped, even though NOT NULL is now a column property
ALTER TABLE part_5 ADD CONSTRAINT check_a CHECK (a IN (5)), ALTER a SET NOT NULL;
ALTER TABLE list_parted2 ATTACH PARTITION part_5 FOR VALUES IN (5);
-- Check the case where attnos of the partitioning columns in the table being
-- attached differs from the parent.  It should not affect the constraint-
-- checking logic that allows to skip the scan.
CREATE TABLE part_6 (
	c int,
	LIKE list_parted2,
	CONSTRAINT check_a CHECK (a IS NOT NULL AND a = 6)
);
ALTER TABLE part_6 DROP c;
ALTER TABLE list_parted2 ATTACH PARTITION part_6 FOR VALUES IN (6);
-- Similar to above, but the table being attached is a partitioned table
-- whose partition has still different attnos for the root partitioning
-- columns.
CREATE TABLE part_7 (
	LIKE list_parted2,
	CONSTRAINT check_a CHECK (a IS NOT NULL AND a = 7)
) PARTITION BY LIST (b);
CREATE TABLE part_7_a_null (
	c int,
	d int,
	e int,
	LIKE list_parted2,  -- 'a' will have attnum = 4
	CONSTRAINT check_b CHECK (b IS NULL OR b = 'a'),
	CONSTRAINT check_a CHECK (a IS NOT NULL AND a = 7)
);
ALTER TABLE part_7_a_null DROP c, DROP d, DROP e;
ALTER TABLE part_7 ATTACH PARTITION part_7_a_null FOR VALUES IN ('a', null);
ALTER TABLE list_parted2 ATTACH PARTITION part_7 FOR VALUES IN (7);
-- Same example, but check this time that the constraint correctly detects
-- violating rows
ALTER TABLE list_parted2 DETACH PARTITION part_7;
ALTER TABLE part_7 DROP CONSTRAINT check_a; -- thusly, scan won't be skipped
INSERT INTO part_7 (a, b) VALUES (8, null), (9, 'a');
SELECT tableoid::regclass, a, b FROM part_7 order by a;
   tableoid    | a | b
---------------+---+---
 part_7_a_null | 8 |
 part_7_a_null | 9 | a
(2 rows)

ALTER TABLE list_parted2 ATTACH PARTITION part_7 FOR VALUES IN (7);
ERROR:  partition constraint of relation "part_7_a_null" is violated by some row
-- check that leaf partitions of default partition are scanned when
-- attaching a partitioned table.
ALTER TABLE part_5 DROP CONSTRAINT check_a;
CREATE TABLE part5_def PARTITION OF part_5 DEFAULT PARTITION BY LIST(a);
CREATE TABLE part5_def_p1 PARTITION OF part5_def FOR VALUES IN (5);
INSERT INTO part5_def_p1 VALUES (5, 'y');
CREATE TABLE part5_p1 (LIKE part_5);
ALTER TABLE part_5 ATTACH PARTITION part5_p1 FOR VALUES IN ('y');
ERROR:  updated partition constraint for default partition "part5_def_p1" would be violated by some row
-- should be ok after deleting the bad row
DELETE FROM part5_def_p1 WHERE b = 'y';
ALTER TABLE part_5 ATTACH PARTITION part5_p1 FOR VALUES IN ('y');
-- check that the table being attached is not already a partition
ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2);
ERROR:  "part_2" is already a partition
-- check that circular inheritance is not allowed
ALTER TABLE part_5 ATTACH PARTITION list_parted2 FOR VALUES IN ('b');
ERROR:  circular inheritance not allowed
DETAIL:  "part_5" is already a child of "list_parted2".
ALTER TABLE list_parted2 ATTACH PARTITION list_parted2 FOR VALUES IN (0);
ERROR:  circular inheritance not allowed
DETAIL:  "list_parted2" is already a child of "list_parted2".
-- If a partitioned table being created or an existing table being attached
-- as a partition does not have a constraint that would allow validation scan
-- to be skipped, but an individual partition does, then the partition's
-- validation scan is skipped.
CREATE TABLE quuux (a int, b text) PARTITION BY LIST (a);
CREATE TABLE quuux_default PARTITION OF quuux DEFAULT PARTITION BY LIST (b);
CREATE TABLE quuux_default1 PARTITION OF quuux_default (
	CONSTRAINT check_1 CHECK (a IS NOT NULL AND a = 1)
) FOR VALUES IN ('b');
CREATE TABLE quuux1 (a int, b text);
ALTER TABLE quuux ATTACH PARTITION quuux1 FOR VALUES IN (1); -- validate!
CREATE TABLE quuux2 (a int, b text);
ALTER TABLE quuux ATTACH PARTITION quuux2 FOR VALUES IN (2); -- skip validation
DROP TABLE quuux1, quuux2;
-- should validate for quuux1, but not for quuux2
CREATE TABLE quuux1 PARTITION OF quuux FOR VALUES IN (1);
CREATE TABLE quuux2 PARTITION OF quuux FOR VALUES IN (2);
DROP TABLE quuux;
-- check validation when attaching hash partitions
-- Use hand-rolled hash functions and operator class to get predictable result
-- on different machines. part_test_int4_ops is defined in insert.sql.
-- check that the new partition won't overlap with an existing partition
CREATE TABLE hash_parted (
	a int,
	b int
) PARTITION BY HASH (a part_test_int4_ops);
CREATE TABLE hpart_1 PARTITION OF hash_parted FOR VALUES WITH (MODULUS 4, REMAINDER 0);
CREATE TABLE fail_part (LIKE hpart_1);
ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 8, REMAINDER 4);
ERROR:  partition "fail_part" would overlap partition "hpart_1"
LINE 1: ...hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODU...
                                                             ^
ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 8, REMAINDER 0);
ERROR:  partition "fail_part" would overlap partition "hpart_1"
LINE 1: ...hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODU...
                                                             ^
DROP TABLE fail_part;
-- check validation when attaching hash partitions
-- check that violating rows are correctly reported
CREATE TABLE hpart_2 (LIKE hash_parted);
INSERT INTO hpart_2 VALUES (3, 0);
ALTER TABLE hash_parted ATTACH PARTITION hpart_2 FOR VALUES WITH (MODULUS 4, REMAINDER 1);
ERROR:  partition constraint of relation "hpart_2" is violated by some row
-- should be ok after deleting the bad row
DELETE FROM hpart_2;
ALTER TABLE hash_parted ATTACH PARTITION hpart_2 FOR VALUES WITH (MODULUS 4, REMAINDER 1);
-- check that leaf partitions are scanned when attaching a partitioned
-- table
CREATE TABLE hpart_5 (
	LIKE hash_parted
) PARTITION BY LIST (b);
-- check that violating rows are correctly reported
CREATE TABLE hpart_5_a PARTITION OF hpart_5 FOR VALUES IN ('1', '2', '3');
INSERT INTO hpart_5_a (a, b) VALUES (7, 1);
ALTER TABLE hash_parted ATTACH PARTITION hpart_5 FOR VALUES WITH (MODULUS 4, REMAINDER 2);
ERROR:  partition constraint of relation "hpart_5_a" is violated by some row
-- should be ok after deleting the bad row
DELETE FROM hpart_5_a;
ALTER TABLE hash_parted ATTACH PARTITION hpart_5 FOR VALUES WITH (MODULUS 4, REMAINDER 2);
-- check that the table being attach is with valid modulus and remainder value
CREATE TABLE fail_part(LIKE hash_parted);
ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 0, REMAINDER 1);
ERROR:  modulus for hash partition must be an integer value greater than zero
ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 8, REMAINDER 8);
ERROR:  remainder for hash partition must be less than modulus
ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 3, REMAINDER 2);
ERROR:  every hash partition modulus must be a factor of the next larger modulus
DETAIL:  The new modulus 3 is not a factor of 4, the modulus of existing partition "hpart_1".
DROP TABLE fail_part;
--
-- DETACH PARTITION
--
-- check that the table is partitioned at all
CREATE TABLE regular_table (a int);
-- YB note: upstream PG shows a different error message because YB hits this
-- one first in a YB codepath (see ATRewriteCatalogs, YBCPrepareAlterTable,
-- ATExecCmd).
ALTER TABLE regular_table DETACH PARTITION any_name;
ERROR:  relation "any_name" does not exist
DROP TABLE regular_table;
-- check that the partition being detached exists at all
ALTER TABLE list_parted2 DETACH PARTITION part_4;
ERROR:  relation "part_4" does not exist
ALTER TABLE hash_parted DETACH PARTITION hpart_4;
ERROR:  relation "hpart_4" does not exist
-- check that the partition being detached is actually a partition of the parent
CREATE TABLE not_a_part (a int);
ALTER TABLE list_parted2 DETACH PARTITION not_a_part;
ERROR:  relation "not_a_part" is not a partition of relation "list_parted2"
ALTER TABLE list_parted2 DETACH PARTITION part_1;
ERROR:  relation "part_1" is not a partition of relation "list_parted2"
ALTER TABLE hash_parted DETACH PARTITION not_a_part;
ERROR:  relation "not_a_part" is not a partition of relation "hash_parted"
DROP TABLE not_a_part;
-- check that, after being detached, attinhcount/coninhcount is dropped to 0 and
-- attislocal/conislocal is set to true
ALTER TABLE list_parted2 DETACH PARTITION part_3_4;
SELECT attinhcount, attislocal FROM pg_attribute WHERE attrelid = 'part_3_4'::regclass AND attnum > 0;
 attinhcount | attislocal
-------------+------------
           0 | t
           0 | t
(2 rows)

SELECT coninhcount, conislocal FROM pg_constraint WHERE conrelid = 'part_3_4'::regclass AND conname = 'check_a';
 coninhcount | conislocal
-------------+------------
           0 | t
(1 row)

DROP TABLE part_3_4;
-- check that a detached partition is not dropped on dropping a partitioned table
CREATE TABLE range_parted2 (
    a int
) PARTITION BY RANGE(a);
CREATE TABLE part_rp PARTITION OF range_parted2 FOR VALUES FROM (0) to (100);
ALTER TABLE range_parted2 DETACH PARTITION part_rp;
DROP TABLE range_parted2;
SELECT * from part_rp;
 a
---
(0 rows)

DROP TABLE part_rp;
-- Check ALTER TABLE commands for partitioned tables and partitions
-- cannot add/drop column to/from *only* the parent
ALTER TABLE ONLY list_parted2 ADD COLUMN c int;
ERROR:  column must be added to child tables too
ALTER TABLE ONLY list_parted2 DROP COLUMN b;
ERROR:  cannot drop column from only the partitioned table when partitions exist
HINT:  Do not specify the ONLY keyword.
-- cannot add a column to partition or drop an inherited one
ALTER TABLE part_2 ADD COLUMN c text;
ERROR:  cannot add column to a partition
ALTER TABLE part_2 DROP COLUMN b;
ERROR:  cannot drop inherited column "b"
-- Nor rename, alter type
ALTER TABLE part_2 RENAME COLUMN b to c;
ERROR:  cannot rename inherited column "b"
ALTER TABLE part_2 ALTER COLUMN b TYPE text;
ERROR:  cannot alter inherited column "b"
-- cannot add/drop NOT NULL or check constraints to *only* the parent, when
-- partitions exist
ALTER TABLE ONLY list_parted2 ALTER b SET NOT NULL;
ERROR:  constraint must be added to child tables too
DETAIL:  Column "b" of relation "part_2" is not already NOT NULL.
HINT:  Do not specify the ONLY keyword.
ALTER TABLE ONLY list_parted2 ADD CONSTRAINT check_b CHECK (b <> 'zz');
ERROR:  constraint must be added to child tables too
ALTER TABLE list_parted2 ALTER b SET NOT NULL;
ALTER TABLE ONLY list_parted2 ALTER b DROP NOT NULL;
ERROR:  cannot remove constraint from only the partitioned table when partitions exist
HINT:  Do not specify the ONLY keyword.
ALTER TABLE list_parted2 ADD CONSTRAINT check_b CHECK (b <> 'zz');
-- Uncomment when #14570 is fixed
/*
ALTER TABLE ONLY list_parted2 DROP CONSTRAINT check_b;

-- It's alright though, if no partitions are yet created
CREATE TABLE parted_no_parts (a int) PARTITION BY LIST (a);
ALTER TABLE ONLY parted_no_parts ALTER a SET NOT NULL;
ALTER TABLE ONLY parted_no_parts ADD CONSTRAINT check_a CHECK (a > 0);
ALTER TABLE ONLY parted_no_parts ALTER a DROP NOT NULL;
ALTER TABLE ONLY parted_no_parts DROP CONSTRAINT check_a;
DROP TABLE parted_no_parts;
*/
-- cannot drop inherited NOT NULL or check constraints from partition
ALTER TABLE list_parted2 ALTER b SET NOT NULL, ADD CONSTRAINT check_a2 CHECK (a > 0);
ALTER TABLE part_2 ALTER b DROP NOT NULL;
ERROR:  column "b" is marked NOT NULL in parent table
ALTER TABLE part_2 DROP CONSTRAINT check_a2;
ERROR:  cannot drop inherited constraint "check_a2" of relation "part_2"
-- Doesn't make sense to add NO INHERIT constraints on partitioned tables
ALTER TABLE list_parted2 add constraint check_b2 check (b <> 'zz') NO INHERIT;
ERROR:  cannot add NO INHERIT constraint to partitioned table "list_parted2"
-- check that a partition cannot participate in regular inheritance
CREATE TABLE inh_test () INHERITS (part_2);
ERROR:  INHERITS not supported yet
LINE 1: CREATE TABLE inh_test () INHERITS (part_2);
                                 ^
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/1129. React with thumbs up to raise its priority
-- Uncomment if INHERITS is supported (#5956).
/*
CREATE TABLE inh_test (LIKE part_2);
ALTER TABLE inh_test INHERIT part_2;
ALTER TABLE part_2 INHERIT inh_test;
*/
-- cannot drop or alter type of partition key columns of lower level
-- partitioned tables; for example, part_5, which is list_parted2's
-- partition, is partitioned on b;
ALTER TABLE list_parted2 DROP COLUMN b;
ERROR:  cannot drop column "b" because it is part of the partition key of relation "part_5"
ALTER TABLE list_parted2 ALTER COLUMN b TYPE text;
ERROR:  cannot alter column "b" because it is part of the partition key of relation "part_5"
-- dropping non-partition key columns should be allowed on the parent table.
ALTER TABLE list_parted DROP COLUMN b;
SELECT * FROM list_parted;
 a
---
(0 rows)

-- cleanup
DROP TABLE list_parted, list_parted2, range_parted;
DROP TABLE fail_def_part;
DROP TABLE hash_parted;
-- more tests for certain multi-level partitioning scenarios
create table p (a int, b int) partition by range (a, b);
create table p1 (b int, a int not null) partition by range (b);
create table p11 (like p1);
alter table p11 drop a;
alter table p11 add a int;
alter table p11 drop a;
alter table p11 add a int not null;
-- attnum for key attribute 'a' is different in p, p1, and p11
select attrelid::regclass, attname, attnum
from pg_attribute
where attname = 'a'
 and (attrelid = 'p'::regclass
   or attrelid = 'p1'::regclass
   or attrelid = 'p11'::regclass)
order by attrelid::regclass::text;
 attrelid | attname | attnum
----------+---------+--------
 p        | a       |      1
 p1       | a       |      2
 p11      | a       |      4
(3 rows)

alter table p1 attach partition p11 for values from (2) to (5);
insert into p1 (a, b) values (2, 3);
-- check that partition validation scan correctly detects violating rows
alter table p attach partition p1 for values from (1, 2) to (1, 10);
ERROR:  partition constraint of relation "p11" is violated by some row
-- cleanup
drop table p;
drop table p1;
-- validate constraint on partitioned tables should only scan leaf partitions
create table parted_validate_test (a int) partition by list (a);
create table parted_validate_test_1 partition of parted_validate_test for values in (0, 1);
alter table parted_validate_test add constraint parted_validate_test_chka check (a > 0) not valid;
alter table parted_validate_test validate constraint parted_validate_test_chka;
drop table parted_validate_test;
-- test alter column options
CREATE TABLE attmp(i integer);
INSERT INTO attmp VALUES (1);
ALTER TABLE attmp ALTER COLUMN i SET (n_distinct = 1, n_distinct_inherited = 2);
ERROR:  ALTER action ALTER COLUMN ... SET not supported yet
LINE 1: ALTER TABLE attmp ALTER COLUMN i SET (n_distinct = 1, n_dist...
                          ^
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/1124. React with thumbs up to raise its priority
-- Uncomment when ALTER COLUMN is supported (#1200).
-- ALTER TABLE attmp ALTER COLUMN i RESET (n_distinct_inherited);
-- ANALYZE attmp;
DROP TABLE attmp;
DROP USER regress_alter_table_user1;
-- check that violating rows are correctly reported when attaching as the
-- default partition
create table defpart_attach_test (a int) partition by list (a);
create table defpart_attach_test1 partition of defpart_attach_test for values in (1);
create table defpart_attach_test_d (b int, a int);
alter table defpart_attach_test_d drop b;
insert into defpart_attach_test_d values (1), (2);
-- error because its constraint as the default partition would be violated
-- by the row containing 1
alter table defpart_attach_test attach partition defpart_attach_test_d default;
ERROR:  partition constraint of relation "defpart_attach_test_d" is violated by some row
delete from defpart_attach_test_d where a = 1;
alter table defpart_attach_test_d add check (a > 1);
-- should be attached successfully and without needing to be scanned
alter table defpart_attach_test attach partition defpart_attach_test_d default;
-- check that attaching a partition correctly reports any rows in the default
-- partition that should not be there for the new partition to be attached
-- successfully
create table defpart_attach_test_2 (like defpart_attach_test_d);
alter table defpart_attach_test attach partition defpart_attach_test_2 for values in (2);
ERROR:  updated partition constraint for default partition "defpart_attach_test_d" would be violated by some row
drop table defpart_attach_test;
-- check combinations of temporary and permanent relations when attaching
-- partitions.
create table perm_part_parent (a int) partition by list (a);
create temp table temp_part_parent (a int) partition by list (a);
create table perm_part_child (a int);
create temp table temp_part_child (a int);
alter table temp_part_parent attach partition perm_part_child default; -- error
ERROR:  cannot attach a permanent relation as partition of temporary relation "temp_part_parent"
alter table perm_part_parent attach partition temp_part_child default; -- error
ERROR:  cannot attach a temporary relation as partition of permanent relation "perm_part_parent"
alter table temp_part_parent attach partition temp_part_child default; -- ok
drop table perm_part_parent cascade;
drop table temp_part_parent cascade;
-- check that attaching partitions to a table while it is being used is
-- prevented
create table tab_part_attach (a int) partition by list (a);
create or replace function func_part_attach() returns trigger
  language plpgsql as $$
  begin
    execute 'create table tab_part_attach_1 (a int)';
    execute 'alter table tab_part_attach attach partition tab_part_attach_1 for values in (1)';
    return null;
  end $$;
create trigger trig_part_attach before insert on tab_part_attach
  for each statement execute procedure func_part_attach();
insert into tab_part_attach values (1);
ERROR:  cannot ALTER TABLE "tab_part_attach" because it is being used by active queries in this session
CONTEXT:  SQL statement "alter table tab_part_attach attach partition tab_part_attach_1 for values in (1)"
PL/pgSQL function func_part_attach() line 4 at EXECUTE
drop table tab_part_attach;
drop function func_part_attach();
-- test case where the partitioning operator is a SQL function whose
-- evaluation results in the table's relcache being rebuilt partway through
-- the execution of an ATTACH PARTITION command
create function at_test_sql_partop (int4, int4) returns int language sql
as $$ select case when $1 = $2 then 0 when $1 > $2 then 1 else -1 end; $$;
create operator class at_test_sql_partop for type int4 using btree as
    operator 1 < (int4, int4), operator 2 <= (int4, int4),
    operator 3 = (int4, int4), operator 4 >= (int4, int4),
    operator 5 > (int4, int4), function 1 at_test_sql_partop(int4, int4);
-- Fails due to #14575, uncomment the following tests once fixed.
create table at_test_sql_partop (a int) partition by range (a at_test_sql_partop);
ERROR:  operator class "at_test_sql_partop" does not exist for access method "btree"
/*
create table at_test_sql_partop_1 (a int);
alter table at_test_sql_partop attach partition at_test_sql_partop_1 for values from (0) to (10);
drop table at_test_sql_partop;
*/
drop operator class at_test_sql_partop using btree;
drop function at_test_sql_partop;
--
-- Check that attaching or detaching a partitioned partition correctly leads
-- to its partitions' constraint being updated to reflect the parent's
-- newly added/removed constraint
create table target_parted (a int, b int) partition by list (a);
create table attach_parted (a int, b int) partition by list (b);
create table attach_parted_part1 partition of attach_parted for values in (1);
-- insert a row directly into the leaf partition so that its partition
-- constraint is built and stored in the relcache
insert into attach_parted_part1 values (1, 1);
-- the following better invalidate the partition constraint of the leaf
-- partition too...
alter table target_parted attach partition attach_parted for values in (1);
-- ...such that the following insert fails
insert into attach_parted_part1 values (2, 1);
ERROR:  new row for relation "attach_parted_part1" violates partition constraint
DETAIL:  Failing row contains (2, 1).
-- ...and doesn't when the partition is detached along with its own partition
alter table target_parted detach partition attach_parted;
insert into attach_parted_part1 values (2, 1);
