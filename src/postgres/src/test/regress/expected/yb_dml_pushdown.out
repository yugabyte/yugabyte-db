--
-- Test that single-row UPDATE/DELETEs bypass scan.
--
CREATE TABLE single_row (k int primary key, v1 int, v2 int);
-- Below statements should all USE single-row.
EXPLAIN (COSTS FALSE, VERBOSE TRUE) DELETE FROM single_row WHERE k = 1;
                   QUERY PLAN
-------------------------------------------------
 Delete on public.single_row
   ->  Result
         Output: 1, NULL::integer, NULL::integer
(3 rows)

EXPLAIN (COSTS FALSE, VERBOSE TRUE) DELETE FROM single_row WHERE k = 1 RETURNING k;
                   QUERY PLAN
-------------------------------------------------
 Delete on public.single_row
   Output: k
   ->  Result
         Output: 1, NULL::integer, NULL::integer
(4 rows)

EXPLAIN (COSTS FALSE, VERBOSE TRUE) DELETE FROM single_row WHERE k = 1 RETURNING v1;
                   QUERY PLAN
-------------------------------------------------
 Delete on public.single_row
   Output: v1
   ->  Result
         Output: 1, NULL::integer, NULL::integer
(4 rows)

EXPLAIN (COSTS FALSE, VERBOSE TRUE) DELETE FROM single_row WHERE k IN (1);
                   QUERY PLAN
-------------------------------------------------
 Delete on public.single_row
   ->  Result
         Output: 1, NULL::integer, NULL::integer
(3 rows)

-- Below statements should all NOT USE single-row.
EXPLAIN (COSTS FALSE, VERBOSE TRUE) DELETE FROM single_row;
             QUERY PLAN
-------------------------------------
 Delete on public.single_row
   ->  Seq Scan on public.single_row
         Output: ybctid
(3 rows)

EXPLAIN (COSTS FALSE, VERBOSE TRUE) DELETE FROM single_row WHERE k = 1 and v1 = 1;
                         QUERY PLAN
-------------------------------------------------------------
 Delete on public.single_row
   ->  Index Scan using single_row_pkey on public.single_row
         Output: ybctid
         Index Cond: (single_row.k = 1)
         Storage Filter: (single_row.v1 = 1)
(5 rows)

EXPLAIN (COSTS FALSE, VERBOSE TRUE) DELETE FROM single_row WHERE v1 = 1 and v2 = 1;
                              QUERY PLAN
-----------------------------------------------------------------------
 Delete on public.single_row
   ->  Seq Scan on public.single_row
         Output: ybctid
         Storage Filter: ((single_row.v1 = 1) AND (single_row.v2 = 1))
(4 rows)

EXPLAIN (COSTS FALSE, VERBOSE TRUE) DELETE FROM single_row WHERE k > 1;
                 QUERY PLAN
--------------------------------------------
 Delete on public.single_row
   ->  Seq Scan on public.single_row
         Output: ybctid
         Storage Filter: (single_row.k > 1)
(4 rows)

EXPLAIN (COSTS FALSE, VERBOSE TRUE) DELETE FROM single_row WHERE k != 1;
                 QUERY PLAN
---------------------------------------------
 Delete on public.single_row
   ->  Seq Scan on public.single_row
         Output: ybctid
         Storage Filter: (single_row.k <> 1)
(4 rows)

EXPLAIN (COSTS FALSE, VERBOSE TRUE) DELETE FROM single_row WHERE k IN (1, 2);
                          QUERY PLAN
---------------------------------------------------------------
 Delete on public.single_row
   ->  Index Scan using single_row_pkey on public.single_row
         Output: ybctid
         Index Cond: (single_row.k = ANY ('{1,2}'::integer[]))
(4 rows)

-- Below statements should all USE single-row.
EXPLAIN (COSTS FALSE, VERBOSE TRUE) UPDATE single_row SET v1 = 1 WHERE k = 1;
             QUERY PLAN
-------------------------------------
 Update on public.single_row
   ->  Result
         Output: 1, 1, NULL::integer
(3 rows)

EXPLAIN (COSTS FALSE, VERBOSE TRUE) UPDATE single_row SET v1 = 1 WHERE k = 1 RETURNING k, v1;
             QUERY PLAN
-------------------------------------
 Update on public.single_row
   Output: k, v1
   ->  Result
         Output: 1, 1, NULL::integer
(4 rows)

EXPLAIN (COSTS FALSE, VERBOSE TRUE) UPDATE single_row SET v1 = 1, v2 = 1 + 2 WHERE k = 1;
         QUERY PLAN
-----------------------------
 Update on public.single_row
   ->  Result
         Output: 1, 1, 3
(3 rows)

EXPLAIN (COSTS FALSE, VERBOSE TRUE) UPDATE single_row SET v1 = v1 + v2 WHERE k = 1;
             QUERY PLAN
-------------------------------------
 Update on public.single_row
   ->  Result
         Output: 1, 0, NULL::integer
(3 rows)

EXPLAIN (COSTS FALSE, VERBOSE TRUE) UPDATE single_row SET v1 = v2 + 1 WHERE k = 1;
             QUERY PLAN
-------------------------------------
 Update on public.single_row
   ->  Result
         Output: 1, 0, NULL::integer
(3 rows)

EXPLAIN (COSTS FALSE, VERBOSE TRUE) UPDATE single_row SET v1 = 1, v2 = v1 + v2 WHERE k = 1;
         QUERY PLAN
-----------------------------
 Update on public.single_row
   ->  Result
         Output: 1, 1, 0
(3 rows)

EXPLAIN (COSTS FALSE, VERBOSE TRUE) UPDATE single_row SET v1 = v2 + 1, v2 = 1 WHERE k = 1;
         QUERY PLAN
-----------------------------
 Update on public.single_row
   ->  Result
         Output: 1, 0, 1
(3 rows)

EXPLAIN (COSTS FALSE, VERBOSE TRUE) UPDATE single_row SET v1 = 1, v2 = 2 WHERE k = 1 RETURNING k, v1, v2;
         QUERY PLAN
-----------------------------
 Update on public.single_row
   Output: k, v1, v2
   ->  Result
         Output: 1, 1, 2
(4 rows)

EXPLAIN (COSTS FALSE, VERBOSE TRUE) UPDATE single_row SET v1 = 1, v2 = 2 WHERE k = 1 RETURNING *;
         QUERY PLAN
-----------------------------
 Update on public.single_row
   Output: k, v1, v2
   ->  Result
         Output: 1, 1, 2
(4 rows)

EXPLAIN (COSTS FALSE, VERBOSE TRUE) UPDATE single_row SET v1 = v1 + 1, v2 = 2 WHERE k = 1 RETURNING v2;
         QUERY PLAN
-----------------------------
 Update on public.single_row
   Output: v2
   ->  Result
         Output: 1, 0, 2
(4 rows)

EXPLAIN (COSTS FALSE, VERBOSE TRUE) UPDATE single_row SET v1 = 1 WHERE k IN (1);
             QUERY PLAN
-------------------------------------
 Update on public.single_row
   ->  Result
         Output: 1, 1, NULL::integer
(3 rows)

EXPLAIN (COSTS FALSE, VERBOSE TRUE) UPDATE single_row SET v1 = 3 + 2 WHERE k = 1;
             QUERY PLAN
-------------------------------------
 Update on public.single_row
   ->  Result
         Output: 1, 5, NULL::integer
(3 rows)

EXPLAIN (COSTS FALSE, VERBOSE TRUE) UPDATE single_row SET v1 = power(2, 3 - 1) WHERE k = 1;
             QUERY PLAN
-------------------------------------
 Update on public.single_row
   ->  Result
         Output: 1, 4, NULL::integer
(3 rows)

EXPLAIN (COSTS FALSE, VERBOSE TRUE) UPDATE single_row SET v1 = v1 + 3 WHERE k = 1;
             QUERY PLAN
-------------------------------------
 Update on public.single_row
   ->  Result
         Output: 1, 0, NULL::integer
(3 rows)

EXPLAIN (COSTS FALSE, VERBOSE TRUE) UPDATE single_row SET v1 = v1 * 2 WHERE k = 1;
             QUERY PLAN
-------------------------------------
 Update on public.single_row
   ->  Result
         Output: 1, 0, NULL::integer
(3 rows)

EXPLAIN (COSTS FALSE, VERBOSE TRUE) UPDATE single_row SET v1 = power(2, 3 - k) WHERE k = 1;
             QUERY PLAN
-------------------------------------
 Update on public.single_row
   ->  Result
         Output: 1, 0, NULL::integer
(3 rows)

EXPLAIN (COSTS FALSE, VERBOSE TRUE) UPDATE single_row SET v1 = 1 WHERE k = 1 RETURNING v2;
             QUERY PLAN
-------------------------------------
 Update on public.single_row
   Output: v2
   ->  Result
         Output: 1, 1, NULL::integer
(4 rows)

EXPLAIN (COSTS FALSE, VERBOSE TRUE) UPDATE single_row SET v1 = v1 + 1 WHERE k = 1 RETURNING v1;
             QUERY PLAN
-------------------------------------
 Update on public.single_row
   Output: v1
   ->  Result
         Output: 1, 0, NULL::integer
(4 rows)

EXPLAIN (COSTS FALSE, VERBOSE TRUE) UPDATE single_row SET v1 = 1 WHERE k = 1 RETURNING *;
             QUERY PLAN
-------------------------------------
 Update on public.single_row
   Output: k, v1, v2
   ->  Result
         Output: 1, 1, NULL::integer
(4 rows)

EXPLAIN (COSTS FALSE, VERBOSE TRUE) UPDATE single_row SET v1 = CASE WHEN random() < 0.1 THEN 0 ELSE 1 END WHERE k = 1;
                                             QUERY PLAN
----------------------------------------------------------------------------------------------------
 Update on public.single_row
   ->  Result
         Output: 1, CASE WHEN (random() < '0.1'::double precision) THEN 0 ELSE 1 END, NULL::integer
(3 rows)

EXPLAIN (COSTS FALSE, VERBOSE TRUE) UPDATE single_row SET v2 = CASE WHEN v1 % 2 = 0 THEN v2 * 3 ELSE v2 *2 END WHERE k = 1;
             QUERY PLAN
-------------------------------------
 Update on public.single_row
   ->  Result
         Output: 1, NULL::integer, 0
(3 rows)

-- Below statements should all NOT USE single-row.
EXPLAIN (COSTS FALSE) UPDATE single_row SET v1 = 1;
          QUERY PLAN
------------------------------
 Update on single_row
   ->  Seq Scan on single_row
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row SET v1 = 1 WHERE k = 1 and v2 = 1;
                      QUERY PLAN
------------------------------------------------------
 Update on single_row
   ->  Index Scan using single_row_pkey on single_row
         Index Cond: (k = 1)
         Storage Filter: (v2 = 1)
(4 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row SET v1 = 1 WHERE k > 1;
           QUERY PLAN
---------------------------------
 Update on single_row
   ->  Seq Scan on single_row
         Storage Filter: (k > 1)
(3 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row SET v1 = 1 WHERE k != 1;
            QUERY PLAN
----------------------------------
 Update on single_row
   ->  Seq Scan on single_row
         Storage Filter: (k <> 1)
(3 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row SET v1 = 1 WHERE k IN (1, 2);
                      QUERY PLAN
------------------------------------------------------
 Update on single_row
   ->  Index Scan using single_row_pkey on single_row
         Index Cond: (k = ANY ('{1,2}'::integer[]))
(3 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row SET v1 = 1 WHERE k % 2 = 0;
              QUERY PLAN
---------------------------------------
 Update on single_row
   ->  Seq Scan on single_row
         Storage Filter: ((k % 2) = 0)
(3 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row SET v2 = CASE v1 WHEN 1 THEN v2 * 2 ELSE v2 END WHERE k = 1;
                      QUERY PLAN
------------------------------------------------------
 Update on single_row
   ->  Index Scan using single_row_pkey on single_row
         Index Cond: (k = 1)
(3 rows)

--
-- Test single-row UPDATE/DELETE execution.
--
INSERT INTO single_row VALUES (1, 1, 1);
UPDATE single_row SET v1 = 2 WHERE k = 1;
SELECT * FROM single_row;
 k | v1 | v2
---+----+----
 1 |  2 |  1
(1 row)

UPDATE single_row SET v1 = v1 * 2 WHERE k = 1;
SELECT * FROM single_row;
 k | v1 | v2
---+----+----
 1 |  4 |  1
(1 row)

UPDATE single_row SET v2 = CASE WHEN v1 % 2 = 0 THEN v2 * 3 ELSE v2 *2 END WHERE k = 1;
SELECT * FROM single_row;
 k | v1 | v2
---+----+----
 1 |  4 |  3
(1 row)

DELETE FROM single_row WHERE k = 1;
SELECT * FROM single_row;
 k | v1 | v2
---+----+----
(0 rows)

--
-- Test UPDATE/DELETEs of non-existent data return no rows.
--
UPDATE single_row SET v1 = 1 WHERE k = 100 RETURNING k;
 k
---
(0 rows)

DELETE FROM single_row WHERE k = 100 RETURNING k;
 k
---
(0 rows)

SELECT * FROM single_row;
 k | v1 | v2
---+----+----
(0 rows)

--
-- Test prepared statements.
--
INSERT INTO single_row VALUES (1, 1, 1);
PREPARE single_row_update (int, int, int) AS
  UPDATE single_row SET v1 = $2, v2 = $3 WHERE k = $1;
PREPARE single_row_delete (int) AS
  DELETE FROM single_row WHERE k = $1;
EXPLAIN (COSTS FALSE) EXECUTE single_row_update (1, 2, 2);
      QUERY PLAN
----------------------
 Update on single_row
   ->  Result
(2 rows)

EXECUTE single_row_update (1, 2, 2);
SELECT * FROM single_row;
 k | v1 | v2
---+----+----
 1 |  2 |  2
(1 row)

EXPLAIN (COSTS FALSE) EXECUTE single_row_delete (1);
      QUERY PLAN
----------------------
 Delete on single_row
   ->  Result
(2 rows)

EXECUTE single_row_delete (1);
SELECT * FROM single_row;
 k | v1 | v2
---+----+----
(0 rows)

--
-- Test returning clauses.
--
INSERT INTO single_row VALUES (1, 1, 1);
UPDATE single_row SET v1 = 2, v2 = 2 WHERE k = 1 RETURNING v1, v2, k;
 v1 | v2 | k
----+----+---
  2 |  2 | 1
(1 row)

SELECT * FROM single_row;
 k | v1 | v2
---+----+----
 1 |  2 |  2
(1 row)

UPDATE single_row SET v1 = 3, v2 = 3 WHERE k = 1 RETURNING *;
 k | v1 | v2
---+----+----
 1 |  3 |  3
(1 row)

SELECT * FROM single_row;
 k | v1 | v2
---+----+----
 1 |  3 |  3
(1 row)

UPDATE single_row SET v1 = v1 + 1 WHERE k = 1 RETURNING v1;
 v1
----
  4
(1 row)

SELECT * FROM single_row;
 k | v1 | v2
---+----+----
 1 |  4 |  3
(1 row)

UPDATE single_row SET v1 = v1 + 1, v2 = 4 WHERE k = 1 RETURNING v2;
 v2
----
  4
(1 row)

SELECT * FROM single_row;
 k | v1 | v2
---+----+----
 1 |  5 |  4
(1 row)

DELETE FROM single_row WHERE k = 1 RETURNING k;
 k
---
 1
(1 row)

SELECT * FROM single_row;
 k | v1 | v2
---+----+----
(0 rows)

---
--- Test in transaction block.
---
INSERT INTO single_row VALUES (1, 1, 1);
BEGIN;
EXPLAIN (COSTS FALSE) DELETE FROM single_row WHERE k = 1;
      QUERY PLAN
----------------------
 Delete on single_row
   ->  Result
(2 rows)

DELETE FROM single_row WHERE k = 1;
END;
SELECT * FROM single_row;
 k | v1 | v2
---+----+----
(0 rows)

-- Test UPDATE/DELETE of non-existing rows.
BEGIN;
DELETE FROM single_row WHERE k = 1;
UPDATE single_row SET v1 = 2 WHERE k = 1;
END;
SELECT * FROM single_row;
 k | v1 | v2
---+----+----
(0 rows)

---
--- Test WITH clause.
---
INSERT INTO single_row VALUES (1, 1, 1);
EXPLAIN (COSTS FALSE) WITH temp AS (UPDATE single_row SET v1 = 2 WHERE k = 1)
  UPDATE single_row SET v1 = 2 WHERE k = 1;
                QUERY PLAN
-------------------------------------------
 Update on single_row
   CTE temp
     ->  Update on single_row single_row_1
           ->  Result
   ->  Result
(5 rows)

WITH temp AS (UPDATE single_row SET v1 = 2 WHERE k = 1)
  UPDATE single_row SET v1 = 2 WHERE k = 1;
SELECT * FROM single_row;
 k | v1 | v2
---+----+----
 1 |  2 |  1
(1 row)

EXPLAIN (COSTS FALSE) WITH temp AS (UPDATE single_row SET v1 = v1 + 1 WHERE k = 1 RETURNING k, v1)
  UPDATE single_row SET v2 = temp.v1 FROM temp WHERE single_row.k = temp.k;
                               QUERY PLAN
-------------------------------------------------------------------------
 Update on single_row
   CTE temp
     ->  Update on single_row single_row_1
           ->  Result
   ->  YB Batched Nested Loop Join
         Join Filter: (single_row.k = temp.k)
         ->  CTE Scan on temp
         ->  Index Scan using single_row_pkey on single_row
               Index Cond: (k = ANY (ARRAY[temp.k, $4, $5, ..., $1026]))
(9 rows)

WITH temp AS (UPDATE single_row SET v1 = v1 + 1 WHERE k = 1 RETURNING k, v1)
  UPDATE single_row SET v2 = temp.v1 FROM temp WHERE single_row.k = temp.k;
SELECT * FROM single_row;
 k | v1 | v2
---+----+----
 1 |  3 |  3
(1 row)

-- Update row that doesn't exist.
WITH temp AS (UPDATE single_row SET v1 = 2 WHERE k = 2)
  UPDATE single_row SET v1 = 2 WHERE k = 2;
SELECT * FROM single_row;
 k | v1 | v2
---+----+----
 1 |  3 |  3
(1 row)

WITH temp AS (UPDATE single_row SET v1 = v1 + 1 WHERE k = 2 RETURNING k, v1)
  UPDATE single_row SET v2 = temp.v1 FROM temp WHERE single_row.k = temp.k;
SELECT * FROM single_row;
 k | v1 | v2
---+----+----
 1 |  3 |  3
(1 row)

-- GHI 23461
CREATE TABLE single_row_changes(k int, v1 int);
INSERT INTO single_row_changes VALUES (1, 1), (1, 2);
WITH deleted_rows AS (
  DELETE FROM single_row_changes
  WHERE k = 1
  RETURNING v1
)
UPDATE single_row
SET v1 = v1 + (SELECT COALESCE(SUM(v1), 0) FROM deleted_rows)
WHERE k = 1;
SELECT * FROM single_row;
 k | v1 | v2
---+----+----
 1 |  6 |  3
(1 row)

-- Updates on a table with a secondary index
CREATE INDEX single_row_v2_idx ON single_row(v2);
EXPLAIN (COSTS FALSE) WITH temp AS (UPDATE single_row SET v1 = v1 + 1 WHERE k = 1 RETURNING k, v1)
  UPDATE single_row SET v2 = temp.v1 FROM temp WHERE single_row.k = temp.k;
                               QUERY PLAN
-------------------------------------------------------------------------
 Update on single_row
   CTE temp
     ->  Update on single_row single_row_1
           ->  Result
   ->  YB Batched Nested Loop Join
         Join Filter: (single_row.k = temp.k)
         ->  CTE Scan on temp
         ->  Index Scan using single_row_pkey on single_row
               Index Cond: (k = ANY (ARRAY[temp.k, $4, $5, ..., $1026]))
(9 rows)

EXPLAIN (COSTS FALSE) WITH temp AS (UPDATE single_row SET v2 = v1 + 1 WHERE k = 1 RETURNING k, v1)
  UPDATE single_row SET v2 = temp.v1 FROM temp WHERE single_row.k = temp.k;
                                QUERY PLAN
---------------------------------------------------------------------------
 Update on single_row
   CTE temp
     ->  Update on single_row single_row_1
           ->  Index Scan using single_row_pkey on single_row single_row_1
                 Index Cond: (k = 1)
   ->  YB Batched Nested Loop Join
         Join Filter: (single_row.k = temp.k)
         ->  CTE Scan on temp
         ->  Index Scan using single_row_pkey on single_row
               Index Cond: (k = ANY (ARRAY[temp.k, $4, $5, ..., $1026]))
(10 rows)

DROP INDEX single_row_v2_idx;
-- Updates on a table with a trigger
CREATE FUNCTION notify_single_row_v1_update_trigger() RETURNS trigger AS $$
BEGIN
  RAISE NOTICE 'v1 has been updated';
  RETURN NEW;
END $$ language plpgsql;
CREATE TRIGGER notify_single_row_v1_update AFTER UPDATE ON single_row
  FOR EACH ROW WHEN (OLD.v1 != NEW.v1)
  EXECUTE FUNCTION notify_single_row_v1_update_trigger();
EXPLAIN (COSTS FALSE) WITH temp AS (UPDATE single_row SET v2 = v1 + 1 WHERE k = 1 RETURNING k, v1)
  UPDATE single_row SET v2 = temp.v1 FROM temp WHERE single_row.k = temp.k;
                                QUERY PLAN
---------------------------------------------------------------------------
 Update on single_row
   CTE temp
     ->  Update on single_row single_row_1
           ->  Index Scan using single_row_pkey on single_row single_row_1
                 Index Cond: (k = 1)
   ->  YB Batched Nested Loop Join
         Join Filter: (single_row.k = temp.k)
         ->  CTE Scan on temp
         ->  Index Scan using single_row_pkey on single_row
               Index Cond: (k = ANY (ARRAY[temp.k, $4, $5, ..., $1026]))
(10 rows)

DROP TRIGGER notify_single_row_v1_update ON single_row;
DROP FUNCTION notify_single_row_v1_update_trigger;
-- Adding secondary index should force re-planning, which would
-- then not choose single-row plan due to the secondary index.
EXPLAIN (COSTS FALSE) EXECUTE single_row_delete (1);
      QUERY PLAN
----------------------
 Delete on single_row
   ->  Result
(2 rows)

CREATE INDEX single_row_index ON single_row (v1);
EXPLAIN (COSTS FALSE) EXECUTE single_row_delete (1);
                      QUERY PLAN
------------------------------------------------------
 Delete on single_row
   ->  Index Scan using single_row_pkey on single_row
         Index Cond: (k = 1)
(3 rows)

DROP INDEX single_row_index;
-- Same as above but for UPDATE.
EXPLAIN (COSTS FALSE) EXECUTE single_row_update (1, 1, 1);
      QUERY PLAN
----------------------
 Update on single_row
   ->  Result
(2 rows)

CREATE INDEX single_row_index ON single_row (v1);
EXPLAIN (COSTS FALSE) EXECUTE single_row_update (1, 1, 1);
                      QUERY PLAN
------------------------------------------------------
 Update on single_row
   ->  Index Scan using single_row_pkey on single_row
         Index Cond: (k = 1)
(3 rows)

DROP INDEX single_row_index;
-- Adding BEFORE DELETE row triggers should do the same as secondary index.
EXPLAIN (COSTS FALSE) EXECUTE single_row_delete (1);
      QUERY PLAN
----------------------
 Delete on single_row
   ->  Result
(2 rows)

CREATE TRIGGER single_row_delete_trigger BEFORE DELETE ON single_row
  FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();
EXPLAIN (COSTS FALSE) EXECUTE single_row_delete (1);
                      QUERY PLAN
------------------------------------------------------
 Delete on single_row
   ->  Index Scan using single_row_pkey on single_row
         Index Cond: (k = $1)
(3 rows)

-- UPDATE should still use single-row since trigger does not apply to it.
EXPLAIN (COSTS FALSE) EXECUTE single_row_update (1, 1, 1);
      QUERY PLAN
----------------------
 Update on single_row
   ->  Result
(2 rows)

DROP TRIGGER single_row_delete_trigger ON single_row;
-- Adding BEFORE UPDATE row triggers should do the same as secondary index.
EXPLAIN (COSTS FALSE) EXECUTE single_row_update (1, 1, 1);
      QUERY PLAN
----------------------
 Update on single_row
   ->  Result
(2 rows)

CREATE TRIGGER single_row_update_trigger BEFORE UPDATE ON single_row
  FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();
EXPLAIN (COSTS FALSE) EXECUTE single_row_update (1, 1, 1);
                      QUERY PLAN
------------------------------------------------------
 Update on single_row
   ->  Index Scan using single_row_pkey on single_row
         Index Cond: (k = $1)
(3 rows)

-- DELETE should still use single-row since trigger does not apply to it.
EXPLAIN (COSTS FALSE) EXECUTE single_row_delete (1);
      QUERY PLAN
----------------------
 Delete on single_row
   ->  Result
(2 rows)

DROP TRIGGER single_row_update_trigger ON single_row;
--
-- Test stored procedure
--
CREATE PROCEDURE update_single_row_proc(pk int, new_v1 int, inc_v2 int) AS $$
  UPDATE single_row SET v1 = new_v1, v2 = v2 + inc_v2 WHERE k = pk;
$$ LANGUAGE SQL;
CALL update_single_row_proc(1, 2, 3);
SELECT * FROM single_row WHERE k = 1;
 k | v1 | v2
---+----+----
 1 |  2 |  6
(1 row)

DROP PROCEDURE update_single_row_proc;
--
-- Test table with composite primary key.
--
CREATE TABLE single_row_comp_key (v int, k1 int, k2 int, PRIMARY KEY (k1 HASH, k2 ASC));
-- Below statements should all USE single-row.
EXPLAIN (COSTS FALSE) DELETE FROM single_row_comp_key WHERE k1 = 1 and k2 = 1;
          QUERY PLAN
-------------------------------
 Delete on single_row_comp_key
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) DELETE FROM single_row_comp_key WHERE k1 = 1 and k2 = 1 RETURNING k1, k2;
          QUERY PLAN
-------------------------------
 Delete on single_row_comp_key
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) DELETE FROM single_row_comp_key WHERE k1 = 1 and k2 = 1 RETURNING v;
          QUERY PLAN
-------------------------------
 Delete on single_row_comp_key
   ->  Result
(2 rows)

-- Below statements should all NOT USE single-row.
EXPLAIN (COSTS FALSE) DELETE FROM single_row_comp_key;
              QUERY PLAN
---------------------------------------
 Delete on single_row_comp_key
   ->  Seq Scan on single_row_comp_key
(2 rows)

EXPLAIN (COSTS FALSE) DELETE FROM single_row_comp_key WHERE k1 = 1;
                               QUERY PLAN
------------------------------------------------------------------------
 Delete on single_row_comp_key
   ->  Index Scan using single_row_comp_key_pkey on single_row_comp_key
         Index Cond: (k1 = 1)
(3 rows)

EXPLAIN (COSTS FALSE) DELETE FROM single_row_comp_key WHERE k2 = 1;
              QUERY PLAN
---------------------------------------
 Delete on single_row_comp_key
   ->  Seq Scan on single_row_comp_key
         Storage Filter: (k2 = 1)
(3 rows)

EXPLAIN (COSTS FALSE) DELETE FROM single_row_comp_key WHERE v = 1 and k1 = 1 and k2 = 1;
                               QUERY PLAN
------------------------------------------------------------------------
 Delete on single_row_comp_key
   ->  Index Scan using single_row_comp_key_pkey on single_row_comp_key
         Index Cond: ((k1 = 1) AND (k2 = 1))
         Storage Filter: (v = 1)
(4 rows)

EXPLAIN (COSTS FALSE) DELETE FROM single_row_comp_key WHERE k1 = 1 AND k2 < 1;
                               QUERY PLAN
------------------------------------------------------------------------
 Delete on single_row_comp_key
   ->  Index Scan using single_row_comp_key_pkey on single_row_comp_key
         Index Cond: ((k1 = 1) AND (k2 < 1))
(3 rows)

EXPLAIN (COSTS FALSE) DELETE FROM single_row_comp_key WHERE k1 = 1 AND k2 != 1;
                               QUERY PLAN
------------------------------------------------------------------------
 Delete on single_row_comp_key
   ->  Index Scan using single_row_comp_key_pkey on single_row_comp_key
         Index Cond: (k1 = 1)
         Storage Filter: (k2 <> 1)
(4 rows)

-- Below statements should all USE single-row.
EXPLAIN (COSTS FALSE) UPDATE single_row_comp_key SET v = 1 WHERE k1 = 1 and k2 = 1;
          QUERY PLAN
-------------------------------
 Update on single_row_comp_key
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_comp_key SET v = k1 + 1 WHERE k1 = 1 and k2 = 1;
          QUERY PLAN
-------------------------------
 Update on single_row_comp_key
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_comp_key SET v = 1 WHERE k1 = 1 and k2 = 1 RETURNING k1, k2, v;
          QUERY PLAN
-------------------------------
 Update on single_row_comp_key
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_comp_key SET v = 1 + 2 WHERE k1 = 1 and k2 = 1;
          QUERY PLAN
-------------------------------
 Update on single_row_comp_key
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_comp_key SET v = v + 1 WHERE k1 = 1 and k2 = 1;
          QUERY PLAN
-------------------------------
 Update on single_row_comp_key
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row SET v1 = 3 - 2 WHERE k = 1;
      QUERY PLAN
----------------------
 Update on single_row
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row SET v1 = ceil(3 - 2.5) WHERE k = 1;
      QUERY PLAN
----------------------
 Update on single_row
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row SET v1 = 3 - v1 WHERE k = 1;
      QUERY PLAN
----------------------
 Update on single_row
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row SET v1 = 3 - k WHERE k = 1;
      QUERY PLAN
----------------------
 Update on single_row
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row SET v1 = v1 - k WHERE k = 1;
      QUERY PLAN
----------------------
 Update on single_row
   ->  Result
(2 rows)

-- Below statements should all NOT USE single-row.
EXPLAIN (COSTS FALSE) UPDATE single_row_comp_key SET v = 1;
              QUERY PLAN
---------------------------------------
 Update on single_row_comp_key
   ->  Seq Scan on single_row_comp_key
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_comp_key SET v = 1 WHERE k1 = 1 and k2 = 1 and v = 1;
                               QUERY PLAN
------------------------------------------------------------------------
 Update on single_row_comp_key
   ->  Index Scan using single_row_comp_key_pkey on single_row_comp_key
         Index Cond: ((k1 = 1) AND (k2 = 1))
         Storage Filter: (v = 1)
(4 rows)

-- Test the impact of functions on single row optimization.
CREATE TABLE single_row_function_test (k INTEGER NOT NULL, date_pk TIMESTAMPTZ, random_field INTEGER, v varchar, created_at TIMESTAMP, PRIMARY KEY(k, date_pk));
-- Verify that using unsupported non-immutable functions in the WHERE clause disables the use of fast path.
EXPLAIN (COSTS OFF) UPDATE single_row_function_test SET random_field = 2 WHERE k = 1 AND date_pk = timeofday()::TIMESTAMP;
                                    QUERY PLAN
----------------------------------------------------------------------------------
 Update on single_row_function_test
   ->  Index Scan using single_row_function_test_pkey on single_row_function_test
         Index Cond: (k = 1)
         Filter: (date_pk = (timeofday())::timestamp without time zone)
(4 rows)

-- Verify that using unsupported non-immutable functions to assign values does not disable the use of fast path.
EXPLAIN (COSTS OFF) UPDATE single_row_function_test SET v=getpgusername() WHERE k = 1 AND date_pk = NOW();
             QUERY PLAN
------------------------------------
 Update on single_row_function_test
   ->  Result
(2 rows)

-- Verify that using supported non-immutable functions (like random(), NOW(), timestamp, timestampz etc) which do not perform reads or writes to the database
-- to assign values/WHERE clause does not prevent the use of fast-path.
EXPLAIN (COSTS OFF) UPDATE single_row_function_test SET created_at = '2022-01-01 00:00:00'::TIMESTAMP WITH TIME ZONE, random_field = ceil(random())::int  WHERE date_pk = NOW() AND k = 1;
             QUERY PLAN
------------------------------------
 Update on single_row_function_test
   ->  Result
(2 rows)

-- Verify that even if the function used in the WHERE clause is a supported but volatile function, the fast path is still disabled.
EXPLAIN (COSTS OFF) UPDATE single_row_function_test SET created_at = '2022-01-01 00:00:00'::TIMESTAMP WITH TIME ZONE, random_field = ceil(random())::int  WHERE date_pk = NOW() AND k = random()::int;
                    QUERY PLAN
---------------------------------------------------
 Update on single_row_function_test
   ->  Seq Scan on single_row_function_test
         Storage Filter: (k = (random())::integer)
         Filter: (date_pk = now())
(4 rows)

DROP TABLE single_row_function_test;
-- Test execution.
INSERT INTO single_row_comp_key VALUES (1, 2, 3);
UPDATE single_row_comp_key SET v = 2 WHERE k1 = 2 and k2 = 3;
SELECT * FROM single_row_comp_key;
 v | k1 | k2
---+----+----
 2 |  2 |  3
(1 row)

-- try switching around the order, reversing value/key
DELETE FROM single_row_comp_key WHERE 2 = k2 and 3 = k1;
SELECT * FROM single_row_comp_key;
 v | k1 | k2
---+----+----
 2 |  2 |  3
(1 row)

DELETE FROM single_row_comp_key WHERE 3 = k2 and 2 = k1;
SELECT * FROM single_row_comp_key;
 v | k1 | k2
---+----+----
(0 rows)

--
-- Test table with non-standard const type.
--
CREATE TABLE single_row_complex (k bigint PRIMARY KEY, v float);
-- Below statements should all USE single-row.
EXPLAIN (COSTS FALSE) DELETE FROM single_row_complex WHERE k = 1;
          QUERY PLAN
------------------------------
 Delete on single_row_complex
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) DELETE FROM single_row_complex WHERE k = 1 RETURNING k;
          QUERY PLAN
------------------------------
 Delete on single_row_complex
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) DELETE FROM single_row_complex WHERE k = 1 RETURNING v;
          QUERY PLAN
------------------------------
 Delete on single_row_complex
   ->  Result
(2 rows)

-- Below statements should all NOT USE single-row.
EXPLAIN (COSTS FALSE) DELETE FROM single_row_complex;
              QUERY PLAN
--------------------------------------
 Delete on single_row_complex
   ->  Seq Scan on single_row_complex
(2 rows)

EXPLAIN (COSTS FALSE) DELETE FROM single_row_complex WHERE k = 1 and v = 1;
                              QUERY PLAN
----------------------------------------------------------------------
 Delete on single_row_complex
   ->  Index Scan using single_row_complex_pkey on single_row_complex
         Index Cond: (k = 1)
         Storage Filter: (v = '1'::double precision)
(4 rows)

EXPLAIN (COSTS FALSE) DELETE FROM single_row_complex WHERE v = 1;
                     QUERY PLAN
-----------------------------------------------------
 Delete on single_row_complex
   ->  Seq Scan on single_row_complex
         Storage Filter: (v = '1'::double precision)
(3 rows)

-- Below statements should all USE single-row.
EXPLAIN (COSTS FALSE) UPDATE single_row_complex SET v = 1 WHERE k = 1;
          QUERY PLAN
------------------------------
 Update on single_row_complex
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_complex SET v = 1 WHERE k = 1 RETURNING k, v;
          QUERY PLAN
------------------------------
 Update on single_row_complex
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_complex SET v = 1 + 2 WHERE k = 1;
          QUERY PLAN
------------------------------
 Update on single_row_complex
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_complex SET v = v + 1 WHERE k = 1;
          QUERY PLAN
------------------------------
 Update on single_row_complex
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_complex SET v = 3 * (v + 3 - 2) WHERE k = 1;
          QUERY PLAN
------------------------------
 Update on single_row_complex
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_complex SET v = k + 1 WHERE k = 1;
          QUERY PLAN
------------------------------
 Update on single_row_complex
   ->  Result
(2 rows)

-- Below statements should all NOT USE single-row.
EXPLAIN (COSTS FALSE) UPDATE single_row_complex SET v = 1;
              QUERY PLAN
--------------------------------------
 Update on single_row_complex
   ->  Seq Scan on single_row_complex
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_complex SET v = 1 WHERE k = 1 and v = 1;
                              QUERY PLAN
----------------------------------------------------------------------
 Update on single_row_complex
   ->  Index Scan using single_row_complex_pkey on single_row_complex
         Index Cond: (k = 1)
         Storage Filter: (v = '1'::double precision)
(4 rows)

-- Test execution.
INSERT INTO single_row_complex VALUES (1, 1);
UPDATE single_row_complex SET v = 2 WHERE k = 1;
SELECT * FROM single_row_complex;
 k | v
---+---
 1 | 2
(1 row)

UPDATE single_row_complex SET v = 3 * (v + 3 - 2) WHERE k = 1;
SELECT * FROM single_row_complex;
 k | v
---+---
 1 | 9
(1 row)

DELETE FROM single_row_complex WHERE k = 1;
SELECT * FROM single_row_complex;
 k | v
---+---
(0 rows)

--
-- Test table with non-const type.
--
CREATE TABLE single_row_array (k int primary key, arr int []);
-- Below statements should all USE single-row.
EXPLAIN (COSTS FALSE) DELETE FROM single_row_array WHERE k = 1;
         QUERY PLAN
----------------------------
 Delete on single_row_array
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) DELETE FROM single_row_array WHERE k = 1 RETURNING k;
         QUERY PLAN
----------------------------
 Delete on single_row_array
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) DELETE FROM single_row_array WHERE k = 1 RETURNING arr;
         QUERY PLAN
----------------------------
 Delete on single_row_array
   ->  Result
(2 rows)

-- Below statements should all NOT USE single-row.
EXPLAIN (COSTS FALSE) DELETE FROM single_row_array;
             QUERY PLAN
------------------------------------
 Delete on single_row_array
   ->  Seq Scan on single_row_array
(2 rows)

EXPLAIN (COSTS FALSE) DELETE FROM single_row_array WHERE k = 1 and arr[1] = 1;
                            QUERY PLAN
------------------------------------------------------------------
 Delete on single_row_array
   ->  Index Scan using single_row_array_pkey on single_row_array
         Index Cond: (k = 1)
         Filter: (arr[1] = 1)
(4 rows)

EXPLAIN (COSTS FALSE) DELETE FROM single_row_array WHERE arr[1] = 1;
             QUERY PLAN
------------------------------------
 Delete on single_row_array
   ->  Seq Scan on single_row_array
         Filter: (arr[1] = 1)
(3 rows)

-- Below statements should all NOT USE single-row.
EXPLAIN (COSTS FALSE) UPDATE single_row_array SET arr[1] = 1 WHERE k = 1;
                            QUERY PLAN
------------------------------------------------------------------
 Update on single_row_array
   ->  Index Scan using single_row_array_pkey on single_row_array
         Index Cond: (k = 1)
(3 rows)

-- Test execution.
INSERT INTO single_row_array VALUES (1, ARRAY [1, 2, 3]);
DELETE FROM single_row_array WHERE k = 1;
SELECT * FROM single_row_array;
 k | arr
---+-----
(0 rows)

--
-- Test update with complex returning clause expressions
--
CREATE TYPE two_int AS (first integer, second integer);
CREATE TYPE two_text AS (first_text text, second_text text);
CREATE TABLE single_row_complex_returning (k int primary key, v1 int, v2 text, v3 two_text, array_int int[], v5 int);
CREATE FUNCTION assign_one_plus_param_to_v1(integer) RETURNS integer
   AS 'UPDATE single_row_complex_returning SET v1 = $1 + 1 WHERE k = 1 RETURNING $1 * 2;'
   LANGUAGE SQL;
CREATE FUNCTION assign_one_plus_param_to_v1_hard(integer) RETURNS two_int
   AS 'UPDATE single_row_complex_returning SET v1 = $1 + 1 WHERE k = 1 RETURNING $1 * 2, v5 + 1;'
   LANGUAGE SQL;
-- Below statements should all USE single-row.
-- (1) Constant
EXPLAIN (COSTS FALSE) UPDATE single_row_complex_returning SET v1 = v1 + 1 WHERE k = 1 RETURNING 1;
               QUERY PLAN
----------------------------------------
 Update on single_row_complex_returning
   ->  Result
(2 rows)

-- (2) Column reference
EXPLAIN (COSTS FALSE) UPDATE single_row_complex_returning SET v1 = v1 + 1 WHERE k = 1 RETURNING v2, v3, array_int;
               QUERY PLAN
----------------------------------------
 Update on single_row_complex_returning
   ->  Result
(2 rows)

-- (3) Subscript
EXPLAIN (COSTS FALSE) UPDATE single_row_complex_returning SET v1 = v1 + 1 WHERE k = 1 RETURNING array_int[1];
               QUERY PLAN
----------------------------------------
 Update on single_row_complex_returning
   ->  Result
(2 rows)

-- (4) Field selection
EXPLAIN (COSTS FALSE) UPDATE single_row_complex_returning SET v1 = v1 + 1 WHERE k = 1 RETURNING (v3).first_text;
               QUERY PLAN
----------------------------------------
 Update on single_row_complex_returning
   ->  Result
(2 rows)

-- (5) Immutable Operator Invocation
EXPLAIN (COSTS FALSE) UPDATE single_row_complex_returning SET v1 = v1 + 1 WHERE k = 1 RETURNING v2||'abc';
               QUERY PLAN
----------------------------------------
 Update on single_row_complex_returning
   ->  Result
(2 rows)

-- (6) Immutable Function Call
EXPLAIN (COSTS FALSE) UPDATE single_row_complex_returning SET v1 = v1 + 1 WHERE k = 1 RETURNING power(v5, 2);
               QUERY PLAN
----------------------------------------
 Update on single_row_complex_returning
   ->  Result
(2 rows)

-- (7) Type Cast
EXPLAIN (COSTS FALSE) UPDATE single_row_complex_returning SET v1 = v1 + 1 WHERE k = 1 RETURNING v5::text;
               QUERY PLAN
----------------------------------------
 Update on single_row_complex_returning
   ->  Result
(2 rows)

-- (8) Collation Expression
EXPLAIN (COSTS FALSE) UPDATE single_row_complex_returning SET v1 = v1 + 1 WHERE k = 1 RETURNING v2 COLLATE "C";
               QUERY PLAN
----------------------------------------
 Update on single_row_complex_returning
   ->  Result
(2 rows)

-- (9) Array Constructor
EXPLAIN (COSTS FALSE) UPDATE single_row_complex_returning SET v1 = v1 + 1 WHERE k = 1 RETURNING ARRAY[[v1,2,v5], [2,3,v5+1]];
               QUERY PLAN
----------------------------------------
 Update on single_row_complex_returning
   ->  Result
(2 rows)

-- (10) Row Constructor
EXPLAIN (COSTS FALSE) UPDATE single_row_complex_returning SET v1 = v1 + 1 WHERE k = 1 RETURNING ROW(1,v2,v3,v5);
               QUERY PLAN
----------------------------------------
 Update on single_row_complex_returning
   ->  Result
(2 rows)

-- (11) Scalar Subquery
EXPLAIN (COSTS FALSE) UPDATE single_row_complex_returning SET v1 = v1 + 1 WHERE k = 1 RETURNING (SELECT MAX(v5)+1 from single_row_complex_returning);
                                      QUERY PLAN
---------------------------------------------------------------------------------------
 Update on single_row_complex_returning
   InitPlan 1 (returns $0)
     ->  Finalize Aggregate
           ->  Seq Scan on single_row_complex_returning single_row_complex_returning_1
                 Partial Aggregate: true
   ->  Result
(6 rows)

-- (12) Mutable function
EXPLAIN (COSTS FALSE) UPDATE single_row_complex_returning SET v1 = v1 + 1 WHERE k = 1 RETURNING assign_one_plus_param_to_v1(1);
               QUERY PLAN
----------------------------------------
 Update on single_row_complex_returning
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_complex_returning SET v1 = v1 + 1 WHERE k = 1 RETURNING assign_one_plus_param_to_v1(v1);
               QUERY PLAN
----------------------------------------
 Update on single_row_complex_returning
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_complex_returning SET v1 = v1 + 1 WHERE k = 1 RETURNING assign_one_plus_param_to_v1_hard(v1);
               QUERY PLAN
----------------------------------------
 Update on single_row_complex_returning
   ->  Result
(2 rows)

-- Test execution
INSERT INTO single_row_complex_returning VALUES (1, 1, 'xyz', ('a','b'), '{11, 11, 11}', 1);
UPDATE single_row_complex_returning SET v1 = v1 + 1 WHERE k = 1 RETURNING 1, v2, array_int[1], (v3).first_text;
 ?column? | v2  | array_int | first_text
----------+-----+-----------+------------
        1 | xyz |        11 | a
(1 row)

SELECT * FROM single_row_complex_returning;
 k | v1 | v2  |  v3   | array_int  | v5
---+----+-----+-------+------------+----
 1 |  2 | xyz | (a,b) | {11,11,11} |  1
(1 row)

UPDATE single_row_complex_returning SET v1 = v1 + 1 WHERE k = 1 RETURNING v2||'abc', power(v5, 2), v5::text, v2 COLLATE "C";
 ?column? | power | v5 | v2
----------+-------+----+-----
 xyzabc   |     1 | 1  | xyz
(1 row)

SELECT * FROM single_row_complex_returning;
 k | v1 | v2  |  v3   | array_int  | v5
---+----+-----+-------+------------+----
 1 |  3 | xyz | (a,b) | {11,11,11} |  1
(1 row)

UPDATE single_row_complex_returning SET v1 = v1 + 1 WHERE k = 1 RETURNING ARRAY[[v1,2,v5], [2,3,v5+1]];
       array
-------------------
 {{4,2,1},{2,3,2}}
(1 row)

SELECT * FROM single_row_complex_returning;
 k | v1 | v2  |  v3   | array_int  | v5
---+----+-----+-------+------------+----
 1 |  4 | xyz | (a,b) | {11,11,11} |  1
(1 row)

UPDATE single_row_complex_returning SET v1 = v1 + 1 WHERE k = 1 RETURNING ROW(1,v2,v3,v5);
        row
-------------------
 (1,xyz,"(a,b)",1)
(1 row)

SELECT * FROM single_row_complex_returning;
 k | v1 | v2  |  v3   | array_int  | v5
---+----+-----+-------+------------+----
 1 |  5 | xyz | (a,b) | {11,11,11} |  1
(1 row)

UPDATE single_row_complex_returning SET v1 = v1 + 1 WHERE k = 1 RETURNING (SELECT MAX(v5)+1 from single_row_complex_returning);
 ?column?
----------
        2
(1 row)

SELECT * FROM single_row_complex_returning;
 k | v1 | v2  |  v3   | array_int  | v5
---+----+-----+-------+------------+----
 1 |  6 | xyz | (a,b) | {11,11,11} |  1
(1 row)

UPDATE single_row_complex_returning SET v1 = v1 + 1 WHERE k = 1 RETURNING assign_one_plus_param_to_v1(1);
 assign_one_plus_param_to_v1
-----------------------------
                           2
(1 row)

SELECT * FROM single_row_complex_returning;
 k | v1 | v2  |  v3   | array_int  | v5
---+----+-----+-------+------------+----
 1 |  2 | xyz | (a,b) | {11,11,11} |  1
(1 row)

UPDATE single_row_complex_returning SET v1 = v1 + 1 WHERE k = 1 RETURNING assign_one_plus_param_to_v1(v1);
 assign_one_plus_param_to_v1
-----------------------------
                           6
(1 row)

SELECT * FROM single_row_complex_returning;
 k | v1 | v2  |  v3   | array_int  | v5
---+----+-----+-------+------------+----
 1 |  4 | xyz | (a,b) | {11,11,11} |  1
(1 row)

UPDATE single_row_complex_returning SET v1 = v1 + 1 WHERE k = 1 RETURNING assign_one_plus_param_to_v1_hard(v1);
 assign_one_plus_param_to_v1_hard
----------------------------------
 (10,2)
(1 row)

SELECT * FROM single_row_complex_returning;
 k | v1 | v2  |  v3   | array_int  | v5
---+----+-----+-------+------------+----
 1 |  6 | xyz | (a,b) | {11,11,11} |  1
(1 row)

--
-- Test table without a primary key.
--
CREATE TABLE single_row_no_primary_key (a int, b int);
-- Below statements should all NOT USE single-row.
EXPLAIN (COSTS FALSE) DELETE FROM single_row_no_primary_key;
                 QUERY PLAN
---------------------------------------------
 Delete on single_row_no_primary_key
   ->  Seq Scan on single_row_no_primary_key
(2 rows)

EXPLAIN (COSTS FALSE) DELETE FROM single_row_no_primary_key WHERE a = 1;
                 QUERY PLAN
---------------------------------------------
 Delete on single_row_no_primary_key
   ->  Seq Scan on single_row_no_primary_key
         Storage Filter: (a = 1)
(3 rows)

EXPLAIN (COSTS FALSE) DELETE FROM single_row_no_primary_key WHERE a = 1 and b = 1;
                  QUERY PLAN
-----------------------------------------------
 Delete on single_row_no_primary_key
   ->  Seq Scan on single_row_no_primary_key
         Storage Filter: ((a = 1) AND (b = 1))
(3 rows)

-- Below statements should all NOT USE single-row.
EXPLAIN (COSTS FALSE) UPDATE single_row_no_primary_key SET a = 1;
                 QUERY PLAN
---------------------------------------------
 Update on single_row_no_primary_key
   ->  Seq Scan on single_row_no_primary_key
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_no_primary_key SET b = 1 WHERE a = 1;
                 QUERY PLAN
---------------------------------------------
 Update on single_row_no_primary_key
   ->  Seq Scan on single_row_no_primary_key
         Storage Filter: (a = 1)
(3 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_no_primary_key SET b = 1 WHERE b = 1;
                 QUERY PLAN
---------------------------------------------
 Update on single_row_no_primary_key
   ->  Seq Scan on single_row_no_primary_key
         Storage Filter: (b = 1)
(3 rows)

--
-- Test table with range primary key (ASC).
--
CREATE TABLE single_row_range_asc_primary_key (k int, v int, primary key (k ASC));
-- Below statements should all USE single-row.
EXPLAIN (COSTS FALSE) DELETE FROM single_row_range_asc_primary_key WHERE k = 1;
                 QUERY PLAN
--------------------------------------------
 Delete on single_row_range_asc_primary_key
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_range_asc_primary_key SET v = 1 WHERE k = 1;
                 QUERY PLAN
--------------------------------------------
 Update on single_row_range_asc_primary_key
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_range_asc_primary_key SET v = 1 + 2 WHERE k = 1;
                 QUERY PLAN
--------------------------------------------
 Update on single_row_range_asc_primary_key
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_range_asc_primary_key SET v = ceil(2.5 + power(2,2)) WHERE k = 4;
                 QUERY PLAN
--------------------------------------------
 Update on single_row_range_asc_primary_key
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_range_asc_primary_key SET v = v + 1 WHERE k = 1;
                 QUERY PLAN
--------------------------------------------
 Update on single_row_range_asc_primary_key
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_range_asc_primary_key SET v = v + k WHERE k = 1;
                 QUERY PLAN
--------------------------------------------
 Update on single_row_range_asc_primary_key
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_range_asc_primary_key SET v = abs(5 - k) WHERE k = 1;
                 QUERY PLAN
--------------------------------------------
 Update on single_row_range_asc_primary_key
   ->  Result
(2 rows)

-- Below statements should all NOT USE single-row.
EXPLAIN (COSTS FALSE) UPDATE single_row_range_asc_primary_key SET v = 1 WHERE k > 1;
                                            QUERY PLAN
--------------------------------------------------------------------------------------------------
 Update on single_row_range_asc_primary_key
   ->  Index Scan using single_row_range_asc_primary_key_pkey on single_row_range_asc_primary_key
         Index Cond: (k > 1)
(3 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_range_asc_primary_key SET v = 1 WHERE k != 1;
                     QUERY PLAN
----------------------------------------------------
 Update on single_row_range_asc_primary_key
   ->  Seq Scan on single_row_range_asc_primary_key
         Storage Filter: (k <> 1)
(3 rows)

-- Test execution
INSERT INTO single_row_range_asc_primary_key(k,v) values (1,1), (2,2), (3,3), (4,4);
UPDATE single_row_range_asc_primary_key SET v = 10 WHERE k = 1;
SELECT * FROM single_row_range_asc_primary_key;
 k | v
---+----
 1 | 10
 2 |  2
 3 |  3
 4 |  4
(4 rows)

UPDATE single_row_range_asc_primary_key SET v = v + 1 WHERE k = 2;
SELECT * FROM single_row_range_asc_primary_key;
 k | v
---+----
 1 | 10
 2 |  3
 3 |  3
 4 |  4
(4 rows)

UPDATE single_row_range_asc_primary_key SET v = -3 WHERE k < 4 AND k >= 3;
SELECT * FROM single_row_range_asc_primary_key;
 k | v
---+----
 1 | 10
 2 |  3
 3 | -3
 4 |  4
(4 rows)

UPDATE single_row_range_asc_primary_key SET v = ceil(2.5 + power(2,2)) WHERE k = 4;
SELECT * FROM single_row_range_asc_primary_key;
 k | v
---+----
 1 | 10
 2 |  3
 3 | -3
 4 |  7
(4 rows)

DELETE FROM single_row_range_asc_primary_key WHERE k < 3;
SELECT * FROM single_row_range_asc_primary_key;
 k | v
---+----
 3 | -3
 4 |  7
(2 rows)

DELETE FROM single_row_range_asc_primary_key WHERE k = 4;
SELECT * FROM single_row_range_asc_primary_key;
 k | v
---+----
 3 | -3
(1 row)

--
-- Test table with range primary key (DESC).
--
CREATE TABLE single_row_range_desc_primary_key (k int, v int, primary key (k DESC));
-- Below statements should all USE single-row.
EXPLAIN (COSTS FALSE) DELETE FROM single_row_range_desc_primary_key WHERE k = 1;
                 QUERY PLAN
---------------------------------------------
 Delete on single_row_range_desc_primary_key
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_range_desc_primary_key SET v = 1 WHERE k = 1;
                 QUERY PLAN
---------------------------------------------
 Update on single_row_range_desc_primary_key
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_range_desc_primary_key SET v = 1 + 2 WHERE k = 1;
                 QUERY PLAN
---------------------------------------------
 Update on single_row_range_desc_primary_key
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_range_desc_primary_key SET v = ceil(2.5 + power(2,2)) WHERE k = 4;
                 QUERY PLAN
---------------------------------------------
 Update on single_row_range_desc_primary_key
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_range_desc_primary_key SET v = v + 1 WHERE k = 1;
                 QUERY PLAN
---------------------------------------------
 Update on single_row_range_desc_primary_key
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_range_desc_primary_key SET v = k + 1 WHERE k = 1;
                 QUERY PLAN
---------------------------------------------
 Update on single_row_range_desc_primary_key
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_range_desc_primary_key SET v = abs(5 - k) WHERE k = 1;
                 QUERY PLAN
---------------------------------------------
 Update on single_row_range_desc_primary_key
   ->  Result
(2 rows)

-- Below statements should all NOT USE single-row.
EXPLAIN (COSTS FALSE) UPDATE single_row_range_desc_primary_key SET v = 1 WHERE k > 1;
                                             QUERY PLAN
----------------------------------------------------------------------------------------------------
 Update on single_row_range_desc_primary_key
   ->  Index Scan using single_row_range_desc_primary_key_pkey on single_row_range_desc_primary_key
         Index Cond: (k > 1)
(3 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_range_desc_primary_key SET v = 1 WHERE k != 1;
                     QUERY PLAN
-----------------------------------------------------
 Update on single_row_range_desc_primary_key
   ->  Seq Scan on single_row_range_desc_primary_key
         Storage Filter: (k <> 1)
(3 rows)

-- Test execution
INSERT INTO single_row_range_desc_primary_key(k,v) values (1,1), (2,2), (3,3), (4,4);
UPDATE single_row_range_desc_primary_key SET v = 10 WHERE k = 1;
SELECT * FROM single_row_range_desc_primary_key;
 k | v
---+----
 4 |  4
 3 |  3
 2 |  2
 1 | 10
(4 rows)

UPDATE single_row_range_desc_primary_key SET v = v + 1 WHERE k = 2;
SELECT * FROM single_row_range_desc_primary_key;
 k | v
---+----
 4 |  4
 3 |  3
 2 |  3
 1 | 10
(4 rows)

UPDATE single_row_range_desc_primary_key SET v = -3 WHERE k < 4 AND k >= 3;
SELECT * FROM single_row_range_desc_primary_key;
 k | v
---+----
 4 |  4
 3 | -3
 2 |  3
 1 | 10
(4 rows)

UPDATE single_row_range_desc_primary_key SET v = ceil(2.5 + power(2,2)) WHERE k = 4;
SELECT * FROM single_row_range_desc_primary_key;
 k | v
---+----
 4 |  7
 3 | -3
 2 |  3
 1 | 10
(4 rows)

DELETE FROM single_row_range_desc_primary_key WHERE k < 3;
SELECT * FROM single_row_range_desc_primary_key;
 k | v
---+----
 4 |  7
 3 | -3
(2 rows)

DELETE FROM single_row_range_desc_primary_key WHERE k = 4;
SELECT * FROM single_row_range_desc_primary_key;
 k | v
---+----
 3 | -3
(1 row)

--
-- Test tables with constraints.
--
CREATE TABLE single_row_not_null_constraints (k int PRIMARY KEY, v1 int NOT NULL, v2 int NOT NULL);
CREATE TABLE single_row_check_constraints (k int PRIMARY KEY, v1 int NOT NULL, v2 int CHECK (v2 >= 0));
CREATE TABLE single_row_check_constraints2 (k int PRIMARY KEY, v1 int NOT NULL, v2 int CHECK (v1 >= v2));
-- Below statements should all USE single-row.
EXPLAIN (COSTS FALSE) DELETE FROM single_row_not_null_constraints WHERE k = 1;
                QUERY PLAN
-------------------------------------------
 Delete on single_row_not_null_constraints
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) DELETE FROM single_row_check_constraints WHERE k = 1;
               QUERY PLAN
----------------------------------------
 Delete on single_row_check_constraints
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) DELETE FROM single_row_check_constraints2 WHERE k = 1;
               QUERY PLAN
-----------------------------------------
 Delete on single_row_check_constraints2
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_not_null_constraints SET v1 = 2 WHERE k = 1;
                QUERY PLAN
-------------------------------------------
 Update on single_row_not_null_constraints
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_not_null_constraints SET v2 = 2 WHERE k = 1;
                QUERY PLAN
-------------------------------------------
 Update on single_row_not_null_constraints
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_not_null_constraints SET v2 = v2 + null WHERE k = 1;
                QUERY PLAN
-------------------------------------------
 Update on single_row_not_null_constraints
   ->  Result
(2 rows)

-- Below statements should all NOT USE single-row.
EXPLAIN (COSTS FALSE) UPDATE single_row_check_constraints SET v1 = 2 WHERE k = 1;
                                        QUERY PLAN
------------------------------------------------------------------------------------------
 Update on single_row_check_constraints
   ->  Index Scan using single_row_check_constraints_pkey on single_row_check_constraints
         Index Cond: (k = 1)
(3 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_check_constraints SET v2 = 2 WHERE k = 1;
                                        QUERY PLAN
------------------------------------------------------------------------------------------
 Update on single_row_check_constraints
   ->  Index Scan using single_row_check_constraints_pkey on single_row_check_constraints
         Index Cond: (k = 1)
(3 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_check_constraints2 SET v1 = 2 WHERE k = 1;
                                         QUERY PLAN
--------------------------------------------------------------------------------------------
 Update on single_row_check_constraints2
   ->  Index Scan using single_row_check_constraints2_pkey on single_row_check_constraints2
         Index Cond: (k = 1)
(3 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_check_constraints2 SET v2 = 2 WHERE k = 1;
                                         QUERY PLAN
--------------------------------------------------------------------------------------------
 Update on single_row_check_constraints2
   ->  Index Scan using single_row_check_constraints2_pkey on single_row_check_constraints2
         Index Cond: (k = 1)
(3 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_not_null_constraints SET v2 = v2 + 3 WHERE k = 1;
                                           QUERY PLAN
------------------------------------------------------------------------------------------------
 Update on single_row_not_null_constraints
   ->  Index Scan using single_row_not_null_constraints_pkey on single_row_not_null_constraints
         Index Cond: (k = 1)
(3 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_not_null_constraints SET v1 = abs(v1), v2 = power(v2,2) WHERE k = 1;
                                           QUERY PLAN
------------------------------------------------------------------------------------------------
 Update on single_row_not_null_constraints
   ->  Index Scan using single_row_not_null_constraints_pkey on single_row_not_null_constraints
         Index Cond: (k = 1)
(3 rows)

-- Test execution.
INSERT INTO single_row_not_null_constraints(k,v1, v2) values (1,1,1), (2,2,2), (3,3,3);
UPDATE single_row_not_null_constraints SET v1 = 2 WHERE k = 1;
UPDATE single_row_not_null_constraints SET v2 = v2 + 3 WHERE k = 1;
DELETE FROM single_row_not_null_constraints where k = 3;
SELECT * FROM single_row_not_null_constraints ORDER BY k;
 k | v1 | v2
---+----+----
 1 |  2 |  4
 2 |  2 |  2
(2 rows)

UPDATE single_row_not_null_constraints SET v1 = abs(v1), v2 = power(v2,2) WHERE k = 1;
SELECT * FROM single_row_not_null_constraints ORDER BY k;
 k | v1 | v2
---+----+----
 1 |  2 | 16
 2 |  2 |  2
(2 rows)

-- Should fail constraint check.
UPDATE single_row_not_null_constraints SET v2 = v2 + null WHERE k = 1;
ERROR:  null value in column "v2" of relation "single_row_not_null_constraints" violates not-null constraint
DETAIL:  Failing row contains (1, null, null).
-- Should update 0 rows (non-existent key).
UPDATE single_row_not_null_constraints SET v2 = v2 + 2 WHERE k = 4;
SELECT * FROM single_row_not_null_constraints ORDER BY k;
 k | v1 | v2
---+----+----
 1 |  2 | 16
 2 |  2 |  2
(2 rows)

INSERT INTO single_row_check_constraints(k,v1, v2) values (1,1,1), (2,2,2), (3,3,3);
UPDATE single_row_check_constraints SET v1 = 2 WHERE k = 1;
UPDATE single_row_check_constraints SET v2 = 3 WHERE k = 1;
UPDATE single_row_check_constraints SET v2 = -3 WHERE k = 1;
ERROR:  new row for relation "single_row_check_constraints" violates check constraint "single_row_check_constraints_v2_check"
DETAIL:  Failing row contains (1, 2, -3).
DELETE FROM single_row_check_constraints where k = 3;
SELECT * FROM single_row_check_constraints ORDER BY k;
 k | v1 | v2
---+----+----
 1 |  2 |  3
 2 |  2 |  2
(2 rows)

INSERT INTO single_row_check_constraints2(k,v1, v2) values (1,1,1), (2,2,2), (3,3,3);
UPDATE single_row_check_constraints2 SET v1 = 2 WHERE k = 1;
UPDATE single_row_check_constraints2 SET v2 = 3 WHERE k = 1;
ERROR:  new row for relation "single_row_check_constraints2" violates check constraint "single_row_check_constraints2_check"
DETAIL:  Failing row contains (1, 2, 3).
UPDATE single_row_check_constraints2 SET v2 = 1 WHERE k = 1;
DELETE FROM single_row_check_constraints2 where k = 3;
SELECT * FROM single_row_check_constraints2 ORDER BY k;
 k | v1 | v2
---+----+----
 1 |  2 |  1
 2 |  2 |  2
(2 rows)

--
-- Test table with decimal.
--
CREATE TABLE single_row_decimal (k int PRIMARY KEY, v1 decimal, v2 decimal(10,2), v3 int);
CREATE FUNCTION next_v3(int) returns int language sql as $$
  SELECT v3 + 1 FROM single_row_decimal WHERE k = $1;
$$;
-- Below statements should all USE single-row.
EXPLAIN (COSTS FALSE) UPDATE single_row_decimal SET v1 = 1.555 WHERE k = 1;
          QUERY PLAN
------------------------------
 Update on single_row_decimal
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_decimal SET v1 = v1 + 1.555 WHERE k = 1;
          QUERY PLAN
------------------------------
 Update on single_row_decimal
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_decimal SET v2 = 1.555 WHERE k = 1;
          QUERY PLAN
------------------------------
 Update on single_row_decimal
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_decimal SET v2 = v2 + 1.555 WHERE k = 1;
          QUERY PLAN
------------------------------
 Update on single_row_decimal
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_decimal SET v3 = 1 WHERE k = 1;
          QUERY PLAN
------------------------------
 Update on single_row_decimal
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_decimal SET v3 = v3 + 1 WHERE k = 1;
          QUERY PLAN
------------------------------
 Update on single_row_decimal
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_decimal SET v1 = v1 + 1.555, v2 = v2 + 1.555, v3 = 3 WHERE k = 1;
          QUERY PLAN
------------------------------
 Update on single_row_decimal
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_decimal SET v1 = v1 + 1.555, v2 = v2 + 1.555, v3 = next_v3(1) WHERE k = 1;
          QUERY PLAN
------------------------------
 Update on single_row_decimal
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_decimal SET v1 = v1 + 1.555, v2 = v2 + 1.555, v3 = v3 + 1 WHERE k = 1;
          QUERY PLAN
------------------------------
 Update on single_row_decimal
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_decimal SET v1 = v1 + null WHERE k = 2;
          QUERY PLAN
------------------------------
 Update on single_row_decimal
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_decimal SET v2 = null + v2 WHERE k = 2;
          QUERY PLAN
------------------------------
 Update on single_row_decimal
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_decimal SET v3 = v3 + 4 * (null - 5) WHERE k = 2;
          QUERY PLAN
------------------------------
 Update on single_row_decimal
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_decimal SET v1 = v2 + 1.555 WHERE k = 1;
          QUERY PLAN
------------------------------
 Update on single_row_decimal
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_decimal SET v2 = k + 1.555 WHERE k = 1;
          QUERY PLAN
------------------------------
 Update on single_row_decimal
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_decimal SET v3 = k - v3 WHERE k = 1;
          QUERY PLAN
------------------------------
 Update on single_row_decimal
   ->  Result
(2 rows)

-- Test execution.
INSERT INTO single_row_decimal(k, v1, v2, v3) values (1,1.5,1.5,1), (2,2.5,2.5,2), (3,null, null,null);
SELECT * FROM single_row_decimal ORDER BY k;
 k | v1  |  v2  | v3
---+-----+------+----
 1 | 1.5 | 1.50 |  1
 2 | 2.5 | 2.50 |  2
 3 |     |      |
(3 rows)

UPDATE single_row_decimal SET v1 = v1 + 1.555, v2 = v2 + 1.555, v3 = v3 + 1 WHERE k = 1;
-- v2 should be rounded to 2 decimals.
SELECT * FROM single_row_decimal ORDER BY k;
 k |  v1   |  v2  | v3
---+-------+------+----
 1 | 3.055 | 3.06 |  2
 2 |   2.5 | 2.50 |  2
 3 |       |      |
(3 rows)

UPDATE single_row_decimal SET v1 = v1 + 1.555, v2 = v2 + 1.555, v3 = 3 WHERE k = 1;
SELECT * FROM single_row_decimal ORDER BY k;
 k |  v1  |  v2  | v3
---+------+------+----
 1 | 4.61 | 4.62 |  3
 2 |  2.5 | 2.50 |  2
 3 |      |      |
(3 rows)

UPDATE single_row_decimal SET v1 = v1 + 1.555, v2 = v2 + 1.555, v3 = next_v3(1) WHERE k = 1;
SELECT * FROM single_row_decimal ORDER BY k;
 k |  v1   |  v2  | v3
---+-------+------+----
 1 | 6.165 | 6.18 |  4
 2 |   2.5 | 2.50 |  2
 3 |       |      |
(3 rows)

-- Test null arguments, all expressions should evaluate to null.
UPDATE single_row_decimal SET v1 = v1 + null WHERE k = 2;
UPDATE single_row_decimal SET v2 = null + v2 WHERE k = 2;
UPDATE single_row_decimal SET v3 = v3 + 4 * (null - 5) WHERE k = 2;
SELECT * FROM single_row_decimal ORDER BY k;
 k |  v1   |  v2  | v3
---+-------+------+----
 1 | 6.165 | 6.18 |  4
 2 |       |      |
 3 |       |      |
(3 rows)

-- Test null values, all expressions should evaluate to null.
UPDATE single_row_decimal SET v1 = v1 + 1.555 WHERE k = 3;
UPDATE single_row_decimal SET v2 = v2 + 1.555 WHERE k = 3;
UPDATE single_row_decimal SET v3 = v3 + 1 WHERE k = 3;
SELECT * FROM single_row_decimal ORDER BY k;
 k |  v1   |  v2  | v3
---+-------+------+----
 1 | 6.165 | 6.18 |  4
 2 |       |      |
 3 |       |      |
(3 rows)

--
-- Test table with foreign key constraint.
-- Should still try single-row if (and only if) the FK column is not updated.
--
CREATE TABLE single_row_decimal_fk(k int PRIMARY KEY);
INSERT INTO single_row_decimal_fk(k) VALUES (1), (2), (3), (4);
ALTER TABLE single_row_decimal ADD FOREIGN KEY (v3) REFERENCES single_row_decimal_fk(k);
-- Below statements should all USE single-row.
EXPLAIN (COSTS FALSE) UPDATE single_row_decimal SET v1 = 1.555 WHERE k = 4;
          QUERY PLAN
------------------------------
 Update on single_row_decimal
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_decimal SET v1 = v1 + 1.555 WHERE k = 4;
          QUERY PLAN
------------------------------
 Update on single_row_decimal
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_decimal SET v2 = 1.555 WHERE k = 4;
          QUERY PLAN
------------------------------
 Update on single_row_decimal
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_decimal SET v2 = v2 + 1.555 WHERE k = 4;
          QUERY PLAN
------------------------------
 Update on single_row_decimal
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_decimal SET v1 = v2 + 1.555 WHERE k = 4;
          QUERY PLAN
------------------------------
 Update on single_row_decimal
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_decimal SET v2 = k + 1.555 WHERE k = 4;
          QUERY PLAN
------------------------------
 Update on single_row_decimal
   ->  Result
(2 rows)

-- Below statements should all NOT USE single-row.
EXPLAIN (COSTS FALSE) UPDATE single_row_decimal SET v3 = 1 WHERE k = 4;
                              QUERY PLAN
----------------------------------------------------------------------
 Update on single_row_decimal
   ->  Index Scan using single_row_decimal_pkey on single_row_decimal
         Index Cond: (k = 4)
(3 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_decimal SET v3 = v3 + 1 WHERE k = 4;
                              QUERY PLAN
----------------------------------------------------------------------
 Update on single_row_decimal
   ->  Index Scan using single_row_decimal_pkey on single_row_decimal
         Index Cond: (k = 4)
(3 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_decimal SET v3 = k - v3 WHERE k = 4;
                              QUERY PLAN
----------------------------------------------------------------------
 Update on single_row_decimal
   ->  Index Scan using single_row_decimal_pkey on single_row_decimal
         Index Cond: (k = 4)
(3 rows)

-- Test execution.
INSERT INTO single_row_decimal(k, v1, v2, v3) values (4,4.5,4.5,4);
SELECT * FROM single_row_decimal ORDER BY k;
 k |  v1   |  v2  | v3
---+-------+------+----
 1 | 6.165 | 6.18 |  4
 2 |       |      |
 3 |       |      |
 4 |   4.5 | 4.50 |  4
(4 rows)

UPDATE single_row_decimal SET v1 = v1 + 4.555 WHERE k = 4;
UPDATE single_row_decimal SET v2 = v2 + 4.555 WHERE k = 4;
UPDATE single_row_decimal SET v3 = v3 + 4 WHERE k = 4;
ERROR:  insert or update on table "single_row_decimal" violates foreign key constraint "single_row_decimal_v3_fkey"
DETAIL:  Key (v3)=(8) is not present in table "single_row_decimal_fk".
-- v2 should be rounded to 2 decimals.
SELECT * FROM single_row_decimal ORDER BY k;
 k |  v1   |  v2  | v3
---+-------+------+----
 1 | 6.165 | 6.18 |  4
 2 |       |      |
 3 |       |      |
 4 | 9.055 | 9.06 |  4
(4 rows)

--
-- Test table with indexes.
-- Should use single-row for expressions if (and only if) the indexed columns are not updated.
--
CREATE TABLE single_row_index(k int PRIMARY KEY, v1 smallint, v2 smallint, v3 smallint);
-- Below statements should all USE single-row.
EXPLAIN (COSTS FALSE) UPDATE single_row_index SET v1 = 1 WHERE k = 1;
         QUERY PLAN
----------------------------
 Update on single_row_index
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_index SET v1 = v1 + 1 WHERE k = 1;
         QUERY PLAN
----------------------------
 Update on single_row_index
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_index SET v2 = 2 WHERE k = 1;
         QUERY PLAN
----------------------------
 Update on single_row_index
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_index SET v2 = v2 + 2 WHERE k = 1;
         QUERY PLAN
----------------------------
 Update on single_row_index
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_index SET v3 = 3 WHERE k = 1;
         QUERY PLAN
----------------------------
 Update on single_row_index
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_index SET v3 = v3 + 3 WHERE k = 1;
         QUERY PLAN
----------------------------
 Update on single_row_index
   ->  Result
(2 rows)

CREATE INDEX single_row_index_idx on single_row_index(v1) include (v3);
-- Below statements should all USE single-row.
EXPLAIN (COSTS FALSE) UPDATE single_row_index SET v2 = 2 WHERE k = 1;
         QUERY PLAN
----------------------------
 Update on single_row_index
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_index SET v2 = v2 + 2 WHERE k = 1;
         QUERY PLAN
----------------------------
 Update on single_row_index
   ->  Result
(2 rows)

-- Below statements should all NOT USE single-row.
EXPLAIN (COSTS FALSE) UPDATE single_row_index SET v1 = 1 WHERE k = 1;
                            QUERY PLAN
------------------------------------------------------------------
 Update on single_row_index
   ->  Index Scan using single_row_index_pkey on single_row_index
         Index Cond: (k = 1)
(3 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_index SET v1 = v1 + 1 WHERE k = 1;
                            QUERY PLAN
------------------------------------------------------------------
 Update on single_row_index
   ->  Index Scan using single_row_index_pkey on single_row_index
         Index Cond: (k = 1)
(3 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_index SET v3 = 3 WHERE k = 1;
                            QUERY PLAN
------------------------------------------------------------------
 Update on single_row_index
   ->  Index Scan using single_row_index_pkey on single_row_index
         Index Cond: (k = 1)
(3 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_index SET v3 = v3 + 3 WHERE k = 1;
                            QUERY PLAN
------------------------------------------------------------------
 Update on single_row_index
   ->  Index Scan using single_row_index_pkey on single_row_index
         Index Cond: (k = 1)
(3 rows)

-- Test execution.
INSERT INTO single_row_index(k, v1, v2, v3) VALUES (1,0,0,0), (2,2,32000,2);
SELECT * FROM single_row_index ORDER BY k;
 k | v1 |  v2   | v3
---+----+-------+----
 1 |  0 |     0 |  0
 2 |  2 | 32000 |  2
(2 rows)

UPDATE single_row_index SET v1 = 1 WHERE k = 1;
UPDATE single_row_index SET v2 = 2 WHERE k = 1;
UPDATE single_row_index SET v3 = 3 WHERE k = 1;
SELECT * FROM single_row_index ORDER BY k;
 k | v1 |  v2   | v3
---+----+-------+----
 1 |  1 |     2 |  3
 2 |  2 | 32000 |  2
(2 rows)

UPDATE single_row_index SET v1 = v1 + 1 WHERE k = 1;
UPDATE single_row_index SET v2 = v2 + 2 WHERE k = 1;
UPDATE single_row_index SET v3 = v3 + 3 WHERE k = 1;
SELECT * FROM single_row_index ORDER BY k;
 k | v1 |  v2   | v3
---+----+-------+----
 1 |  2 |     4 |  6
 2 |  2 | 32000 |  2
(2 rows)

-- Test error reporting (overflow).
EXPLAIN (COSTS FALSE) UPDATE single_row_index SET v2 = v2 + 1000 WHERE k = 2;
         QUERY PLAN
----------------------------
 Update on single_row_index
   ->  Result
(2 rows)

UPDATE single_row_index SET v2 = v2 + 1000 WHERE k = 2;
ERROR:  smallint out of range
-- Test column ordering.
CREATE TABLE single_row_col_order(a int, b int, c int, d int, e int, primary key(d, b));
-- Below statements should all USE single-row.
EXPLAIN (COSTS OFF) UPDATE single_row_col_order SET c = 6, a = 2, e = 10 WHERE b = 2 and d = 4;
           QUERY PLAN
--------------------------------
 Update on single_row_col_order
   ->  Result
(2 rows)

EXPLAIN (COSTS OFF) UPDATE single_row_col_order SET c = c * c, a = a * 2, e = power(e, 2) WHERE b = 2 and d = 4;
           QUERY PLAN
--------------------------------
 Update on single_row_col_order
   ->  Result
(2 rows)

EXPLAIN (COSTS OFF) DELETE FROM single_row_col_order WHERE b = 2 and d = 4;
           QUERY PLAN
--------------------------------
 Delete on single_row_col_order
   ->  Result
(2 rows)

EXPLAIN (COSTS OFF) UPDATE single_row_col_order SET c = 6, a = c + 2, e = 10 WHERE b = 2 and d = 4;
           QUERY PLAN
--------------------------------
 Update on single_row_col_order
   ->  Result
(2 rows)

EXPLAIN (COSTS OFF) UPDATE single_row_col_order SET c = c * b, a = a * 2, e = power(e, 2) WHERE b = 2 and d = 4;
           QUERY PLAN
--------------------------------
 Update on single_row_col_order
   ->  Result
(2 rows)

-- Test execution.
INSERT INTO single_row_col_order(a,b,c,d,e) VALUES (1,2,3,4,5), (2,3,4,5,6);
UPDATE single_row_col_order SET c = 6, a = 2, e = 10 WHERE b = 2 and d = 4;
SELECT * FROM single_row_col_order ORDER BY d, b;
 a | b | c | d | e
---+---+---+---+----
 2 | 2 | 6 | 4 | 10
 2 | 3 | 4 | 5 |  6
(2 rows)

UPDATE single_row_col_order SET c = c * c, a = a * 2, e = power(e, 2) WHERE d = 4 and b = 2;
SELECT * FROM single_row_col_order ORDER BY d, b;
 a | b | c  | d |  e
---+---+----+---+-----
 4 | 2 | 36 | 4 | 100
 2 | 3 |  4 | 5 |   6
(2 rows)

DELETE FROM single_row_col_order WHERE b = 2 and d = 4;
SELECT * FROM single_row_col_order ORDER BY d, b;
 a | b | c | d | e
---+---+---+---+---
 2 | 3 | 4 | 5 | 6
(1 row)

--
-- Test single-row with default values
--
CREATE TABLE single_row_default_col(k int PRIMARY KEY, a int default 10, b int default 20 not null, c int);
------------------
-- Test Planning
EXPLAIN (COSTS FALSE) UPDATE single_row_default_col SET a = 3 WHERE k = 2;
            QUERY PLAN
----------------------------------
 Update on single_row_default_col
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_default_col SET b = 3 WHERE k = 2;
            QUERY PLAN
----------------------------------
 Update on single_row_default_col
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_default_col SET a = 3, c = 4 WHERE k = 2;
            QUERY PLAN
----------------------------------
 Update on single_row_default_col
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_default_col SET b = NULL, c = 5 WHERE k = 3;
            QUERY PLAN
----------------------------------
 Update on single_row_default_col
   ->  Result
(2 rows)

EXPLAIN (COSTS FALSE) UPDATE single_row_default_col SET a = 3, b = 3, c = 3 WHERE k = 2;
            QUERY PLAN
----------------------------------
 Update on single_row_default_col
   ->  Result
(2 rows)

------------------
-- Test Execution
-- Insert should use defaults for missing columns.
INSERT INTO single_row_default_col(k, a, b, c) VALUES (1, 1, 1, 1);
INSERT INTO single_row_default_col(k, c) VALUES (2, 2);
INSERT INTO single_row_default_col(k, a, c) VALUES (3, NULL, 3);
INSERT INTO single_row_default_col(k, a, c) VALUES (4, NULL, 4);
-- Setting b to null should not be allowed.
INSERT INTO single_row_default_col(k, a, b, c) VALUES (5, 5, NULL, 5);
ERROR:  null value in column "b" of relation "single_row_default_col" violates not-null constraint
DETAIL:  Failing row contains (5, 5, null, 5).
SELECT * FROM single_row_default_col ORDER BY k;
 k | a  | b  | c
---+----+----+---
 1 |  1 |  1 | 1
 2 | 10 | 20 | 2
 3 |    | 20 | 3
 4 |    | 20 | 4
(4 rows)

-- Updates should not modify the existing (non-updated) values.
UPDATE single_row_default_col SET b = 3 WHERE k = 2;
SELECT * FROM single_row_default_col ORDER BY k;
 k | a  | b  | c
---+----+----+---
 1 |  1 |  1 | 1
 2 | 10 |  3 | 2
 3 |    | 20 | 3
 4 |    | 20 | 4
(4 rows)

UPDATE single_row_default_col SET a = 3, c = 4 WHERE k = 2;
SELECT * FROM single_row_default_col ORDER BY k;
 k | a | b  | c
---+---+----+---
 1 | 1 |  1 | 1
 2 | 3 |  3 | 4
 3 |   | 20 | 3
 4 |   | 20 | 4
(4 rows)

-- a should stay null (because it was explicitly set).
UPDATE single_row_default_col SET b = 4, c = 5 WHERE k = 3;
SELECT * FROM single_row_default_col ORDER BY k;
 k | a | b  | c
---+---+----+---
 1 | 1 |  1 | 1
 2 | 3 |  3 | 4
 3 |   |  4 | 5
 4 |   | 20 | 4
(4 rows)

UPDATE single_row_default_col SET a = 4 WHERE k = 3;
SELECT * FROM single_row_default_col ORDER BY k;
 k | a | b  | c
---+---+----+---
 1 | 1 |  1 | 1
 2 | 3 |  3 | 4
 3 | 4 |  4 | 5
 4 |   | 20 | 4
(4 rows)

-- Setting b to null should not be allowed.
UPDATE single_row_default_col SET b = NULL, c = 5 WHERE k = 3;
ERROR:  null value in column "b" of relation "single_row_default_col" violates not-null constraint
DETAIL:  Failing row contains (3, null, null, 5).
SELECT * FROM single_row_default_col ORDER BY k;
 k | a | b  | c
---+---+----+---
 1 | 1 |  1 | 1
 2 | 3 |  3 | 4
 3 | 4 |  4 | 5
 4 |   | 20 | 4
(4 rows)

ALTER TABLE single_row_default_col ALTER COLUMN a SET DEFAULT 30;
-- Insert should use the new default.
INSERT INTO single_row_default_col(k, c) VALUES (5, 5);
SELECT * FROM single_row_default_col ORDER BY k;
 k | a  | b  | c
---+----+----+---
 1 |  1 |  1 | 1
 2 |  3 |  3 | 4
 3 |  4 |  4 | 5
 4 |    | 20 | 4
 5 | 30 | 20 | 5
(5 rows)

-- Updates should not modify the existing (non-updated) values.
UPDATE single_row_default_col SET a = 4 WHERE k = 4;
SELECT * FROM single_row_default_col ORDER BY k;
 k | a  | b  | c
---+----+----+---
 1 |  1 |  1 | 1
 2 |  3 |  3 | 4
 3 |  4 |  4 | 5
 4 |  4 | 20 | 4
 5 | 30 | 20 | 5
(5 rows)

UPDATE single_row_default_col SET c = 6, b = 5 WHERE k = 5;
SELECT * FROM single_row_default_col ORDER BY k;
 k | a  | b  | c
---+----+----+---
 1 |  1 |  1 | 1
 2 |  3 |  3 | 4
 3 |  4 |  4 | 5
 4 |  4 | 20 | 4
 5 | 30 |  5 | 6
(5 rows)

UPDATE single_row_default_col SET c = 7, b = 7, a = 7 WHERE k = 5;
SELECT * FROM single_row_default_col ORDER BY k;
 k | a | b  | c
---+---+----+---
 1 | 1 |  1 | 1
 2 | 3 |  3 | 4
 3 | 4 |  4 | 5
 4 | 4 | 20 | 4
 5 | 7 |  7 | 7
(5 rows)

-- Setting b to null should not be allowed.
UPDATE single_row_default_col SET b = NULL, c = 5 WHERE k = 3;
ERROR:  null value in column "b" of relation "single_row_default_col" violates not-null constraint
DETAIL:  Failing row contains (3, null, null, 5).
SELECT * FROM single_row_default_col ORDER BY k;
 k | a | b  | c
---+---+----+---
 1 | 1 |  1 | 1
 2 | 3 |  3 | 4
 3 | 4 |  4 | 5
 4 | 4 | 20 | 4
 5 | 7 |  7 | 7
(5 rows)

--
-- Test single-row with partial index
--
CREATE TABLE single_row_partial_index(k SERIAL PRIMARY KEY, value INT NOT NULL, status INT NOT NULL);
CREATE UNIQUE INDEX ON single_row_partial_index(value ASC) WHERE status = 10;
INSERT INTO single_row_partial_index(value, status) VALUES(1, 10), (2, 20), (3, 10), (4, 30);
EXPLAIN (COSTS OFF) SELECT * FROM single_row_partial_index WHERE status = 10;
                                   QUERY PLAN
---------------------------------------------------------------------------------
 Index Scan using single_row_partial_index_value_idx on single_row_partial_index
(1 row)

SELECT * FROM single_row_partial_index WHERE status = 10;
 k | value | status
---+-------+--------
 1 |     1 |     10
 3 |     3 |     10
(2 rows)

EXPLAIN (COSTS OFF) UPDATE single_row_partial_index SET status = 10 WHERE k = 2;
                                    QUERY PLAN
----------------------------------------------------------------------------------
 Update on single_row_partial_index
   ->  Index Scan using single_row_partial_index_pkey on single_row_partial_index
         Index Cond: (k = 2)
(3 rows)

UPDATE single_row_partial_index SET status = 10 WHERE k = 2;
SELECT * FROM single_row_partial_index WHERE status = 10;
 k | value | status
---+-------+--------
 1 |     1 |     10
 2 |     2 |     10
 3 |     3 |     10
(3 rows)

EXPLAIN (COSTS OFF) UPDATE single_row_partial_index SET status = 9 WHERE k = 1;
                                    QUERY PLAN
----------------------------------------------------------------------------------
 Update on single_row_partial_index
   ->  Index Scan using single_row_partial_index_pkey on single_row_partial_index
         Index Cond: (k = 1)
(3 rows)

UPDATE single_row_partial_index SET status = 9 WHERE k = 1;
SELECT * FROM single_row_partial_index WHERE status = 10;
 k | value | status
---+-------+--------
 2 |     2 |     10
 3 |     3 |     10
(2 rows)

--
-- Test single-row with index expression
--
CREATE TABLE single_row_expression_index(k SERIAL PRIMARY KEY, value text NOT NULL);
CREATE UNIQUE INDEX ON single_row_expression_index(lower(value) ASC);
INSERT INTO single_row_expression_index(value) VALUES('aBc'), ('deF'), ('HIJ');
EXPLAIN (COSTS OFF) SELECT * FROM single_row_expression_index WHERE lower(value)='def';
                                      QUERY PLAN
---------------------------------------------------------------------------------------
 Index Scan using single_row_expression_index_lower_idx on single_row_expression_index
   Index Cond: (lower(value) = 'def'::text)
(2 rows)

SELECT * FROM single_row_expression_index WHERE lower(value)='def';
 k | value
---+-------
 2 | deF
(1 row)

EXPLAIN (COSTS OFF) UPDATE single_row_expression_index SET value = 'kLm' WHERE k = 2;
                                       QUERY PLAN
----------------------------------------------------------------------------------------
 Update on single_row_expression_index
   ->  Index Scan using single_row_expression_index_pkey on single_row_expression_index
         Index Cond: (k = 2)
(3 rows)

UPDATE single_row_expression_index SET value = 'kLm' WHERE k = 2;
SELECT * FROM single_row_expression_index WHERE lower(value)='def';
 k | value
---+-------
(0 rows)

SELECT * FROM single_row_expression_index WHERE lower(value)='klm';
 k | value
---+-------
 2 | kLm
(1 row)

--
-- Test array types.
--
-----------------------------------
-- int[] arrays.
CREATE TABLE array_t1(k int PRIMARY KEY, arr int[]);
INSERT INTO array_t1(k, arr) VALUES (1, '{1, 2, 3, 4}'::int[]);
SELECT * FROM array_t1 ORDER BY k;
 k |    arr
---+-----------
 1 | {1,2,3,4}
(1 row)

-- the || operator.
UPDATE array_t1 SET arr = arr||'{5, 6}'::int[] WHERE k = 1;
SELECT * FROM array_t1 ORDER BY k;
 k |      arr
---+---------------
 1 | {1,2,3,4,5,6}
(1 row)

-- array_cat().
UPDATE array_t1 SET arr = array_cat(arr, '{7, 8}'::int[]) WHERE k = 1;
SELECT * FROM array_t1 ORDER BY k;
 k |        arr
---+-------------------
 1 | {1,2,3,4,5,6,7,8}
(1 row)

-- array_append().
UPDATE array_t1 SET arr = array_append(arr, 9::int) WHERE k = 1;
SELECT * FROM array_t1 ORDER BY k;
 k |         arr
---+---------------------
 1 | {1,2,3,4,5,6,7,8,9}
(1 row)

-- array_prepend().
UPDATE array_t1 SET arr = array_prepend(0::int, arr) WHERE k = 1;
SELECT * FROM array_t1 ORDER BY k;
 k |          arr
---+-----------------------
 1 | {0,1,2,3,4,5,6,7,8,9}
(1 row)

-- array_remove().
UPDATE array_t1 SET arr = array_remove(arr, 4) WHERE k = 1;
SELECT * FROM array_t1 ORDER BY k;
 k |         arr
---+---------------------
 1 | {0,1,2,3,5,6,7,8,9}
(1 row)

-- array_replace().
UPDATE array_t1 SET arr = array_replace(arr, 7, 77) WHERE k = 1;
SELECT * FROM array_t1 ORDER BY k;
 k |         arr
---+----------------------
 1 | {0,1,2,3,5,6,77,8,9}
(1 row)

-----------------------------------
-- text[] arrays.
CREATE TABLE array_t2(k int PRIMARY KEY, arr text[]);
INSERT INTO array_t2(k, arr) VALUES (1, '{a, b}'::text[]);
SELECT * FROM array_t2 ORDER BY k;
 k |  arr
---+-------
 1 | {a,b}
(1 row)

UPDATE array_t2 SET arr = array_replace(arr, 'b', 'p') WHERE k = 1;
SELECT * FROM array_t2 ORDER BY k;
 k |  arr
---+-------
 1 | {a,p}
(1 row)

UPDATE array_t2 SET arr = '{x, y, z}'::text[] WHERE k = 1;
SELECT * FROM array_t2 ORDER BY k;
 k |   arr
---+---------
 1 | {x,y,z}
(1 row)

UPDATE array_t2 SET arr[2] = 'q' where k = 1;
SELECT * FROM array_t2 ORDER BY k;
 k |   arr
---+---------
 1 | {x,q,z}
(1 row)

-----------------------------------
-- Arrays of composite types.
CREATE TYPE rt as (f1 int, f2 text);
CREATE TABLE array_t3(k int PRIMARY KEY, arr rt[] NOT NULL);
INSERT INTO array_t3(k, arr) VALUES (1, '{"(1,a)", "(2,b)"}'::rt[]);
SELECT * FROM array_t3 ORDER BY k;
 k |        arr
---+-------------------
 1 | {"(1,a)","(2,b)"}
(1 row)

UPDATE array_t3 SET arr = '{"(1,c)", "(2,d)"}'::rt[] WHERE k = 1;
SELECT * FROM array_t3 ORDER BY k;
 k |        arr
---+-------------------
 1 | {"(1,c)","(2,d)"}
(1 row)

UPDATE array_t3 SET arr[2] = '(2,e)'::rt WHERE k = 1;
SELECT * FROM array_t3 ORDER BY k;
 k |        arr
---+-------------------
 1 | {"(1,c)","(2,e)"}
(1 row)

UPDATE array_t3 SET arr = array_replace(arr, '(1,c)', '(1,p)') WHERE k = 1;
SELECT * FROM array_t3 ORDER BY k;
 k |        arr
---+-------------------
 1 | {"(1,p)","(2,e)"}
(1 row)

-----------------------------------
-- Test more builtin array types.
-- INT2ARRAYOID, FLOAT8ARRAYOID, CHARARRAYOID.
CREATE TABLE array_t4(k int PRIMARY KEY, arr1 int2[], arr2 double precision[], arr3 char[]);
INSERT INTO array_t4(k, arr1, arr2, arr3) VALUES (1, '{1, 2, 3}'::int2[], '{1.5, 2.25, 3.25}'::float[], '{a, b, c}'::char[]);
SELECT * FROM array_t4 ORDER BY k;
 k |  arr1   |      arr2       |  arr3
---+---------+-----------------+---------
 1 | {1,2,3} | {1.5,2.25,3.25} | {a,b,c}
(1 row)

-- array_replace().
UPDATE array_t4 SET arr1 = array_replace(arr1, 2::int2, 22::int2) WHERE k = 1;
UPDATE array_t4 SET arr2 = array_replace(arr2, 2.25::double precision, 22.25::double precision) WHERE k = 1;
UPDATE array_t4 SET arr3 = array_replace(arr3, 'b'::char, 'x'::char) WHERE k = 1;
SELECT * FROM array_t4 ORDER BY k;
 k |   arr1   |       arr2       |  arr3
---+----------+------------------+---------
 1 | {1,22,3} | {1.5,22.25,3.25} | {a,x,c}
(1 row)

-- array_cat().
UPDATE array_t4 SET arr1 = array_cat(arr1, '{4, 5}'::int2[]) WHERE k = 1;
UPDATE array_t4 SET arr2 = array_cat(arr2, '{4.5, 5.25}'::double precision[][]) WHERE k = 1;
UPDATE array_t4 SET arr3 = array_cat(arr3, '{d, e, f}'::char[]) WHERE k = 1;
SELECT * FROM array_t4 ORDER BY k;
 k |     arr1     |           arr2            |     arr3
---+--------------+---------------------------+---------------
 1 | {1,22,3,4,5} | {1.5,22.25,3.25,4.5,5.25} | {a,x,c,d,e,f}
(1 row)

-- array_prepend().
UPDATE array_t4 SET arr1 = array_prepend(0::int2, arr1),
                    arr2 = array_prepend(0.5::double precision, arr2),
                    arr3 = array_prepend('z'::char, arr3) WHERE k = 1;
SELECT * FROM array_t4 ORDER BY k;
 k |      arr1      |             arr2              |      arr3
---+----------------+-------------------------------+-----------------
 1 | {0,1,22,3,4,5} | {0.5,1.5,22.25,3.25,4.5,5.25} | {z,a,x,c,d,e,f}
(1 row)

-- array_remove().
UPDATE array_t4 SET arr1 = array_remove(arr1, 3::int2),
                    arr2 = array_remove(arr2, 3.25::double precision),
                    arr3 = array_remove(arr3, 'c'::char) WHERE k = 1;
SELECT * FROM array_t4 ORDER BY k;
 k |     arr1     |           arr2           |     arr3
---+--------------+--------------------------+---------------
 1 | {0,1,22,4,5} | {0.5,1.5,22.25,4.5,5.25} | {z,a,x,d,e,f}
(1 row)

-----------------------------------
-- Test json types.
CREATE TABLE json_t1(k int PRIMARY KEY, json1 json, json2 jsonb);
INSERT INTO json_t1 (k, json1, json2) VALUES (1, '["a", 1]'::json, '["b", 2]'::jsonb);
SELECT * FROM json_t1;
 k |  json1   |  json2
---+----------+----------
 1 | ["a", 1] | ["b", 2]
(1 row)

UPDATE json_t1 SET json1 = json1 -> 0, json2 = json2||'["c", 3]'::jsonb WHERE k = 1;
SELECT * FROM json_t1;
 k | json1 |      json2
---+-------+------------------
 1 | "a"   | ["b", 2, "c", 3]
(1 row)

-----------------------------------
-- Cleanup.
DROP FUNCTION next_v3;
DROP FUNCTION assign_one_plus_param_to_v1;
DROP FUNCTION assign_one_plus_param_to_v1_hard;
DROP TABLE single_row;
DROP TABLE single_row_comp_key;
DROP TABLE single_row_complex;
DROP TABLE single_row_array;
DROP TABLE single_row_complex_returning;
DROP TABLE single_row_no_primary_key;
DROP TABLE single_row_range_asc_primary_key;
DROP TABLE single_row_range_desc_primary_key;
DROP TABLE single_row_not_null_constraints;
DROP TABLE single_row_check_constraints;
DROP TABLE single_row_check_constraints2;
DROP TABLE single_row_decimal;
DROP TABLE single_row_decimal_fk;
DROP TABLE single_row_index;
DROP TABLE single_row_col_order;
DROP TABLE single_row_default_col;
DROP TABLE single_row_partial_index;
DROP TABLE single_row_expression_index;
DROP TABLE array_t1;
DROP TABLE array_t2;
DROP TABLE array_t3;
DROP TABLE array_t4;
DROP TABLE json_t1;
DROP TYPE rt;
DROP TYPE two_int;
DROP TYPE two_text;
