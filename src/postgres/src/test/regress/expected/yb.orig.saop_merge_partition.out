--
-- See yb_saop_merge_schedule for details about the test.
--
\getenv abs_srcdir PG_ABS_SRCDIR
\set filename :abs_srcdir '/data/explainrun_saop_merge.sql'
\i :filename
\getenv abs_srcdir PG_ABS_SRCDIR
\set filename :abs_srcdir '/data/explainrun.sql'
\i :filename
-- A helper script to explain and run a query.  Use in regress tests by
-- defining :explain, :query, and optionally :hint#.
\set explain1 ':explain :hint1 :query;'
\set explain2 ':explain1 :explain :hint2 :query;'
\set explain3 ':explain2 :explain :hint3 :query;'
\set explain4 ':explain3 :explain :hint4 :query;'
\set explain5 ':explain4 :explain :hint5 :query;'
\set explain1run1 ':explain1; :hint1 :query;'
\set explain2run2 ':explain2; :hint1 :query; :hint2 :query;'
\set explain3run3 ':explain3; :hint1 :query; :hint2 :query; :hint3 :query;'
\set explain4run4 ':explain4; :hint1 :query; :hint2 :query; :hint3 :query; :hint4 :query;'
\set explain5run5 ':explain5; :hint1 :query; :hint2 :query; :hint3 :query; :hint4 :query; :hint5 :query;'
-- Default to no hints.
\set hint1 ''
\set hint2 ''
\set hint3 ''
\set hint4 ''
\set hint5 ''
\set explain 'EXPLAIN (ANALYZE, DIST, VERBOSE, COSTS OFF, SUMMARY OFF, TIMING OFF)'
\set off '/*+Set(yb_max_saop_merge_streams 0)*/'
\set on '/*+Set(yb_max_saop_merge_streams 64)*/'
\set hint1 ':off'
\set hint2 ':on'
-- No order
-- SAOP merge should not be used.
\set query 'SELECT * FROM parent WHERE r1 IN (0, 1, 2, 3) LIMIT 5'
:explain2
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Limit (actual rows=5 loops=1)
   Output: parent.n, parent.r3, parent.p1, parent.r1, parent.r2, parent.p2
   ->  Append (actual rows=5 loops=1)
         ->  Index Scan using child1a_pkey on public.child1a parent_1 (actual rows=5 loops=1)
               Output: parent_1.n, parent_1.r3, parent_1.p1, parent_1.r1, parent_1.r2, parent_1.p2
               Index Cond: (parent_1.r1 = ANY ('{0,1,2,3}'::integer[]))
               Storage Table Read Requests: 1
               Storage Table Read Ops: 1
               Storage Table Rows Scanned: 5
         ->  Index Scan using child1b_pkey on public.child1b parent_2 (never executed)
               Output: parent_2.n, parent_2.r3, parent_2.p1, parent_2.r1, parent_2.r2, parent_2.p2
               Index Cond: (parent_2.r1 = ANY ('{0,1,2,3}'::integer[]))
         ->  Index Scan using child2_pkey on public.child2 parent_3 (never executed)
               Output: parent_3.n, parent_3.r3, parent_3.p1, parent_3.r1, parent_3.r2, parent_3.p2
               Index Cond: (parent_3.r1 = ANY ('{0,1,2,3}'::integer[]))
         ->  Index Scan using child3_pkey on public.child3 parent_4 (never executed)
               Output: parent_4.n, parent_4.r3, parent_4.p1, parent_4.r1, parent_4.r2, parent_4.p2
               Index Cond: (parent_4.r1 = ANY ('{0,1,2,3}'::integer[]))
(18 rows)

                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Limit (actual rows=5 loops=1)
   Output: parent.n, parent.r3, parent.p1, parent.r1, parent.r2, parent.p2
   ->  Append (actual rows=5 loops=1)
         ->  Index Scan using child1a_pkey on public.child1a parent_1 (actual rows=5 loops=1)
               Output: parent_1.n, parent_1.r3, parent_1.p1, parent_1.r1, parent_1.r2, parent_1.p2
               Index Cond: (parent_1.r1 = ANY ('{0,1,2,3}'::integer[]))
               Storage Table Read Requests: 1
               Storage Table Read Ops: 1
               Storage Table Rows Scanned: 5
         ->  Index Scan using child1b_pkey on public.child1b parent_2 (never executed)
               Output: parent_2.n, parent_2.r3, parent_2.p1, parent_2.r1, parent_2.r2, parent_2.p2
               Index Cond: (parent_2.r1 = ANY ('{0,1,2,3}'::integer[]))
         ->  Index Scan using child2_pkey on public.child2 parent_3 (never executed)
               Output: parent_3.n, parent_3.r3, parent_3.p1, parent_3.r1, parent_3.r2, parent_3.p2
               Index Cond: (parent_3.r1 = ANY ('{0,1,2,3}'::integer[]))
         ->  Index Scan using child3_pkey on public.child3 parent_4 (never executed)
               Output: parent_4.n, parent_4.r3, parent_4.p1, parent_4.r1, parent_4.r2, parent_4.p2
               Index Cond: (parent_4.r1 = ANY ('{0,1,2,3}'::integer[]))
(18 rows)

-- Forward scan
\set query 'SELECT * FROM parent WHERE r1 IN (0, 1, 2, 3) ORDER BY r2, r3, p1, p2, n LIMIT 5'
:explain2run2
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Limit (actual rows=5 loops=1)
   Output: parent.n, parent.r3, parent.p1, parent.r1, parent.r2, parent.p2
   ->  Sort (actual rows=5 loops=1)
         Output: parent.n, parent.r3, parent.p1, parent.r1, parent.r2, parent.p2
         Sort Key: parent.r2, parent.r3, parent.p1, parent.p2, parent.n
         Sort Method: top-N heapsort
         ->  Append (actual rows=1983 loops=1)
               ->  Index Scan using child1a_pkey on public.child1a parent_1 (actual rows=439 loops=1)
                     Output: parent_1.n, parent_1.r3, parent_1.p1, parent_1.r1, parent_1.r2, parent_1.p2
                     Index Cond: (parent_1.r1 = ANY ('{0,1,2,3}'::integer[]))
                     Storage Table Read Requests: 1
                     Storage Table Read Ops: 1
                     Storage Table Rows Scanned: 439
               ->  Index Scan using child1b_pkey on public.child1b parent_2 (actual rows=247 loops=1)
                     Output: parent_2.n, parent_2.r3, parent_2.p1, parent_2.r1, parent_2.r2, parent_2.p2
                     Index Cond: (parent_2.r1 = ANY ('{0,1,2,3}'::integer[]))
                     Storage Table Read Requests: 1
                     Storage Table Read Ops: 1
                     Storage Table Rows Scanned: 247
               ->  Index Scan using child2_pkey on public.child2 parent_3 (actual rows=751 loops=1)
                     Output: parent_3.n, parent_3.r3, parent_3.p1, parent_3.r1, parent_3.r2, parent_3.p2
                     Index Cond: (parent_3.r1 = ANY ('{0,1,2,3}'::integer[]))
                     Storage Table Read Requests: 1
                     Storage Table Read Ops: 1
                     Storage Table Rows Scanned: 751
               ->  Index Scan using child3_pkey on public.child3 parent_4 (actual rows=546 loops=1)
                     Output: parent_4.n, parent_4.r3, parent_4.p1, parent_4.r1, parent_4.r2, parent_4.p2
                     Index Cond: (parent_4.r1 = ANY ('{0,1,2,3}'::integer[]))
                     Storage Table Read Requests: 1
                     Storage Table Read Ops: 1
                     Storage Table Rows Scanned: 546
(31 rows)

                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Limit (actual rows=5 loops=1)
   Output: parent.n, parent.r3, parent.p1, parent.r1, parent.r2, parent.p2
   ->  Incremental Sort (actual rows=5 loops=1)
         Output: parent.n, parent.r3, parent.p1, parent.r1, parent.r2, parent.p2
         Sort Key: parent.r2, parent.r3, parent.p1, parent.p2, parent.n
         Presorted Key: parent.r2, parent.r3, parent.p1, parent.p2
         Full-sort Groups: 1  Sort Method: quicksort
         ->  Merge Append (actual rows=6 loops=1)
               Sort Key: parent.r2, parent.r3, parent.p1, parent.p2
               ->  Index Scan using child1a_pkey on public.child1a parent_1 (actual rows=2 loops=1)
                     Output: parent_1.n, parent_1.r3, parent_1.p1, parent_1.r1, parent_1.r2, parent_1.p2
                     Index Cond: (parent_1.r1 = ANY ('{0,1,2,3}'::integer[]))
                     Merge Sort Key: parent_1.r2, parent_1.r3, parent_1.p1, parent_1.p2
                     Merge Stream Key: parent_1.r1
                     Merge Streams: 4
                     Merge Cond: (parent_1.r1 = ANY ('{0,1,2,3}'::integer[]))
                     Storage Table Read Requests: 1
                     Storage Table Read Ops: 4
                     Storage Table Rows Scanned: 20
               ->  Index Scan using child1b_pkey on public.child1b parent_2 (actual rows=3 loops=1)
                     Output: parent_2.n, parent_2.r3, parent_2.p1, parent_2.r1, parent_2.r2, parent_2.p2
                     Index Cond: (parent_2.r1 = ANY ('{0,1,2,3}'::integer[]))
                     Merge Sort Key: parent_2.r2, parent_2.r3, parent_2.p1, parent_2.p2
                     Merge Stream Key: parent_2.r1
                     Merge Streams: 4
                     Merge Cond: (parent_2.r1 = ANY ('{0,1,2,3}'::integer[]))
                     Storage Table Read Requests: 1
                     Storage Table Read Ops: 4
                     Storage Table Rows Scanned: 20
               ->  Index Scan using child2_pkey on public.child2 parent_3 (actual rows=3 loops=1)
                     Output: parent_3.n, parent_3.r3, parent_3.p1, parent_3.r1, parent_3.r2, parent_3.p2
                     Index Cond: (parent_3.r1 = ANY ('{0,1,2,3}'::integer[]))
                     Merge Sort Key: parent_3.r2, parent_3.r3, parent_3.p1, parent_3.p2
                     Merge Stream Key: parent_3.r1
                     Merge Streams: 4
                     Merge Cond: (parent_3.r1 = ANY ('{0,1,2,3}'::integer[]))
                     Storage Table Read Requests: 1
                     Storage Table Read Ops: 4
                     Storage Table Rows Scanned: 20
               ->  Index Scan using child3_pkey on public.child3 parent_4 (actual rows=1 loops=1)
                     Output: parent_4.n, parent_4.r3, parent_4.p1, parent_4.r1, parent_4.r2, parent_4.p2
                     Index Cond: (parent_4.r1 = ANY ('{0,1,2,3}'::integer[]))
                     Merge Sort Key: parent_4.r2, parent_4.r3, parent_4.p1, parent_4.p2
                     Merge Stream Key: parent_4.r1
                     Merge Streams: 4
                     Merge Cond: (parent_4.r1 = ANY ('{0,1,2,3}'::integer[]))
                     Storage Table Read Requests: 1
                     Storage Table Read Ops: 4
                     Storage Table Rows Scanned: 20
(49 rows)

   n   | r3 | p1 | r1 | r2 | p2 
-------+----+----+----+----+----
 30002 |  0 |  0 |  2 |  0 |  3
 52001 |  0 |  2 |  1 |  0 |  5
 62001 |  0 |  2 |  1 |  0 |  6
 14003 |  0 |  4 |  3 |  0 |  1
 24002 |  0 |  4 |  2 |  0 |  2
(5 rows)

   n   | r3 | p1 | r1 | r2 | p2 
-------+----+----+----+----+----
 30002 |  0 |  0 |  2 |  0 |  3
 52001 |  0 |  2 |  1 |  0 |  5
 62001 |  0 |  2 |  1 |  0 |  6
 14003 |  0 |  4 |  3 |  0 |  1
 24002 |  0 |  4 |  2 |  0 |  2
(5 rows)

-- Backward scan
\set query 'SELECT * FROM parent WHERE r1 IN (0, 1, 2, 3) ORDER BY r2 DESC, r3 DESC, p1 DESC, p2 DESC, n LIMIT 5'
:explain2run2
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Limit (actual rows=5 loops=1)
   Output: parent.n, parent.r3, parent.p1, parent.r1, parent.r2, parent.p2
   ->  Sort (actual rows=5 loops=1)
         Output: parent.n, parent.r3, parent.p1, parent.r1, parent.r2, parent.p2
         Sort Key: parent.r2 DESC, parent.r3 DESC, parent.p1 DESC, parent.p2 DESC, parent.n
         Sort Method: top-N heapsort
         ->  Append (actual rows=1983 loops=1)
               ->  Index Scan using child1a_pkey on public.child1a parent_1 (actual rows=439 loops=1)
                     Output: parent_1.n, parent_1.r3, parent_1.p1, parent_1.r1, parent_1.r2, parent_1.p2
                     Index Cond: (parent_1.r1 = ANY ('{0,1,2,3}'::integer[]))
                     Storage Table Read Requests: 1
                     Storage Table Read Ops: 1
                     Storage Table Rows Scanned: 439
               ->  Index Scan using child1b_pkey on public.child1b parent_2 (actual rows=247 loops=1)
                     Output: parent_2.n, parent_2.r3, parent_2.p1, parent_2.r1, parent_2.r2, parent_2.p2
                     Index Cond: (parent_2.r1 = ANY ('{0,1,2,3}'::integer[]))
                     Storage Table Read Requests: 1
                     Storage Table Read Ops: 1
                     Storage Table Rows Scanned: 247
               ->  Index Scan using child2_pkey on public.child2 parent_3 (actual rows=751 loops=1)
                     Output: parent_3.n, parent_3.r3, parent_3.p1, parent_3.r1, parent_3.r2, parent_3.p2
                     Index Cond: (parent_3.r1 = ANY ('{0,1,2,3}'::integer[]))
                     Storage Table Read Requests: 1
                     Storage Table Read Ops: 1
                     Storage Table Rows Scanned: 751
               ->  Index Scan using child3_pkey on public.child3 parent_4 (actual rows=546 loops=1)
                     Output: parent_4.n, parent_4.r3, parent_4.p1, parent_4.r1, parent_4.r2, parent_4.p2
                     Index Cond: (parent_4.r1 = ANY ('{0,1,2,3}'::integer[]))
                     Storage Table Read Requests: 1
                     Storage Table Read Ops: 1
                     Storage Table Rows Scanned: 546
(31 rows)

                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Limit (actual rows=5 loops=1)
   Output: parent.n, parent.r3, parent.p1, parent.r1, parent.r2, parent.p2
   ->  Incremental Sort (actual rows=5 loops=1)
         Output: parent.n, parent.r3, parent.p1, parent.r1, parent.r2, parent.p2
         Sort Key: parent.r2 DESC, parent.r3 DESC, parent.p1 DESC, parent.p2 DESC, parent.n
         Presorted Key: parent.r2, parent.r3, parent.p1, parent.p2
         Full-sort Groups: 1  Sort Method: quicksort
         ->  Merge Append (actual rows=6 loops=1)
               Sort Key: parent.r2 DESC, parent.r3 DESC, parent.p1 DESC, parent.p2 DESC
               ->  Index Scan Backward using child1a_pkey on public.child1a parent_1 (actual rows=1 loops=1)
                     Output: parent_1.n, parent_1.r3, parent_1.p1, parent_1.r1, parent_1.r2, parent_1.p2
                     Index Cond: (parent_1.r1 = ANY ('{0,1,2,3}'::integer[]))
                     Merge Sort Key: parent_1.r2 DESC, parent_1.r3 DESC, parent_1.p1 DESC, parent_1.p2 DESC
                     Merge Stream Key: parent_1.r1
                     Merge Streams: 4
                     Merge Cond: (parent_1.r1 = ANY ('{0,1,2,3}'::integer[]))
                     Storage Table Read Requests: 1
                     Storage Table Read Ops: 4
                     Storage Table Rows Scanned: 20
               ->  Index Scan Backward using child1b_pkey on public.child1b parent_2 (actual rows=1 loops=1)
                     Output: parent_2.n, parent_2.r3, parent_2.p1, parent_2.r1, parent_2.r2, parent_2.p2
                     Index Cond: (parent_2.r1 = ANY ('{0,1,2,3}'::integer[]))
                     Merge Sort Key: parent_2.r2 DESC, parent_2.r3 DESC, parent_2.p1 DESC, parent_2.p2 DESC
                     Merge Stream Key: parent_2.r1
                     Merge Streams: 4
                     Merge Cond: (parent_2.r1 = ANY ('{0,1,2,3}'::integer[]))
                     Storage Table Read Requests: 1
                     Storage Table Read Ops: 4
                     Storage Table Rows Scanned: 20
               ->  Index Scan Backward using child2_pkey on public.child2 parent_3 (actual rows=3 loops=1)
                     Output: parent_3.n, parent_3.r3, parent_3.p1, parent_3.r1, parent_3.r2, parent_3.p2
                     Index Cond: (parent_3.r1 = ANY ('{0,1,2,3}'::integer[]))
                     Merge Sort Key: parent_3.r2 DESC, parent_3.r3 DESC, parent_3.p1 DESC, parent_3.p2 DESC
                     Merge Stream Key: parent_3.r1
                     Merge Streams: 4
                     Merge Cond: (parent_3.r1 = ANY ('{0,1,2,3}'::integer[]))
                     Storage Table Read Requests: 1
                     Storage Table Read Ops: 4
                     Storage Table Rows Scanned: 20
               ->  Index Scan Backward using child3_pkey on public.child3 parent_4 (actual rows=4 loops=1)
                     Output: parent_4.n, parent_4.r3, parent_4.p1, parent_4.r1, parent_4.r2, parent_4.p2
                     Index Cond: (parent_4.r1 = ANY ('{0,1,2,3}'::integer[]))
                     Merge Sort Key: parent_4.r2 DESC, parent_4.r3 DESC, parent_4.p1 DESC, parent_4.p2 DESC
                     Merge Stream Key: parent_4.r1
                     Merge Streams: 4
                     Merge Cond: (parent_4.r1 = ANY ('{0,1,2,3}'::integer[]))
                     Storage Table Read Requests: 1
                     Storage Table Read Ops: 4
                     Storage Table Rows Scanned: 20
(49 rows)

   n   | r3 | p1 | r1 | r2 | p2 
-------+----+----+----+----+----
 48991 |  9 |  8 |  1 |  9 |  4
 48993 |  9 |  8 |  3 |  9 |  4
 87991 |  9 |  7 |  1 |  9 |  8
 37991 |  9 |  7 |  1 |  9 |  3
 27992 |  9 |  7 |  2 |  9 |  2
(5 rows)

   n   | r3 | p1 | r1 | r2 | p2 
-------+----+----+----+----+----
 48991 |  9 |  8 |  1 |  9 |  4
 48993 |  9 |  8 |  3 |  9 |  4
 87991 |  9 |  7 |  1 |  9 |  8
 37991 |  9 |  7 |  1 |  9 |  3
 27992 |  9 |  7 |  2 |  9 |  2
(5 rows)

--
-- Partitioned index
--
CREATE INDEX ON parent (p2 ASC, r2, p1, r3, r1);
-- No order
-- SAOP merge should not be used.
\set query 'SELECT * FROM parent WHERE p2 IN (0, 1, 2, 3) LIMIT 5'
:explain2
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Limit (actual rows=5 loops=1)
   Output: parent.n, parent.r3, parent.p1, parent.r1, parent.r2, parent.p2
   ->  Append (actual rows=5 loops=1)
         ->  Index Scan using child1a_pkey on public.child1a parent_1 (actual rows=5 loops=1)
               Output: parent_1.n, parent_1.r3, parent_1.p1, parent_1.r1, parent_1.r2, parent_1.p2
               Index Cond: (parent_1.p2 = ANY ('{0,1,2,3}'::double precision[]))
               Storage Table Read Requests: 1
               Storage Table Read Ops: 1
               Storage Table Rows Scanned: 5
         ->  Index Scan using child2_pkey on public.child2 parent_2 (never executed)
               Output: parent_2.n, parent_2.r3, parent_2.p1, parent_2.r1, parent_2.r2, parent_2.p2
               Index Cond: (parent_2.p2 = ANY ('{0,1,2,3}'::double precision[]))
         ->  Index Scan using child3_pkey on public.child3 parent_3 (never executed)
               Output: parent_3.n, parent_3.r3, parent_3.p1, parent_3.r1, parent_3.r2, parent_3.p2
               Index Cond: (parent_3.p2 = ANY ('{0,1,2,3}'::double precision[]))
(15 rows)

                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Limit (actual rows=5 loops=1)
   Output: parent.n, parent.r3, parent.p1, parent.r1, parent.r2, parent.p2
   ->  Append (actual rows=5 loops=1)
         ->  Index Scan using child1a_pkey on public.child1a parent_1 (actual rows=5 loops=1)
               Output: parent_1.n, parent_1.r3, parent_1.p1, parent_1.r1, parent_1.r2, parent_1.p2
               Index Cond: (parent_1.p2 = ANY ('{0,1,2,3}'::double precision[]))
               Storage Table Read Requests: 1
               Storage Table Read Ops: 1
               Storage Table Rows Scanned: 5
         ->  Index Scan using child2_pkey on public.child2 parent_2 (never executed)
               Output: parent_2.n, parent_2.r3, parent_2.p1, parent_2.r1, parent_2.r2, parent_2.p2
               Index Cond: (parent_2.p2 = ANY ('{0,1,2,3}'::double precision[]))
         ->  Index Scan using child3_pkey on public.child3 parent_3 (never executed)
               Output: parent_3.n, parent_3.r3, parent_3.p1, parent_3.r1, parent_3.r2, parent_3.p2
               Index Cond: (parent_3.p2 = ANY ('{0,1,2,3}'::double precision[]))
(15 rows)

-- Forward scan
\set query 'SELECT * FROM parent WHERE p2 IN (0, 1, 2, 3) ORDER BY r2, p1, r3, r1, n LIMIT 5'
:explain2run2
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Limit (actual rows=5 loops=1)
   Output: parent.n, parent.r3, parent.p1, parent.r1, parent.r2, parent.p2
   ->  Sort (actual rows=5 loops=1)
         Output: parent.n, parent.r3, parent.p1, parent.r1, parent.r2, parent.p2
         Sort Key: parent.r2, parent.p1, parent.r3, parent.r1, parent.n
         Sort Method: top-N heapsort
         ->  Append (actual rows=2018 loops=1)
               ->  Index Scan using child1a_pkey on public.child1a parent_1 (actual rows=807 loops=1)
                     Output: parent_1.n, parent_1.r3, parent_1.p1, parent_1.r1, parent_1.r2, parent_1.p2
                     Index Cond: (parent_1.p2 = ANY ('{0,1,2,3}'::double precision[]))
                     Storage Table Read Requests: 1
                     Storage Table Read Ops: 1
                     Storage Table Rows Scanned: 807
               ->  Index Scan using child2_pkey on public.child2 parent_2 (actual rows=818 loops=1)
                     Output: parent_2.n, parent_2.r3, parent_2.p1, parent_2.r1, parent_2.r2, parent_2.p2
                     Index Cond: (parent_2.p2 = ANY ('{0,1,2,3}'::double precision[]))
                     Storage Table Read Requests: 1
                     Storage Table Read Ops: 1
                     Storage Table Rows Scanned: 818
               ->  Index Scan using child3_pkey on public.child3 parent_3 (actual rows=393 loops=1)
                     Output: parent_3.n, parent_3.r3, parent_3.p1, parent_3.r1, parent_3.r2, parent_3.p2
                     Index Cond: (parent_3.p2 = ANY ('{0,1,2,3}'::double precision[]))
                     Storage Table Read Requests: 1
                     Storage Table Read Ops: 1
                     Storage Table Rows Scanned: 393
(25 rows)

                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=5 loops=1)
   Output: parent.n, parent.r3, parent.p1, parent.r1, parent.r2, parent.p2
   ->  Incremental Sort (actual rows=5 loops=1)
         Output: parent.n, parent.r3, parent.p1, parent.r1, parent.r2, parent.p2
         Sort Key: parent.r2, parent.p1, parent.r3, parent.r1, parent.n
         Presorted Key: parent.r2, parent.p1, parent.r3, parent.r1
         Full-sort Groups: 1  Sort Method: quicksort
         ->  Merge Append (actual rows=6 loops=1)
               Sort Key: parent.r2, parent.p1, parent.r3, parent.r1
               ->  Index Scan using child1a_p2_r2_p1_r3_r1_idx on public.child1a parent_1 (actual rows=6 loops=1)
                     Output: parent_1.n, parent_1.r3, parent_1.p1, parent_1.r1, parent_1.r2, parent_1.p2
                     Index Cond: (parent_1.p2 = ANY ('{0,1,2,3}'::double precision[]))
                     Merge Sort Key: parent_1.r2, parent_1.p1, parent_1.r3, parent_1.r1
                     Merge Stream Key: parent_1.p2
                     Merge Streams: 4
                     Merge Cond: (parent_1.p2 = ANY ('{0,1,2,3}'::double precision[]))
                     Storage Table Read Requests: 1
                     Storage Table Read Ops: 1
                     Storage Table Rows Scanned: 7
                     Storage Index Read Requests: 1
                     Storage Index Read Ops: 4
                     Storage Index Rows Scanned: 20
               ->  Index Scan using child2_p2_r2_p1_r3_r1_idx on public.child2 parent_2 (actual rows=1 loops=1)
                     Output: parent_2.n, parent_2.r3, parent_2.p1, parent_2.r1, parent_2.r2, parent_2.p2
                     Index Cond: (parent_2.p2 = ANY ('{0,1,2,3}'::double precision[]))
                     Merge Sort Key: parent_2.r2, parent_2.p1, parent_2.r3, parent_2.r1
                     Merge Stream Key: parent_2.p2
                     Merge Streams: 4
                     Merge Cond: (parent_2.p2 = ANY ('{0,1,2,3}'::double precision[]))
                     Storage Table Read Requests: 1
                     Storage Table Read Ops: 1
                     Storage Table Rows Scanned: 14
                     Storage Index Read Requests: 1
                     Storage Index Read Ops: 4
                     Storage Index Rows Scanned: 20
               ->  Index Scan using child3_p2_r2_p1_r3_r1_idx on public.child3 parent_3 (actual rows=1 loops=1)
                     Output: parent_3.n, parent_3.r3, parent_3.p1, parent_3.r1, parent_3.r2, parent_3.p2
                     Index Cond: (parent_3.p2 = ANY ('{0,1,2,3}'::double precision[]))
                     Merge Sort Key: parent_3.r2, parent_3.p1, parent_3.r3, parent_3.r1
                     Merge Stream Key: parent_3.p2
                     Merge Streams: 4
                     Merge Cond: (parent_3.p2 = ANY ('{0,1,2,3}'::double precision[]))
                     Storage Table Read Requests: 1
                     Storage Table Read Ops: 1
                     Storage Table Rows Scanned: 11
                     Storage Index Read Requests: 1
                     Storage Index Read Ops: 4
                     Storage Index Rows Scanned: 20
(48 rows)

   n   | r3 | p1 | r1 | r2 | p2 
-------+----+----+----+----+----
 30002 |  0 |  0 |  2 |  0 |  3
     6 |  0 |  0 |  6 |  0 |  0
     8 |  0 |  0 |  8 |  0 |  0
 20009 |  0 |  0 |  9 |  0 |  2
   103 |  1 |  0 |  3 |  0 |  0
(5 rows)

   n   | r3 | p1 | r1 | r2 | p2 
-------+----+----+----+----+----
 30002 |  0 |  0 |  2 |  0 |  3
     6 |  0 |  0 |  6 |  0 |  0
     8 |  0 |  0 |  8 |  0 |  0
 20009 |  0 |  0 |  9 |  0 |  2
   103 |  1 |  0 |  3 |  0 |  0
(5 rows)

-- Backward scan
\set query 'SELECT * FROM parent WHERE p2 IN (0, 1, 2, 3) ORDER BY r2 DESC, p1 DESC, r3 DESC, r1 DESC, n LIMIT 5'
:explain2run2
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Limit (actual rows=5 loops=1)
   Output: parent.n, parent.r3, parent.p1, parent.r1, parent.r2, parent.p2
   ->  Sort (actual rows=5 loops=1)
         Output: parent.n, parent.r3, parent.p1, parent.r1, parent.r2, parent.p2
         Sort Key: parent.r2 DESC, parent.p1 DESC, parent.r3 DESC, parent.r1 DESC, parent.n
         Sort Method: top-N heapsort
         ->  Append (actual rows=2018 loops=1)
               ->  Index Scan using child1a_pkey on public.child1a parent_1 (actual rows=807 loops=1)
                     Output: parent_1.n, parent_1.r3, parent_1.p1, parent_1.r1, parent_1.r2, parent_1.p2
                     Index Cond: (parent_1.p2 = ANY ('{0,1,2,3}'::double precision[]))
                     Storage Table Read Requests: 1
                     Storage Table Read Ops: 1
                     Storage Table Rows Scanned: 807
               ->  Index Scan using child2_pkey on public.child2 parent_2 (actual rows=818 loops=1)
                     Output: parent_2.n, parent_2.r3, parent_2.p1, parent_2.r1, parent_2.r2, parent_2.p2
                     Index Cond: (parent_2.p2 = ANY ('{0,1,2,3}'::double precision[]))
                     Storage Table Read Requests: 1
                     Storage Table Read Ops: 1
                     Storage Table Rows Scanned: 818
               ->  Index Scan using child3_pkey on public.child3 parent_3 (actual rows=393 loops=1)
                     Output: parent_3.n, parent_3.r3, parent_3.p1, parent_3.r1, parent_3.r2, parent_3.p2
                     Index Cond: (parent_3.p2 = ANY ('{0,1,2,3}'::double precision[]))
                     Storage Table Read Requests: 1
                     Storage Table Read Ops: 1
                     Storage Table Rows Scanned: 393
(25 rows)

                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Limit (actual rows=5 loops=1)
   Output: parent.n, parent.r3, parent.p1, parent.r1, parent.r2, parent.p2
   ->  Incremental Sort (actual rows=5 loops=1)
         Output: parent.n, parent.r3, parent.p1, parent.r1, parent.r2, parent.p2
         Sort Key: parent.r2 DESC, parent.p1 DESC, parent.r3 DESC, parent.r1 DESC, parent.n
         Presorted Key: parent.r2, parent.p1, parent.r3, parent.r1
         Full-sort Groups: 1  Sort Method: quicksort
         ->  Merge Append (actual rows=6 loops=1)
               Sort Key: parent.r2 DESC, parent.p1 DESC, parent.r3 DESC, parent.r1 DESC
               ->  Index Scan Backward using child1a_p2_r2_p1_r3_r1_idx on public.child1a parent_1 (actual rows=1 loops=1)
                     Output: parent_1.n, parent_1.r3, parent_1.p1, parent_1.r1, parent_1.r2, parent_1.p2
                     Index Cond: (parent_1.p2 = ANY ('{0,1,2,3}'::double precision[]))
                     Merge Sort Key: parent_1.r2 DESC, parent_1.p1 DESC, parent_1.r3 DESC, parent_1.r1 DESC
                     Merge Stream Key: parent_1.p2
                     Merge Streams: 4
                     Merge Cond: (parent_1.p2 = ANY ('{0,1,2,3}'::double precision[]))
                     Storage Table Read Requests: 1
                     Storage Table Read Ops: 1
                     Storage Table Rows Scanned: 16
                     Storage Index Read Requests: 1
                     Storage Index Read Ops: 4
                     Storage Index Rows Scanned: 20
               ->  Index Scan Backward using child2_p2_r2_p1_r3_r1_idx on public.child2 parent_2 (actual rows=1 loops=1)
                     Output: parent_2.n, parent_2.r3, parent_2.p1, parent_2.r1, parent_2.r2, parent_2.p2
                     Index Cond: (parent_2.p2 = ANY ('{0,1,2,3}'::double precision[]))
                     Merge Sort Key: parent_2.r2 DESC, parent_2.p1 DESC, parent_2.r3 DESC, parent_2.r1 DESC
                     Merge Stream Key: parent_2.p2
                     Merge Streams: 4
                     Merge Cond: (parent_2.p2 = ANY ('{0,1,2,3}'::double precision[]))
                     Storage Table Read Requests: 1
                     Storage Table Read Ops: 1
                     Storage Table Rows Scanned: 13
                     Storage Index Read Requests: 1
                     Storage Index Read Ops: 4
                     Storage Index Rows Scanned: 20
               ->  Index Scan Backward using child3_p2_r2_p1_r3_r1_idx on public.child3 parent_3 (actual rows=6 loops=1)
                     Output: parent_3.n, parent_3.r3, parent_3.p1, parent_3.r1, parent_3.r2, parent_3.p2
                     Index Cond: (parent_3.p2 = ANY ('{0,1,2,3}'::double precision[]))
                     Merge Sort Key: parent_3.r2 DESC, parent_3.p1 DESC, parent_3.r3 DESC, parent_3.r1 DESC
                     Merge Stream Key: parent_3.p2
                     Merge Streams: 4
                     Merge Cond: (parent_3.p2 = ANY ('{0,1,2,3}'::double precision[]))
                     Storage Table Read Requests: 1
                     Storage Table Read Ops: 1
                     Storage Table Rows Scanned: 13
                     Storage Index Read Requests: 1
                     Storage Index Read Ops: 4
                     Storage Index Rows Scanned: 20
(48 rows)

   n   | r3 | p1 | r1 | r2 | p2 
-------+----+----+----+----+----
  9996 |  9 |  9 |  6 |  9 |  0
 29996 |  9 |  9 |  6 |  9 |  2
 39994 |  9 |  9 |  4 |  9 |  3
 29799 |  7 |  9 |  9 |  9 |  2
 39796 |  7 |  9 |  6 |  9 |  3
(5 rows)

   n   | r3 | p1 | r1 | r2 | p2 
-------+----+----+----+----+----
  9996 |  9 |  9 |  6 |  9 |  0
 29996 |  9 |  9 |  6 |  9 |  2
 39994 |  9 |  9 |  4 |  9 |  3
 29799 |  7 |  9 |  9 |  9 |  2
 39796 |  7 |  9 |  6 |  9 |  3
(5 rows)

-- (Drop this index)
DROP INDEX parent_p2_r2_p1_r3_r1_idx;
