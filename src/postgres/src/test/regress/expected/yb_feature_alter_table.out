--
-- ALTER_TABLE
-- add, rename, drop, alter type of attribute
--
CREATE TABLE tmp (initial int4);
ALTER TABLE tmp1 ADD COLUMN xmin integer; -- fails
ERROR:  relation "tmp1" does not exist
ALTER TABLE tmp ADD COLUMN b name;
ALTER TABLE tmp ADD COLUMN c text;
ALTER TABLE tmp ADD COLUMN d float8;
ALTER TABLE tmp ADD COLUMN e float4;
ALTER TABLE tmp ADD COLUMN f int2;
ALTER TABLE tmp ADD COLUMN i char;
ALTER TABLE tmp ADD COLUMN k int4;
ALTER TABLE tmp ADD COLUMN m xid;
ALTER TABLE tmp ADD COLUMN n oidvector;
ALTER TABLE tmp ADD COLUMN v timestamp;
ALTER TABLE tmp ADD COLUMN y float4[];
ALTER TABLE tmp ADD COLUMN z int2[];
INSERT INTO tmp (b, c, d, e, f, i, k, m, n, v, y, z)
   VALUES ('name', 'text', 4.1, 4.1, 2, 'c', 314159, '512',
   '1 2 3 4 5 6 7 8', 'epoch', '{1.0,2.0,3.0,4.0}', '{1,2,3,4}');
SELECT * FROM tmp;
 initial |  b   |  c   |  d  |  e  | f | i |   k    |  m  |        n        |            v             |     y     |     z
---------+------+------+-----+-----+---+---+--------+-----+-----------------+--------------------------+-----------+-----------
         | name | text | 4.1 | 4.1 | 2 | c | 314159 | 512 | 1 2 3 4 5 6 7 8 | Thu Jan 01 00:00:00 1970 | {1,2,3,4} | {1,2,3,4}
(1 row)

DROP TABLE tmp;
-- alter table / drop column tests
-- try altering system catalogs, should fail
alter table pg_class drop column relname;
ERROR:  permission denied: "pg_class" is a system catalog
-- try altering non-existent table, should fail
alter table nosuchtable drop column bar;
ERROR:  relation "nosuchtable" does not exist
-- test dropping columns
create table atacc1 (a int4 not null, b int4, c int4 not null, d int4);
insert into atacc1 values (1, 2, 3, 4);
alter table atacc1 drop a;
alter table atacc1 drop a;
ERROR:  column "a" of relation "atacc1" does not exist
-- SELECTs
select * from atacc1;
 b | c | d
---+---+---
 2 | 3 | 4
(1 row)

select * from atacc1 order by a;
ERROR:  column "a" does not exist
LINE 1: select * from atacc1 order by a;
                                      ^
select * from atacc1 order by "........pg.dropped.1........";
ERROR:  column "........pg.dropped.1........" does not exist
LINE 1: select * from atacc1 order by "........pg.dropped.1........"...
                                      ^
select * from atacc1 group by a;
ERROR:  column "a" does not exist
LINE 1: select * from atacc1 group by a;
                                      ^
select * from atacc1 group by "........pg.dropped.1........";
ERROR:  column "........pg.dropped.1........" does not exist
LINE 1: select * from atacc1 group by "........pg.dropped.1........"...
                                      ^
select atacc1.* from atacc1;
 b | c | d
---+---+---
 2 | 3 | 4
(1 row)

select a from atacc1;
ERROR:  column "a" does not exist
LINE 1: select a from atacc1;
               ^
select atacc1.a from atacc1;
ERROR:  column atacc1.a does not exist
LINE 1: select atacc1.a from atacc1;
               ^
select b,c,d from atacc1;
 b | c | d
---+---+---
 2 | 3 | 4
(1 row)

select a,b,c,d from atacc1;
ERROR:  column "a" does not exist
LINE 1: select a,b,c,d from atacc1;
               ^
select * from atacc1 where a = 1;
ERROR:  column "a" does not exist
LINE 1: select * from atacc1 where a = 1;
                                   ^
select "........pg.dropped.1........" from atacc1;
ERROR:  column "........pg.dropped.1........" does not exist
LINE 1: select "........pg.dropped.1........" from atacc1;
               ^
select atacc1."........pg.dropped.1........" from atacc1;
ERROR:  column atacc1.........pg.dropped.1........ does not exist
LINE 1: select atacc1."........pg.dropped.1........" from atacc1;
               ^
select "........pg.dropped.1........",b,c,d from atacc1;
ERROR:  column "........pg.dropped.1........" does not exist
LINE 1: select "........pg.dropped.1........",b,c,d from atacc1;
               ^
select * from atacc1 where "........pg.dropped.1........" = 1;
ERROR:  column "........pg.dropped.1........" does not exist
LINE 1: select * from atacc1 where "........pg.dropped.1........" = ...
                                   ^
-- UPDATEs
update atacc1 set a = 3;
ERROR:  column "a" of relation "atacc1" does not exist
LINE 1: update atacc1 set a = 3;
                          ^
update atacc1 set b = 2 where a = 3;
ERROR:  column "a" does not exist
LINE 1: update atacc1 set b = 2 where a = 3;
                                      ^
update atacc1 set "........pg.dropped.1........" = 3;
ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
LINE 1: update atacc1 set "........pg.dropped.1........" = 3;
                          ^
update atacc1 set b = 2 where "........pg.dropped.1........" = 3;
ERROR:  column "........pg.dropped.1........" does not exist
LINE 1: update atacc1 set b = 2 where "........pg.dropped.1........"...
                                      ^
-- INSERTs
insert into atacc1 values (10, 11, 12, 13);
ERROR:  INSERT has more expressions than target columns
LINE 1: insert into atacc1 values (10, 11, 12, 13);
                                               ^
insert into atacc1 values (default, 11, 12, 13);
ERROR:  INSERT has more expressions than target columns
LINE 1: insert into atacc1 values (default, 11, 12, 13);
                                                    ^
insert into atacc1 values (11, 12, 13);
insert into atacc1 (a) values (10);
ERROR:  column "a" of relation "atacc1" does not exist
LINE 1: insert into atacc1 (a) values (10);
                            ^
insert into atacc1 (a) values (default);
ERROR:  column "a" of relation "atacc1" does not exist
LINE 1: insert into atacc1 (a) values (default);
                            ^
insert into atacc1 (a,b,c,d) values (10,11,12,13);
ERROR:  column "a" of relation "atacc1" does not exist
LINE 1: insert into atacc1 (a,b,c,d) values (10,11,12,13);
                            ^
insert into atacc1 (a,b,c,d) values (default,11,12,13);
ERROR:  column "a" of relation "atacc1" does not exist
LINE 1: insert into atacc1 (a,b,c,d) values (default,11,12,13);
                            ^
insert into atacc1 (b,c,d) values (11,12,13);
insert into atacc1 ("........pg.dropped.1........") values (10);
ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
LINE 1: insert into atacc1 ("........pg.dropped.1........") values (...
                            ^
insert into atacc1 ("........pg.dropped.1........") values (default);
ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
LINE 1: insert into atacc1 ("........pg.dropped.1........") values (...
                            ^
insert into atacc1 ("........pg.dropped.1........",b,c,d) values (10,11,12,13);
ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
LINE 1: insert into atacc1 ("........pg.dropped.1........",b,c,d) va...
                            ^
insert into atacc1 ("........pg.dropped.1........",b,c,d) values (default,11,12,13);
ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
LINE 1: insert into atacc1 ("........pg.dropped.1........",b,c,d) va...
                            ^
-- DELETEs
delete from atacc1 where a = 3;
ERROR:  column "a" does not exist
LINE 1: delete from atacc1 where a = 3;
                                 ^
delete from atacc1 where "........pg.dropped.1........" = 3;
ERROR:  column "........pg.dropped.1........" does not exist
LINE 1: delete from atacc1 where "........pg.dropped.1........" = 3;
                                 ^
delete from atacc1;
-- try dropping a non-existent column, should fail
alter table atacc1 drop bar;
ERROR:  column "bar" of relation "atacc1" does not exist
-- try dropping the oid column, should succeed
alter table atacc1 drop oid;
ERROR:  column "oid" of relation "atacc1" does not exist
-- try dropping the xmin column, should fail
alter table atacc1 drop xmin;
ERROR:  cannot drop system column "xmin"
-- try creating a view and altering that, should fail
create view myview as select * from atacc1;
select * from myview;
 b | c | d
---+---+---
(0 rows)

alter table myview drop d;
ERROR:  "myview" is not a table, composite type, or foreign table
drop view myview;
-- test some commands to make sure they fail on the dropped column
create index "testing_idx" on atacc1(a);
ERROR:  column "a" does not exist
create index "testing_idx" on atacc1("........pg.dropped.1........");
ERROR:  column "........pg.dropped.1........" does not exist
alter table atacc1 rename a to z;
ERROR:  column "a" does not exist
alter table atacc1 add constraint checka check (a >= 0);
ERROR:  column "a" does not exist
alter table if exists atacc1 add constraint checka check (a >= 0);
ERROR:  column "a" does not exist
-- test create as and select into
insert into atacc1 values (21, 22, 23);
create table test1 as select * from atacc1;
select * from test1;
 b  | c  | d
----+----+----
 21 | 22 | 23
(1 row)

drop table test1;
select * into test2 from atacc1;
select * from test2;
 b  | c  | d
----+----+----
 21 | 22 | 23
(1 row)

drop table test2;
-- test constraints
alter table atacc1 add constraint checkb check (b < 0); -- should fail
ERROR:  check constraint "checkb" is violated by some row
alter table if exists atacc1 add constraint checkb check (b < 0); -- should fail
ERROR:  check constraint "checkb" is violated by some row
alter table atacc1 add constraint checkb check (b > 0);
alter table atacc1 add constraint checkb2 check (b > 10);
alter table atacc1 add constraint checkb3 check (b > 10);
insert into atacc1 values (5, 5, 5); -- should fail
ERROR:  new row for relation "atacc1" violates check constraint "checkb2"
DETAIL:  Failing row contains (5, 5, 5).
alter table atacc1 drop constraint checkb2;
alter table if exists atacc1 add constraint checkb2 check (b > 10);
insert into atacc1 values (5, 5, 5); -- should fail
ERROR:  new row for relation "atacc1" violates check constraint "checkb2"
DETAIL:  Failing row contains (5, 5, 5).
alter table atacc1 drop constraint checkb2;
insert into atacc1 values (5, 5, 5);
ERROR:  new row for relation "atacc1" violates check constraint "checkb3"
DETAIL:  Failing row contains (5, 5, 5).
alter table atacc1 drop constraint checkb;
alter table atacc1 drop constraint if exists checkb2;
NOTICE:  constraint "checkb2" of relation "atacc1" does not exist, skipping
alter table atacc1 drop constraint checkb2;
ERROR:  constraint "checkb2" for table "atacc1" does not exist
alter table atacc1 drop constraint if exists checkb3;
delete from atacc1 where b = 5;
-- test rename
alter table atacc1 rename b to e;
select * from atacc1;
 e  | c  | d
----+----+----
 21 | 22 | 23
(1 row)

-- try dropping all columns
alter table atacc1 drop c;
alter table atacc1 drop d;
alter table atacc1 drop b;
ERROR:  column "b" of relation "atacc1" does not exist
select * from atacc1;
 e
----
 21
(1 row)

drop table atacc1;
-- test dropping primary key constraints
CREATE TABLE with_simple_pk_i (i int PRIMARY KEY);
ALTER TABLE with_simple_pk_i DROP CONSTRAINT with_simple_pk_i_pkey;
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
INSERT INTO with_simple_pk_i VALUES (1);
INSERT INTO with_simple_pk_i VALUES (1);
DROP TABLE with_simple_pk_i;
--
CREATE TABLE with_simple_pk_ij (i int, j int, PRIMARY KEY(i, j));
ALTER TABLE with_simple_pk_ij DROP CONSTRAINT with_simple_pk_ij_pkey;
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
INSERT INTO with_simple_pk_ij VALUES (1, 1);
INSERT INTO with_simple_pk_ij VALUES (1, 1);
DROP TABLE with_simple_pk_ij;
--
CREATE TABLE with_named_pk_i (i int CONSTRAINT named_pk_i PRIMARY KEY);
ALTER TABLE with_named_pk_i DROP CONSTRAINT named_pk_i;
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
INSERT INTO with_named_pk_i VALUES (1);
INSERT INTO with_named_pk_i VALUES (1);
DROP TABLE with_named_pk_i;
--
CREATE TABLE with_named_pk_ij (i int, j int, CONSTRAINT named_pk_ij PRIMARY KEY (i HASH, j ASC));
ALTER TABLE with_named_pk_ij DROP CONSTRAINT named_pk_ij;
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
INSERT INTO with_named_pk_ij VALUES (1, 1);
INSERT INTO with_named_pk_ij VALUES (1, 1);
DROP TABLE with_named_pk_ij;
--
-- rename
--
CREATE TABLE tmp (regtable int);
ALTER TABLE tmp RENAME TO tmp_new;
SELECT * FROM tmp_new;
 regtable
----------
(0 rows)

SELECT * FROM tmp;		-- should fail
ERROR:  relation "tmp" does not exist
LINE 1: SELECT * FROM tmp;
                      ^
DROP TABLE tmp_new;
-- alter table / alter column [set/drop] not null tests
-- try altering system catalogs, should fail
alter table pg_class alter column relname drop not null;
ERROR:  permission denied: "pg_class" is a system catalog
alter table pg_class alter relname set not null;
ERROR:  permission denied: "pg_class" is a system catalog
-- try altering non-existent table, should fail
alter table non_existent alter column bar set not null;
ERROR:  relation "non_existent" does not exist
alter table non_existent alter column bar drop not null;
ERROR:  relation "non_existent" does not exist
-- try altering non-existent table with IF EXISTS clause, should pass with a notice message
alter table if exists non_existent alter column bar set not null;
NOTICE:  relation "non_existent" does not exist, skipping
alter table if exists non_existent alter column bar drop not null;
NOTICE:  relation "non_existent" does not exist, skipping
alter table if exists non_existent
    add constraint some_constraint_name foreign key (k) references atacc1;
NOTICE:  relation "non_existent" does not exist, skipping
-- test setting columns to null and not null and vice versa
-- test checking for null values and primary key
create table atacc1tmp (test int not null PRIMARY KEY);
alter table atacc1tmp alter column test drop not null;
ERROR:  column "test" is in a primary key
drop table atacc1tmp;
create table atacc1 (test int not null);
alter table atacc1 alter column test drop not null;
insert into atacc1 values (null);
alter table atacc1 alter test set not null;
ERROR:  column "test" contains null values
delete from atacc1;
alter table atacc1 alter test set not null;
-- try altering a non-existent column, should fail
alter table atacc1 alter bar set not null;
ERROR:  column "bar" of relation "atacc1" does not exist
alter table atacc1 alter bar drop not null;
ERROR:  column "bar" of relation "atacc1" does not exist
-- -- try altering the oid column, should fail
-- alter table atacc1 alter oid set not null;
-- alter table atacc1 alter oid drop not null;
-- try creating a view and altering that, should fail
create view myview as select * from atacc1;
alter table myview alter column test drop not null;
ERROR:  "myview" is not a table or foreign table
alter table myview alter column test set not null;
ERROR:  "myview" is not a table or foreign table
drop view myview;
drop table atacc1;
-- test setting and removing default values
create table def_test (
	c1	int4 default 5,
	c2	text default 'initial_default'
);
insert into def_test default values;
alter table def_test alter column c1 drop default;
insert into def_test default values;
alter table def_test alter column c2 drop default;
insert into def_test default values;
alter table def_test alter column c1 set default 10;
alter table def_test alter column c2 set default 'new_default';
insert into def_test default values;
select * from def_test order by c1, c2;
 c1 |       c2
----+-----------------
  5 | initial_default
 10 | new_default
    | initial_default
    |
(4 rows)

-- set defaults to an incorrect type: this should fail
alter table def_test alter column c1 set default 'wrong_datatype';
ERROR:  invalid input syntax for integer: "wrong_datatype"
alter table def_test alter column c2 set default 20;
-- set defaults on a non-existent column: this should fail
alter table def_test alter column c3 set default 30;
ERROR:  column "c3" of relation "def_test" does not exist
-- set defaults on views: we need to create a view, add a rule
-- to allow insertions into it, and then alter the view to add
-- a default
create view def_view_test as select * from def_test;
create rule def_view_test_ins as
	on insert to def_view_test
	do instead insert into def_test select new.*;
insert into def_view_test default values;
alter table def_view_test alter column c1 set default 45;
insert into def_view_test default values;
alter table def_view_test alter column c2 set default 'view_default';
insert into def_view_test default values;
select * from def_view_test ORDER BY c1 NULLS FIRST, c2 NULLS FIRST;
 c1 |       c2
----+-----------------
    |
    |
    | initial_default
  5 | initial_default
 10 | new_default
 45 |
 45 | view_default
(7 rows)

drop rule def_view_test_ins on def_view_test;
drop view def_view_test;
drop table def_test;
-- test CREATE or REPLACE VIEW
create or replace view v as select 17 as c1;
select * from v;
 c1
----
 17
(1 row)

create or replace view v as select 42 as c1;
select * from v;
 c1
----
 42
(1 row)

create or replace view v as select 11 as
	c1, 12 AS c2, 13 AS c3; -- testing replace/alter view by adding columns
select * from v;
 c1 | c2 | c3
----+----+----
 11 | 12 | 13
(1 row)

drop view v;
-- test ADD COLUMN IF NOT EXISTS
CREATE TABLE test_add_column(c1 integer);
\d test_add_column
          Table "public.test_add_column"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 c1     | integer |           |          |

ALTER TABLE test_add_column
	ADD COLUMN c2 integer;
\d test_add_column
          Table "public.test_add_column"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 c1     | integer |           |          |
 c2     | integer |           |          |

ALTER TABLE test_add_column
	ADD COLUMN c2 integer; -- fail because c2 already exists
ERROR:  column "c2" of relation "test_add_column" already exists
ALTER TABLE ONLY test_add_column
	ADD COLUMN c2 integer; -- fail because c2 already exists
ERROR:  column "c2" of relation "test_add_column" already exists
\d test_add_column
          Table "public.test_add_column"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 c1     | integer |           |          |
 c2     | integer |           |          |

ALTER TABLE test_add_column
	ADD COLUMN IF NOT EXISTS c2 integer; -- skipping because c2 already exists
NOTICE:  column "c2" of relation "test_add_column" already exists, skipping
ALTER TABLE ONLY test_add_column
	ADD COLUMN IF NOT EXISTS c2 integer; -- skipping because c2 already exists
NOTICE:  column "c2" of relation "test_add_column" already exists, skipping
\d test_add_column
          Table "public.test_add_column"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 c1     | integer |           |          |
 c2     | integer |           |          |

ALTER TABLE test_add_column
	ADD COLUMN c2 integer, -- fail because c2 already exists
	ADD COLUMN c3 integer;
ERROR:  column "c2" of relation "test_add_column" already exists
\d test_add_column
          Table "public.test_add_column"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 c1     | integer |           |          |
 c2     | integer |           |          |

ALTER TABLE test_add_column
	ADD COLUMN IF NOT EXISTS c2 integer, -- skipping because c2 already exists
	ADD COLUMN c3 integer; -- fail because c3 already exists
NOTICE:  column "c2" of relation "test_add_column" already exists, skipping
\d test_add_column
          Table "public.test_add_column"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 c1     | integer |           |          |
 c2     | integer |           |          |
 c3     | integer |           |          |

ALTER TABLE test_add_column
	ADD COLUMN IF NOT EXISTS c2 integer, -- skipping because c2 already exists
	ADD COLUMN IF NOT EXISTS c3 integer; -- skipping because c3 already exists
NOTICE:  column "c2" of relation "test_add_column" already exists, skipping
NOTICE:  column "c3" of relation "test_add_column" already exists, skipping
\d test_add_column
          Table "public.test_add_column"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 c1     | integer |           |          |
 c2     | integer |           |          |
 c3     | integer |           |          |

ALTER TABLE test_add_column
	ADD COLUMN IF NOT EXISTS c2 integer, -- skipping because c2 already exists
	ADD COLUMN IF NOT EXISTS c3 integer, -- skipping because c3 already exists
	ADD COLUMN c4 integer;
NOTICE:  column "c2" of relation "test_add_column" already exists, skipping
NOTICE:  column "c3" of relation "test_add_column" already exists, skipping
\d test_add_column
          Table "public.test_add_column"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 c1     | integer |           |          |
 c2     | integer |           |          |
 c3     | integer |           |          |
 c4     | integer |           |          |

DROP TABLE test_add_column;
-- test Add/Set/Drop Identity
CREATE TABLE test_identity(
    c1 integer NOT NULL,
    c2 integer NOT NULL
);
-- test ADD GENERATED ALWAYS
ALTER TABLE test_identity ALTER COLUMN c1 ADD GENERATED ALWAYS AS IDENTITY;
\d test_identity;
                      Table "public.test_identity"
 Column |  Type   | Collation | Nullable |           Default
--------+---------+-----------+----------+------------------------------
 c1     | integer |           | not null | generated always as identity
 c2     | integer |           | not null |

INSERT INTO test_identity (c1, c2) VALUES (0, 0);
ERROR:  cannot insert into column "c1"
DETAIL:  Column "c1" is an identity column defined as GENERATED ALWAYS.
HINT:  Use OVERRIDING SYSTEM VALUE to override.
INSERT INTO test_identity (c2) VALUES (1);
INSERT INTO test_identity (c2) VALUES (2);
-- test DROP IDENTITY
ALTER TABLE test_identity ALTER COLUMN c1 DROP IDENTITY;
\d test_identity;
           Table "public.test_identity"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 c1     | integer |           | not null |
 c2     | integer |           | not null |

ALTER TABLE test_identity ALTER COLUMN c1 DROP IDENTITY;
ERROR:  column "c1" of relation "test_identity" is not an identity column
\d test_identity;
           Table "public.test_identity"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 c1     | integer |           | not null |
 c2     | integer |           | not null |

-- test ADD GENERATED BY DEFAULT
ALTER TABLE test_identity ALTER COLUMN c1 ADD GENERATED BY DEFAULT AS IDENTITY;
\d test_identity;
                        Table "public.test_identity"
 Column |  Type   | Collation | Nullable |             Default
--------+---------+-----------+----------+----------------------------------
 c1     | integer |           | not null | generated by default as identity
 c2     | integer |           | not null |

INSERT INTO test_identity (c1, c2) VALUES (1000, 3);
INSERT INTO test_identity (c2) VALUES (4);
INSERT INTO test_identity (c2) VALUES (5);
-- test DROP IDENTITY IF EXISTS
ALTER TABLE test_identity ALTER COLUMN c1 DROP IDENTITY IF EXISTS;
\d test_identity;
           Table "public.test_identity"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 c1     | integer |           | not null |
 c2     | integer |           | not null |

ALTER TABLE test_identity ALTER COLUMN c1 DROP IDENTITY IF EXISTS;
NOTICE:  column "c1" of relation "test_identity" is not an identity column, skipping
\d test_identity;
           Table "public.test_identity"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 c1     | integer |           | not null |
 c2     | integer |           | not null |

-- test SET GENERATED
ALTER TABLE test_identity ALTER COLUMN c1 ADD GENERATED BY DEFAULT AS IDENTITY (INCREMENT 10 MINVALUE 10);
\d test_identity;
                        Table "public.test_identity"
 Column |  Type   | Collation | Nullable |             Default
--------+---------+-----------+----------+----------------------------------
 c1     | integer |           | not null | generated by default as identity
 c2     | integer |           | not null |

ALTER TABLE test_identity ALTER c1 SET GENERATED ALWAYS;
\d test_identity;
                      Table "public.test_identity"
 Column |  Type   | Collation | Nullable |           Default
--------+---------+-----------+----------+------------------------------
 c1     | integer |           | not null | generated always as identity
 c2     | integer |           | not null |

ALTER TABLE test_identity ALTER c1 SET GENERATED BY DEFAULT;
\d test_identity;
                        Table "public.test_identity"
 Column |  Type   | Collation | Nullable |             Default
--------+---------+-----------+----------+----------------------------------
 c1     | integer |           | not null | generated by default as identity
 c2     | integer |           | not null |

INSERT INTO test_identity (c2) VALUES (6);
INSERT INTO test_identity (c2) VALUES (7);
ALTER TABLE test_identity ALTER c1 SET INCREMENT 20;
INSERT INTO test_identity (c2) VALUES (8);
INSERT INTO test_identity (c2) VALUES (9);
ALTER TABLE test_identity ALTER c1 RESTART;
INSERT INTO test_identity (c2) VALUES (10);
INSERT INTO test_identity (c2) VALUES (11);
ALTER TABLE test_identity ALTER c1 SET INCREMENT 50 RESTART WITH 100;
INSERT INTO test_identity (c2) VALUES (12);
INSERT INTO test_identity (c2) VALUES (13);
SELECT * FROM test_identity ORDER BY c2;
  c1  | c2
------+----
    1 |  1
    2 |  2
 1000 |  3
    1 |  4
    2 |  5
   10 |  6
   20 |  7
   40 |  8
   60 |  9
   10 | 10
   30 | 11
  100 | 12
  150 | 13
(13 rows)

DROP TABLE test_identity;
-- Test that updating table after dropping a column does not result in spurious error #1969
create table test_update_dropped(a int, b int);
insert into test_update_dropped(a, b) values(1, 1);
update test_update_dropped set a = 2 where a = 1;
alter table test_update_dropped drop column b;
update test_update_dropped set a = 3 where a = 2;
\d test_update_dropped;
        Table "public.test_update_dropped"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 a      | integer |           |          |

select * from test_update_dropped;
 a
---
 3
(1 row)

DROP TABLE test_update_dropped;
-- Test that deleting table with a returning clause after dropping a column
-- does not result in spurious error #2938.
create table test_delete_dropped(a int, b int);
insert into test_delete_dropped(a, b) values(1, 1), (2, 2);
alter table test_delete_dropped drop column b;
delete from test_delete_dropped where a = 1 returning *;
 a
---
 1
(1 row)

\d test_delete_dropped;
        Table "public.test_delete_dropped"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 a      | integer |           |          |

select * from test_delete_dropped;
 a
---
 2
(1 row)

DROP TABLE test_delete_dropped;
-- Test ALTER TABLE _ ALTER COLUMN _ TYPE _
create table test_alter_column_type(a varchar(1));
alter table test_alter_column_type add column b name;
alter table test_alter_column_type add column c text;
alter table test_alter_column_type add column d char(1);
alter table test_alter_column_type add column e varbit(1);
alter table test_alter_column_type add column f int;
alter table test_alter_column_type add column g varchar;
alter table test_alter_column_type add column h varbit;
insert into test_alter_column_type values ('a', 'b', 'c', 'd', B'1', 1, 'g', B'1');
select * from test_alter_column_type;
 a | b | c | d | e | f | g | h
---+---+---+---+---+---+---+---
 a | b | c | d | 1 | 1 | g | 1
(1 row)

\d test_alter_column_type
             Table "public.test_alter_column_type"
 Column |         Type         | Collation | Nullable | Default
--------+----------------------+-----------+----------+---------
 a      | character varying(1) |           |          |
 b      | name                 |           |          |
 c      | text                 |           |          |
 d      | character(1)         |           |          |
 e      | bit varying(1)       |           |          |
 f      | integer              |           |          |
 g      | character varying    |           |          |
 h      | bit varying          |           |          |

alter table test_alter_column_type alter column a type varchar(1);
alter table test_alter_column_type alter column a type varchar(5);
alter table test_alter_column_type alter column a type varchar(1);
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
alter table test_alter_column_type alter column a type char(10);
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
alter table test_alter_column_type alter column b type name;
alter table test_alter_column_type alter column b type varchar(100);
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
alter table test_alter_column_type alter column c type text;
alter table test_alter_column_type alter column c type varchar(100);
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
alter table test_alter_column_type alter column d type char(1);
alter table test_alter_column_type alter column d type varchar(100);
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
alter table test_alter_column_type alter column d type char(100);
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
alter table test_alter_column_type alter column e type varbit(1);
alter table test_alter_column_type alter column e type varbit(5);
alter table test_alter_column_type alter column e type varbit(1);
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
alter table test_alter_column_type alter column f type varchar(100);
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
alter table test_alter_column_type alter column f type varbit(100); --fails
ERROR:  column "f" cannot be cast automatically to type bit varying
HINT:  You might need to specify "USING f::bit varying(100)".
alter table test_alter_column_type alter column f type int; --fails
ERROR:  column "f" cannot be cast automatically to type integer
HINT:  You might need to specify "USING f::integer".
alter table test_alter_column_type alter column g type varchar;
alter table test_alter_column_type alter column g type varchar(5);
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
alter table test_alter_column_type alter column g type text;
alter table test_alter_column_type alter column h type varbit;
alter table test_alter_column_type alter column h type varbit(5);
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
insert into test_alter_column_type values ('abcde', '-', '-', '-', B'10101', 0, '-', B'0'); --fails
ERROR:  bit string too long for type bit varying(1)
insert into test_alter_column_type values ('abcde', '-', '-', '-', B'1', 0, '-', B'0');
select * from test_alter_column_type order by a;
     a      | b | c |                                                  d                                                   | e | f | g | h
------------+---+---+------------------------------------------------------------------------------------------------------+---+---+---+---
 a          | b | c | d                                                                                                    | 1 | 1 | g | 1
 abcde      | - | - | -                                                                                                    | 1 | 0 | - | 0
(2 rows)

\d test_alter_column_type
              Table "public.test_alter_column_type"
 Column |          Type          | Collation | Nullable | Default
--------+------------------------+-----------+----------+---------
 a      | character(10)          |           |          |
 b      | character varying(100) |           |          |
 c      | character varying(100) |           |          |
 d      | character(100)         |           |          |
 e      | bit varying(1)         |           |          |
 f      | character varying(100) |           |          |
 g      | text                   |           |          |
 h      | bit varying(5)         |           |          |

alter table test_alter_column_type alter column a type varchar;
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
alter table test_alter_column_type alter column e type varbit;
\d test_alter_column_type
              Table "public.test_alter_column_type"
 Column |          Type          | Collation | Nullable | Default
--------+------------------------+-----------+----------+---------
 a      | character varying      |           |          |
 b      | character varying(100) |           |          |
 c      | character varying(100) |           |          |
 d      | character(100)         |           |          |
 e      | bit varying            |           |          |
 f      | character varying(100) |           |          |
 g      | text                   |           |          |
 h      | bit varying(5)         |           |          |

DROP TABLE test_alter_column_type;
-- Test ALTER TABLE _ ALTER COLUMN _ TYPE _ with an index (Issue #6113)
create table test_alter_column_type_with_index(i int primary key, a varchar(50));
alter table test_alter_column_type_with_index alter column a type varchar(100);
insert into test_alter_column_type_with_index values (1, 'abcde'), (2, 'fghij');
create index on test_alter_column_type_with_index(a);
alter table test_alter_column_type_with_index alter column a type varchar(100);
alter table test_alter_column_type_with_index alter column a type varchar(200);
insert into test_alter_column_type_with_index values (3, 'klmno'), (4, 'pqrst');
select * from test_alter_column_type_with_index order by a;
 i |   a
---+-------
 1 | abcde
 2 | fghij
 3 | klmno
 4 | pqrst
(4 rows)

\d test_alter_column_type_with_index
         Table "public.test_alter_column_type_with_index"
 Column |          Type          | Collation | Nullable | Default
--------+------------------------+-----------+----------+---------
 i      | integer                |           | not null |
 a      | character varying(200) |           |          |
Indexes:
    "test_alter_column_type_with_index_pkey" PRIMARY KEY, lsm (i HASH)
    "test_alter_column_type_with_index_a_idx" lsm (a HASH)

DROP TABLE test_alter_column_type_with_index;
-- Test #5543 by exercising cases where ALTER command fails due to constraint
-- check validation, causing rollback of ALTER operation on DocDB.
CREATE TABLE foobar (key text, value text);
INSERT INTO foobar VALUES ('key', 'value');
ALTER TABLE foobar ADD COLUMN v2 text not null; -- fails due to not null constraint
ERROR:  column "v2" contains null values
ALTER TABLE foobar ADD COLUMN v2 text not null DEFAULT 'abc'; -- passes
DROP TABLE foobar;
--
-- Check that attaching or detaching a partitioned partition correctly leads
-- to its partitions' constraint being updated to reflect the parent's
-- newly added/removed constraint
create table target_parted (a int, b int) partition by list (a);
create table attach_parted (a int, b int) partition by list (b);
create table attach_parted_part1 partition of attach_parted for values in (1);
-- insert a row directly into the leaf partition so that its partition
-- constraint is built and stored in the relcache
insert into attach_parted_part1 values (1, 1);
-- the following better invalidate the partition constraint of the leaf
-- partition too...
alter table target_parted attach partition attach_parted for values in (1);
-- ...such that the following insert fails
insert into attach_parted_part1 values (2, 1);
ERROR:  new row for relation "attach_parted_part1" violates partition constraint
DETAIL:  Failing row contains (2, 1).
-- ...and doesn't when the partition is detached along with its own partition
alter table target_parted detach partition attach_parted;
insert into attach_parted_part1 values (2, 1);
CREATE TABLE demo (i int);
INSERT INTO demo VALUES (1);
CREATE UNIQUE INDEX demoi ON demo(i);
ALTER TABLE demo ADD CONSTRAINT demoi UNIQUE USING INDEX demoi;
INSERT INTO demo VALUES (1);
ERROR:  duplicate key value violates unique constraint "demoi"
ALTER TABLE demo DROP CONSTRAINT demoi;
INSERT INTO demo VALUES (1);
SELECT * FROM demo;
 i
---
 1
 1
(2 rows)

-- Test that an attemp to drop primary key column with sequence generator
-- does not delete the associated sequence.
CREATE TABLE tbl_serial_primary_key (k serial PRIMARY KEY, v text);
ALTER TABLE tbl_serial_primary_key DROP COLUMN k;
ERROR:  cannot drop key column "k"
INSERT INTO tbl_serial_primary_key(v) VALUES ('ABC');
SELECT * FROM tbl_serial_primary_key;
 k |  v
---+-----
 1 | ABC
(1 row)

DROP TABLE tbl_serial_primary_key;
