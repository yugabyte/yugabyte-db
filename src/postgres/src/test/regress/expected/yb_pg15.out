--
-- Tests for pg15 branch stability.
--
-- Basics
create table t1 (id int, name text);
create table t2 (id int primary key, name text);
explain (COSTS OFF) insert into t2 values (1);
  QUERY PLAN  
--------------
 Insert on t2
   ->  Result
(2 rows)

insert into t2 values (1);
explain (COSTS OFF) insert into t2 values (2), (3);
           QUERY PLAN            
---------------------------------
 Insert on t2
   ->  Values Scan on "*VALUES*"
(2 rows)

insert into t2 values (2), (3);
explain (COSTS OFF) select * from t2 where id = 1;
           QUERY PLAN           
--------------------------------
 Index Scan using t2_pkey on t2
   Index Cond: (id = 1)
(2 rows)

select * from t2 where id = 1;
 id | name 
----+------
  1 | 
(1 row)

explain (COSTS OFF) select * from t2 where id > 1;
        QUERY PLAN         
---------------------------
 Seq Scan on t2
   Remote Filter: (id > 1)
(2 rows)

select * from t2 where id > 1;
 id | name 
----+------
  2 | 
  3 | 
(2 rows)

explain (COSTS OFF) update t2 set name = 'John' where id = 1;
  QUERY PLAN  
--------------
 Update on t2
   ->  Result
(2 rows)

update t2 set name = 'John' where id = 1;
explain (COSTS OFF) update t2 set name = 'John' where id > 1;
           QUERY PLAN            
---------------------------------
 Update on t2
   ->  Seq Scan on t2
         Remote Filter: (id > 1)
(3 rows)

update t2 set name = 'John' where id > 1;
explain (COSTS OFF) update t2 set id = id + 4 where id = 1;
              QUERY PLAN              
--------------------------------------
 Update on t2
   ->  Index Scan using t2_pkey on t2
         Index Cond: (id = 1)
(3 rows)

update t2 set id = id + 4 where id = 1;
explain (COSTS OFF) update t2 set id = id + 4 where id > 1;
           QUERY PLAN            
---------------------------------
 Update on t2
   ->  Seq Scan on t2
         Remote Filter: (id > 1)
(3 rows)

update t2 set id = id + 4 where id > 1;
explain (COSTS OFF) delete from t2 where id = 1;
  QUERY PLAN  
--------------
 Delete on t2
   ->  Result
(2 rows)

delete from t2 where id = 1;
explain (COSTS OFF) delete from t2 where id > 1;
           QUERY PLAN            
---------------------------------
 Delete on t2
   ->  Seq Scan on t2
         Remote Filter: (id > 1)
(3 rows)

delete from t2 where id > 1;
-- Before update trigger test.
alter table t2 add column count int;
insert into t2 values (1, 'John', 0);
CREATE OR REPLACE FUNCTION update_count() RETURNS trigger LANGUAGE plpgsql AS
$func$
BEGIN
   NEW.count := NEW.count+1;
   RETURN NEW;
END
$func$;
CREATE TRIGGER update_count_trig BEFORE UPDATE ON t2 FOR ROW EXECUTE PROCEDURE update_count();
update t2 set name = 'Jane' where id = 1;
select * from t2;
 id | name | count 
----+------+-------
  1 | Jane |     1
(1 row)

-- CREATE INDEX
CREATE INDEX myidx on t2(name);
-- Insert with on conflict
insert into t2 values (1, 'foo') on conflict ON CONSTRAINT t2_pkey do update set id = t2.id+1;
select * from t2;
 id | name | count 
----+------+-------
  2 | Jane |     2
(1 row)

-- Joins (YB_TODO: if I move it below pushdown test, the test fails)
CREATE TABLE p1 (a int, b int, c varchar, primary key(a,b));
INSERT INTO p1 SELECT i, i % 25, to_char(i, 'FM0000') FROM generate_series(0, 599) i WHERE i % 2 = 0;
CREATE TABLE p2 (a int, b int, c varchar, primary key(a,b));
INSERT INTO p2 SELECT i, i % 25, to_char(i, 'FM0000') FROM generate_series(0, 599) i WHERE i % 3 = 0;
-- Merge join
EXPLAIN (COSTS OFF) SELECT * FROM p1 t1 JOIN p2 t2 ON t1.a = t2.a WHERE t1.a <= 100 AND t2.a <= 100;
               QUERY PLAN                
-----------------------------------------
 Merge Join
   Merge Cond: (t1.a = t2.a)
   ->  Sort
         Sort Key: t1.a
         ->  Seq Scan on p1 t1
               Remote Filter: (a <= 100)
   ->  Sort
         Sort Key: t2.a
         ->  Seq Scan on p2 t2
               Remote Filter: (a <= 100)
(10 rows)

SELECT * FROM p1 t1 JOIN p2 t2 ON t1.a = t2.a WHERE t1.a <= 100 AND t2.a <= 100;
 a  | b  |  c   | a  | b  |  c   
----+----+------+----+----+------
  0 |  0 | 0000 |  0 |  0 | 0000
  6 |  6 | 0006 |  6 |  6 | 0006
 12 | 12 | 0012 | 12 | 12 | 0012
 18 | 18 | 0018 | 18 | 18 | 0018
 24 | 24 | 0024 | 24 | 24 | 0024
 30 |  5 | 0030 | 30 |  5 | 0030
 36 | 11 | 0036 | 36 | 11 | 0036
 42 | 17 | 0042 | 42 | 17 | 0042
 48 | 23 | 0048 | 48 | 23 | 0048
 54 |  4 | 0054 | 54 |  4 | 0054
 60 | 10 | 0060 | 60 | 10 | 0060
 66 | 16 | 0066 | 66 | 16 | 0066
 72 | 22 | 0072 | 72 | 22 | 0072
 78 |  3 | 0078 | 78 |  3 | 0078
 84 |  9 | 0084 | 84 |  9 | 0084
 90 | 15 | 0090 | 90 | 15 | 0090
 96 | 21 | 0096 | 96 | 21 | 0096
(17 rows)

-- Hash join
SET enable_mergejoin = off;
EXPLAIN (COSTS OFF) SELECT * FROM p1 t1 JOIN p2 t2 ON t1.a = t2.a WHERE t1.a <= 100 AND t2.a <= 100;
               QUERY PLAN                
-----------------------------------------
 Hash Join
   Hash Cond: (t1.a = t2.a)
   ->  Seq Scan on p1 t1
         Remote Filter: (a <= 100)
   ->  Hash
         ->  Seq Scan on p2 t2
               Remote Filter: (a <= 100)
(7 rows)

SELECT * FROM p1 t1 JOIN p2 t2 ON t1.a = t2.a WHERE t1.a <= 100 AND t2.a <= 100;
 a  | b  |  c   | a  | b  |  c   
----+----+------+----+----+------
 78 |  3 | 0078 | 78 |  3 | 0078
 90 | 15 | 0090 | 90 | 15 | 0090
 12 | 12 | 0012 | 12 | 12 | 0012
  6 |  6 | 0006 |  6 |  6 | 0006
 96 | 21 | 0096 | 96 | 21 | 0096
 42 | 17 | 0042 | 42 | 17 | 0042
 48 | 23 | 0048 | 48 | 23 | 0048
 60 | 10 | 0060 | 60 | 10 | 0060
 72 | 22 | 0072 | 72 | 22 | 0072
 36 | 11 | 0036 | 36 | 11 | 0036
 54 |  4 | 0054 | 54 |  4 | 0054
 18 | 18 | 0018 | 18 | 18 | 0018
 66 | 16 | 0066 | 66 | 16 | 0066
 30 |  5 | 0030 | 30 |  5 | 0030
 84 |  9 | 0084 | 84 |  9 | 0084
  0 |  0 | 0000 |  0 |  0 | 0000
 24 | 24 | 0024 | 24 | 24 | 0024
(17 rows)

-- Batched nested loop join
SET enable_hashjoin = off;
SET enable_seqscan = off;
SET enable_material = off;
SET yb_bnl_batch_size = 3;
EXPLAIN (COSTS OFF) SELECT * FROM p1 t1 JOIN p2 t2 ON t1.a = t2.a WHERE t1.a <= 100 AND t2.a <= 100;
               QUERY PLAN                
-----------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.a)
   ->  Seq Scan on p1 t1
         Remote Filter: (a <= 100)
   ->  Index Scan using p2_pkey on p2 t2
         Remote Filter: (a <= 100)
(6 rows)

-- YB_TODO: Explain has a missing line Index Cond: (a = ANY (ARRAY[t1.a, $1, $2])) under Index Scan
SELECT * FROM p1 t1 JOIN p2 t2 ON t1.a = t2.a WHERE t1.a <= 100 AND t2.a <= 100;
 a  | b  |  c   | a  | b  |  c   
----+----+------+----+----+------
 78 |  3 | 0078 | 78 |  3 | 0078
 90 | 15 | 0090 | 90 | 15 | 0090
 12 | 12 | 0012 | 12 | 12 | 0012
  6 |  6 | 0006 |  6 |  6 | 0006
 96 | 21 | 0096 | 96 | 21 | 0096
 42 | 17 | 0042 | 42 | 17 | 0042
 48 | 23 | 0048 | 48 | 23 | 0048
 60 | 10 | 0060 | 60 | 10 | 0060
 72 | 22 | 0072 | 72 | 22 | 0072
 36 | 11 | 0036 | 36 | 11 | 0036
 54 |  4 | 0054 | 54 |  4 | 0054
 18 | 18 | 0018 | 18 | 18 | 0018
 66 | 16 | 0066 | 66 | 16 | 0066
 30 |  5 | 0030 | 30 |  5 | 0030
 84 |  9 | 0084 | 84 |  9 | 0084
  0 |  0 | 0000 |  0 |  0 | 0000
 24 | 24 | 0024 | 24 | 24 | 0024
(17 rows)

-- Update pushdown test.
CREATE TABLE single_row_decimal (k int PRIMARY KEY, v1 decimal, v2 decimal(10,2), v3 int);
CREATE FUNCTION next_v3(int) returns int language sql as $$
  SELECT v3 + 1 FROM single_row_decimal WHERE k = $1;
$$;
INSERT INTO single_row_decimal(k, v1, v2, v3) values (1,1.5,1.5,1), (2,2.5,2.5,2), (3,null, null,null);
SELECT * FROM single_row_decimal ORDER BY k;
 k | v1  |  v2  | v3
---+-----+------+----
 1 | 1.5 | 1.50 |  1
 2 | 2.5 | 2.50 |  2
 3 |     |      |
(3 rows)

UPDATE single_row_decimal SET v1 = v1 + 1.555, v2 = v2 + 1.555, v3 = v3 + 1 WHERE k = 1;
-- v2 should be rounded to 2 decimals.
SELECT * FROM single_row_decimal ORDER BY k;
 k |  v1   |  v2  | v3
---+-------+------+----
 1 | 3.055 | 3.06 |  2
 2 |   2.5 | 2.50 |  2
 3 |       |      |
(3 rows)

UPDATE single_row_decimal SET v1 = v1 + 1.555, v2 = v2 + 1.555, v3 = 3 WHERE k = 1;
SELECT * FROM single_row_decimal ORDER BY k;
 k |  v1  |  v2  | v3
---+------+------+----
 1 | 4.61 | 4.62 |  3
 2 |  2.5 | 2.50 |  2
 3 |      |      |
(3 rows)

UPDATE single_row_decimal SET v1 = v1 + 1.555, v2 = v2 + 1.555, v3 = next_v3(1) WHERE k = 1;
SELECT * FROM single_row_decimal ORDER BY k;
 k |  v1   |  v2  | v3
---+-------+------+----
 1 | 6.165 | 6.18 |  4
 2 |   2.5 | 2.50 |  2
 3 |       |      |
(3 rows)

-- Delete with returning
insert into t2 values (4), (5), (6);
delete from t2 where id > 2 returning id, name;
 id | name 
----+------
  5 | 
  6 | 
  4 | 
(3 rows)

-- COPY FROM
CREATE TABLE myemp (id int primary key, name text);
COPY myemp FROM stdin;
SELECT * from myemp;
 id | name 
----+------
  1 | a
  2 | b
(2 rows)

CREATE TABLE myemp2(id int primary key, name text) PARTITION BY range(id);
CREATE TABLE myemp2_1_100 PARTITION OF myemp2 FOR VALUES FROM (1) TO (100);
CREATE TABLE myemp2_101_200 PARTITION OF myemp2 FOR VALUES FROM (101) TO (200);
COPY myemp2 FROM stdin;
SELECT * from myemp2_1_100;
 id | name 
----+------
  1 | a
(1 row)

SELECT * from myemp2_101_200;
 id  | name 
-----+------
 102 | b
(1 row)

-- Adding PK
create table test (id int);
insert into test values (1);
ALTER TABLE test ENABLE ROW LEVEL SECURITY;
CREATE POLICY test_policy ON test FOR SELECT USING (true);
alter table test add primary key (id);
create table test2 (id int);
insert into test2 values (1), (1);
alter table test2 add primary key (id);
ERROR:  duplicate key value violates unique constraint "test2"
-- Creating partitioned table
create table emp_par1(id int primary key, name text) partition by range(id);
CREATE TABLE emp_par1_1_100 PARTITION OF emp_par1 FOR VALUES FROM (1) TO (100);
create table emp_par2(id int primary key, name text) partition by list(id);
create table emp_par3(id int primary key, name text) partition by hash(id);
-- Adding FK
create table emp(id int unique);
create table address(emp_id int, addr text);
insert into address values (1, 'a');
ALTER TABLE address ADD FOREIGN KEY(emp_id) REFERENCES emp(id);
ERROR:  insert or update on table "address" violates foreign key constraint "address_emp_id_fkey"
DETAIL:  Key (emp_id)=(1) is not present in table "emp".
insert into emp values (1);
ALTER TABLE address ADD FOREIGN KEY(emp_id) REFERENCES emp(id);
-- Adding PK with pre-existing FK constraint
alter table emp add primary key (id);
alter table address add primary key (emp_id);
-- Add primary key with with pre-existing FK where confdelsetcols non nul
create table emp2 (id int, name text, primary key (id, name));
create table address2 (id int, name text, addr text,  FOREIGN KEY (id, name) REFERENCES emp2 ON DELETE SET NULL (name));
insert into emp2 values (1, 'a'), (2, 'b');
insert into address2 values (1, 'a', 'a'), (2, 'b', 'b');
delete from emp2 where id = 1;
select * from address2 order by id;
 id | name | addr 
----+------+------
  1 |      | a
  2 | b    | b
(2 rows)

alter table address2 add primary key (id);
delete from emp2 where id = 2;
select * from address2 order by id;
 id | name | addr 
----+------+------
  1 |      | a
  2 |      | b
(2 rows)

-- create database
CREATE DATABASE mytest;
-- drop database
DROP DATABASE mytest;
create table fastpath (a int, b text, c numeric);
insert into fastpath select y.x, 'b' || (y.x/10)::text, 100 from (select generate_series(1,10000) as x) y;
select md5(string_agg(a::text, b order by a, b asc)) from fastpath
	where a >= 1000 and a < 2000 and b > 'b1' and b < 'b3';
               md5
----------------------------------
 2ca216010a558a52d7df12f76dfc77ab
(1 row)

-- Index scan test row comparison expressions
CREATE TABLE pk_range_int_asc (r1 INT, r2 INT, r3 INT, v INT, PRIMARY KEY(r1 asc, r2 asc, r3 asc));
INSERT INTO pk_range_int_asc SELECT i/25, (i/5) % 5, i % 5, i FROM generate_series(1, 125) AS i;
EXPLAIN (COSTS OFF, TIMING OFF, SUMMARY OFF, ANALYZE) SELECT * FROM pk_range_int_asc WHERE (r1, r2, r3) <= (2,3,2);
                                     QUERY PLAN
-------------------------------------------------------------------------------------
 Index Scan using pk_range_int_asc_pkey on pk_range_int_asc (actual rows=67 loops=1)
   Index Cond: (ROW(r1, r2, r3) <= ROW(2, 3, 2))
(2 rows)

SELECT * FROM pk_range_int_asc WHERE (r1, r2, r3) <= (2,3,2);
 r1 | r2 | r3 | v
----+----+----+----
  0 |  0 |  1 |  1
  0 |  0 |  2 |  2
  0 |  0 |  3 |  3
  0 |  0 |  4 |  4
  0 |  1 |  0 |  5
  0 |  1 |  1 |  6
  0 |  1 |  2 |  7
  0 |  1 |  3 |  8
  0 |  1 |  4 |  9
  0 |  2 |  0 | 10
  0 |  2 |  1 | 11
  0 |  2 |  2 | 12
  0 |  2 |  3 | 13
  0 |  2 |  4 | 14
  0 |  3 |  0 | 15
  0 |  3 |  1 | 16
  0 |  3 |  2 | 17
  0 |  3 |  3 | 18
  0 |  3 |  4 | 19
  0 |  4 |  0 | 20
  0 |  4 |  1 | 21
  0 |  4 |  2 | 22
  0 |  4 |  3 | 23
  0 |  4 |  4 | 24
  1 |  0 |  0 | 25
  1 |  0 |  1 | 26
  1 |  0 |  2 | 27
  1 |  0 |  3 | 28
  1 |  0 |  4 | 29
  1 |  1 |  0 | 30
  1 |  1 |  1 | 31
  1 |  1 |  2 | 32
  1 |  1 |  3 | 33
  1 |  1 |  4 | 34
  1 |  2 |  0 | 35
  1 |  2 |  1 | 36
  1 |  2 |  2 | 37
  1 |  2 |  3 | 38
  1 |  2 |  4 | 39
  1 |  3 |  0 | 40
  1 |  3 |  1 | 41
  1 |  3 |  2 | 42
  1 |  3 |  3 | 43
  1 |  3 |  4 | 44
  1 |  4 |  0 | 45
  1 |  4 |  1 | 46
  1 |  4 |  2 | 47
  1 |  4 |  3 | 48
  1 |  4 |  4 | 49
  2 |  0 |  0 | 50
  2 |  0 |  1 | 51
  2 |  0 |  2 | 52
  2 |  0 |  3 | 53
  2 |  0 |  4 | 54
  2 |  1 |  0 | 55
  2 |  1 |  1 | 56
  2 |  1 |  2 | 57
  2 |  1 |  3 | 58
  2 |  1 |  4 | 59
  2 |  2 |  0 | 60
  2 |  2 |  1 | 61
  2 |  2 |  2 | 62
  2 |  2 |  3 | 63
  2 |  2 |  4 | 64
  2 |  3 |  0 | 65
  2 |  3 |  1 | 66
  2 |  3 |  2 | 67
(67 rows)

-- SERIAL type
CREATE TABLE serial_test (k int, v SERIAL);
INSERT INTO serial_test VALUES (1), (1), (1);
SELECT * FROM serial_test ORDER BY v;
 k | v
---+---
 1 | 1
 1 | 2
 1 | 3
(3 rows)

SELECT last_value, is_called FROM public.serial_test_v_seq;
 last_value | is_called
------------+-----------
        100 | t
(1 row)

-- lateral join
CREATE TABLE tlateral1 (a int, b int, c varchar);
INSERT INTO tlateral1 SELECT i, i % 25, to_char(i % 4, 'FM0000') FROM generate_series(0, 599, 2) i;
CREATE TABLE tlateral2 (a int, b int, c varchar);
INSERT INTO tlateral2 SELECT i % 25, i, to_char(i % 4, 'FM0000') FROM generate_series(0, 599, 3) i;
ANALYZE tlateral1, tlateral2;
-- YB_TODO: pg15 used merge join, whereas hash join is expected.
-- EXPLAIN (COSTS FALSE) SELECT * FROM tlateral1 t1 LEFT JOIN LATERAL (SELECT t2.a AS t2a, t2.c AS t2c, t2.b AS t2b, t3.b AS t3b, least(t1.a,t2.a,t3.b) FROM tlateral1 t2 JOIN tlateral2 t3 ON (t2.a = t3.b AND t2.c = t3.c)) ss ON t1.a = ss.t2a WHERE t1.b = 0 ORDER BY t1.a;
SELECT * FROM tlateral1 t1 LEFT JOIN LATERAL (SELECT t2.a AS t2a, t2.c AS t2c, t2.b AS t2b, t3.b AS t3b, least(t1.a,t2.a,t3.b) FROM tlateral1 t2 JOIN tlateral2 t3 ON (t2.a = t3.b AND t2.c = t3.c)) ss ON t1.a = ss.t2a WHERE t1.b = 0 ORDER BY t1.a;
  a  | b |  c   | t2a | t2c  | t2b | t3b | least
-----+---+------+-----+------+-----+-----+-------
   0 | 0 | 0000 |   0 | 0000 |   0 |   0 |     0
  50 | 0 | 0002 |     |      |     |     |
 100 | 0 | 0000 |     |      |     |     |
 150 | 0 | 0002 | 150 | 0002 |   0 | 150 |   150
 200 | 0 | 0000 |     |      |     |     |
 250 | 0 | 0002 |     |      |     |     |
 300 | 0 | 0000 | 300 | 0000 |   0 | 300 |   300
 350 | 0 | 0002 |     |      |     |     |
 400 | 0 | 0000 |     |      |     |     |
 450 | 0 | 0002 | 450 | 0002 |   0 | 450 |   450
 500 | 0 | 0000 |     |      |     |     |
 550 | 0 | 0002 |     |      |     |     |
(12 rows)

-- Insert with on conflict on temp table
create temporary table mytmp (id int primary key, name text, count int);
insert into mytmp values (1, 'foo', 0);
insert into mytmp values (1, 'foo') on conflict ON CONSTRAINT mytmp_pkey do update set id = mytmp.id+1;
select * from mytmp;
 id | name | count 
----+------+-------
  2 | foo  |     0
(1 row)

CREATE OR REPLACE FUNCTION update_count() RETURNS trigger LANGUAGE plpgsql AS
$func$
BEGIN
   NEW.count := NEW.count+1;
   RETURN NEW;
END
$func$;
CREATE TRIGGER update_count_trig BEFORE UPDATE ON mytmp FOR ROW EXECUTE PROCEDURE update_count();
insert into mytmp values (2, 'foo') on conflict ON CONSTRAINT mytmp_pkey do update set id = mytmp.id+1;
select * from mytmp;
 id | name | count 
----+------+-------
  3 | foo  |     1
(1 row)

create view myview as  select * from mytmp;
NOTICE:  view "myview" will be a temporary view
insert into myview values (3, 'foo') on conflict (id) do update set id = myview.id + 1;
select * from myview;
 id | name | count 
----+------+-------
  4 | foo  |     2
(1 row)

-- Cleanup
DROP TABLE IF EXISTS address, address2, emp, emp2, emp_par1, emp_par1_1_100, emp_par2, emp_par3,
  fastpath, myemp, myemp2, myemp2_101_200, myemp2_1_100, p1, p2, pk_range_int_asc,
  single_row_decimal, t1, t2, test, test2, serial_test, tlateral1, tlateral2 CASCADE;
