--
-- Tests for pg15 branch stability.
--
-- Basics
create table t1 (id int, name text);
create table t2 (id int primary key, name text);
explain (COSTS OFF) insert into t2 values (1);
  QUERY PLAN  
--------------
 Insert on t2
   ->  Result
(2 rows)

insert into t2 values (1);
explain (COSTS OFF) insert into t2 values (2), (3);
           QUERY PLAN            
---------------------------------
 Insert on t2
   ->  Values Scan on "*VALUES*"
(2 rows)

insert into t2 values (2), (3);
explain (COSTS OFF) select * from t2 where id = 1;
           QUERY PLAN           
--------------------------------
 Index Scan using t2_pkey on t2
   Index Cond: (id = 1)
(2 rows)

select * from t2 where id = 1;
 id | name 
----+------
  1 | 
(1 row)

explain (COSTS OFF) select * from t2 where id > 1;
         QUERY PLAN         
----------------------------
 Seq Scan on t2
   Storage Filter: (id > 1)
(2 rows)

select * from t2 where id > 1;
 id | name 
----+------
  2 | 
  3 | 
(2 rows)

explain (COSTS OFF) update t2 set name = 'John' where id = 1;
  QUERY PLAN  
--------------
 Update on t2
   ->  Result
(2 rows)

update t2 set name = 'John' where id = 1;
explain (COSTS OFF) update t2 set name = 'John' where id > 1;
            QUERY PLAN            
----------------------------------
 Update on t2
   ->  Seq Scan on t2
         Storage Filter: (id > 1)
(3 rows)

update t2 set name = 'John' where id > 1;
explain (COSTS OFF) update t2 set id = id + 4 where id = 1;
              QUERY PLAN              
--------------------------------------
 Update on t2
   ->  Index Scan using t2_pkey on t2
         Index Cond: (id = 1)
(3 rows)

update t2 set id = id + 4 where id = 1;
explain (COSTS OFF) update t2 set id = id + 4 where id > 1;
            QUERY PLAN            
----------------------------------
 Update on t2
   ->  Seq Scan on t2
         Storage Filter: (id > 1)
(3 rows)

update t2 set id = id + 4 where id > 1;
explain (COSTS OFF) delete from t2 where id = 1;
  QUERY PLAN  
--------------
 Delete on t2
   ->  Result
(2 rows)

delete from t2 where id = 1;
explain (COSTS OFF) delete from t2 where id > 1;
            QUERY PLAN            
----------------------------------
 Delete on t2
   ->  Seq Scan on t2
         Storage Filter: (id > 1)
(3 rows)

delete from t2 where id > 1;
-- Before update trigger test.
alter table t2 add column count int;
insert into t2 values (1, 'John', 0);
CREATE OR REPLACE FUNCTION update_count() RETURNS trigger LANGUAGE plpgsql AS
$func$
BEGIN
   NEW.count := NEW.count+1;
   RETURN NEW;
END
$func$;
CREATE TRIGGER update_count_trig BEFORE UPDATE ON t2 FOR ROW EXECUTE PROCEDURE update_count();
update t2 set name = 'Jane' where id = 1;
select * from t2;
 id | name | count 
----+------+-------
  1 | Jane |     1
(1 row)

-- CREATE INDEX
CREATE INDEX myidx on t2(name);
-- Insert with on conflict
insert into t2 values (1, 'foo') on conflict ON CONSTRAINT t2_pkey do update set id = t2.id+1;
select * from t2;
 id | name | count 
----+------+-------
  2 | Jane |     2
(1 row)

-- Joins (YB_TODO: if I move it below pushdown test, the test fails)
CREATE TABLE p1 (a int, b int, c varchar, primary key(a,b));
INSERT INTO p1 SELECT i, i % 25, to_char(i, 'FM0000') FROM generate_series(0, 599) i WHERE i % 2 = 0;
CREATE TABLE p2 (a int, b int, c varchar, primary key(a,b));
INSERT INTO p2 SELECT i, i % 25, to_char(i, 'FM0000') FROM generate_series(0, 599) i WHERE i % 3 = 0;
-- Merge join
EXPLAIN (COSTS OFF) SELECT * FROM p1 t1 JOIN p2 t2 ON t1.a = t2.a WHERE t1.a <= 100 AND t2.a <= 100;
                QUERY PLAN                
------------------------------------------
 Merge Join
   Merge Cond: (t1.a = t2.a)
   ->  Sort
         Sort Key: t1.a
         ->  Seq Scan on p1 t1
               Storage Filter: (a <= 100)
   ->  Sort
         Sort Key: t2.a
         ->  Seq Scan on p2 t2
               Storage Filter: (a <= 100)
(10 rows)

SELECT * FROM p1 t1 JOIN p2 t2 ON t1.a = t2.a WHERE t1.a <= 100 AND t2.a <= 100;
 a  | b  |  c   | a  | b  |  c   
----+----+------+----+----+------
  0 |  0 | 0000 |  0 |  0 | 0000
  6 |  6 | 0006 |  6 |  6 | 0006
 12 | 12 | 0012 | 12 | 12 | 0012
 18 | 18 | 0018 | 18 | 18 | 0018
 24 | 24 | 0024 | 24 | 24 | 0024
 30 |  5 | 0030 | 30 |  5 | 0030
 36 | 11 | 0036 | 36 | 11 | 0036
 42 | 17 | 0042 | 42 | 17 | 0042
 48 | 23 | 0048 | 48 | 23 | 0048
 54 |  4 | 0054 | 54 |  4 | 0054
 60 | 10 | 0060 | 60 | 10 | 0060
 66 | 16 | 0066 | 66 | 16 | 0066
 72 | 22 | 0072 | 72 | 22 | 0072
 78 |  3 | 0078 | 78 |  3 | 0078
 84 |  9 | 0084 | 84 |  9 | 0084
 90 | 15 | 0090 | 90 | 15 | 0090
 96 | 21 | 0096 | 96 | 21 | 0096
(17 rows)

-- Hash join
SET enable_mergejoin = off;
EXPLAIN (COSTS OFF) SELECT * FROM p1 t1 JOIN p2 t2 ON t1.a = t2.a WHERE t1.a <= 100 AND t2.a <= 100;
                QUERY PLAN                
------------------------------------------
 Hash Join
   Hash Cond: (t1.a = t2.a)
   ->  Seq Scan on p1 t1
         Storage Filter: (a <= 100)
   ->  Hash
         ->  Seq Scan on p2 t2
               Storage Filter: (a <= 100)
(7 rows)

SELECT * FROM p1 t1 JOIN p2 t2 ON t1.a = t2.a WHERE t1.a <= 100 AND t2.a <= 100;
 a  | b  |  c   | a  | b  |  c   
----+----+------+----+----+------
 78 |  3 | 0078 | 78 |  3 | 0078
 90 | 15 | 0090 | 90 | 15 | 0090
 12 | 12 | 0012 | 12 | 12 | 0012
  6 |  6 | 0006 |  6 |  6 | 0006
 96 | 21 | 0096 | 96 | 21 | 0096
 42 | 17 | 0042 | 42 | 17 | 0042
 48 | 23 | 0048 | 48 | 23 | 0048
 60 | 10 | 0060 | 60 | 10 | 0060
 72 | 22 | 0072 | 72 | 22 | 0072
 36 | 11 | 0036 | 36 | 11 | 0036
 54 |  4 | 0054 | 54 |  4 | 0054
 18 | 18 | 0018 | 18 | 18 | 0018
 66 | 16 | 0066 | 66 | 16 | 0066
 30 |  5 | 0030 | 30 |  5 | 0030
 84 |  9 | 0084 | 84 |  9 | 0084
  0 |  0 | 0000 |  0 |  0 | 0000
 24 | 24 | 0024 | 24 | 24 | 0024
(17 rows)

-- Batched nested loop join
ANALYZE p1;
ANALYZE p2;
SET enable_hashjoin = off;
SET enable_seqscan = off;
SET enable_material = off;
SET yb_bnl_batch_size = 3;
EXPLAIN (COSTS OFF) SELECT * FROM p1 t1 JOIN p2 t2 ON t1.a = t2.a WHERE t1.a <= 100 AND t2.a <= 100;
                     QUERY PLAN                      
-----------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.a)
   ->  Seq Scan on p2 t2
         Storage Filter: (a <= 100)
   ->  Index Scan using p1_pkey on p1 t1
         Index Cond: (a = ANY (ARRAY[t2.a, $1, $2]))
         Storage Filter: (a <= 100)
(7 rows)

SELECT * FROM p1 t1 JOIN p2 t2 ON t1.a = t2.a WHERE t1.a <= 100 AND t2.a <= 100;
 a  | b  |  c   | a  | b  |  c   
----+----+------+----+----+------
 78 |  3 | 0078 | 78 |  3 | 0078
 90 | 15 | 0090 | 90 | 15 | 0090
 12 | 12 | 0012 | 12 | 12 | 0012
  6 |  6 | 0006 |  6 |  6 | 0006
 96 | 21 | 0096 | 96 | 21 | 0096
 42 | 17 | 0042 | 42 | 17 | 0042
 48 | 23 | 0048 | 48 | 23 | 0048
 60 | 10 | 0060 | 60 | 10 | 0060
 72 | 22 | 0072 | 72 | 22 | 0072
 36 | 11 | 0036 | 36 | 11 | 0036
 54 |  4 | 0054 | 54 |  4 | 0054
 18 | 18 | 0018 | 18 | 18 | 0018
 66 | 16 | 0066 | 66 | 16 | 0066
 30 |  5 | 0030 | 30 |  5 | 0030
 84 |  9 | 0084 | 84 |  9 | 0084
  0 |  0 | 0000 |  0 |  0 | 0000
 24 | 24 | 0024 | 24 | 24 | 0024
(17 rows)

SET enable_mergejoin = on;
SET enable_hashjoin = on;
SET enable_seqscan = on;
SET enable_material = on;
-- Update pushdown test.
CREATE TABLE single_row_decimal (k int PRIMARY KEY, v1 decimal, v2 decimal(10,2), v3 int);
CREATE FUNCTION next_v3(int) returns int language sql as $$
  SELECT v3 + 1 FROM single_row_decimal WHERE k = $1;
$$;
INSERT INTO single_row_decimal(k, v1, v2, v3) values (1,1.5,1.5,1), (2,2.5,2.5,2), (3,null, null,null);
SELECT * FROM single_row_decimal ORDER BY k;
 k | v1  |  v2  | v3
---+-----+------+----
 1 | 1.5 | 1.50 |  1
 2 | 2.5 | 2.50 |  2
 3 |     |      |
(3 rows)

UPDATE single_row_decimal SET v1 = v1 + 1.555, v2 = v2 + 1.555, v3 = v3 + 1 WHERE k = 1;
-- v2 should be rounded to 2 decimals.
SELECT * FROM single_row_decimal ORDER BY k;
 k |  v1   |  v2  | v3
---+-------+------+----
 1 | 3.055 | 3.06 |  2
 2 |   2.5 | 2.50 |  2
 3 |       |      |
(3 rows)

UPDATE single_row_decimal SET v1 = v1 + 1.555, v2 = v2 + 1.555, v3 = 3 WHERE k = 1;
SELECT * FROM single_row_decimal ORDER BY k;
 k |  v1  |  v2  | v3
---+------+------+----
 1 | 4.61 | 4.62 |  3
 2 |  2.5 | 2.50 |  2
 3 |      |      |
(3 rows)

UPDATE single_row_decimal SET v1 = v1 + 1.555, v2 = v2 + 1.555, v3 = next_v3(1) WHERE k = 1;
SELECT * FROM single_row_decimal ORDER BY k;
 k |  v1   |  v2  | v3
---+-------+------+----
 1 | 6.165 | 6.18 |  4
 2 |   2.5 | 2.50 |  2
 3 |       |      |
(3 rows)

-- Delete with returning
insert into t2 values (4), (5), (6);
delete from t2 where id > 2 returning id, name;
 id | name 
----+------
  5 | 
  6 | 
  4 | 
(3 rows)

-- COPY FROM
CREATE TABLE myemp (id int primary key, name text);
COPY myemp FROM stdin;
SELECT * from myemp;
 id | name 
----+------
  1 | a
  2 | b
(2 rows)

CREATE TABLE myemp2(id int primary key, name text) PARTITION BY range(id);
CREATE TABLE myemp2_1_100 PARTITION OF myemp2 FOR VALUES FROM (1) TO (100);
CREATE TABLE myemp2_101_200 PARTITION OF myemp2 FOR VALUES FROM (101) TO (200);
COPY myemp2 FROM stdin;
SELECT * from myemp2_1_100;
 id | name 
----+------
  1 | a
(1 row)

SELECT * from myemp2_101_200;
 id  | name 
-----+------
 102 | b
(1 row)

-- Adding PK
create table test (id int);
insert into test values (1);
ALTER TABLE test ENABLE ROW LEVEL SECURITY;
CREATE POLICY test_policy ON test FOR SELECT USING (true);
alter table test add primary key (id);
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
create table test2 (id int);
insert into test2 values (1), (1);
alter table test2 add primary key (id);
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
ERROR:  duplicate key value violates unique constraint "test2"
-- Creating partitioned table
create table emp_par1(id int primary key, name text) partition by range(id);
CREATE TABLE emp_par1_1_100 PARTITION OF emp_par1 FOR VALUES FROM (1) TO (100);
create table emp_par2(id int primary key, name text) partition by list(id);
create table emp_par3(id int primary key, name text) partition by hash(id);
-- Adding FK
create table emp(id int unique);
create table address(emp_id int, addr text);
insert into address values (1, 'a');
ALTER TABLE address ADD FOREIGN KEY(emp_id) REFERENCES emp(id);
ERROR:  insert or update on table "address" violates foreign key constraint "address_emp_id_fkey"
DETAIL:  Key (emp_id)=(1) is not present in table "emp".
insert into emp values (1);
ALTER TABLE address ADD FOREIGN KEY(emp_id) REFERENCES emp(id);
-- Adding PK with pre-existing FK constraint
alter table emp add primary key (id);
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
alter table address add primary key (emp_id);
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
-- Add primary key with with pre-existing FK where confdelsetcols non nul
create table emp2 (id int, name text, primary key (id, name));
create table address2 (id int, name text, addr text,  FOREIGN KEY (id, name) REFERENCES emp2 ON DELETE SET NULL (name));
insert into emp2 values (1, 'a'), (2, 'b');
insert into address2 values (1, 'a', 'a'), (2, 'b', 'b');
delete from emp2 where id = 1;
select * from address2 order by id;
 id | name | addr 
----+------+------
  1 |      | a
  2 | b    | b
(2 rows)

alter table address2 add primary key (id);
NOTICE:  table rewrite may lead to inconsistencies
DETAIL:  Concurrent DMLs may not be reflected in the new table.
HINT:  See https://github.com/yugabyte/yugabyte-db/issues/19860. Set 'ysql_suppress_unsafe_alter_notice' yb-tserver gflag to true to suppress this notice.
delete from emp2 where id = 2;
select * from address2 order by id;
 id | name | addr 
----+------+------
  1 |      | a
  2 |      | b
(2 rows)

-- create database
CREATE DATABASE mytest;
-- drop database
DROP DATABASE mytest;
create table fastpath (a int, b text, c numeric);
insert into fastpath select y.x, 'b' || (y.x/10)::text, 100 from (select generate_series(1,10000) as x) y;
select md5(string_agg(a::text, b order by a, b asc)) from fastpath
	where a >= 1000 and a < 2000 and b > 'b1' and b < 'b3';
               md5
----------------------------------
 2ca216010a558a52d7df12f76dfc77ab
(1 row)

-- Index scan test row comparison expressions
CREATE TABLE pk_range_int_asc (r1 INT, r2 INT, r3 INT, v INT, PRIMARY KEY(r1 asc, r2 asc, r3 asc));
INSERT INTO pk_range_int_asc SELECT i/25, (i/5) % 5, i % 5, i FROM generate_series(1, 125) AS i;
EXPLAIN (COSTS OFF, TIMING OFF, SUMMARY OFF, ANALYZE) SELECT * FROM pk_range_int_asc WHERE (r1, r2, r3) <= (2,3,2);
                                     QUERY PLAN
-------------------------------------------------------------------------------------
 Index Scan using pk_range_int_asc_pkey on pk_range_int_asc (actual rows=67 loops=1)
   Index Cond: (ROW(r1, r2, r3) <= ROW(2, 3, 2))
(2 rows)

SELECT * FROM pk_range_int_asc WHERE (r1, r2, r3) <= (2,3,2);
 r1 | r2 | r3 | v
----+----+----+----
  0 |  0 |  1 |  1
  0 |  0 |  2 |  2
  0 |  0 |  3 |  3
  0 |  0 |  4 |  4
  0 |  1 |  0 |  5
  0 |  1 |  1 |  6
  0 |  1 |  2 |  7
  0 |  1 |  3 |  8
  0 |  1 |  4 |  9
  0 |  2 |  0 | 10
  0 |  2 |  1 | 11
  0 |  2 |  2 | 12
  0 |  2 |  3 | 13
  0 |  2 |  4 | 14
  0 |  3 |  0 | 15
  0 |  3 |  1 | 16
  0 |  3 |  2 | 17
  0 |  3 |  3 | 18
  0 |  3 |  4 | 19
  0 |  4 |  0 | 20
  0 |  4 |  1 | 21
  0 |  4 |  2 | 22
  0 |  4 |  3 | 23
  0 |  4 |  4 | 24
  1 |  0 |  0 | 25
  1 |  0 |  1 | 26
  1 |  0 |  2 | 27
  1 |  0 |  3 | 28
  1 |  0 |  4 | 29
  1 |  1 |  0 | 30
  1 |  1 |  1 | 31
  1 |  1 |  2 | 32
  1 |  1 |  3 | 33
  1 |  1 |  4 | 34
  1 |  2 |  0 | 35
  1 |  2 |  1 | 36
  1 |  2 |  2 | 37
  1 |  2 |  3 | 38
  1 |  2 |  4 | 39
  1 |  3 |  0 | 40
  1 |  3 |  1 | 41
  1 |  3 |  2 | 42
  1 |  3 |  3 | 43
  1 |  3 |  4 | 44
  1 |  4 |  0 | 45
  1 |  4 |  1 | 46
  1 |  4 |  2 | 47
  1 |  4 |  3 | 48
  1 |  4 |  4 | 49
  2 |  0 |  0 | 50
  2 |  0 |  1 | 51
  2 |  0 |  2 | 52
  2 |  0 |  3 | 53
  2 |  0 |  4 | 54
  2 |  1 |  0 | 55
  2 |  1 |  1 | 56
  2 |  1 |  2 | 57
  2 |  1 |  3 | 58
  2 |  1 |  4 | 59
  2 |  2 |  0 | 60
  2 |  2 |  1 | 61
  2 |  2 |  2 | 62
  2 |  2 |  3 | 63
  2 |  2 |  4 | 64
  2 |  3 |  0 | 65
  2 |  3 |  1 | 66
  2 |  3 |  2 | 67
(67 rows)

-- SERIAL type
CREATE TABLE serial_test (k int, v SERIAL);
INSERT INTO serial_test VALUES (1), (1), (1);
SELECT * FROM serial_test ORDER BY v;
 k | v
---+---
 1 | 1
 1 | 2
 1 | 3
(3 rows)

SELECT last_value, is_called FROM public.serial_test_v_seq;
 last_value | is_called
------------+-----------
        100 | t
(1 row)

-- lateral join
CREATE TABLE tlateral1 (a int, b int, c varchar);
INSERT INTO tlateral1 SELECT i, i % 25, to_char(i % 4, 'FM0000') FROM generate_series(0, 599, 2) i;
CREATE TABLE tlateral2 (a int, b int, c varchar);
INSERT INTO tlateral2 SELECT i % 25, i, to_char(i % 4, 'FM0000') FROM generate_series(0, 599, 3) i;
ANALYZE tlateral1, tlateral2;
-- YB_TODO: pg15 used merge join, whereas hash join is expected.
-- EXPLAIN (COSTS FALSE) SELECT * FROM tlateral1 t1 LEFT JOIN LATERAL (SELECT t2.a AS t2a, t2.c AS t2c, t2.b AS t2b, t3.b AS t3b, least(t1.a,t2.a,t3.b) FROM tlateral1 t2 JOIN tlateral2 t3 ON (t2.a = t3.b AND t2.c = t3.c)) ss ON t1.a = ss.t2a WHERE t1.b = 0 ORDER BY t1.a;
SELECT * FROM tlateral1 t1 LEFT JOIN LATERAL (SELECT t2.a AS t2a, t2.c AS t2c, t2.b AS t2b, t3.b AS t3b, least(t1.a,t2.a,t3.b) FROM tlateral1 t2 JOIN tlateral2 t3 ON (t2.a = t3.b AND t2.c = t3.c)) ss ON t1.a = ss.t2a WHERE t1.b = 0 ORDER BY t1.a;
  a  | b |  c   | t2a | t2c  | t2b | t3b | least
-----+---+------+-----+------+-----+-----+-------
   0 | 0 | 0000 |   0 | 0000 |   0 |   0 |     0
  50 | 0 | 0002 |     |      |     |     |
 100 | 0 | 0000 |     |      |     |     |
 150 | 0 | 0002 | 150 | 0002 |   0 | 150 |   150
 200 | 0 | 0000 |     |      |     |     |
 250 | 0 | 0002 |     |      |     |     |
 300 | 0 | 0000 | 300 | 0000 |   0 | 300 |   300
 350 | 0 | 0002 |     |      |     |     |
 400 | 0 | 0000 |     |      |     |     |
 450 | 0 | 0002 | 450 | 0002 |   0 | 450 |   450
 500 | 0 | 0000 |     |      |     |     |
 550 | 0 | 0002 |     |      |     |     |
(12 rows)

-- Test FailedAssertion("BufferIsValid(bsrcslot->buffer) failure from ExecCopySlot in ExecMergeJoin.
CREATE TABLE mytest1(h int, r int, v1 int, v2 int, v3 int, primary key(h HASH, r ASC));
INSERT INTO mytest1 VALUES (1,2,4,9,2), (2,3,2,4,6);
CREATE TABLE mytest2(h int, r int, v1 int, v2 int, v3 int, primary key(h ASC, r ASC));
INSERT INTO mytest2 VALUES (1,2,4,5,7), (1,3,8,6,1), (4,3,7,3,2);
SET enable_hashjoin = off;
SET enable_nestloop = off;
explain SELECT * FROM mytest1 t1 JOIN mytest2 t2 on t1.h = t2.h WHERE t2.r = 2;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Merge Join  (cost=149.83..175.33 rows=500 width=40)
   Merge Cond: (t1.h = t2.h)
   ->  Sort  (cost=149.83..152.33 rows=1000 width=20)
         Sort Key: t1.h
         ->  Seq Scan on mytest1 t1  (cost=0.00..100.00 rows=1000 width=20)
   ->  Index Scan using mytest2_pkey on mytest2 t2  (cost=0.00..15.25 rows=100 width=20)
         Index Cond: (r = 2)
(7 rows)

SELECT * FROM mytest1 t1 JOIN mytest2 t2 on t1.h = t2.h WHERE t2.r = 2;
 h | r | v1 | v2 | v3 | h | r | v1 | v2 | v3 
---+---+----+----+----+---+---+----+----+----
 1 | 2 |  4 |  9 |  2 | 1 | 2 |  4 |  5 |  7
(1 row)

SET enable_hashjoin = on;
SET enable_nestloop = on;
-- Insert with on conflict on temp table
create temporary table mytmp (id int primary key, name text, count int);
insert into mytmp values (1, 'foo', 0);
insert into mytmp values (1, 'foo') on conflict ON CONSTRAINT mytmp_pkey do update set id = mytmp.id+1;
select * from mytmp;
 id | name | count 
----+------+-------
  2 | foo  |     0
(1 row)

CREATE OR REPLACE FUNCTION update_count() RETURNS trigger LANGUAGE plpgsql AS
$func$
BEGIN
   NEW.count := NEW.count+1;
   RETURN NEW;
END
$func$;
CREATE TRIGGER update_count_trig BEFORE UPDATE ON mytmp FOR ROW EXECUTE PROCEDURE update_count();
insert into mytmp values (2, 'foo') on conflict ON CONSTRAINT mytmp_pkey do update set id = mytmp.id+1;
select * from mytmp;
 id | name | count 
----+------+-------
  3 | foo  |     1
(1 row)

create view myview as  select * from mytmp;
NOTICE:  view "myview" will be a temporary view
insert into myview values (3, 'foo') on conflict (id) do update set id = myview.id + 1;
select * from myview;
 id | name | count 
----+------+-------
  4 | foo  |     2
(1 row)

-- YB batched nested loop join
CREATE TABLE p3 (a int, b int, c varchar, primary key(a,b));
INSERT INTO p3 SELECT i, i % 25, to_char(i, 'FM0000') FROM generate_series(0, 599) i WHERE i % 5 = 0;
ANALYZE p3;
CREATE INDEX p1_b_idx ON p1 (b ASC);
SET enable_hashjoin = off;
SET enable_mergejoin = off;
SET enable_seqscan = off;
SET enable_material = off;
SET yb_bnl_batch_size = 3;
SELECT * FROM p1 JOIN p2 ON p1.a = p2.b AND p2.a = p1.b;
 a  | b  |  c   | a  | b  |  c   
----+----+------+----+----+------
  0 |  0 | 0000 |  0 |  0 | 0000
  6 |  6 | 0006 |  6 |  6 | 0006
 12 | 12 | 0012 | 12 | 12 | 0012
 18 | 18 | 0018 | 18 | 18 | 0018
 24 | 24 | 0024 | 24 | 24 | 0024
(5 rows)

SELECT * FROM p3 t3 RIGHT OUTER JOIN (SELECT t1.a as a FROM p1 t1 JOIN p2 t2 ON t1.a = t2.b WHERE t1.b <= 10 AND t2.b <= 15) s ON t3.a = s.a;
 a  | b  |  c   | a  
----+----+------+----
 10 | 10 | 0010 | 10
    |    |      |  6
    |    |      |  6
 10 | 10 | 0010 | 10
 10 | 10 | 0010 | 10
    |    |      |  8
 10 | 10 | 0010 | 10
    |    |      |  2
    |    |      |  2
  0 |  0 | 0000 |  0
  0 |  0 | 0000 |  0
    |    |      |  4
  0 |  0 | 0000 |  0
    |    |      |  4
    |    |      |  8
 10 | 10 | 0010 | 10
    |    |      |  4
    |    |      |  6
 10 | 10 | 0010 | 10
    |    |      |  4
    |    |      |  4
    |    |      |  2
    |    |      |  8
    |    |      |  6
 10 | 10 | 0010 | 10
    |    |      |  2
    |    |      |  8
  0 |  0 | 0000 |  0
    |    |      |  4
    |    |      |  6
  0 |  0 | 0000 |  0
    |    |      |  4
    |    |      |  8
  0 |  0 | 0000 |  0
  0 |  0 | 0000 |  0
    |    |      |  2
    |    |      |  2
    |    |      |  4
    |    |      |  8
    |    |      |  2
    |    |      |  8
    |    |      |  6
  0 |  0 | 0000 |  0
    |    |      |  8
    |    |      |  6
 10 | 10 | 0010 | 10
    |    |      |  2
    |    |      |  6
(48 rows)

CREATE TABLE m1 (a money, primary key(a asc));
INSERT INTO m1 SELECT i*2 FROM generate_series(1, 2000) i;
CREATE TABLE m2 (a money, primary key(a asc));
INSERT INTO m2 SELECT i*5 FROM generate_series(1, 2000) i;
SELECT * FROM m1 t1 JOIN m2 t2 ON t1.a = t2.a WHERE t1.a <= 50::money;
   a    |   a    
--------+--------
 $10.00 | $10.00
 $20.00 | $20.00
 $30.00 | $30.00
 $40.00 | $40.00
 $50.00 | $50.00
(5 rows)

-- Index on tmp table
create temp table prtx2 (a integer, b integer, c integer);
insert into prtx2 select 1 + i%10, i, i from generate_series(1,5000) i, generate_series(1,10) j;
create index on prtx2 (c);
-- testing yb_hash_code pushdown on a secondary index with a text hash column
CREATE TABLE text_table (hr text, ti text, tj text, i int, j int, primary key (hr));
INSERT INTO text_table SELECT i::TEXT, i::TEXT, i::TEXT, i, i FROM generate_series(1,10000) i;
CREATE INDEX textidx ON text_table (tj);
SELECT tj FROM text_table WHERE yb_hash_code(tj) <= 63;
  tj  
------
 4999
 8300
 6918
 912
 8646
 4946
 6920
 6785
 5659
 1363
(10 rows)

-- Row locking
CREATE TABLE t(h INT, r INT, PRIMARY KEY(h, r));
INSERT INTO t VALUES(1, 1), (1, 3);
SELECT * FROM t WHERE h = 1 AND r in(1, 3) FOR KEY SHARE;
 h | r 
---+---
 1 | 1
 1 | 3
(2 rows)

DROP TABLE t;
-- Test for ItemPointerIsValid assertion failure
CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow', 'green', 'blue', 'purple');
-- Aggregate pushdown
SELECT COUNT(*) FROM pg_enum WHERE enumtypid = 'rainbow'::regtype;
 count 
-------
     6
(1 row)

-- IndexOnlyScan
SELECT enumlabel FROM pg_enum WHERE enumtypid = 'rainbow'::regtype;
 enumlabel 
-----------
 blue
 green
 orange
 purple
 red
 yellow
(6 rows)

-- Cleanup
DROP TABLE IF EXISTS address, address2, emp, emp2, emp_par1, emp_par1_1_100, emp_par2, emp_par3,
  fastpath, myemp, myemp2, myemp2_101_200, myemp2_1_100, p1, p2, pk_range_int_asc,
  single_row_decimal, t1, t2, test, test2, serial_test, tlateral1, tlateral2, mytest1, mytest2 CASCADE;
-- insert into temp table in function body
create temp table compos (f1 int, f2 text);
create function fcompos1(v compos) returns void as $$
insert into compos values (v.*);
$$ language sql;
select fcompos1(row(1,'one'));
 fcompos1 
----------
 
(1 row)

-- very basic REINDEX
CREATE TABLE yb (i int PRIMARY KEY, j int);
CREATE INDEX NONCONCURRENTLY ON yb (j);
UPDATE pg_index SET indisvalid = false
    WHERE indexrelid = 'yb_j_idx'::regclass;
\c
REINDEX INDEX yb_j_idx;
UPDATE pg_index SET indisvalid = false
    WHERE indexrelid = 'yb_j_idx'::regclass;
\c
\set VERBOSITY terse
REINDEX(verbose) INDEX yb_j_idx;
INFO:  index "yb_j_idx" was reindexed
\set VERBOSITY default
-- internal collation
create table texttab (t text);
insert into texttab values ('a');
select count(*) from texttab group by t;
 count
-------
     1
(1 row)

-- ALTER TABLE ADD COLUMN DEFAULT with pre-existing rows
CREATE TABLE mytable (pk INT NOT NULL PRIMARY KEY);
INSERT INTO mytable SELECT * FROM generate_series(1, 10) a;
ALTER TABLE mytable ADD COLUMN c_bigint BIGINT NOT NULL DEFAULT -1;
SELECT c_bigint FROM mytable WHERE c_bigint = -1 LIMIT 1;
 c_bigint 
----------
       -1
(1 row)

DROP TABLE mytable;
-- Test ON CONFLICT DO UPDATE with partitioned table and non-identical children
CREATE TABLE upsert_test (
    a   INT PRIMARY KEY,
    b   TEXT
) PARTITION BY LIST (a);
CREATE TABLE upsert_test_1 PARTITION OF upsert_test FOR VALUES IN (1);
CREATE TABLE upsert_test_2 (b TEXT, a INT PRIMARY KEY);
ALTER TABLE upsert_test ATTACH PARTITION upsert_test_2 FOR VALUES IN (2);
INSERT INTO upsert_test VALUES(1, 'Boo'), (2, 'Zoo');
-- uncorrelated sub-select:
WITH aaa AS (SELECT 1 AS a, 'Foo' AS b) INSERT INTO upsert_test
  VALUES (1, 'Bar') ON CONFLICT(a)
  DO UPDATE SET (b, a) = (SELECT b, a FROM aaa) RETURNING *;
 a |  b
---+-----
 1 | Foo
(1 row)

-- correlated sub-select:
WITH aaa AS (SELECT 1 AS ctea, ' Foo' AS cteb) INSERT INTO upsert_test
  VALUES (1, 'Bar'), (2, 'Baz') ON CONFLICT(a)
  DO UPDATE SET (b, a) = (SELECT upsert_test.b||cteb, upsert_test.a FROM aaa) RETURNING *;
 a |    b
---+---------
 1 | Foo Foo
 2 | Zoo Foo
(2 rows)

DROP TABLE upsert_test;
-- Update partitioned table with multiple partitions
CREATE TABLE t(id int) PARTITION BY range(id);
CREATE TABLE t_1_100 PARTITION OF t FOR VALUES FROM (1) TO (100);
CREATE TABLE t_101_200 PARTITION OF t FOR VALUES FROM (101) TO (200);
INSERT INTO t VALUES (1);
UPDATE t SET id = 2;
SELECT * FROM t;
 id 
----
  2
(1 row)

DROP TABLE t;
-- Update partitioned table with multiple partitions and secondary index
CREATE TABLE t3(id int primary key, name int, add int, unique(id, name)) PARTITION BY range(id);
CREATE TABLE t3_1_100 partition of t3 FOR VALUES FROM (1) TO (100);
CREATE TABLE t3_101_200 partition of t3 FOR VALUES FROM (101) TO (200);
INSERT INTO t3 VALUES (1, 1, 1);
UPDATE t3 SET ADD = 2;
SELECT * from t3;
 id | name | add 
----+------+-----
  1 |    1 |   2
(1 row)

DROP TABLE t3;
-- Test whether single row optimization is invoked when
-- only one partition is being updated.
CREATE TABLE list_parted (a int, b int, c int, primary key(a,b)) PARTITION BY list (a);
CREATE TABLE sub_parted PARTITION OF list_parted for VALUES in (1) PARTITION BY list (b);
CREATE TABLE sub_part1 PARTITION OF sub_parted for VALUES in (1);
INSERT INTO list_parted VALUES (1, 1, 1);
EXPLAIN (COSTS OFF) UPDATE list_parted SET c = 2 WHERE a = 1 and b = 1;
            QUERY PLAN             
-----------------------------------
 Update on list_parted
   Update on sub_part1 list_parted
   ->  Result
(3 rows)

UPDATE list_parted SET c = 2 WHERE a = 1 and b = 1;
SELECT * FROM list_parted;
 a | b | c 
---+---+---
 1 | 1 | 2
(1 row)

EXPLAIN (COSTS OFF) DELETE FROM list_parted WHERE a = 1 and b = 1;
            QUERY PLAN             
-----------------------------------
 Delete on list_parted
   Delete on sub_part1 list_parted
   ->  Result
(3 rows)

DELETE FROM list_parted WHERE a = 1 and b = 1;
SELECT * FROM list_parted;
 a | b | c 
---+---+---
(0 rows)

DROP TABLE list_parted;
-- Cross partition UPDATE with nested loop join (multiple matches)
CREATE TABLE list_parted (a int, b int) PARTITION BY list (a);
CREATE TABLE sub_part1 PARTITION OF list_parted for VALUES in (1);
CREATE TABLE sub_part2 PARTITION OF list_parted for VALUES in (2);
INSERT into list_parted VALUES (1, 2);
CREATE TABLE non_parted (id int);
INSERT into non_parted VALUES (1), (1), (1);
UPDATE list_parted t1 set a = 2 FROM non_parted t2 WHERE t1.a = t2.id and a = 1;
SELECT * FROM list_parted;
 a | b 
---+---
 2 | 2
(1 row)

DROP TABLE list_parted;
DROP TABLE non_parted;
-- Test no segmentation fault in YbSeqscan with row marks
CREATE TABLE main_table (a int) partition by range(a);
CREATE TABLE main_table_1_100 partition of main_table FOR VALUES FROM (1) TO (100);
INSERT INTO main_table VALUES (1);
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SELECT * FROM main_table;
 a 
---
 1
(1 row)

SELECT * FROM main_table FOR KEY SHARE;
 a 
---
 1
(1 row)

COMMIT;
-- YB_TODO: begin: remove this after tracking yb_pg_partition_prune
-- Test partition pruning
create table rlp (a int, b varchar) partition by range (a);
create table rlp_default partition of rlp default partition by list (a);
create table rlp_default_default partition of rlp_default default;
create table rlp_default_10 partition of rlp_default for values in (10);
create table rlp_default_30 partition of rlp_default for values in (30);
create table rlp_default_null partition of rlp_default for values in (null);
create table rlp1 partition of rlp for values from (minvalue) to (1);
create table rlp2 partition of rlp for values from (1) to (10);
create table rlp3 (b varchar, a int) partition by list (b varchar_ops);
create table rlp3_default partition of rlp3 default;
create table rlp3abcd partition of rlp3 for values in ('ab', 'cd');
create table rlp3efgh partition of rlp3 for values in ('ef', 'gh');
create table rlp3nullxy partition of rlp3 for values in (null, 'xy');
alter table rlp attach partition rlp3 for values from (15) to (20);
create table rlp4 partition of rlp for values from (20) to (30) partition by range (a);
create table rlp4_default partition of rlp4 default;
create table rlp4_1 partition of rlp4 for values from (20) to (25);
create table rlp4_2 partition of rlp4 for values from (25) to (29);
create table rlp5 partition of rlp for values from (31) to (maxvalue) partition by range (a);
create table rlp5_default partition of rlp5 default;
create table rlp5_1 partition of rlp5 for values from (31) to (40);
explain (costs off) select * from rlp where a = 1 or b = 'ab';
                          QUERY PLAN                           
---------------------------------------------------------------
 Append
   ->  Seq Scan on rlp1 rlp_1
         Storage Filter: ((a = 1) OR ((b)::text = 'ab'::text))
   ->  Seq Scan on rlp2 rlp_2
         Storage Filter: ((a = 1) OR ((b)::text = 'ab'::text))
   ->  Seq Scan on rlp3abcd rlp_3
         Storage Filter: ((a = 1) OR ((b)::text = 'ab'::text))
   ->  Seq Scan on rlp4_1 rlp_4
         Storage Filter: ((a = 1) OR ((b)::text = 'ab'::text))
   ->  Seq Scan on rlp4_2 rlp_5
         Storage Filter: ((a = 1) OR ((b)::text = 'ab'::text))
   ->  Seq Scan on rlp4_default rlp_6
         Storage Filter: ((a = 1) OR ((b)::text = 'ab'::text))
   ->  Seq Scan on rlp5_1 rlp_7
         Storage Filter: ((a = 1) OR ((b)::text = 'ab'::text))
   ->  Seq Scan on rlp5_default rlp_8
         Storage Filter: ((a = 1) OR ((b)::text = 'ab'::text))
   ->  Seq Scan on rlp_default_10 rlp_9
         Storage Filter: ((a = 1) OR ((b)::text = 'ab'::text))
   ->  Seq Scan on rlp_default_30 rlp_10
         Storage Filter: ((a = 1) OR ((b)::text = 'ab'::text))
   ->  Seq Scan on rlp_default_null rlp_11
         Storage Filter: ((a = 1) OR ((b)::text = 'ab'::text))
   ->  Seq Scan on rlp_default_default rlp_12
         Storage Filter: ((a = 1) OR ((b)::text = 'ab'::text))
(25 rows)

-- YB_TODO: end
-- YB_TODO: Remove after tracking yb_create_index
CREATE TABLE test_include (c1 int, c2 int, c3 int);
INSERT INTO test_include VALUES (1, 1, 1), (2, 2, 2), (3, 3, 3);
CREATE UNIQUE INDEX ON test_include (c1) include (c2);
UPDATE test_include SET c2 = 22 WHERE c1 = 2;
SELECT * FROM test_include WHERE c1 = 2;
 c1 | c2 | c3 
----+----+----
  2 | 22 |  2
(1 row)

DROP TABLE test_include;
-- YB_TODO: end
-- suppress warning that depends on wal_level
SET client_min_messages = 'ERROR';
CREATE PUBLICATION p;
RESET client_min_messages;
ALTER PUBLICATION p ADD TABLES IN SCHEMA public;
ERROR:  CREATE/ALTER PUBLICATION SCHEMA not supported yet
LINE 1: ALTER PUBLICATION p ADD TABLES IN SCHEMA public;
                                ^
HINT:  Please report the issue on https://github.com/YugaByte/yugabyte-db/issues
ALTER PUBLICATION p DROP TABLES IN SCHEMA CURRENT_SCHEMA;
ERROR:  CREATE/ALTER PUBLICATION SCHEMA not supported yet
LINE 1: ALTER PUBLICATION p DROP TABLES IN SCHEMA CURRENT_SCHEMA;
                                 ^
HINT:  Please report the issue on https://github.com/YugaByte/yugabyte-db/issues
ALTER PUBLICATION p SET CURRENT_SCHEMA;
ERROR:  CREATE/ALTER PUBLICATION SCHEMA not supported yet
LINE 1: ALTER PUBLICATION p SET CURRENT_SCHEMA;
                                ^
HINT:  Please report the issue on https://github.com/YugaByte/yugabyte-db/issues
-- YB_TODO: begin: remove after tracking yb_join_batching
SET enable_hashjoin = off;
SET enable_mergejoin = off;
SET enable_seqscan = off;
SET enable_material = off;
SET yb_prefer_bnl = on;
SET yb_bnl_batch_size = 3;
CREATE TABLE t10 (r1 int, r2 int, r3 int, r4 int);
INSERT INTO t10
  SELECT DISTINCT
    i1, i2+5, i3, i4
  FROM generate_series(1, 5) i1,
       generate_series(1, 5) i2,
       generate_series(1, 5) i3,
       generate_series(1, 10) i4;
CREATE index i_t ON t10 (r1 ASC, r2 ASC, r3 ASC, r4 ASC);
CREATE TABLE t11 (c1 int, c3 int, x int);
INSERT INTO t11 VALUES (1,2,0), (1,3,0), (5,2,0), (5,3,0), (5,4,0);
CREATE TABLE t12 (c4 int, c2 int, y int);
INSERT INTO t12 VALUES (3,7,0),(6,9,0),(9,7,0),(4,9,0);
EXPLAIN (COSTS OFF) /*+ Leading((t12 (t11 t10))) Set(enable_seqscan true) */ SELECT t10.* FROM t12, t11, t10 WHERE x = y AND c1 = r1 AND c2 = r2 AND c3 = r3 AND c4 = r4 order by c1, c2, c3, c4;
                                                                    QUERY PLAN
--------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: t10.r1, t10.r2, t10.r3, t10.r4
   ->  Nested Loop
         ->  Seq Scan on t12
         ->  YB Batched Nested Loop Join
               Join Filter: ((t12.y = t11.x) AND (t11.c1 = t10.r1) AND (t11.c3 = t10.r3))
               ->  Seq Scan on t11
               ->  Index Only Scan using i_t on t10
                     Index Cond: ((ROW(r1, r3) = ANY (ARRAY[ROW(t11.c1, t11.c3), ROW($1, $4), ROW($2, $5)])) AND (r2 = t12.c2) AND (r4 = t12.c4))
(9 rows)

/*+ Leading((t12 (t11 t10))) Set(enable_seqscan true) */ SELECT t10.* FROM t12, t11, t10 WHERE x = y AND c1 = r1 AND c2 = r2 AND c3 = r3 AND c4 = r4 order by c1, c2, c3, c4;
 r1 | r2 | r3 | r4
----+----+----+----
  1 |  7 |  2 |  3
  1 |  7 |  2 |  9
  1 |  7 |  3 |  3
  1 |  7 |  3 |  9
  1 |  9 |  2 |  4
  1 |  9 |  2 |  6
  1 |  9 |  3 |  4
  1 |  9 |  3 |  6
  5 |  7 |  2 |  3
  5 |  7 |  2 |  9
  5 |  7 |  3 |  3
  5 |  7 |  3 |  9
  5 |  7 |  4 |  3
  5 |  7 |  4 |  9
  5 |  9 |  2 |  4
  5 |  9 |  2 |  6
  5 |  9 |  3 |  4
  5 |  9 |  3 |  6
  5 |  9 |  4 |  4
  5 |  9 |  4 |  6
(20 rows)

DROP TABLE t10;
DROP TABLE t11;
DROP TABLE t12;
RESET enable_hashjoin;
RESET enable_mergejoin;
RESET enable_seqscan;
RESET enable_material;
RESET yb_prefer_bnl;
RESET yb_bnl_batch_size;
-- YB_TODO: end
-- YB_TODO: begin: remove after tracking yb_pg_foreign_key
-- (the following test is a simplified version of the test under
--  'Foreign keys and partitioned tables' section there).
CREATE TABLE fk_notpartitioned_pk (a int, b int,PRIMARY KEY (a, b));
INSERT INTO fk_notpartitioned_pk VALUES (2501, 2503);
CREATE TABLE fk_partitioned_fk (a int, b int) PARTITION BY HASH (a);
ALTER TABLE fk_partitioned_fk ADD FOREIGN KEY (a, b) REFERENCES fk_notpartitioned_pk;
CREATE TABLE fk_partitioned_fk_0 PARTITION OF fk_partitioned_fk FOR VALUES WITH (MODULUS 5, REMAINDER 0);
CREATE TABLE fk_partitioned_fk_1 PARTITION OF fk_partitioned_fk FOR VALUES WITH (MODULUS 5, REMAINDER 1);
INSERT INTO fk_partitioned_fk (a,b) VALUES (2501, 2503);
-- this update fails because there is no referenced row
UPDATE fk_partitioned_fk SET a = a + 1 WHERE a = 2501;
ERROR:  insert or update on table "fk_partitioned_fk_1" violates foreign key constraint "fk_partitioned_fk_a_b_fkey"
DETAIL:  Key (a, b)=(2502, 2503) is not present in table "fk_notpartitioned_pk".
-- but we can fix it thusly:
INSERT INTO fk_notpartitioned_pk (a,b) VALUES (2502, 2503);
UPDATE fk_partitioned_fk SET a = a + 1 WHERE a = 2501;
-- YB_TODO: end
-- YB_TODO: begin: remove after tracking postgres_fdw
CREATE EXTENSION postgres_fdw;
CREATE SERVER testserver1 FOREIGN DATA WRAPPER postgres_fdw;
DO $d$
    BEGIN
        EXECUTE $$CREATE SERVER loopback FOREIGN DATA WRAPPER postgres_fdw
            OPTIONS (dbname '$$||current_database()||$$',
                     host '$$||current_setting('listen_addresses')||$$',
                     port '$$||current_setting('port')||$$'
            )$$;
    END;
$d$;
CREATE USER MAPPING FOR public SERVER testserver1
    OPTIONS (user 'value', password 'value');
CREATE USER MAPPING FOR CURRENT_USER SERVER loopback;
create table ctrtest (a int, b text) partition by list (a);
create table loct1 (a int check (a in (1)), b text);
create foreign table remp1 (a int check (a in (1)), b text) server loopback options (table_name 'loct1');
alter table ctrtest attach partition remp1 for values in (1);
copy ctrtest from stdin;
select * from ctrtest;
 a |  b  
---+-----
 1 | foo
(1 row)

create table return_test (a int, b int, c int);
insert into return_test values (1, 1, 1);
update return_test set c = c returning *;
 a | b | c
---+---+---
 1 | 1 | 1
(1 row)

update return_test set c = c returning c;
 c
---
 1
(1 row)

update return_test set c = c returning a,b;
 a | b
---+---
 1 | 1
(1 row)

-- YB_TODO: end
-- YB_TODO: begin: remove after generated is tracked
CREATE TABLE sales (
    id SERIAL PRIMARY KEY,
    product_id INT NOT NULL,
    quantity INT NOT NULL,
    price_per_unit NUMERIC(10, 2) NOT NULL,
    total_price NUMERIC GENERATED ALWAYS AS (quantity * price_per_unit) STORED
);
INSERT INTO sales (product_id, quantity, price_per_unit) VALUES (1, 10, 100), (2, 10, 200);
SELECT * FROM SALES;
 id | product_id | quantity | price_per_unit | total_price 
----+------------+----------+----------------+-------------
  1 |          1 |       10 |         100.00 |        1000
  2 |          2 |       10 |         200.00 |        2000
(2 rows)

UPDATE sales set quantity = quantity + 1;
SELECT * FROM SALES;
 id | product_id | quantity | price_per_unit | total_price 
----+------------+----------+----------------+-------------
  1 |          1 |       11 |         100.00 |        1100
  2 |          2 |       11 |         200.00 |        2200
(2 rows)

UPDATE sales set price_per_unit = price_per_unit + 100;
SELECT * FROM SALES;
 id | product_id | quantity | price_per_unit | total_price 
----+------------+----------+----------------+-------------
  1 |          1 |       11 |         200.00 |        2200
  2 |          2 |       11 |         300.00 |        3300
(2 rows)

UPDATE sales SET total_price = 0;
ERROR:  column "total_price" can only be updated to DEFAULT
DETAIL:  Column "total_price" is a generated column.
UPDATE sales SET product_id = product_id + 10;
SELECT * FROM SALES;
 id | product_id | quantity | price_per_unit | total_price 
----+------------+----------+----------------+-------------
  1 |         11 |       11 |         200.00 |        2200
  2 |         12 |       11 |         300.00 |        3300
(2 rows)

CREATE OR REPLACE FUNCTION update_count() RETURNS trigger LANGUAGE plpgsql AS
$func$
BEGIN
   NEW.count := NEW.count+1;
   RETURN NEW;
END
$func$;
CREATE TABLE test(a int, b int, count int, double_count int GENERATED ALWAYS AS (2 * count) STORED);
CREATE TRIGGER update_count_test_trig BEFORE UPDATE OF a ON test FOR ROW EXECUTE PROCEDURE update_count();
INSERT INTO test(a, b, count) values (1, 1, 1), (2, 2, 1);
SELECT * FROM test;
 a | b | count | double_count 
---+---+-------+--------------
 2 | 2 |     1 |            2
 1 | 1 |     1 |            2
(2 rows)

UPDATE test set a = a + 5;
SELECT * FROM test;
 a | b | count | double_count 
---+---+-------+--------------
 7 | 2 |     2 |            4
 6 | 1 |     2 |            4
(2 rows)

UPDATE test set b = b + 5;
SELECT * FROM test;
 a | b | count | double_count 
---+---+-------+--------------
 7 | 7 |     2 |            4
 6 | 6 |     2 |            4
(2 rows)

-- YB_TODO: end
