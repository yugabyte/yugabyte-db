--
-- YB_FEATURE_PARTITIONING Testsuite
--   An introduction on whether or not a feature is supported in YugaByte.
--   This test suite does not go in depth for each command.
--
-- Testing basic SPLIT AT functionalities.
--
-- Table with RANGE primary key.
--
CREATE TABLE feature_pk_split (
		col_integer INTEGER,
		col_varchar VARCHAR(100),
		col_text TEXT,
		col_double DOUBLE PRECISION,
		PRIMARY KEY (col_integer ASC, col_varchar ASC))
	SPLIT AT VALUES ((1, 'a'), (10, 'e'), (100, 'i'), (1000, 'o'), (10000, 'u'));
--
-- Secondary index for some of the splits.
-- This work needs optimization.
--
CREATE INDEX idx_small ON feature_pk_split (col_double ASC) WHERE col_double <= 9;
CREATE INDEX idx_large ON feature_pk_split (col_double ASC) WHERE col_double >= 10;
--
-- INSERT at least 1 row for each partition.
--
INSERT INTO feature_pk_split
	VALUES  ( -1, '-', 'partition 1', 1 ),
			( 0, 'm', 'partition 1', 2 ),
			( 1, '9', 'partition 1', 3 ),
			( 1, 'a', 'partition 2', 4 ),
			( 5, 'm', 'partition 2', 5 ),
			( 10, 'd', 'partition 2', 6 ),
			( 10, 'e', 'partition 3', 7 ),
			( 50, 'a', 'partition 3', 8 ),
			( 100, 'h', 'partition 3', 9 ),
			( 100, 'i', 'partition 4', 10 ),
			( 500, 'm', 'partition 4', 11 ),
			( 1000, 'n', 'partition 4', 12 ),
			( 1000, 'o', 'partition 5', 13 ),
			( 5000, 'm', 'partition 5', 14 ),
			( 10000, 't', 'partition 5', 15 ),
			( 10000, 'u', 'partition 6', 16 ),
			( 50000, 'm', 'partition 6', 17 ),
			( 100000, 'z', 'partition 6', 18 );
--
-- Full scan.
--
EXPLAIN SELECT * FROM feature_pk_split;
                              QUERY PLAN
-----------------------------------------------------------------------
 Seq Scan on feature_pk_split  (cost=0.00..100.00 rows=1000 width=262)
(1 row)

SELECT * FROM feature_pk_split;
 col_integer | col_varchar |  col_text   | col_double
-------------+-------------+-------------+------------
          -1 | -           | partition 1 |          1
           0 | m           | partition 1 |          2
           1 | 9           | partition 1 |          3
           1 | a           | partition 2 |          4
           5 | m           | partition 2 |          5
          10 | d           | partition 2 |          6
          10 | e           | partition 3 |          7
          50 | a           | partition 3 |          8
         100 | h           | partition 3 |          9
         100 | i           | partition 4 |         10
         500 | m           | partition 4 |         11
        1000 | n           | partition 4 |         12
        1000 | o           | partition 5 |         13
        5000 | m           | partition 5 |         14
       10000 | t           | partition 5 |         15
       10000 | u           | partition 6 |         16
       50000 | m           | partition 6 |         17
      100000 | z           | partition 6 |         18
(18 rows)

--
-- Full scan with conditional operators.
--
-- Operator `=`
EXPLAIN SELECT * FROM feature_pk_split WHERE col_text = 'partition 3';
                              QUERY PLAN
-----------------------------------------------------------------------
 Seq Scan on feature_pk_split  (cost=0.00..102.50 rows=1000 width=262)
   Storage Filter: (col_text = 'partition 3'::text)
(2 rows)

SELECT * FROM feature_pk_split WHERE col_text = 'partition 3';
 col_integer | col_varchar |  col_text   | col_double
-------------+-------------+-------------+------------
          10 | e           | partition 3 |          7
          50 | a           | partition 3 |          8
         100 | h           | partition 3 |          9
(3 rows)

-- Operator `IN`
EXPLAIN SELECT * FROM feature_pk_split WHERE col_text IN ('partition 2', 'partition 5');
                                  QUERY PLAN
------------------------------------------------------------------------------
 Seq Scan on feature_pk_split  (cost=0.00..102.50 rows=1000 width=262)
   Storage Filter: (col_text = ANY ('{"partition 2","partition 5"}'::text[]))
(2 rows)

SELECT * FROM feature_pk_split WHERE col_text IN ('partition 2', 'partition 5');
 col_integer | col_varchar |  col_text   | col_double
-------------+-------------+-------------+------------
           1 | a           | partition 2 |          4
           5 | m           | partition 2 |          5
          10 | d           | partition 2 |          6
        1000 | o           | partition 5 |         13
        5000 | m           | partition 5 |         14
       10000 | t           | partition 5 |         15
(6 rows)

-- Operator `<=`
EXPLAIN SELECT * FROM feature_pk_split WHERE col_double <= 10;
                              QUERY PLAN
-----------------------------------------------------------------------
 Seq Scan on feature_pk_split  (cost=0.00..102.50 rows=1000 width=262)
   Storage Filter: (col_double <= '10'::double precision)
(2 rows)

SELECT * FROM feature_pk_split WHERE col_double <= 10;
 col_integer | col_varchar |  col_text   | col_double
-------------+-------------+-------------+------------
          -1 | -           | partition 1 |          1
           0 | m           | partition 1 |          2
           1 | 9           | partition 1 |          3
           1 | a           | partition 2 |          4
           5 | m           | partition 2 |          5
          10 | d           | partition 2 |          6
          10 | e           | partition 3 |          7
          50 | a           | partition 3 |          8
         100 | h           | partition 3 |          9
         100 | i           | partition 4 |         10
(10 rows)

-- Operator `AND`
EXPLAIN SELECT * FROM feature_pk_split WHERE col_text >= 'partition 3' AND col_double <= 10;
                                            QUERY PLAN
--------------------------------------------------------------------------------------------------
 Seq Scan on feature_pk_split  (cost=0.00..105.00 rows=1000 width=262)
   Storage Filter: ((col_text >= 'partition 3'::text) AND (col_double <= '10'::double precision))
(2 rows)

SELECT * FROM feature_pk_split WHERE col_text >= 'partition 3' AND col_double <= 10;
 col_integer | col_varchar |  col_text   | col_double
-------------+-------------+-------------+------------
          10 | e           | partition 3 |          7
          50 | a           | partition 3 |          8
         100 | h           | partition 3 |          9
         100 | i           | partition 4 |         10
(4 rows)

--
-- Full scan with aggregate functions.
--
EXPLAIN SELECT COUNT(*) FROM feature_pk_split;
                                QUERY PLAN
---------------------------------------------------------------------------
 Finalize Aggregate  (cost=102.50..102.51 rows=1 width=8)
   ->  Seq Scan on feature_pk_split  (cost=0.00..100.00 rows=1000 width=0)
         Partial Aggregate: true
(3 rows)

SELECT COUNT(*) FROM feature_pk_split;
 count
-------
    18
(1 row)

EXPLAIN SELECT MAX(col_integer) FROM feature_pk_split;
                                                       QUERY PLAN
------------------------------------------------------------------------------------------------------------------------
 Result  (cost=0.16..0.17 rows=1 width=4)
   InitPlan 1 (returns $0)
     ->  Limit  (cost=0.00..0.16 rows=1 width=4)
           ->  Index Scan Backward using feature_pk_split_pkey on feature_pk_split  (cost=0.00..16.00 rows=100 width=4)
                 Index Cond: (col_integer IS NOT NULL)
(5 rows)

SELECT MAX(col_integer) FROM feature_pk_split;
  max
--------
 100000
(1 row)

EXPLAIN SELECT MIN(col_varchar) FROM feature_pk_split;
                                 QUERY PLAN
-----------------------------------------------------------------------------
 Aggregate  (cost=102.50..102.51 rows=1 width=32)
   ->  Seq Scan on feature_pk_split  (cost=0.00..100.00 rows=1000 width=218)
(2 rows)

SELECT MIN(col_varchar) FROM feature_pk_split;
 min
-----
 -
(1 row)

EXPLAIN SELECT AVG(col_double) FROM feature_pk_split;
                                QUERY PLAN
---------------------------------------------------------------------------
 Aggregate  (cost=102.50..102.51 rows=1 width=8)
   ->  Seq Scan on feature_pk_split  (cost=0.00..100.00 rows=1000 width=8)
(2 rows)

SELECT AVG(col_double) FROM feature_pk_split;
 avg
-----
 9.5
(1 row)

--
-- Primary key scan.
-- This work needs to be optimized.
--
EXPLAIN SELECT * FROM feature_pk_split WHERE col_integer = 50 AND col_varchar = 'a';
                                           QUERY PLAN
------------------------------------------------------------------------------------------------
 Index Scan using feature_pk_split_pkey on feature_pk_split  (cost=0.00..4.12 rows=1 width=262)
   Index Cond: ((col_integer = 50) AND ((col_varchar)::text = 'a'::text))
(2 rows)

SELECT * FROM feature_pk_split WHERE col_integer = 50 AND col_varchar = 'a';
 col_integer | col_varchar |  col_text   | col_double
-------------+-------------+-------------+------------
          50 | a           | partition 3 |          8
(1 row)

EXPLAIN SELECT * FROM feature_pk_split
	WHERE col_integer >= 500 AND col_integer <= 5000 AND
		  col_varchar >= 'a' AND col_varchar <= 'n'
	ORDER BY col_integer, col_varchar;
                                                                  QUERY PLAN
----------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using feature_pk_split_pkey on feature_pk_split  (cost=0.00..4.12 rows=1 width=262)
   Index Cond: ((col_integer >= 500) AND (col_integer <= 5000) AND ((col_varchar)::text >= 'a'::text) AND ((col_varchar)::text <= 'n'::text))
(2 rows)

SELECT * FROM feature_pk_split
	WHERE col_integer >= 500 AND col_integer <= 5000 AND
		  col_varchar >= 'a' AND col_varchar <= 'n'
	ORDER BY col_integer, col_varchar;
 col_integer | col_varchar |  col_text   | col_double
-------------+-------------+-------------+------------
         500 | m           | partition 4 |         11
        1000 | n           | partition 4 |         12
        5000 | m           | partition 5 |         14
(3 rows)

EXPLAIN SELECT COUNT(*) FROM feature_pk_split WHERE col_integer = 50 AND col_varchar = 'a';
                                             QUERY PLAN
----------------------------------------------------------------------------------------------------
 Finalize Aggregate  (cost=4.12..4.13 rows=1 width=8)
   ->  Index Scan using feature_pk_split_pkey on feature_pk_split  (cost=0.00..4.12 rows=1 width=0)
         Index Cond: ((col_integer = 50) AND ((col_varchar)::text = 'a'::text))
         Partial Aggregate: true
(4 rows)

SELECT COUNT(*) FROM feature_pk_split WHERE col_integer = 50 AND col_varchar = 'a';
 count
-------
     1
(1 row)

EXPLAIN SELECT COUNT(*) FROM feature_pk_split
	WHERE col_integer >= 500 AND col_integer <= 5000 AND
		  col_varchar >= 'a' AND col_varchar <= 'n';
                                                                     QUERY PLAN
----------------------------------------------------------------------------------------------------------------------------------------------------
 Finalize Aggregate  (cost=4.12..4.13 rows=1 width=8)
   ->  Index Scan using feature_pk_split_pkey on feature_pk_split  (cost=0.00..4.12 rows=1 width=0)
         Index Cond: ((col_integer >= 500) AND (col_integer <= 5000) AND ((col_varchar)::text >= 'a'::text) AND ((col_varchar)::text <= 'n'::text))
         Partial Aggregate: true
(4 rows)

SELECT COUNT(*) FROM feature_pk_split
	WHERE col_integer >= 500 AND col_integer <= 5000 AND
		  col_varchar >= 'a' AND col_varchar <= 'n';
 count
-------
     3
(1 row)

--
-- Secondary key scan.
-- This work needs to be optimized.
--
-- Scan one tablet.
EXPLAIN SELECT * FROM feature_pk_split WHERE col_double < 2;
                                     QUERY PLAN
-------------------------------------------------------------------------------------
 Index Scan using idx_small on feature_pk_split  (cost=0.00..4.98 rows=10 width=262)
   Index Cond: (col_double < '2'::double precision)
(2 rows)

SELECT * FROM feature_pk_split WHERE col_double < 2;
 col_integer | col_varchar |  col_text   | col_double
-------------+-------------+-------------+------------
          -1 | -           | partition 1 |          1
(1 row)

-- Scan two tablets.
EXPLAIN SELECT * FROM feature_pk_split WHERE col_double <= 5;
                                     QUERY PLAN
-------------------------------------------------------------------------------------
 Index Scan using idx_small on feature_pk_split  (cost=0.00..4.98 rows=10 width=262)
   Index Cond: (col_double <= '5'::double precision)
(2 rows)

SELECT * FROM feature_pk_split WHERE col_double <= 5;
 col_integer | col_varchar |  col_text   | col_double
-------------+-------------+-------------+------------
          -1 | -           | partition 1 |          1
           0 | m           | partition 1 |          2
           1 | 9           | partition 1 |          3
           1 | a           | partition 2 |          4
           5 | m           | partition 2 |          5
(5 rows)

-- Scan three tablets.
EXPLAIN SELECT * FROM feature_pk_split WHERE col_double <= 8;
                                     QUERY PLAN
-------------------------------------------------------------------------------------
 Index Scan using idx_small on feature_pk_split  (cost=0.00..4.98 rows=10 width=262)
   Index Cond: (col_double <= '8'::double precision)
(2 rows)

SELECT * FROM feature_pk_split WHERE col_double <= 8;
 col_integer | col_varchar |  col_text   | col_double
-------------+-------------+-------------+------------
          -1 | -           | partition 1 |          1
           0 | m           | partition 1 |          2
           1 | 9           | partition 1 |          3
           1 | a           | partition 2 |          4
           5 | m           | partition 2 |          5
          10 | d           | partition 2 |          6
          10 | e           | partition 3 |          7
          50 | a           | partition 3 |          8
(8 rows)

-- Scan four tablets.
EXPLAIN SELECT * FROM feature_pk_split WHERE col_double <= 11;
                              QUERY PLAN
-----------------------------------------------------------------------
 Seq Scan on feature_pk_split  (cost=0.00..102.50 rows=1000 width=262)
   Storage Filter: (col_double <= '11'::double precision)
(2 rows)

SELECT * FROM feature_pk_split WHERE col_double <= 11;
 col_integer | col_varchar |  col_text   | col_double
-------------+-------------+-------------+------------
          -1 | -           | partition 1 |          1
           0 | m           | partition 1 |          2
           1 | 9           | partition 1 |          3
           1 | a           | partition 2 |          4
           5 | m           | partition 2 |          5
          10 | d           | partition 2 |          6
          10 | e           | partition 3 |          7
          50 | a           | partition 3 |          8
         100 | h           | partition 3 |          9
         100 | i           | partition 4 |         10
         500 | m           | partition 4 |         11
(11 rows)

-- Scan five tablets.
EXPLAIN SELECT * FROM feature_pk_split WHERE col_double <= 14;
                              QUERY PLAN
-----------------------------------------------------------------------
 Seq Scan on feature_pk_split  (cost=0.00..102.50 rows=1000 width=262)
   Storage Filter: (col_double <= '14'::double precision)
(2 rows)

SELECT * FROM feature_pk_split WHERE col_double <= 14;
 col_integer | col_varchar |  col_text   | col_double
-------------+-------------+-------------+------------
          -1 | -           | partition 1 |          1
           0 | m           | partition 1 |          2
           1 | 9           | partition 1 |          3
           1 | a           | partition 2 |          4
           5 | m           | partition 2 |          5
          10 | d           | partition 2 |          6
          10 | e           | partition 3 |          7
          50 | a           | partition 3 |          8
         100 | h           | partition 3 |          9
         100 | i           | partition 4 |         10
         500 | m           | partition 4 |         11
        1000 | n           | partition 4 |         12
        1000 | o           | partition 5 |         13
        5000 | m           | partition 5 |         14
(14 rows)

-- Scan six tablets.
EXPLAIN SELECT * FROM feature_pk_split WHERE col_double <= 17;
                              QUERY PLAN
-----------------------------------------------------------------------
 Seq Scan on feature_pk_split  (cost=0.00..102.50 rows=1000 width=262)
   Storage Filter: (col_double <= '17'::double precision)
(2 rows)

SELECT * FROM feature_pk_split WHERE col_double <= 17;
 col_integer | col_varchar |  col_text   | col_double
-------------+-------------+-------------+------------
          -1 | -           | partition 1 |          1
           0 | m           | partition 1 |          2
           1 | 9           | partition 1 |          3
           1 | a           | partition 2 |          4
           5 | m           | partition 2 |          5
          10 | d           | partition 2 |          6
          10 | e           | partition 3 |          7
          50 | a           | partition 3 |          8
         100 | h           | partition 3 |          9
         100 | i           | partition 4 |         10
         500 | m           | partition 4 |         11
        1000 | n           | partition 4 |         12
        1000 | o           | partition 5 |         13
        5000 | m           | partition 5 |         14
       10000 | t           | partition 5 |         15
       10000 | u           | partition 6 |         16
       50000 | m           | partition 6 |         17
(17 rows)

-- Scan all tablets.
EXPLAIN SELECT * FROM feature_pk_split WHERE col_double <= 100;
                              QUERY PLAN
-----------------------------------------------------------------------
 Seq Scan on feature_pk_split  (cost=0.00..102.50 rows=1000 width=262)
   Storage Filter: (col_double <= '100'::double precision)
(2 rows)

SELECT * FROM feature_pk_split WHERE col_double <= 100;
 col_integer | col_varchar |  col_text   | col_double
-------------+-------------+-------------+------------
          -1 | -           | partition 1 |          1
           0 | m           | partition 1 |          2
           1 | 9           | partition 1 |          3
           1 | a           | partition 2 |          4
           5 | m           | partition 2 |          5
          10 | d           | partition 2 |          6
          10 | e           | partition 3 |          7
          50 | a           | partition 3 |          8
         100 | h           | partition 3 |          9
         100 | i           | partition 4 |         10
         500 | m           | partition 4 |         11
        1000 | n           | partition 4 |         12
        1000 | o           | partition 5 |         13
        5000 | m           | partition 5 |         14
       10000 | t           | partition 5 |         15
       10000 | u           | partition 6 |         16
       50000 | m           | partition 6 |         17
      100000 | z           | partition 6 |         18
(18 rows)

-- Index only scan.
EXPLAIN SELECT col_double FROM feature_pk_split WHERE col_double <= 8;
                                       QUERY PLAN
----------------------------------------------------------------------------------------
 Index Only Scan using idx_small on feature_pk_split  (cost=0.00..4.90 rows=10 width=8)
   Index Cond: (col_double <= '8'::double precision)
(2 rows)

SELECT col_double FROM feature_pk_split WHERE col_double <= 8;
 col_double
------------
          1
          2
          3
          4
          5
          6
          7
          8
(8 rows)

--
-- Table that has min & max split values.
-- * Using 3 splits: (1, MAX), (10, MIN), and (100, MIN).
-- * Unspecified split values are defaulted to MINVALUE.
--     SPLIT (10) is (10, MIN)
--
CREATE TABLE feature_pk_split_min_max (
		col_integer INTEGER,
		col_varchar VARCHAR(100),
		col_text TEXT,
		col_double DOUBLE PRECISION,
		PRIMARY KEY (col_integer ASC, col_varchar ASC))
	SPLIT AT VALUES ((1, MAXVALUE), (10), (100, MINVALUE));
--
-- INSERT 2 rows to each partition.
--
INSERT INTO feature_pk_split_min_max
	VALUES  ( 0, '-', 'partition 1', 2 ),
			( 1, 'z', 'partition 1', 2 ),
			( 2, '-', 'partition 2', 3 ),
			( 3, '-', 'partition 2', 3 ),
			( 9, 'z', 'partition 2', 3 ),
			( 10, '-', 'partition 3', 4 ),
			( 20, '-', 'partition 3', 4 ),
			( 30, '-', 'partition 3', 4),
			( 99, 'z', 'partition 3', 4 ),
			( 100, '-', 'partition 4', 5 ),
			( 200, '-', 'partition 4', 5 ),
			( 300, '-', 'partition 4', 5 ),
			( 400, '-', 'partition 4', 5 ),
			( 999, 'z', 'partition 4', 5 );
--
-- SELECT from each partition.
-- TODO(neil) To complete this test, server must provide a method to track tablet information for
-- each row. Currently, this is verified by tracking number rows per tablet during development.
--
-- All rows must be from partition 1: (nan) < PKey < (1, max)
SELECT * FROM feature_pk_split_min_max WHERE col_integer <= 1;
 col_integer | col_varchar |  col_text   | col_double
-------------+-------------+-------------+------------
           0 | -           | partition 1 |          2
           1 | z           | partition 1 |          2
(2 rows)

-- All rows must be from partition 2: (1, max) <= PKey < (10, min)
SELECT * FROM feature_pk_split_min_max WHERE col_integer > 1 AND col_integer < 10;
 col_integer | col_varchar |  col_text   | col_double
-------------+-------------+-------------+------------
           2 | -           | partition 2 |          3
           3 | -           | partition 2 |          3
           9 | z           | partition 2 |          3
(3 rows)

-- All rows must be from partition3: (10, min) <= PKey < (100, min)
SELECT * FROM feature_pk_split_min_max WHERE col_integer >= 10 AND col_integer < 100;
 col_integer | col_varchar |  col_text   | col_double
-------------+-------------+-------------+------------
          10 | -           | partition 3 |          4
          20 | -           | partition 3 |          4
          30 | -           | partition 3 |          4
          99 | z           | partition 3 |          4
(4 rows)

-- All rows must be from partition 4: (100, min) <= PKey < (nan)
SELECT * FROM feature_pk_split_min_max WHERE col_integer >= 100;
 col_integer | col_varchar |  col_text   | col_double
-------------+-------------+-------------+------------
         100 | -           | partition 4 |          5
         200 | -           | partition 4 |          5
         300 | -           | partition 4 |          5
         400 | -           | partition 4 |          5
         999 | z           | partition 4 |          5
(5 rows)
