--
-- Legacy mode Join Plans
--
set client_min_messages = 'warning';
drop table if exists t1, t2, t2r;
create table t1 (a int, b int);
insert into t1 select i, i from generate_series(1, 1000) i;
create table t2 (k1 int, k2 int, k3 int, k4 int, k5 int, v int, primary key (k1 hash));
create unique index i_t2_k2 on t2 (k2 hash);
create index i_t2_k3 on t2 (k3 hash);
create unique index i_t2_k4k5 on t2 (k4 hash, k5 asc);
insert into t2 select i, i, i % 10000, i % 10000, (i / 10000) * 10000, i from generate_series(1, 100000) i;
create table t2r (k1 int, k2 int, k3 int, k4 int, k5 int, v int, primary key (k1 asc));
create unique index i_t2r_k2 on t2r (k2 asc);
create index i_t2r_k3 on t2r (k3 asc);
create unique index i_t2r_k4k5 on t2r (k4 asc, k5 asc);
insert into t2r select i, i, i % 10000, i % 10000, (i / 10000) * 10000, i from generate_series(1, 100000) i;
\getenv abs_srcdir PG_ABS_SRCDIR
\set filename :abs_srcdir '/data/yb.orig.legacy_join_plan_queries.sql'
----------------
-- Unanalyzed --
----------------
--
-- Pre-2024.1 behavior (20.2.x and earlier)
--
set yb_enable_cbo = legacy_bnl_mode;
-- Pre-2024.1 defaults
set yb_bnl_batch_size = 1;
set yb_prefer_bnl = off;
\i :filename
-- hash pk
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k1;
              QUERY PLAN              
--------------------------------------
 Nested Loop
   ->  Seq Scan on t1
   ->  Index Scan using t2_pkey on t2
         Index Cond: (k1 = t1.a)
(4 rows)

-- unique secondary hash index
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k2;
              QUERY PLAN              
--------------------------------------
 Nested Loop
   ->  Seq Scan on t1
   ->  Index Scan using i_t2_k2 on t2
         Index Cond: (k2 = t1.a)
(4 rows)

-- non-unique secondary hash index
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k3;
          QUERY PLAN          
------------------------------
 Merge Join
   Merge Cond: (t1.a = t2.k3)
   ->  Sort
         Sort Key: t1.a
         ->  Seq Scan on t1
   ->  Sort
         Sort Key: t2.k3
         ->  Seq Scan on t2
(8 rows)

-- unique secondary hash index partial key match
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k4;
          QUERY PLAN          
------------------------------
 Merge Join
   Merge Cond: (t1.a = t2.k4)
   ->  Sort
         Sort Key: t1.a
         ->  Seq Scan on t1
   ->  Sort
         Sort Key: t2.k4
         ->  Seq Scan on t2
(8 rows)

-- pk
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k1;
                QUERY PLAN                 
-------------------------------------------
 Nested Loop
   ->  Seq Scan on t1
   ->  Index Scan using t2r_pkey on t2r t2
         Index Cond: (k1 = t1.a)
(4 rows)

-- unique secondary index
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k2;
                QUERY PLAN                 
-------------------------------------------
 Nested Loop
   ->  Seq Scan on t1
   ->  Index Scan using i_t2r_k2 on t2r t2
         Index Cond: (k2 = t1.a)
(4 rows)

-- non-unique secondary index
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k3;
                QUERY PLAN                 
-------------------------------------------
 Merge Join
   Merge Cond: (t2.k3 = t1.a)
   ->  Index Scan using i_t2r_k3 on t2r t2
   ->  Sort
         Sort Key: t1.a
         ->  Seq Scan on t1
(6 rows)

-- unique secondary index partial key match
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k4;
                 QUERY PLAN                  
---------------------------------------------
 Merge Join
   Merge Cond: (t2.k4 = t1.a)
   ->  Index Scan using i_t2r_k4k5 on t2r t2
   ->  Sort
         Sort Key: t1.a
         ->  Seq Scan on t1
(6 rows)

-- BNL enabled
set yb_bnl_batch_size = 1024;
set yb_prefer_bnl = on;
\i :filename
-- hash pk
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k1;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k1)
   ->  Seq Scan on t1
   ->  Index Scan using t2_pkey on t2
         Index Cond: (k1 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- unique secondary hash index
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k2;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k2)
   ->  Seq Scan on t1
   ->  Index Scan using i_t2_k2 on t2
         Index Cond: (k2 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- non-unique secondary hash index
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k3;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k3)
   ->  Seq Scan on t1
   ->  Index Scan using i_t2_k3 on t2
         Index Cond: (k3 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- unique secondary hash index partial key match
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k4;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k4)
   ->  Seq Scan on t1
   ->  Index Scan using i_t2_k4k5 on t2
         Index Cond: (k4 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- pk
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k1;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k1)
   ->  Seq Scan on t1
   ->  Index Scan using t2r_pkey on t2r t2
         Index Cond: (k1 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- unique secondary index
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k2;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k2)
   ->  Seq Scan on t1
   ->  Index Scan using i_t2r_k2 on t2r t2
         Index Cond: (k2 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- non-unique secondary index
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k3;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k3)
   ->  Seq Scan on t1
   ->  Index Scan using i_t2r_k3 on t2r t2
         Index Cond: (k3 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- unique secondary index partial key match
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k4;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k4)
   ->  Seq Scan on t1
   ->  Index Scan using i_t2r_k4k5 on t2r t2
         Index Cond: (k4 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

--
-- 2024.1 and beyond
--
set yb_enable_cbo = legacy_mode;
-- BNL enabled by default since 2024.1
set yb_bnl_batch_size = 1024;
set yb_prefer_bnl = on;
\i :filename
-- hash pk
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k1;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k1)
   ->  Seq Scan on t1
   ->  Index Scan using t2_pkey on t2
         Index Cond: (k1 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- unique secondary hash index
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k2;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k2)
   ->  Seq Scan on t1
   ->  Index Scan using i_t2_k2 on t2
         Index Cond: (k2 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- non-unique secondary hash index
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k3;
          QUERY PLAN          
------------------------------
 Merge Join
   Merge Cond: (t1.a = t2.k3)
   ->  Sort
         Sort Key: t1.a
         ->  Seq Scan on t1
   ->  Sort
         Sort Key: t2.k3
         ->  Seq Scan on t2
(8 rows)

-- unique secondary hash index partial key match
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k4;
          QUERY PLAN          
------------------------------
 Merge Join
   Merge Cond: (t1.a = t2.k4)
   ->  Sort
         Sort Key: t1.a
         ->  Seq Scan on t1
   ->  Sort
         Sort Key: t2.k4
         ->  Seq Scan on t2
(8 rows)

-- pk
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k1;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k1)
   ->  Seq Scan on t1
   ->  Index Scan using t2r_pkey on t2r t2
         Index Cond: (k1 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- unique secondary index
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k2;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k2)
   ->  Seq Scan on t1
   ->  Index Scan using i_t2r_k2 on t2r t2
         Index Cond: (k2 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- non-unique secondary index
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k3;
                QUERY PLAN                 
-------------------------------------------
 Merge Join
   Merge Cond: (t2.k3 = t1.a)
   ->  Index Scan using i_t2r_k3 on t2r t2
   ->  Sort
         Sort Key: t1.a
         ->  Seq Scan on t1
(6 rows)

-- unique secondary index partial key match
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k4;
                 QUERY PLAN                  
---------------------------------------------
 Merge Join
   Merge Cond: (t2.k4 = t1.a)
   ->  Index Scan using i_t2r_k4k5 on t2r t2
   ->  Sort
         Sort Key: t1.a
         ->  Seq Scan on t1
(6 rows)

--------------
-- Analyzed --
--------------
analyze t1, t2, t2r;
--
-- Pre-2024.1 behavior (20.2.x and earlier)
--
-- Pre-2024.1 defaults
set yb_bnl_batch_size = 1;
set yb_prefer_bnl = off;
set yb_enable_cbo = legacy_bnl_mode;
\i :filename
-- hash pk
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k1;
              QUERY PLAN              
--------------------------------------
 Nested Loop
   ->  Seq Scan on t1
   ->  Index Scan using t2_pkey on t2
         Index Cond: (k1 = t1.a)
(4 rows)

-- unique secondary hash index
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k2;
              QUERY PLAN              
--------------------------------------
 Nested Loop
   ->  Seq Scan on t1
   ->  Index Scan using i_t2_k2 on t2
         Index Cond: (k2 = t1.a)
(4 rows)

-- non-unique secondary hash index
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k3;
         QUERY PLAN          
-----------------------------
 Hash Join
   Hash Cond: (t2.k3 = t1.a)
   ->  Seq Scan on t2
   ->  Hash
         ->  Seq Scan on t1
(5 rows)

-- unique secondary hash index partial key match
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k4;
         QUERY PLAN          
-----------------------------
 Hash Join
   Hash Cond: (t2.k4 = t1.a)
   ->  Seq Scan on t2
   ->  Hash
         ->  Seq Scan on t1
(5 rows)

-- pk
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k1;
                QUERY PLAN                 
-------------------------------------------
 Nested Loop
   ->  Seq Scan on t1
   ->  Index Scan using t2r_pkey on t2r t2
         Index Cond: (k1 = t1.a)
(4 rows)

-- unique secondary index
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k2;
                QUERY PLAN                 
-------------------------------------------
 Nested Loop
   ->  Seq Scan on t1
   ->  Index Scan using i_t2r_k2 on t2r t2
         Index Cond: (k2 = t1.a)
(4 rows)

-- non-unique secondary index
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k3;
                QUERY PLAN                 
-------------------------------------------
 Merge Join
   Merge Cond: (t2.k3 = t1.a)
   ->  Index Scan using i_t2r_k3 on t2r t2
   ->  Sort
         Sort Key: t1.a
         ->  Seq Scan on t1
(6 rows)

-- unique secondary index partial key match
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k4;
                 QUERY PLAN                  
---------------------------------------------
 Merge Join
   Merge Cond: (t2.k4 = t1.a)
   ->  Index Scan using i_t2r_k4k5 on t2r t2
   ->  Sort
         Sort Key: t1.a
         ->  Seq Scan on t1
(6 rows)

set yb_enable_cbo = legacy_stats_bnl_mode;
\i :filename
-- hash pk
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k1;
              QUERY PLAN              
--------------------------------------
 Nested Loop
   ->  Seq Scan on t1
   ->  Index Scan using t2_pkey on t2
         Index Cond: (k1 = t1.a)
(4 rows)

-- unique secondary hash index
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k2;
              QUERY PLAN              
--------------------------------------
 Nested Loop
   ->  Seq Scan on t1
   ->  Index Scan using i_t2_k2 on t2
         Index Cond: (k2 = t1.a)
(4 rows)

-- non-unique secondary hash index
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k3;
              QUERY PLAN              
--------------------------------------
 Nested Loop
   ->  Seq Scan on t1
   ->  Index Scan using i_t2_k3 on t2
         Index Cond: (k3 = t1.a)
(4 rows)

-- unique secondary hash index partial key match
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k4;
               QUERY PLAN               
----------------------------------------
 Nested Loop
   ->  Seq Scan on t1
   ->  Index Scan using i_t2_k4k5 on t2
         Index Cond: (k4 = t1.a)
(4 rows)

-- pk
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k1;
                QUERY PLAN                 
-------------------------------------------
 Merge Join
   Merge Cond: (t2.k1 = t1.a)
   ->  Index Scan using t2r_pkey on t2r t2
   ->  Sort
         Sort Key: t1.a
         ->  Seq Scan on t1
(6 rows)

-- unique secondary index
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k2;
                QUERY PLAN                 
-------------------------------------------
 Merge Join
   Merge Cond: (t2.k2 = t1.a)
   ->  Index Scan using i_t2r_k2 on t2r t2
   ->  Sort
         Sort Key: t1.a
         ->  Seq Scan on t1
(6 rows)

-- non-unique secondary index
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k3;
                QUERY PLAN                 
-------------------------------------------
 Merge Join
   Merge Cond: (t2.k3 = t1.a)
   ->  Index Scan using i_t2r_k3 on t2r t2
   ->  Sort
         Sort Key: t1.a
         ->  Seq Scan on t1
(6 rows)

-- unique secondary index partial key match
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k4;
                 QUERY PLAN                  
---------------------------------------------
 Merge Join
   Merge Cond: (t2.k4 = t1.a)
   ->  Index Scan using i_t2r_k4k5 on t2r t2
   ->  Sort
         Sort Key: t1.a
         ->  Seq Scan on t1
(6 rows)

-- BNL enabled
set yb_bnl_batch_size = 1024;
set yb_prefer_bnl = on;
set yb_enable_cbo = legacy_bnl_mode;
\i :filename
-- hash pk
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k1;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k1)
   ->  Seq Scan on t1
   ->  Index Scan using t2_pkey on t2
         Index Cond: (k1 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- unique secondary hash index
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k2;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k2)
   ->  Seq Scan on t1
   ->  Index Scan using i_t2_k2 on t2
         Index Cond: (k2 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- non-unique secondary hash index
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k3;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k3)
   ->  Seq Scan on t1
   ->  Index Scan using i_t2_k3 on t2
         Index Cond: (k3 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- unique secondary hash index partial key match
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k4;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k4)
   ->  Seq Scan on t1
   ->  Index Scan using i_t2_k4k5 on t2
         Index Cond: (k4 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- pk
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k1;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k1)
   ->  Seq Scan on t1
   ->  Index Scan using t2r_pkey on t2r t2
         Index Cond: (k1 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- unique secondary index
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k2;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k2)
   ->  Seq Scan on t1
   ->  Index Scan using i_t2r_k2 on t2r t2
         Index Cond: (k2 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- non-unique secondary index
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k3;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k3)
   ->  Seq Scan on t1
   ->  Index Scan using i_t2r_k3 on t2r t2
         Index Cond: (k3 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- unique secondary index partial key match
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k4;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k4)
   ->  Seq Scan on t1
   ->  Index Scan using i_t2r_k4k5 on t2r t2
         Index Cond: (k4 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

set yb_enable_cbo = legacy_stats_bnl_mode;
\i :filename
-- hash pk
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k1;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k1)
   ->  Seq Scan on t1
   ->  Index Scan using t2_pkey on t2
         Index Cond: (k1 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- unique secondary hash index
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k2;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k2)
   ->  Seq Scan on t1
   ->  Index Scan using i_t2_k2 on t2
         Index Cond: (k2 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- non-unique secondary hash index
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k3;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k3)
   ->  Seq Scan on t1
   ->  Index Scan using i_t2_k3 on t2
         Index Cond: (k3 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- unique secondary hash index partial key match
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k4;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k4)
   ->  Seq Scan on t1
   ->  Index Scan using i_t2_k4k5 on t2
         Index Cond: (k4 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- pk
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k1;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k1)
   ->  Seq Scan on t1
   ->  Index Scan using t2r_pkey on t2r t2
         Index Cond: (k1 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- unique secondary index
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k2;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k2)
   ->  Seq Scan on t1
   ->  Index Scan using i_t2r_k2 on t2r t2
         Index Cond: (k2 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- non-unique secondary index
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k3;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k3)
   ->  Seq Scan on t1
   ->  Index Scan using i_t2r_k3 on t2r t2
         Index Cond: (k3 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- unique secondary index partial key match
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k4;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k4)
   ->  Seq Scan on t1
   ->  Index Scan using i_t2r_k4k5 on t2r t2
         Index Cond: (k4 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

--
-- 2024.1 and beyond
--
-- BNL enabled by default since 2024.1
set yb_bnl_batch_size = 1024;
set yb_prefer_bnl = on;
set yb_enable_cbo = legacy_mode;
\i :filename
-- hash pk
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k1;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k1)
   ->  Seq Scan on t1
   ->  Index Scan using t2_pkey on t2
         Index Cond: (k1 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- unique secondary hash index
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k2;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k2)
   ->  Seq Scan on t1
   ->  Index Scan using i_t2_k2 on t2
         Index Cond: (k2 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- non-unique secondary hash index
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k3;
         QUERY PLAN          
-----------------------------
 Hash Join
   Hash Cond: (t2.k3 = t1.a)
   ->  Seq Scan on t2
   ->  Hash
         ->  Seq Scan on t1
(5 rows)

-- unique secondary hash index partial key match
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k4;
         QUERY PLAN          
-----------------------------
 Hash Join
   Hash Cond: (t2.k4 = t1.a)
   ->  Seq Scan on t2
   ->  Hash
         ->  Seq Scan on t1
(5 rows)

-- pk
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k1;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k1)
   ->  Seq Scan on t1
   ->  Index Scan using t2r_pkey on t2r t2
         Index Cond: (k1 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- unique secondary index
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k2;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k2)
   ->  Seq Scan on t1
   ->  Index Scan using i_t2r_k2 on t2r t2
         Index Cond: (k2 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- non-unique secondary index
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k3;
                QUERY PLAN                 
-------------------------------------------
 Merge Join
   Merge Cond: (t2.k3 = t1.a)
   ->  Index Scan using i_t2r_k3 on t2r t2
   ->  Sort
         Sort Key: t1.a
         ->  Seq Scan on t1
(6 rows)

-- unique secondary index partial key match
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k4;
                 QUERY PLAN                  
---------------------------------------------
 Merge Join
   Merge Cond: (t2.k4 = t1.a)
   ->  Index Scan using i_t2r_k4k5 on t2r t2
   ->  Sort
         Sort Key: t1.a
         ->  Seq Scan on t1
(6 rows)

set yb_enable_cbo = legacy_stats_mode;
\i :filename
-- hash pk
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k1;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k1)
   ->  Seq Scan on t1
   ->  Index Scan using t2_pkey on t2
         Index Cond: (k1 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- unique secondary hash index
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k2;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k2)
   ->  Seq Scan on t1
   ->  Index Scan using i_t2_k2 on t2
         Index Cond: (k2 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- non-unique secondary hash index
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k3;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k3)
   ->  Seq Scan on t1
   ->  Index Scan using i_t2_k3 on t2
         Index Cond: (k3 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- unique secondary hash index partial key match
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k4;
                            QUERY PLAN                            
------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.a = t2.k4)
   ->  Seq Scan on t1
   ->  Index Scan using i_t2_k4k5 on t2
         Index Cond: (k4 = ANY (ARRAY[t1.a, $1, $2, ..., $1023]))
(5 rows)

-- pk
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k1;
                QUERY PLAN                 
-------------------------------------------
 Merge Join
   Merge Cond: (t2.k1 = t1.a)
   ->  Index Scan using t2r_pkey on t2r t2
   ->  Sort
         Sort Key: t1.a
         ->  Seq Scan on t1
(6 rows)

-- unique secondary index
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k2;
                QUERY PLAN                 
-------------------------------------------
 Merge Join
   Merge Cond: (t2.k2 = t1.a)
   ->  Index Scan using i_t2r_k2 on t2r t2
   ->  Sort
         Sort Key: t1.a
         ->  Seq Scan on t1
(6 rows)

-- non-unique secondary index
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k3;
                QUERY PLAN                 
-------------------------------------------
 Merge Join
   Merge Cond: (t2.k3 = t1.a)
   ->  Index Scan using i_t2r_k3 on t2r t2
   ->  Sort
         Sort Key: t1.a
         ->  Seq Scan on t1
(6 rows)

-- unique secondary index partial key match
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k4;
                 QUERY PLAN                  
---------------------------------------------
 Merge Join
   Merge Cond: (t2.k4 = t1.a)
   ->  Index Scan using i_t2r_k4k5 on t2r t2
   ->  Sort
         Sort Key: t1.a
         ->  Seq Scan on t1
(6 rows)

-- BNL disabled
set yb_bnl_batch_size = 1;
set yb_prefer_bnl = off;
set yb_enable_cbo = legacy_mode;
\i :filename
-- hash pk
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k1;
              QUERY PLAN              
--------------------------------------
 Nested Loop
   ->  Seq Scan on t1
   ->  Index Scan using t2_pkey on t2
         Index Cond: (k1 = t1.a)
(4 rows)

-- unique secondary hash index
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k2;
              QUERY PLAN              
--------------------------------------
 Nested Loop
   ->  Seq Scan on t1
   ->  Index Scan using i_t2_k2 on t2
         Index Cond: (k2 = t1.a)
(4 rows)

-- non-unique secondary hash index
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k3;
         QUERY PLAN          
-----------------------------
 Hash Join
   Hash Cond: (t2.k3 = t1.a)
   ->  Seq Scan on t2
   ->  Hash
         ->  Seq Scan on t1
(5 rows)

-- unique secondary hash index partial key match
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k4;
         QUERY PLAN          
-----------------------------
 Hash Join
   Hash Cond: (t2.k4 = t1.a)
   ->  Seq Scan on t2
   ->  Hash
         ->  Seq Scan on t1
(5 rows)

-- pk
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k1;
                QUERY PLAN                 
-------------------------------------------
 Nested Loop
   ->  Seq Scan on t1
   ->  Index Scan using t2r_pkey on t2r t2
         Index Cond: (k1 = t1.a)
(4 rows)

-- unique secondary index
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k2;
                QUERY PLAN                 
-------------------------------------------
 Nested Loop
   ->  Seq Scan on t1
   ->  Index Scan using i_t2r_k2 on t2r t2
         Index Cond: (k2 = t1.a)
(4 rows)

-- non-unique secondary index
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k3;
                QUERY PLAN                 
-------------------------------------------
 Merge Join
   Merge Cond: (t2.k3 = t1.a)
   ->  Index Scan using i_t2r_k3 on t2r t2
   ->  Sort
         Sort Key: t1.a
         ->  Seq Scan on t1
(6 rows)

-- unique secondary index partial key match
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k4;
                 QUERY PLAN                  
---------------------------------------------
 Merge Join
   Merge Cond: (t2.k4 = t1.a)
   ->  Index Scan using i_t2r_k4k5 on t2r t2
   ->  Sort
         Sort Key: t1.a
         ->  Seq Scan on t1
(6 rows)

set yb_enable_cbo = legacy_stats_mode;
\i :filename
-- hash pk
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k1;
              QUERY PLAN              
--------------------------------------
 Nested Loop
   ->  Seq Scan on t1
   ->  Index Scan using t2_pkey on t2
         Index Cond: (k1 = t1.a)
(4 rows)

-- unique secondary hash index
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k2;
              QUERY PLAN              
--------------------------------------
 Nested Loop
   ->  Seq Scan on t1
   ->  Index Scan using i_t2_k2 on t2
         Index Cond: (k2 = t1.a)
(4 rows)

-- non-unique secondary hash index
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k3;
              QUERY PLAN              
--------------------------------------
 Nested Loop
   ->  Seq Scan on t1
   ->  Index Scan using i_t2_k3 on t2
         Index Cond: (k3 = t1.a)
(4 rows)

-- unique secondary hash index partial key match
explain (costs off, summary off)
select * from t1 join t2 on t1.a = t2.k4;
               QUERY PLAN               
----------------------------------------
 Nested Loop
   ->  Seq Scan on t1
   ->  Index Scan using i_t2_k4k5 on t2
         Index Cond: (k4 = t1.a)
(4 rows)

-- pk
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k1;
                QUERY PLAN                 
-------------------------------------------
 Merge Join
   Merge Cond: (t2.k1 = t1.a)
   ->  Index Scan using t2r_pkey on t2r t2
   ->  Sort
         Sort Key: t1.a
         ->  Seq Scan on t1
(6 rows)

-- unique secondary index
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k2;
                QUERY PLAN                 
-------------------------------------------
 Merge Join
   Merge Cond: (t2.k2 = t1.a)
   ->  Index Scan using i_t2r_k2 on t2r t2
   ->  Sort
         Sort Key: t1.a
         ->  Seq Scan on t1
(6 rows)

-- non-unique secondary index
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k3;
                QUERY PLAN                 
-------------------------------------------
 Merge Join
   Merge Cond: (t2.k3 = t1.a)
   ->  Index Scan using i_t2r_k3 on t2r t2
   ->  Sort
         Sort Key: t1.a
         ->  Seq Scan on t1
(6 rows)

-- unique secondary index partial key match
explain (costs off, summary off)
select * from t1 join t2r t2 on t1.a = t2.k4;
                 QUERY PLAN                  
---------------------------------------------
 Merge Join
   Merge Cond: (t2.k4 = t1.a)
   ->  Index Scan using i_t2r_k4k5 on t2r t2
   ->  Sort
         Sort Key: t1.a
         ->  Seq Scan on t1
(6 rows)

drop table t1, t2, t2r;
