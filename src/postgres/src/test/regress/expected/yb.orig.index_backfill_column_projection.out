--
-- Tests for index backfill column projection optimization.
-- This test verifies that concurrent index creation only reads columns
-- that are needed for the index, not the entire row.
-- (GitHub issue: #29906)
--
-- Explicitly enable the feature flag for this test (default is already true)
SET yb_enable_index_backfill_column_projection = true;
-- Test 1: Simple index on a table with many columns
-- Only the indexed column should be read during backfill.
CREATE TABLE wide_table (
    id SERIAL PRIMARY KEY,
    col1 INT,
    col2 INT,
    col3 TEXT,
    col4 TEXT,
    col5 BYTEA,
    col6 JSONB,
    col7 INT[],
    col8 TIMESTAMP,
    col9 NUMERIC(10,2),
    col10 VARCHAR(1000)
);
INSERT INTO wide_table (col1, col2, col3, col4, col5, col6, col7, col8, col9, col10)
SELECT
    i,
    i * 2,
    'text_' || i,
    repeat('x', 100),
    decode(repeat('FF', 50), 'hex'),
    ('{"key": ' || i || '}')::jsonb,
    ARRAY[i, i+1, i+2],
    NOW() + (i || ' days')::interval,
    i * 1.5,
    repeat('y', 500)
FROM generate_series(1, 100) AS i;
-- Create a concurrent index on just col1
CREATE INDEX CONCURRENTLY idx_wide_col1 ON wide_table(col1);
-- Verify the index works correctly
EXPLAIN (COSTS OFF) SELECT col1 FROM wide_table WHERE col1 = 50;
                    QUERY PLAN
---------------------------------------------------
 Index Only Scan using idx_wide_col1 on wide_table
   Index Cond: (col1 = 50)
(2 rows)

SELECT col1 FROM wide_table WHERE col1 = 50;
 col1
------
   50
(1 row)

DROP INDEX idx_wide_col1;
-- Test 2: Multi-column index
-- Only col1 and col2 should be read during backfill.
CREATE INDEX CONCURRENTLY idx_wide_multi ON wide_table(col1, col2);
-- Verify the index works correctly
EXPLAIN (COSTS OFF) SELECT col1, col2 FROM wide_table WHERE col1 = 50 AND col2 = 100;
                     QUERY PLAN
----------------------------------------------------
 Index Only Scan using idx_wide_multi on wide_table
   Index Cond: ((col1 = 50) AND (col2 = 100))
(2 rows)

SELECT col1, col2 FROM wide_table WHERE col1 = 50 AND col2 = 100;
 col1 | col2
------+------
   50 |  100
(1 row)

DROP INDEX idx_wide_multi;
-- Test 3: Expression index
-- Columns referenced in the expression should be read.
CREATE INDEX CONCURRENTLY idx_wide_expr ON wide_table((col1 + col2));
-- Verify the index works correctly
EXPLAIN (COSTS OFF) SELECT * FROM wide_table WHERE col1 + col2 = 150;
                  QUERY PLAN
-----------------------------------------------
 Index Scan using idx_wide_expr on wide_table
   Index Cond: ((col1 + col2) = 150)
(2 rows)

SELECT id, col1, col2 FROM wide_table WHERE col1 + col2 = 150;
 id | col1 | col2
----+------+------
 50 |   50 |  100
(1 row)

DROP INDEX idx_wide_expr;
-- Test 4: Partial index with WHERE predicate
-- Both indexed column and predicate columns should be read.
CREATE INDEX CONCURRENTLY idx_wide_partial ON wide_table(col3) WHERE col1 > 50;
-- Verify the index works correctly
EXPLAIN (COSTS OFF) SELECT col3 FROM wide_table WHERE col3 = 'text_75' AND col1 > 50;
                      QUERY PLAN
------------------------------------------------------
 Index Only Scan using idx_wide_partial on wide_table
   Index Cond: (col3 = 'text_75'::text)
(2 rows)

SELECT col3 FROM wide_table WHERE col3 = 'text_75' AND col1 > 50;
  col3
---------
 text_75
(1 row)

DROP INDEX idx_wide_partial;
-- Test 5: Expression index with partial predicate
-- Columns from both expression and predicate should be read.
CREATE INDEX CONCURRENTLY idx_wide_expr_partial ON wide_table((col1 * col2)) WHERE col9 > 50;
-- Verify the index works correctly
EXPLAIN (COSTS OFF) SELECT col1, col2, col9 FROM wide_table WHERE col1 * col2 = 5000 AND col9 > 50;
                      QUERY PLAN
-------------------------------------------------------
 Index Scan using idx_wide_expr_partial on wide_table
   Index Cond: ((col1 * col2) = 5000)
(2 rows)

SELECT col1, col2, col9 FROM wide_table WHERE col1 * col2 = 5000 AND col9 > 50;
 col1 | col2 |  col9
------+------+--------
   50 |  100 |  75.00
(1 row)

DROP INDEX idx_wide_expr_partial;
-- Test 6: Index with included columns (covering index)
-- Both key columns and included columns should be read.
CREATE INDEX CONCURRENTLY idx_wide_include ON wide_table(col1) INCLUDE (col3, col4);
-- Verify the index works correctly
EXPLAIN (COSTS OFF) SELECT col1, col3, col4 FROM wide_table WHERE col1 = 50;
                    QUERY PLAN
--------------------------------------------------
 Index Only Scan using idx_wide_include on wide_table
   Index Cond: (col1 = 50)
(2 rows)

SELECT col1, col3, col4 FROM wide_table WHERE col1 = 50;
 col1 |  col3   |                                                  col4
------+---------+--------------------------------------------------------------------------------------------------------
   50 | text_50 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
(1 row)

DROP INDEX idx_wide_include;
-- Test 7: Non-concurrent index build (should also use optimization)
CREATE INDEX idx_wide_nonconcurrent ON wide_table(col2);
-- Verify the index works correctly
EXPLAIN (COSTS OFF) SELECT col2 FROM wide_table WHERE col2 = 100;
                         QUERY PLAN
------------------------------------------------------------
 Index Only Scan using idx_wide_nonconcurrent on wide_table
   Index Cond: (col2 = 100)
(2 rows)

SELECT col2 FROM wide_table WHERE col2 = 100;
 col2
------
  100
(1 row)

DROP INDEX idx_wide_nonconcurrent;
-- Cleanup
DROP TABLE wide_table;
-- Test 8: Verify index correctness with updates during backfill simulation
-- Create table and populate with data
CREATE TABLE backfill_test (
    id INT PRIMARY KEY,
    indexed_col INT,
    other_col TEXT
);
INSERT INTO backfill_test SELECT i, i % 100, 'data_' || i FROM generate_series(1, 1000) AS i;
-- Create concurrent index
CREATE INDEX CONCURRENTLY idx_backfill ON backfill_test(indexed_col);
-- Verify all rows are properly indexed
SELECT COUNT(*) FROM backfill_test WHERE indexed_col = 50;
 count
-------
    10
(1 row)

-- Verify using the index
EXPLAIN (COSTS OFF) SELECT * FROM backfill_test WHERE indexed_col = 50;
                   QUERY PLAN
-------------------------------------------------
 Index Scan using idx_backfill on backfill_test
   Index Cond: (indexed_col = 50)
(2 rows)

SELECT COUNT(*) FROM backfill_test WHERE indexed_col = 50;
 count
-------
    10
(1 row)

-- Cleanup
DROP TABLE backfill_test;
