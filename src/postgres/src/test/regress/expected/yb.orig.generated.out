SET yb_explain_hide_non_deterministic_fields TO true;
DROP TABLE IF EXISTS t0_gen;
NOTICE:  table "t0_gen" does not exist, skipping
DROP TABLE IF EXISTS t1_gen;
NOTICE:  table "t1_gen" does not exist, skipping
CREATE TABLE t0_gen (k INT PRIMARY KEY, v1 INT, v2 INT, v1_gen TEXT GENERATED ALWAYS AS ('Text ' || v1::text) STORED);
CREATE TABLE t1_gen (k INT PRIMARY KEY, k_gen TEXT GENERATED ALWAYS AS ('Text ' || k::text) STORED, v1 INT, v2 INT, v3 INT, v1_v2_gen INT GENERATED ALWAYS AS (v1 + v2) STORED);
INSERT INTO t0_gen (k, v1, v2) (SELECT i, i, i FROM generate_series(1, 10) AS i);
INSERT INTO t1_gen (k, v1, v2, v3) (SELECT i, i, i, NULL FROM generate_series(1, 10) AS i);
SELECT * FROM t0_gen ORDER BY k;
 k  | v1 | v2 | v1_gen
----+----+----+---------
  1 |  1 |  1 | Text 1
  2 |  2 |  2 | Text 2
  3 |  3 |  3 | Text 3
  4 |  4 |  4 | Text 4
  5 |  5 |  5 | Text 5
  6 |  6 |  6 | Text 6
  7 |  7 |  7 | Text 7
  8 |  8 |  8 | Text 8
  9 |  9 |  9 | Text 9
 10 | 10 | 10 | Text 10
(10 rows)

SELECT * FROM t1_gen ORDER BY k;
 k  |  k_gen  | v1 | v2 | v3 | v1_v2_gen
----+---------+----+----+----+-----------
  1 | Text 1  |  1 |  1 |    |         2
  2 | Text 2  |  2 |  2 |    |         4
  3 | Text 3  |  3 |  3 |    |         6
  4 | Text 4  |  4 |  4 |    |         8
  5 | Text 5  |  5 |  5 |    |        10
  6 | Text 6  |  6 |  6 |    |        12
  7 | Text 7  |  7 |  7 |    |        14
  8 | Text 8  |  8 |  8 |    |        16
  9 | Text 9  |  9 |  9 |    |        18
 10 | Text 10 | 10 | 10 |    |        20
(10 rows)

-- Updates that don't involve generated columns + columns they depend on should
-- eligible for single-row optimization or expression pushdown.
EXPLAIN (ANALYZE, DIST, COSTS OFF) UPDATE t0_gen SET v2 = v2 + 1 WHERE k = 1;
                QUERY PLAN
------------------------------------------
 Update on t0_gen (actual rows=0 loops=1)
   ->  Result (actual rows=1 loops=1)
         Storage Table Write Requests: 1
 Storage Read Requests: 0
 Storage Rows Scanned: 0
 Storage Write Requests: 1
 Storage Flush Requests: 0
(7 rows)

EXPLAIN (ANALYZE, DIST, COSTS OFF) UPDATE t0_gen SET v2 = (random() * 10)::int WHERE k = 2;
                QUERY PLAN
------------------------------------------
 Update on t0_gen (actual rows=0 loops=1)
   ->  Result (actual rows=1 loops=1)
         Storage Table Write Requests: 1
 Storage Read Requests: 0
 Storage Rows Scanned: 0
 Storage Write Requests: 1
 Storage Flush Requests: 0
(7 rows)

-- Updates involving generated columns should not be eligible for single-row optimization
-- and should not be pushed down.
EXPLAIN (ANALYZE, DIST, COSTS OFF) UPDATE t0_gen SET v1 = v1 + 1 WHERE k = 3;
                              QUERY PLAN
----------------------------------------------------------------------
 Update on t0_gen (actual rows=0 loops=1)
   ->  Index Scan using t0_gen_pkey on t0_gen (actual rows=1 loops=1)
         Index Cond: (k = 3)
         Storage Table Read Requests: 1
         Storage Table Rows Scanned: 1
         Storage Table Write Requests: 1
 Storage Read Requests: 1
 Storage Rows Scanned: 1
 Storage Write Requests: 1
 Storage Flush Requests: 1
(10 rows)

EXPLAIN (ANALYZE, DIST, COSTS OFF) UPDATE t0_gen SET v1 = v2 + 1, v2 = v1 + 1 WHERE k = 4;
                              QUERY PLAN
----------------------------------------------------------------------
 Update on t0_gen (actual rows=0 loops=1)
   ->  Index Scan using t0_gen_pkey on t0_gen (actual rows=1 loops=1)
         Index Cond: (k = 4)
         Storage Table Read Requests: 1
         Storage Table Rows Scanned: 1
         Storage Table Write Requests: 1
 Storage Read Requests: 1
 Storage Rows Scanned: 1
 Storage Write Requests: 1
 Storage Flush Requests: 1
(10 rows)

SELECT * FROM t0_gen WHERE k NOT IN (2) ORDER BY k;
 k  | v1 | v2 | v1_gen
----+----+----+---------
  1 |  1 |  2 | Text 1
  3 |  4 |  3 | Text 4
  4 |  5 |  5 | Text 5
  5 |  5 |  5 | Text 5
  6 |  6 |  6 | Text 6
  7 |  7 |  7 | Text 7
  8 |  8 |  8 | Text 8
  9 |  9 |  9 | Text 9
 10 | 10 | 10 | Text 10
(9 rows)

CREATE INDEX NONCONCURRENTLY v1_gen_idx ON t0_gen (v1_gen) WHERE k > 100;
-- Modifytable operations must correctly work with indexes on generated columns.
EXPLAIN (ANALYZE, DIST, COSTS OFF) INSERT INTO t0_gen VALUES (101, 101, 101), (102, 102, 102);
                       QUERY PLAN
---------------------------------------------------------
 Insert on t0_gen (actual rows=0 loops=1)
   ->  Values Scan on "*VALUES*" (actual rows=2 loops=1)
         Storage Table Write Requests: 2
         Storage Index Write Requests: 2
 Storage Read Requests: 0
 Storage Rows Scanned: 0
 Storage Write Requests: 4
 Storage Flush Requests: 1
(8 rows)

EXPLAIN (ANALYZE, DIST, COSTS OFF) INSERT INTO t0_gen (k, v2) VALUES (103, 103);
                QUERY PLAN
------------------------------------------
 Insert on t0_gen (actual rows=0 loops=1)
   ->  Result (actual rows=1 loops=1)
         Storage Table Write Requests: 1
         Storage Index Write Requests: 1
 Storage Read Requests: 0
 Storage Rows Scanned: 0
 Storage Write Requests: 2
 Storage Flush Requests: 1
(8 rows)

EXPLAIN (ANALYZE, DIST, COSTS OFF) INSERT INTO t0_gen (k, v1) VALUES (104, 104);
                QUERY PLAN
------------------------------------------
 Insert on t0_gen (actual rows=0 loops=1)
   ->  Result (actual rows=1 loops=1)
         Storage Table Write Requests: 1
         Storage Index Write Requests: 1
 Storage Read Requests: 0
 Storage Rows Scanned: 0
 Storage Write Requests: 2
 Storage Flush Requests: 1
(8 rows)

SELECT * FROM t0_gen WHERE k >= 100 ORDER BY k;
  k  | v1  | v2  |  v1_gen
-----+-----+-----+----------
 101 | 101 | 101 | Text 101
 102 | 102 | 102 | Text 102
 103 |     | 103 |
 104 | 104 |     | Text 104
(4 rows)

EXPLAIN (COSTS OFF) /*+ IndexOnlyScan(t0_gen v1_gen_idx) */ SELECT COUNT(v1_gen) FROM t0_gen WHERE k > 100;
                    QUERY PLAN
--------------------------------------------------
 Finalize Aggregate
   ->  Index Only Scan using v1_gen_idx on t0_gen
         Partial Aggregate: true
(3 rows)

-- COUNT(col) will skip over NULL values.
/*+ IndexOnlyScan(t0_gen v1_gen_idx) */ SELECT COUNT(v1_gen) FROM t0_gen WHERE k > 100;
 count
-------
     3
(1 row)

EXPLAIN (ANALYZE, DIST, COSTS OFF) UPDATE t0_gen SET v1 = v1 + 1, v2 = v2 + 1 WHERE k > 100;
                    QUERY PLAN
--------------------------------------------------
 Update on t0_gen (actual rows=0 loops=1)
   ->  Seq Scan on t0_gen (actual rows=4 loops=1)
         Storage Filter: (k > 100)
         Storage Table Read Requests: 1
         Storage Table Rows Scanned: 14
         Storage Table Write Requests: 4
         Storage Index Write Requests: 6
 Storage Read Requests: 1
 Storage Rows Scanned: 14
 Storage Write Requests: 10
 Storage Flush Requests: 1
(11 rows)

EXPLAIN (ANALYZE, DIST, COSTS OFF) UPDATE t0_gen SET v2 = v2 - 1 WHERE k > 100;
                    QUERY PLAN
--------------------------------------------------
 Update on t0_gen (actual rows=0 loops=1)
   ->  Seq Scan on t0_gen (actual rows=4 loops=1)
         Storage Filter: (k > 100)
         Storage Table Read Requests: 1
         Storage Table Rows Scanned: 14
         Storage Table Write Requests: 4
 Storage Read Requests: 1
 Storage Rows Scanned: 14
 Storage Write Requests: 4
 Storage Flush Requests: 1
(10 rows)

EXPLAIN (ANALYZE, DIST, COSTS OFF) UPDATE t0_gen SET k = k + 10 WHERE k > 100;
                    QUERY PLAN
--------------------------------------------------
 Update on t0_gen (actual rows=0 loops=1)
   ->  Seq Scan on t0_gen (actual rows=4 loops=1)
         Storage Filter: (k > 100)
         Storage Table Read Requests: 1
         Storage Table Rows Scanned: 14
         Storage Table Write Requests: 8
         Storage Index Write Requests: 8
 Storage Read Requests: 1
 Storage Rows Scanned: 14
 Storage Write Requests: 16
 Storage Flush Requests: 1
(11 rows)

SELECT * FROM t0_gen WHERE k > 100 ORDER BY k;
  k  | v1  | v2  |  v1_gen
-----+-----+-----+----------
 111 | 102 | 101 | Text 102
 112 | 103 | 102 | Text 103
 113 |     | 103 |
 114 | 105 |     | Text 105
(4 rows)

/*+ IndexOnlyScan(t0_gen v1_gen_idx) */ SELECT COUNT(v1_gen) FROM t0_gen WHERE k > 100;
 count
-------
     3
(1 row)

EXPLAIN (ANALYZE, DIST, COSTS OFF) DELETE FROM t0_gen WHERE k > 110 AND k < 112;
                    QUERY PLAN
---------------------------------------------------
 Delete on t0_gen (actual rows=0 loops=1)
   ->  Seq Scan on t0_gen (actual rows=1 loops=1)
         Storage Filter: ((k > 110) AND (k < 112))
         Storage Table Read Requests: 1
         Storage Table Rows Scanned: 14
         Storage Table Write Requests: 1
         Storage Index Write Requests: 1
 Storage Read Requests: 1
 Storage Rows Scanned: 14
 Storage Write Requests: 2
 Storage Flush Requests: 1
(11 rows)

EXPLAIN (ANALYZE, DIST, COSTS OFF) DELETE FROM t0_gen WHERE v1_gen = 'Text 103';
                     QUERY PLAN
-----------------------------------------------------
 Delete on t0_gen (actual rows=0 loops=1)
   ->  Seq Scan on t0_gen (actual rows=1 loops=1)
         Storage Filter: (v1_gen = 'Text 103'::text)
         Storage Table Read Requests: 1
         Storage Table Rows Scanned: 13
         Storage Table Write Requests: 1
         Storage Index Write Requests: 1
 Storage Read Requests: 1
 Storage Rows Scanned: 13
 Storage Write Requests: 2
 Storage Flush Requests: 1
(11 rows)

EXPLAIN (ANALYZE, DIST, COSTS OFF) DELETE FROM t0_gen WHERE v1_gen IS NULL;
                    QUERY PLAN
--------------------------------------------------
 Delete on t0_gen (actual rows=0 loops=1)
   ->  Seq Scan on t0_gen (actual rows=1 loops=1)
         Storage Filter: (v1_gen IS NULL)
         Storage Table Read Requests: 1
         Storage Table Rows Scanned: 12
         Storage Table Write Requests: 1
         Storage Index Write Requests: 1
 Storage Read Requests: 1
 Storage Rows Scanned: 12
 Storage Write Requests: 2
 Storage Flush Requests: 1
(11 rows)

SELECT * FROM t0_gen WHERE k > 100 ORDER BY k;
  k  | v1  | v2 |  v1_gen
-----+-----+----+----------
 114 | 105 |    | Text 105
(1 row)

/*+ IndexOnlyScan(t0_gen v1_gen_idx) */ SELECT COUNT(v1_gen) FROM t0_gen WHERE k > 100;
 count
-------
     1
(1 row)

-- Modifytable operations must correctly work with multi-column indexes involving generated columns.
CREATE INDEX NONCONCURRENTLY v2_v1_gen_idx ON t0_gen (v2, v1_gen) WHERE k > 200;
EXPLAIN (ANALYZE, DIST, COSTS OFF) INSERT INTO t0_gen VALUES (201, 201, 201), (202, 202, 202);
                       QUERY PLAN
---------------------------------------------------------
 Insert on t0_gen (actual rows=0 loops=1)
   ->  Values Scan on "*VALUES*" (actual rows=2 loops=1)
         Storage Table Write Requests: 2
         Storage Index Write Requests: 4
 Storage Read Requests: 0
 Storage Rows Scanned: 0
 Storage Write Requests: 6
 Storage Flush Requests: 1
(8 rows)

EXPLAIN (ANALYZE, DIST, COSTS OFF) INSERT INTO t0_gen (k, v2) VALUES (203, 203);
                QUERY PLAN
------------------------------------------
 Insert on t0_gen (actual rows=0 loops=1)
   ->  Result (actual rows=1 loops=1)
         Storage Table Write Requests: 1
         Storage Index Write Requests: 2
 Storage Read Requests: 0
 Storage Rows Scanned: 0
 Storage Write Requests: 3
 Storage Flush Requests: 1
(8 rows)

EXPLAIN (ANALYZE, DIST, COSTS OFF) INSERT INTO t0_gen (k, v1) VALUES (204, 204);
                QUERY PLAN
------------------------------------------
 Insert on t0_gen (actual rows=0 loops=1)
   ->  Result (actual rows=1 loops=1)
         Storage Table Write Requests: 1
         Storage Index Write Requests: 2
 Storage Read Requests: 0
 Storage Rows Scanned: 0
 Storage Write Requests: 3
 Storage Flush Requests: 1
(8 rows)

SELECT * FROM t0_gen WHERE k > 200 ORDER BY k;
  k  | v1  | v2  |  v1_gen
-----+-----+-----+----------
 201 | 201 | 201 | Text 201
 202 | 202 | 202 | Text 202
 203 |     | 203 |
 204 | 204 |     | Text 204
(4 rows)

EXPLAIN (COSTS OFF) /*+ IndexOnlyScan(t0_gen v2_v1_gen_idx) */ SELECT COUNT(v1_gen) FROM t0_gen WHERE k > 200;
                     QUERY PLAN
-----------------------------------------------------
 Finalize Aggregate
   ->  Index Only Scan using v2_v1_gen_idx on t0_gen
         Partial Aggregate: true
(3 rows)

/*+ IndexOnlyScan(t0_gen v2_v1_gen_idx) */ SELECT COUNT(v1_gen) FROM t0_gen WHERE k > 200;
 count
-------
     3
(1 row)

-- The following query updates both indexes on the table. Rows corresponding to k = 201, 202, 204
-- need entries in both indexes to be deleted and reinserted, while rows corresponding to k = 203
-- needs only the entry in v2_v1_gen_idx to be updated because the entry in v1_gen_idx evaluates to
-- NULL both before and after the update.
EXPLAIN (ANALYZE, DIST, COSTS OFF) UPDATE t0_gen SET v1 = v1 + 1, v2 = v2 + 1 WHERE k > 200;
                    QUERY PLAN
--------------------------------------------------
 Update on t0_gen (actual rows=0 loops=1)
   ->  Seq Scan on t0_gen (actual rows=4 loops=1)
         Storage Filter: (k > 200)
         Storage Table Read Requests: 1
         Storage Table Rows Scanned: 15
         Storage Table Write Requests: 4
         Storage Index Write Requests: 14
 Storage Read Requests: 1
 Storage Rows Scanned: 15
 Storage Write Requests: 18
 Storage Flush Requests: 1
(11 rows)

EXPLAIN (ANALYZE, DIST, COSTS OFF) UPDATE t0_gen SET v2 = v2 - 1 WHERE k > 200;
                    QUERY PLAN
--------------------------------------------------
 Update on t0_gen (actual rows=0 loops=1)
   ->  Seq Scan on t0_gen (actual rows=4 loops=1)
         Storage Filter: (k > 200)
         Storage Table Read Requests: 1
         Storage Table Rows Scanned: 15
         Storage Table Write Requests: 4
         Storage Index Write Requests: 6
 Storage Read Requests: 1
 Storage Rows Scanned: 15
 Storage Write Requests: 10
 Storage Flush Requests: 1
(11 rows)

EXPLAIN (ANALYZE, DIST, COSTS OFF) UPDATE t0_gen SET v1 = v1 + 1 WHERE k = 204;
                              QUERY PLAN
----------------------------------------------------------------------
 Update on t0_gen (actual rows=0 loops=1)
   ->  Index Scan using t0_gen_pkey on t0_gen (actual rows=1 loops=1)
         Index Cond: (k = 204)
         Storage Table Read Requests: 1
         Storage Table Rows Scanned: 1
         Storage Table Write Requests: 1
         Storage Index Write Requests: 4
 Storage Read Requests: 1
 Storage Rows Scanned: 1
 Storage Write Requests: 5
 Storage Flush Requests: 1
(11 rows)

SELECT * FROM t0_gen WHERE k > 200 ORDER BY k;
  k  | v1  | v2  |  v1_gen
-----+-----+-----+----------
 201 | 202 | 201 | Text 202
 202 | 203 | 202 | Text 203
 203 |     | 203 |
 204 | 206 |     | Text 206
(4 rows)

/*+ IndexOnlyScan(t0_gen v2_v1_gen_idx) */ SELECT COUNT(v1_gen) FROM t0_gen WHERE k > 200;
 count
-------
     3
(1 row)

EXPLAIN (ANALYZE, DIST, COSTS OFF) DELETE FROM t0_gen WHERE k = 201;
                              QUERY PLAN
----------------------------------------------------------------------
 Delete on t0_gen (actual rows=0 loops=1)
   ->  Index Scan using t0_gen_pkey on t0_gen (actual rows=1 loops=1)
         Index Cond: (k = 201)
         Storage Table Read Requests: 1
         Storage Table Rows Scanned: 1
         Storage Table Write Requests: 1
         Storage Index Write Requests: 2
 Storage Read Requests: 1
 Storage Rows Scanned: 1
 Storage Write Requests: 3
 Storage Flush Requests: 1
(11 rows)

EXPLAIN (ANALYZE, DIST, COSTS OFF) DELETE FROM t0_gen WHERE k > 200 AND (v1 < 203 OR v1 IS NULL);
                              QUERY PLAN
----------------------------------------------------------------------
 Delete on t0_gen (actual rows=0 loops=1)
   ->  Seq Scan on t0_gen (actual rows=1 loops=1)
         Storage Filter: ((k > 200) AND ((v1 < 203) OR (v1 IS NULL)))
         Storage Table Read Requests: 1
         Storage Table Rows Scanned: 14
         Storage Table Write Requests: 1
         Storage Index Write Requests: 2
 Storage Read Requests: 1
 Storage Rows Scanned: 14
 Storage Write Requests: 3
 Storage Flush Requests: 1
(11 rows)

EXPLAIN (ANALYZE, DIST, COSTS OFF) DELETE FROM t0_gen WHERE k > 100 AND v2 < 203;
                     QUERY PLAN
----------------------------------------------------
 Delete on t0_gen (actual rows=0 loops=1)
   ->  Seq Scan on t0_gen (actual rows=1 loops=1)
         Storage Filter: ((k > 100) AND (v2 < 203))
         Storage Table Read Requests: 1
         Storage Table Rows Scanned: 13
         Storage Table Write Requests: 1
         Storage Index Write Requests: 2
 Storage Read Requests: 1
 Storage Rows Scanned: 13
 Storage Write Requests: 3
 Storage Flush Requests: 1
(11 rows)

SELECT * FROM t0_gen WHERE k > 200 ORDER BY k;
  k  | v1  | v2 |  v1_gen
-----+-----+----+----------
 204 | 206 |    | Text 206
(1 row)

/*+ IndexOnlyScan(t0_gen v2_v1_gen_idx) */ SELECT COUNT(v1_gen) FROM t0_gen WHERE k > 200;
 count
-------
     1
(1 row)

/*+ IndexOnlyScan(t0_gen v1_gen_idx) */ SELECT COUNT(v1_gen) FROM t0_gen WHERE k > 100;
 count
-------
     2
(1 row)

-- Update operations involving a generated column that depends on multiple columns.
-- If the update operations involves any of the columns that a generated column
-- depends on, then the query should not be eligible for single-row optimization
-- or expression pushdown on those columns.
EXPLAIN (ANALYZE, DIST, COSTS OFF) UPDATE t1_gen SET v1 = v1 + 1 WHERE k = 1;
                              QUERY PLAN
----------------------------------------------------------------------
 Update on t1_gen (actual rows=0 loops=1)
   ->  Index Scan using t1_gen_pkey on t1_gen (actual rows=1 loops=1)
         Index Cond: (k = 1)
         Storage Table Read Requests: 1
         Storage Table Rows Scanned: 1
         Storage Table Write Requests: 1
 Storage Read Requests: 1
 Storage Rows Scanned: 1
 Storage Write Requests: 1
 Storage Flush Requests: 1
(10 rows)

EXPLAIN (ANALYZE, DIST, COSTS OFF) UPDATE t1_gen SET v2 = 2 WHERE k = 1;
                              QUERY PLAN
----------------------------------------------------------------------
 Update on t1_gen (actual rows=0 loops=1)
   ->  Index Scan using t1_gen_pkey on t1_gen (actual rows=1 loops=1)
         Index Cond: (k = 1)
         Storage Table Read Requests: 1
         Storage Table Rows Scanned: 1
         Storage Table Write Requests: 1
 Storage Read Requests: 1
 Storage Rows Scanned: 1
 Storage Write Requests: 1
 Storage Flush Requests: 1
(10 rows)

EXPLAIN (ANALYZE, DIST, COSTS OFF) UPDATE t1_gen SET v1 = v2 + 1, v2 = v1 + 1 WHERE k = 2;
                              QUERY PLAN
----------------------------------------------------------------------
 Update on t1_gen (actual rows=0 loops=1)
   ->  Index Scan using t1_gen_pkey on t1_gen (actual rows=1 loops=1)
         Index Cond: (k = 2)
         Storage Table Read Requests: 1
         Storage Table Rows Scanned: 1
         Storage Table Write Requests: 1
 Storage Read Requests: 1
 Storage Rows Scanned: 1
 Storage Write Requests: 1
 Storage Flush Requests: 1
(10 rows)

EXPLAIN (ANALYZE, DIST, COSTS OFF) UPDATE t1_gen SET v3 = 2 WHERE k = 2;
                QUERY PLAN
------------------------------------------
 Update on t1_gen (actual rows=0 loops=1)
   ->  Result (actual rows=1 loops=1)
         Storage Table Write Requests: 1
 Storage Read Requests: 0
 Storage Rows Scanned: 0
 Storage Write Requests: 1
 Storage Flush Requests: 0
(7 rows)

SELECT * FROM t1_gen WHERE k IN (1, 2) ORDER BY k;
 k | k_gen  | v1 | v2 | v3 | v1_v2_gen
---+--------+----+----+----+-----------
 1 | Text 1 |  2 |  2 |    |         4
 2 | Text 2 |  3 |  3 |  2 |         6
(2 rows)

CREATE INDEX NONCONCURRENTLY t1_gen_v1_v2_gen ON t1_gen (v1_v2_gen);
CREATE INDEX NONCONCURRENTLY ON t1_gen (k_gen) WHERE k < 100;
EXPLAIN (ANALYZE, DIST, COSTS OFF) UPDATE t1_gen SET v1 = v2 + 1, v2 = v1 + 1 WHERE k = 3;
                              QUERY PLAN
----------------------------------------------------------------------
 Update on t1_gen (actual rows=0 loops=1)
   ->  Index Scan using t1_gen_pkey on t1_gen (actual rows=1 loops=1)
         Index Cond: (k = 3)
         Storage Table Read Requests: 1
         Storage Table Rows Scanned: 1
         Storage Table Write Requests: 1
         Storage Index Write Requests: 2
 Storage Read Requests: 1
 Storage Rows Scanned: 1
 Storage Write Requests: 3
 Storage Flush Requests: 1
(11 rows)

EXPLAIN (ANALYZE, DIST, COSTS OFF) UPDATE t1_gen SET v1 = v2, v3 = v3 + 1 WHERE k = 4;
                              QUERY PLAN
----------------------------------------------------------------------
 Update on t1_gen (actual rows=0 loops=1)
   ->  Index Scan using t1_gen_pkey on t1_gen (actual rows=1 loops=1)
         Index Cond: (k = 4)
         Storage Table Read Requests: 1
         Storage Table Rows Scanned: 1
         Storage Table Write Requests: 1
 Storage Read Requests: 1
 Storage Rows Scanned: 1
 Storage Write Requests: 1
 Storage Flush Requests: 1
(10 rows)

EXPLAIN (ANALYZE, DIST, COSTS OFF) UPDATE t1_gen SET v1 = k + 1 WHERE k = 5;
                              QUERY PLAN
----------------------------------------------------------------------
 Update on t1_gen (actual rows=0 loops=1)
   ->  Index Scan using t1_gen_pkey on t1_gen (actual rows=1 loops=1)
         Index Cond: (k = 5)
         Storage Table Read Requests: 1
         Storage Table Rows Scanned: 1
         Storage Table Write Requests: 1
         Storage Index Write Requests: 2
 Storage Read Requests: 1
 Storage Rows Scanned: 1
 Storage Write Requests: 3
 Storage Flush Requests: 1
(11 rows)

EXPLAIN (ANALYZE, DIST, COSTS OFF) UPDATE t1_gen SET k = k + 10 WHERE k = 6;
                              QUERY PLAN
----------------------------------------------------------------------
 Update on t1_gen (actual rows=0 loops=1)
   ->  Index Scan using t1_gen_pkey on t1_gen (actual rows=1 loops=1)
         Index Cond: (k = 6)
         Storage Table Read Requests: 1
         Storage Table Rows Scanned: 1
         Storage Table Write Requests: 2
         Storage Index Write Requests: 4
 Storage Read Requests: 1
 Storage Rows Scanned: 1
 Storage Write Requests: 6
 Storage Flush Requests: 1
(11 rows)

EXPLAIN (ANALYZE, DIST, COSTS OFF) UPDATE t1_gen SET k = k + 10, v1 = v1 + 5, v2 = v2 + 5 WHERE k = 7;
                              QUERY PLAN
----------------------------------------------------------------------
 Update on t1_gen (actual rows=0 loops=1)
   ->  Index Scan using t1_gen_pkey on t1_gen (actual rows=1 loops=1)
         Index Cond: (k = 7)
         Storage Table Read Requests: 1
         Storage Table Rows Scanned: 1
         Storage Table Write Requests: 2
         Storage Index Write Requests: 4
 Storage Read Requests: 1
 Storage Rows Scanned: 1
 Storage Write Requests: 6
 Storage Flush Requests: 1
(11 rows)

SELECT * FROM t1_gen ORDER BY k;
 k  |  k_gen  | v1 | v2 | v3 | v1_v2_gen
----+---------+----+----+----+-----------
  1 | Text 1  |  2 |  2 |    |         4
  2 | Text 2  |  3 |  3 |  2 |         6
  3 | Text 3  |  4 |  4 |    |         8
  4 | Text 4  |  4 |  4 |    |         8
  5 | Text 5  |  6 |  5 |    |        11
  8 | Text 8  |  8 |  8 |    |        16
  9 | Text 9  |  9 |  9 |    |        18
 10 | Text 10 | 10 | 10 |    |        20
 16 | Text 16 |  6 |  6 |    |        12
 17 | Text 17 | 12 | 12 |    |        24
(10 rows)

-- Generated columns should work well with BEFORE UPDATE triggers.
CREATE OR REPLACE FUNCTION increment_v1() RETURNS TRIGGER
LANGUAGE PLPGSQL AS $$
BEGIN
  NEW.v1 = NEW.v1 + 1;
  RETURN NEW;
END;
$$;
CREATE OR REPLACE FUNCTION increment_v2() RETURNS TRIGGER
LANGUAGE PLPGSQL AS $$
BEGIN
  NEW.v2 = NEW.v2 + 1;
  RETURN NEW;
END;
$$;
-- Naming convention: zz_ prefix to ensure that the function is executed last.
CREATE OR REPLACE FUNCTION zz_gen_col_notice() RETURNS TRIGGER
LANGUAGE PLPGSQL AS $$
BEGIN
  RAISE NOTICE '% ROW trigger on generated column invoked', TG_argv[0];
  RETURN NEW;
END;
$$;
CREATE TRIGGER t1_gen_v1_trigger BEFORE UPDATE ON t1_gen FOR EACH ROW EXECUTE FUNCTION increment_v1();
BEGIN;
EXPLAIN (ANALYZE, DIST, COSTS OFF) UPDATE t1_gen SET v3 = v3 + 1 WHERE k = 8;
                              QUERY PLAN
----------------------------------------------------------------------
 Update on t1_gen (actual rows=0 loops=1)
   ->  Index Scan using t1_gen_pkey on t1_gen (actual rows=1 loops=1)
         Index Cond: (k = 8)
         Storage Table Read Requests: 1
         Storage Table Rows Scanned: 1
         Storage Table Write Requests: 1
         Storage Index Write Requests: 2
 Trigger t1_gen_v1_trigger: calls=1
 Storage Read Requests: 1
 Storage Rows Scanned: 1
 Storage Write Requests: 3
 Storage Flush Requests: 1
(12 rows)

EXPLAIN (ANALYZE, DIST, COSTS OFF) UPDATE t1_gen SET v1 = v1 + 1, v2 = v2 + 1 WHERE k = 9;
                              QUERY PLAN
----------------------------------------------------------------------
 Update on t1_gen (actual rows=0 loops=1)
   ->  Index Scan using t1_gen_pkey on t1_gen (actual rows=1 loops=1)
         Index Cond: (k = 9)
         Storage Table Read Requests: 1
         Storage Table Rows Scanned: 1
         Storage Table Write Requests: 1
         Storage Index Write Requests: 2
 Trigger t1_gen_v1_trigger: calls=1
 Storage Read Requests: 1
 Storage Rows Scanned: 1
 Storage Write Requests: 3
 Storage Flush Requests: 1
(12 rows)

SELECT * FROM t1_gen WHERE k > 7 ORDER BY k;
 k  |  k_gen  | v1 | v2 | v3 | v1_v2_gen
----+---------+----+----+----+-----------
  8 | Text 8  |  9 |  8 |    |        17
  9 | Text 9  | 11 | 10 |    |        21
 10 | Text 10 | 10 | 10 |    |        20
 16 | Text 16 |  6 |  6 |    |        12
 17 | Text 17 | 12 | 12 |    |        24
(5 rows)

ROLLBACK;
-- Chaining of triggers with generated columns involved.
CREATE TRIGGER t1_gen_v2_trigger BEFORE UPDATE OF v2 ON t1_gen FOR EACH ROW EXECUTE FUNCTION increment_v2();
BEGIN;
EXPLAIN (ANALYZE, DIST, COSTS OFF) UPDATE t1_gen SET v2 = v2, v3 = v3 + 1 WHERE k = 8;
                              QUERY PLAN
----------------------------------------------------------------------
 Update on t1_gen (actual rows=0 loops=1)
   ->  Index Scan using t1_gen_pkey on t1_gen (actual rows=1 loops=1)
         Index Cond: (k = 8)
         Storage Table Read Requests: 1
         Storage Table Rows Scanned: 1
         Storage Table Write Requests: 1
         Storage Index Write Requests: 2
 Trigger t1_gen_v1_trigger: calls=1
 Trigger t1_gen_v2_trigger: calls=1
 Storage Read Requests: 1
 Storage Rows Scanned: 1
 Storage Write Requests: 3
 Storage Flush Requests: 1
(13 rows)

EXPLAIN (ANALYZE, DIST, COSTS OFF) UPDATE t1_gen SET v1 = v1 + 1, v2 = v2 + 1 WHERE k = 9;
                              QUERY PLAN
----------------------------------------------------------------------
 Update on t1_gen (actual rows=0 loops=1)
   ->  Index Scan using t1_gen_pkey on t1_gen (actual rows=1 loops=1)
         Index Cond: (k = 9)
         Storage Table Read Requests: 1
         Storage Table Rows Scanned: 1
         Storage Table Write Requests: 1
         Storage Index Write Requests: 2
 Trigger t1_gen_v1_trigger: calls=1
 Trigger t1_gen_v2_trigger: calls=1
 Storage Read Requests: 1
 Storage Rows Scanned: 1
 Storage Write Requests: 3
 Storage Flush Requests: 1
(13 rows)

SELECT * FROM t1_gen WHERE k > 7 ORDER BY k;
 k  |  k_gen  | v1 | v2 | v3 | v1_v2_gen
----+---------+----+----+----+-----------
  8 | Text 8  |  9 |  9 |    |        18
  9 | Text 9  | 11 | 11 |    |        22
 10 | Text 10 | 10 | 10 |    |        20
 16 | Text 16 |  6 |  6 |    |        12
 17 | Text 17 | 12 | 12 |    |        24
(5 rows)

ROLLBACK;
-- Triggers should fire on generated columns.
CREATE TRIGGER t1_gen_before_gen BEFORE UPDATE OF v1_v2_gen ON t1_gen FOR EACH ROW EXECUTE FUNCTION zz_gen_col_notice('BEFORE');
CREATE TRIGGER t1_gen_after_gen AFTER UPDATE OF v1_v2_gen ON t1_gen FOR EACH ROW EXECUTE FUNCTION zz_gen_col_notice('AFTER');
EXPLAIN (ANALYZE, DIST, COSTS OFF) UPDATE t1_gen SET v3 = v3 + 1 WHERE k = 10;
NOTICE:  BEFORE ROW trigger on generated column invoked
NOTICE:  AFTER ROW trigger on generated column invoked
                              QUERY PLAN
----------------------------------------------------------------------
 Update on t1_gen (actual rows=0 loops=1)
   ->  Index Scan using t1_gen_pkey on t1_gen (actual rows=1 loops=1)
         Index Cond: (k = 10)
         Storage Table Read Requests: 1
         Storage Table Rows Scanned: 1
         Storage Table Write Requests: 1
         Storage Index Write Requests: 2
 Trigger t1_gen_after_gen: calls=1
 Trigger t1_gen_before_gen: calls=1
 Trigger t1_gen_v1_trigger: calls=1
 Storage Read Requests: 1
 Storage Rows Scanned: 1
 Storage Write Requests: 3
 Storage Flush Requests: 1
(14 rows)

SELECT * FROM t1_gen WHERE k > 7 ORDER BY k;
 k  |  k_gen  | v1 | v2 | v3 | v1_v2_gen
----+---------+----+----+----+-----------
  8 | Text 8  |  8 |  8 |    |        16
  9 | Text 9  |  9 |  9 |    |        18
 10 | Text 10 | 11 | 10 |    |        21
 16 | Text 16 |  6 |  6 |    |        12
 17 | Text 17 | 12 | 12 |    |        24
(5 rows)
