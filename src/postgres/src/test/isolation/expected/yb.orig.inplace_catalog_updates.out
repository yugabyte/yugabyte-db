Parsed test spec with 3 sessions

starting permutation: s3_check_relhasindex s1_begin_rr s2_begin_rr s1_create_index_test1 s2_grant_del_test1 s1_commit s2_commit s3_check_relhasindex s3_check_relacl
step s3_check_relhasindex: SELECT relname, relhasindex FROM pg_class WHERE relname = 'test1';
relname|relhasindex
-------+-----------
test1  |f          
(1 row)

step s1_begin_rr: BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
step s2_begin_rr: BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
step s1_create_index_test1: CREATE INDEX NONCONCURRENTLY idx_test11 ON test1(v);
step s2_grant_del_test1: GRANT DELETE ON TABLE test1 TO role3;
ERROR:  could not serialize access due to concurrent update
step s1_commit: COMMIT;
step s2_commit: COMMIT;
step s3_check_relhasindex: SELECT relname, relhasindex FROM pg_class WHERE relname = 'test1';
relname|relhasindex
-------+-----------
test1  |t          
(1 row)

step s3_check_relacl: SELECT relname, relacl FROM pg_class WHERE relname = 'test1';
relname|relacl
-------+------
test1  |      
(1 row)


starting permutation: s3_check_relhasindex s2_begin_rr s1_begin_rr s2_grant_del_test1 s1_create_index_test1 s1_commit s2_commit s3_check_relhasindex s3_check_relacl
step s3_check_relhasindex: SELECT relname, relhasindex FROM pg_class WHERE relname = 'test1';
relname|relhasindex
-------+-----------
test1  |f          
(1 row)

step s2_begin_rr: BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
step s1_begin_rr: BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
step s2_grant_del_test1: GRANT DELETE ON TABLE test1 TO role3;
step s1_create_index_test1: CREATE INDEX NONCONCURRENTLY idx_test11 ON test1(v);
ERROR:  could not serialize access due to concurrent update
step s1_commit: COMMIT;
step s2_commit: COMMIT;
step s3_check_relhasindex: SELECT relname, relhasindex FROM pg_class WHERE relname = 'test1';
relname|relhasindex
-------+-----------
test1  |f          
(1 row)

step s3_check_relacl: SELECT relname, relacl FROM pg_class WHERE relname = 'test1';
relname|relacl                                      
-------+--------------------------------------------
test1  |{yugabyte=arwdDxt/yugabyte,role3=d/yugabyte}
(1 row)


starting permutation: s3_check_relhasindex s1_begin_rr s2_begin_rr s1_create_index_test1 s2_create_index_test1 s1_commit s2_commit s3_check_relhasindex s3_show_pg_index
step s3_check_relhasindex: SELECT relname, relhasindex FROM pg_class WHERE relname = 'test1';
relname|relhasindex
-------+-----------
test1  |f          
(1 row)

step s1_begin_rr: BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
step s2_begin_rr: BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
step s1_create_index_test1: CREATE INDEX NONCONCURRENTLY idx_test11 ON test1(v);
step s2_create_index_test1: CREATE INDEX NONCONCURRENTLY idx_test21 ON test1(v);
ERROR:  could not serialize access due to concurrent update
step s1_commit: COMMIT;
step s2_commit: COMMIT;
step s3_check_relhasindex: SELECT relname, relhasindex FROM pg_class WHERE relname = 'test1';
relname|relhasindex
-------+-----------
test1  |t          
(1 row)

step s3_show_pg_index: SELECT indexrelid::regclass, indrelid::regclass, indisvalid, indisready FROM pg_index WHERE indrelid = 'test1'::regclass ORDER BY indexrelid::regclass::text;
indexrelid|indrelid|indisvalid|indisready
----------+--------+----------+----------
idx_test11|test1   |t         |t         
(1 row)


starting permutation: s3_add_pkey_test1 s3_check_relhasindex s1_begin_rr s2_begin_rr s1_create_index_test1 s2_create_index_test1 s1_commit s2_commit s3_check_relhasindex s3_show_pg_index
step s3_add_pkey_test1: ALTER TABLE test1 ADD PRIMARY KEY (k);
step s3_check_relhasindex: SELECT relname, relhasindex FROM pg_class WHERE relname = 'test1';
relname|relhasindex
-------+-----------
test1  |t          
(1 row)

step s1_begin_rr: BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
step s2_begin_rr: BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
step s1_create_index_test1: CREATE INDEX NONCONCURRENTLY idx_test11 ON test1(v);
step s2_create_index_test1: CREATE INDEX NONCONCURRENTLY idx_test21 ON test1(v);
step s1_commit: COMMIT;
step s2_commit: COMMIT;
step s3_check_relhasindex: SELECT relname, relhasindex FROM pg_class WHERE relname = 'test1';
relname|relhasindex
-------+-----------
test1  |t          
(1 row)

step s3_show_pg_index: SELECT indexrelid::regclass, indrelid::regclass, indisvalid, indisready FROM pg_index WHERE indrelid = 'test1'::regclass ORDER BY indexrelid::regclass::text;
indexrelid|indrelid|indisvalid|indisready
----------+--------+----------+----------
idx_test11|test1   |t         |t         
idx_test21|test1   |t         |t         
test1_pkey|test1   |t         |t         
(3 rows)


starting permutation: s1_begin_rr s2_begin_rr s1_alter_table_test1_add_col_rewrite s2_alter_table_test2_add_col_rewrite s1_commit s2_commit s3_check_pgattr_test1 s3_check_pgattr_test2
step s1_begin_rr: BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
step s2_begin_rr: BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
step s1_alter_table_test1_add_col_rewrite: ALTER TABLE test1 ADD COLUMN t1_a INT default random();
step s2_alter_table_test2_add_col_rewrite: ALTER TABLE test2 ADD COLUMN t2_a INT default random();
step s1_commit: COMMIT;
step s2_commit: COMMIT;
step s3_check_pgattr_test1: SELECT attname, attnum, atttypid FROM pg_attribute WHERE attrelid = 'test1'::regclass::oid and attnum > 0 ORDER BY attnum ASC;
attname|attnum|atttypid
-------+------+--------
k      |     1|      23
v      |     2|      23
t1_a   |     3|      23
(3 rows)

step s3_check_pgattr_test2: SELECT attname, attnum, atttypid FROM pg_attribute WHERE attrelid = 'test2'::regclass::oid and attnum > 0 ORDER BY attnum ASC;
attname|attnum|atttypid
-------+------+--------
k      |     1|      23
v      |     2|      23
t2_a   |     3|      23
(3 rows)


starting permutation: s1_begin_rr s2_begin_rr s1_alter_table_test1_add_col_rewrite s2_grant_ins_test1 s1_commit s2_commit s3_check_relacl s3_check_pgattr_test1
step s1_begin_rr: BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
step s2_begin_rr: BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
step s1_alter_table_test1_add_col_rewrite: ALTER TABLE test1 ADD COLUMN t1_a INT default random();
step s2_grant_ins_test1: GRANT INSERT ON TABLE test1 TO role3;
ERROR:  could not serialize access due to concurrent update
step s1_commit: COMMIT;
step s2_commit: COMMIT;
step s3_check_relacl: SELECT relname, relacl FROM pg_class WHERE relname = 'test1';
relname|relacl
-------+------
test1  |      
(1 row)

step s3_check_pgattr_test1: SELECT attname, attnum, atttypid FROM pg_attribute WHERE attrelid = 'test1'::regclass::oid and attnum > 0 ORDER BY attnum ASC;
attname|attnum|atttypid
-------+------+--------
k      |     1|      23
v      |     2|      23
t1_a   |     3|      23
(3 rows)


starting permutation: s1_begin_rr s2_begin_rr s1_grant_test1 s2_grant_upd_test1 s1_commit s2_commit s3_check_relacl
step s1_begin_rr: BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
step s2_begin_rr: BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
step s1_grant_test1: GRANT SELECT ON TABLE test1 TO role2;
step s2_grant_upd_test1: GRANT UPDATE ON TABLE test1 TO role3;
ERROR:  could not serialize access due to concurrent update
step s1_commit: COMMIT;
step s2_commit: COMMIT;
step s3_check_relacl: SELECT relname, relacl FROM pg_class WHERE relname = 'test1';
relname|relacl                                      
-------+--------------------------------------------
test1  |{yugabyte=arwdDxt/yugabyte,role2=r/yugabyte}
(1 row)

