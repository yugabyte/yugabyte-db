Parsed test spec with 2 sessions

starting permutation: merge1 c1 select2 c2
step merge1: 
  MERGE INTO target t
  USING (SELECT 1 as key, 'merge1' as val) s
  ON s.key = t.key
  WHEN NOT MATCHED THEN
	INSERT VALUES (s.key, s.val)
  WHEN MATCHED THEN
    UPDATE set key = t.key + 1, val = t.val || ' updated by ' || s.val;

step c1: COMMIT;
step select2: SELECT * FROM target;
key|val                     
---+------------------------
  2|setup1 updated by merge1
(1 row)

step c2: COMMIT;

starting permutation: merge1 c1 merge2a select2 c2
step merge1: 
  MERGE INTO target t
  USING (SELECT 1 as key, 'merge1' as val) s
  ON s.key = t.key
  WHEN NOT MATCHED THEN
	INSERT VALUES (s.key, s.val)
  WHEN MATCHED THEN
    UPDATE set key = t.key + 1, val = t.val || ' updated by ' || s.val;

step c1: COMMIT;
step merge2a: 
  MERGE INTO target t
  USING (SELECT 1 as key, 'merge2a' as val) s
  ON s.key = t.key
  WHEN NOT MATCHED THEN
	INSERT VALUES (s.key, s.val)
  WHEN MATCHED THEN
	UPDATE set key = t.key + 1, val = t.val || ' updated by ' || s.val;

step select2: SELECT * FROM target;
key|val                     
---+------------------------
  2|setup1 updated by merge1
  1|merge2a                 
(2 rows)

step c2: COMMIT;

starting permutation: merge1 merge2a c1 select2 c2
step merge1: 
  MERGE INTO target t
  USING (SELECT 1 as key, 'merge1' as val) s
  ON s.key = t.key
  WHEN NOT MATCHED THEN
	INSERT VALUES (s.key, s.val)
  WHEN MATCHED THEN
    UPDATE set key = t.key + 1, val = t.val || ' updated by ' || s.val;

step merge2a: 
  MERGE INTO target t
  USING (SELECT 1 as key, 'merge2a' as val) s
  ON s.key = t.key
  WHEN NOT MATCHED THEN
	INSERT VALUES (s.key, s.val)
  WHEN MATCHED THEN
	UPDATE set key = t.key + 1, val = t.val || ' updated by ' || s.val;
 <waiting ...>
step c1: COMMIT;
step merge2a: <... completed>
step select2: SELECT * FROM target;
key|val                     
---+------------------------
  2|setup1 updated by merge1
  1|merge2a                 
(2 rows)

step c2: COMMIT;

starting permutation: merge1 merge2a a1 select2 c2
step merge1: 
  MERGE INTO target t
  USING (SELECT 1 as key, 'merge1' as val) s
  ON s.key = t.key
  WHEN NOT MATCHED THEN
	INSERT VALUES (s.key, s.val)
  WHEN MATCHED THEN
    UPDATE set key = t.key + 1, val = t.val || ' updated by ' || s.val;

step merge2a: 
  MERGE INTO target t
  USING (SELECT 1 as key, 'merge2a' as val) s
  ON s.key = t.key
  WHEN NOT MATCHED THEN
	INSERT VALUES (s.key, s.val)
  WHEN MATCHED THEN
	UPDATE set key = t.key + 1, val = t.val || ' updated by ' || s.val;
 <waiting ...>
step a1: ABORT;
step merge2a: <... completed>
step select2: SELECT * FROM target;
key|val                      
---+-------------------------
  2|setup1 updated by merge2a
(1 row)

step c2: COMMIT;

starting permutation: merge1 merge2b c1 select2 c2
step merge1: 
  MERGE INTO target t
  USING (SELECT 1 as key, 'merge1' as val) s
  ON s.key = t.key
  WHEN NOT MATCHED THEN
	INSERT VALUES (s.key, s.val)
  WHEN MATCHED THEN
    UPDATE set key = t.key + 1, val = t.val || ' updated by ' || s.val;

step merge2b: 
  MERGE INTO target t
  USING (SELECT 1 as key, 'merge2b' as val) s
  ON s.key = t.key
  WHEN NOT MATCHED THEN
	INSERT VALUES (s.key, s.val)
  WHEN MATCHED AND t.key < 2 THEN
	UPDATE set key = t.key + 1, val = t.val || ' updated by ' || s.val;
 <waiting ...>
step c1: COMMIT;
step merge2b: <... completed>
step select2: SELECT * FROM target;
key|val                     
---+------------------------
  2|setup1 updated by merge1
  1|merge2b                 
(2 rows)

step c2: COMMIT;

starting permutation: merge1 merge2c c1 select2 c2
step merge1: 
  MERGE INTO target t
  USING (SELECT 1 as key, 'merge1' as val) s
  ON s.key = t.key
  WHEN NOT MATCHED THEN
	INSERT VALUES (s.key, s.val)
  WHEN MATCHED THEN
    UPDATE set key = t.key + 1, val = t.val || ' updated by ' || s.val;

step merge2c: 
  MERGE INTO target t
  USING (SELECT 1 as key, 'merge2c' as val) s
  ON s.key = t.key AND t.key < 2
  WHEN NOT MATCHED THEN
	INSERT VALUES (s.key, s.val)
  WHEN MATCHED THEN
	UPDATE set key = t.key + 1, val = t.val || ' updated by ' || s.val;
 <waiting ...>
step c1: COMMIT;
step merge2c: <... completed>
step select2: SELECT * FROM target;
key|val                     
---+------------------------
  2|setup1 updated by merge1
  1|merge2c                 
(2 rows)

step c2: COMMIT;

starting permutation: pa_merge1 pa_merge2a c1 pa_select2 c2
step pa_merge1: 
  MERGE INTO pa_target t
  USING (SELECT 1 as key, 'pa_merge1' as val) s
  ON s.key = t.key
  WHEN NOT MATCHED THEN
	INSERT VALUES (s.key, s.val)
  WHEN MATCHED THEN
    UPDATE set val = t.val || ' updated by ' || s.val;

step pa_merge2a: 
  MERGE INTO pa_target t
  USING (SELECT 1 as key, 'pa_merge2a' as val) s
  ON s.key = t.key
  WHEN NOT MATCHED THEN
	INSERT VALUES (s.key, s.val)
  WHEN MATCHED THEN
	UPDATE set key = t.key + 1, val = t.val || ' updated by ' || s.val;
 <waiting ...>
step c1: COMMIT;
step pa_merge2a: <... completed>
step pa_select2: SELECT * FROM pa_target;
key|val                                               
---+--------------------------------------------------
  2|initial                                           
  2|initial updated by pa_merge1 updated by pa_merge2a
(2 rows)

step c2: COMMIT;

starting permutation: pa_merge2 pa_merge2a c1 pa_select2 c2
step pa_merge2: 
  MERGE INTO pa_target t
  USING (SELECT 1 as key, 'pa_merge2' as val) s
  ON s.key = t.key
  WHEN NOT MATCHED THEN
	INSERT VALUES (s.key, s.val)
  WHEN MATCHED THEN
    UPDATE set key = t.key + 1, val = t.val || ' updated by ' || s.val;

step pa_merge2a: 
  MERGE INTO pa_target t
  USING (SELECT 1 as key, 'pa_merge2a' as val) s
  ON s.key = t.key
  WHEN NOT MATCHED THEN
	INSERT VALUES (s.key, s.val)
  WHEN MATCHED THEN
	UPDATE set key = t.key + 1, val = t.val || ' updated by ' || s.val;
 <waiting ...>
step c1: COMMIT;
step pa_merge2a: <... completed>
ERROR:  tuple to be locked was already moved to another partition due to concurrent update
step pa_select2: SELECT * FROM pa_target;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
step c2: COMMIT;

starting permutation: pa_merge2 c1 pa_merge2a pa_select2 c2
step pa_merge2: 
  MERGE INTO pa_target t
  USING (SELECT 1 as key, 'pa_merge2' as val) s
  ON s.key = t.key
  WHEN NOT MATCHED THEN
	INSERT VALUES (s.key, s.val)
  WHEN MATCHED THEN
    UPDATE set key = t.key + 1, val = t.val || ' updated by ' || s.val;

step c1: COMMIT;
step pa_merge2a: 
  MERGE INTO pa_target t
  USING (SELECT 1 as key, 'pa_merge2a' as val) s
  ON s.key = t.key
  WHEN NOT MATCHED THEN
	INSERT VALUES (s.key, s.val)
  WHEN MATCHED THEN
	UPDATE set key = t.key + 1, val = t.val || ' updated by ' || s.val;

step pa_select2: SELECT * FROM pa_target;
key|val                         
---+----------------------------
  1|pa_merge2a                  
  2|initial                     
  2|initial updated by pa_merge2
(3 rows)

step c2: COMMIT;

starting permutation: pa_merge3 pa_merge2b_when c1 pa_select2 c2
step pa_merge3: 
  MERGE INTO pa_target t
  USING (SELECT 1 as key, 'pa_merge2' as val) s
  ON s.key = t.key
  WHEN NOT MATCHED THEN
	INSERT VALUES (s.key, s.val)
  WHEN MATCHED THEN
    UPDATE set val = 'prefix ' || t.val;

step pa_merge2b_when: 
  MERGE INTO pa_target t
  USING (SELECT 1 as key, 'pa_merge2b_when' as val) s
  ON s.key = t.key
  WHEN NOT MATCHED THEN
	INSERT VALUES (s.key, s.val)
  WHEN MATCHED AND t.val like 'initial%' THEN
	UPDATE set key = t.key + 1, val = t.val || ' updated by ' || s.val;
 <waiting ...>
step c1: COMMIT;
step pa_merge2b_when: <... completed>
step pa_select2: SELECT * FROM pa_target;
key|val           
---+--------------
  1|prefix initial
  2|initial       
(2 rows)

step c2: COMMIT;

starting permutation: pa_merge1 pa_merge2b_when c1 pa_select2 c2
step pa_merge1: 
  MERGE INTO pa_target t
  USING (SELECT 1 as key, 'pa_merge1' as val) s
  ON s.key = t.key
  WHEN NOT MATCHED THEN
	INSERT VALUES (s.key, s.val)
  WHEN MATCHED THEN
    UPDATE set val = t.val || ' updated by ' || s.val;

step pa_merge2b_when: 
  MERGE INTO pa_target t
  USING (SELECT 1 as key, 'pa_merge2b_when' as val) s
  ON s.key = t.key
  WHEN NOT MATCHED THEN
	INSERT VALUES (s.key, s.val)
  WHEN MATCHED AND t.val like 'initial%' THEN
	UPDATE set key = t.key + 1, val = t.val || ' updated by ' || s.val;
 <waiting ...>
step c1: COMMIT;
step pa_merge2b_when: <... completed>
step pa_select2: SELECT * FROM pa_target;
key|val                                                    
---+-------------------------------------------------------
  2|initial                                                
  2|initial updated by pa_merge1 updated by pa_merge2b_when
(2 rows)

step c2: COMMIT;
