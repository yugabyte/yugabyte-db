Parsed test spec with 2 sessions

starting permutation: s1_update s2_update s1_commit s2_commit s1_pgss_filter_retries
step s1_update: UPDATE test SET v=20 WHERE k=1;
step s2_update: UPDATE test SET v=40 WHERE k=1; <waiting ...>
step s1_commit: COMMIT;
step s2_update: <... completed>
step s2_commit: COMMIT;
step s1_pgss_filter_retries: SELECT query, calls, rows FROM pg_stat_statements WHERE total_retries > 0;
query                          |calls|rows
-------------------------------+-----+----
UPDATE test SET v=$1 WHERE k=$2|    2|   2
(1 row)


starting permutation: s1_update s2_update s1_commit s2_commit s1_pgss_reset s1_update s1_pgss_filter_retries
step s1_update: UPDATE test SET v=20 WHERE k=1;
step s2_update: UPDATE test SET v=40 WHERE k=1; <waiting ...>
step s1_commit: COMMIT;
step s2_update: <... completed>
step s2_commit: COMMIT;
step s1_pgss_reset: SELECT pg_stat_statements_reset();
pg_stat_statements_reset
------------------------
                        
(1 row)

step s1_update: UPDATE test SET v=20 WHERE k=1;
step s1_pgss_filter_retries: SELECT query, calls, rows FROM pg_stat_statements WHERE total_retries > 0;
query|calls|rows
-----+-----+----
(0 rows)


starting permutation: s1_select_in_nonexistent_table s1_commit s1_update s1_pgss_filter_retries
step s1_select_in_nonexistent_table: SELECT * from nonexistent_table;
ERROR:  relation "nonexistent_table" does not exist
step s1_commit: COMMIT;
step s1_update: UPDATE test SET v=20 WHERE k=1;
step s1_pgss_filter_retries: SELECT query, calls, rows FROM pg_stat_statements WHERE total_retries > 0;
query|calls|rows
-----+-----+----
(0 rows)

