unused step name: s2_r
unused step name: s3_b_rc
unused step name: s3_c
unused step name: s3_del_a
unused step name: s3_r
unused step name: s3_upd_a_data
Parsed test spec with 4 sessions

starting permutation: s1_trig_rep_b_u s1_trig_rep_a_u s1_ins_a s1_ins_b s1_b_rc s2_b_rc s1_upd_a_data s1_c s2_upd_a_data s2_c s0_rep
step s1_trig_rep_b_u: CREATE TRIGGER rep_b_u BEFORE UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s1_ins_b: INSERT INTO trigtest VALUES ('key-b', 'val-b-s1') RETURNING *;
key  |data    
-----+--------
key-b|val-b-s1
(1 row)

step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upd: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
s1: NOTICE:  upd: text key-b = text key-a: f
s1: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
step s1_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups1'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;

key  |data         
-----+-------------
key-a|val-a-s1-ups1
(1 row)

step s1_c: COMMIT;
s2: NOTICE:  upd: text key-b = text key-a: f
s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1-ups1 <> text mismatch: t
s2: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1-ups1) new: (key-a,val-a-s1-ups1-ups2)
s2: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1-ups1) new: (key-a,val-a-s1-ups1-ups2)
step s2_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups2'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;

key  |data              
-----+------------------
key-a|val-a-s1-ups1-ups2
(1 row)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data              
-----+------------------
key-a|val-a-s1-ups1-ups2
key-b|val-b-s1          
(2 rows)


starting permutation: s1_trig_rep_b_u s1_trig_rep_a_u s1_ins_a s1_ins_b s1_b_rc s2_b_rc s1_upd_a_data s1_r s2_upd_a_data s2_c s0_rep
step s1_trig_rep_b_u: CREATE TRIGGER rep_b_u BEFORE UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s1_ins_b: INSERT INTO trigtest VALUES ('key-b', 'val-b-s1') RETURNING *;
key  |data    
-----+--------
key-b|val-b-s1
(1 row)

step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upd: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
s1: NOTICE:  upd: text key-b = text key-a: f
s1: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
step s1_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups1'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;

key  |data         
-----+-------------
key-a|val-a-s1-ups1
(1 row)

step s1_r: ROLLBACK;
s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s2: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups2)
s2: NOTICE:  upd: text key-b = text key-a: f
s2: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups2)
step s2_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups2'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;

key  |data         
-----+-------------
key-a|val-a-s1-ups2
(1 row)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data         
-----+-------------
key-a|val-a-s1-ups2
key-b|val-b-s1     
(2 rows)


starting permutation: s1_trig_rep_b_d s1_trig_rep_b_u s1_trig_rep_a_d s1_trig_rep_a_u s1_ins_a s1_ins_b s1_b_rc s2_b_rc s1_upd_a_data s1_c s2_del_a s2_c s0_rep
step s1_trig_rep_b_d: CREATE TRIGGER rep_b_d BEFORE DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_b_u: CREATE TRIGGER rep_b_u BEFORE UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_d: CREATE TRIGGER rep_a_d AFTER DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s1_ins_b: INSERT INTO trigtest VALUES ('key-b', 'val-b-s1') RETURNING *;
key  |data    
-----+--------
key-b|val-b-s1
(1 row)

step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upd: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
s1: NOTICE:  upd: text key-b = text key-a: f
s1: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
step s1_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups1'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;

key  |data         
-----+-------------
key-a|val-a-s1-ups1
(1 row)

step s1_c: COMMIT;
s2: NOTICE:  upd: text key-b = text key-a: f
s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1-ups1 <> text mismatch: t
s2: NOTICE:  trigger: name rep_b_d; when: BEFORE; lev: ROWs; op: DELETE; old: (key-a,val-a-s1-ups1) new: <NULL>
s2: NOTICE:  trigger: name rep_a_d; when: AFTER; lev: ROWs; op: DELETE; old: (key-a,val-a-s1-ups1) new: <NULL>
step s2_del_a: 
    DELETE FROM trigtest
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *

key  |data         
-----+-------------
key-a|val-a-s1-ups1
(1 row)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data    
-----+--------
key-b|val-b-s1
(1 row)


starting permutation: s1_trig_rep_b_d s1_trig_rep_b_u s1_trig_rep_a_d s1_trig_rep_a_u s1_ins_a s1_ins_b s1_b_rc s2_b_rc s1_upd_a_data s1_r s2_del_a s2_c s0_rep
step s1_trig_rep_b_d: CREATE TRIGGER rep_b_d BEFORE DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_b_u: CREATE TRIGGER rep_b_u BEFORE UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_d: CREATE TRIGGER rep_a_d AFTER DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s1_ins_b: INSERT INTO trigtest VALUES ('key-b', 'val-b-s1') RETURNING *;
key  |data    
-----+--------
key-b|val-b-s1
(1 row)

step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upd: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
s1: NOTICE:  upd: text key-b = text key-a: f
s1: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
step s1_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups1'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;

key  |data         
-----+-------------
key-a|val-a-s1-ups1
(1 row)

step s1_r: ROLLBACK;
s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s2: NOTICE:  trigger: name rep_b_d; when: BEFORE; lev: ROWs; op: DELETE; old: (key-a,val-a-s1) new: <NULL>
s2: NOTICE:  upd: text key-b = text key-a: f
s2: NOTICE:  trigger: name rep_a_d; when: AFTER; lev: ROWs; op: DELETE; old: (key-a,val-a-s1) new: <NULL>
step s2_del_a: 
    DELETE FROM trigtest
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *

key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data    
-----+--------
key-b|val-b-s1
(1 row)


starting permutation: s1_trig_rep_b_u s1_trig_rep_a_u s1_ins_a s1_ins_b s1_b_rc s2_b_rc s1_upd_a_data s2_upd_a_data s1_c s2_c s0_rep
step s1_trig_rep_b_u: CREATE TRIGGER rep_b_u BEFORE UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s1_ins_b: INSERT INTO trigtest VALUES ('key-b', 'val-b-s1') RETURNING *;
key  |data    
-----+--------
key-b|val-b-s1
(1 row)

step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upd: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
s1: NOTICE:  upd: text key-b = text key-a: f
s1: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
step s1_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups1'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;

key  |data         
-----+-------------
key-a|val-a-s1-ups1
(1 row)

s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1 <> text mismatch: t
step s2_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups2'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;
 <waiting ...>
step s1_c: COMMIT;
s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1-ups1 <> text mismatch: t
s2: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1-ups1) new: (key-a,val-a-s1-ups1-ups2)
s2: NOTICE:  upd: text key-b = text key-a: f
s2: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1-ups1) new: (key-a,val-a-s1-ups1-ups2)
step s2_upd_a_data: <... completed>
key  |data              
-----+------------------
key-a|val-a-s1-ups1-ups2
(1 row)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data              
-----+------------------
key-a|val-a-s1-ups1-ups2
key-b|val-b-s1          
(2 rows)


starting permutation: s1_trig_rep_b_u s1_trig_rep_a_u s1_ins_a s1_ins_b s1_b_rc s2_b_rc s1_upd_a_data s2_upd_a_data s1_r s2_c s0_rep
step s1_trig_rep_b_u: CREATE TRIGGER rep_b_u BEFORE UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s1_ins_b: INSERT INTO trigtest VALUES ('key-b', 'val-b-s1') RETURNING *;
key  |data    
-----+--------
key-b|val-b-s1
(1 row)

step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upd: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
s1: NOTICE:  upd: text key-b = text key-a: f
s1: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
step s1_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups1'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;

key  |data         
-----+-------------
key-a|val-a-s1-ups1
(1 row)

s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1 <> text mismatch: t
step s2_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups2'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;
 <waiting ...>
step s1_r: ROLLBACK;
s2: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups2)
s2: NOTICE:  upd: text key-b = text key-a: f
s2: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups2)
step s2_upd_a_data: <... completed>
key  |data         
-----+-------------
key-a|val-a-s1-ups2
(1 row)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data         
-----+-------------
key-a|val-a-s1-ups2
key-b|val-b-s1     
(2 rows)


starting permutation: s1_trig_rep_b_d s1_trig_rep_b_u s1_trig_rep_a_d s1_trig_rep_a_u s1_ins_a s1_ins_b s1_b_rc s2_b_rc s1_upd_a_data s2_upd_a_data s1_c s2_c s0_rep
step s1_trig_rep_b_d: CREATE TRIGGER rep_b_d BEFORE DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_b_u: CREATE TRIGGER rep_b_u BEFORE UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_d: CREATE TRIGGER rep_a_d AFTER DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s1_ins_b: INSERT INTO trigtest VALUES ('key-b', 'val-b-s1') RETURNING *;
key  |data    
-----+--------
key-b|val-b-s1
(1 row)

step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upd: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
s1: NOTICE:  upd: text key-b = text key-a: f
s1: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
step s1_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups1'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;

key  |data         
-----+-------------
key-a|val-a-s1-ups1
(1 row)

s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1 <> text mismatch: t
step s2_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups2'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;
 <waiting ...>
step s1_c: COMMIT;
s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1-ups1 <> text mismatch: t
s2: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1-ups1) new: (key-a,val-a-s1-ups1-ups2)
s2: NOTICE:  upd: text key-b = text key-a: f
s2: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1-ups1) new: (key-a,val-a-s1-ups1-ups2)
step s2_upd_a_data: <... completed>
key  |data              
-----+------------------
key-a|val-a-s1-ups1-ups2
(1 row)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data              
-----+------------------
key-a|val-a-s1-ups1-ups2
key-b|val-b-s1          
(2 rows)


starting permutation: s1_trig_rep_b_d s1_trig_rep_b_u s1_trig_rep_a_d s1_trig_rep_a_u s1_ins_a s1_ins_b s1_b_rc s2_b_rc s1_upd_a_data s2_upd_a_data s1_r s2_c s0_rep
step s1_trig_rep_b_d: CREATE TRIGGER rep_b_d BEFORE DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_b_u: CREATE TRIGGER rep_b_u BEFORE UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_d: CREATE TRIGGER rep_a_d AFTER DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s1_ins_b: INSERT INTO trigtest VALUES ('key-b', 'val-b-s1') RETURNING *;
key  |data    
-----+--------
key-b|val-b-s1
(1 row)

step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upd: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
s1: NOTICE:  upd: text key-b = text key-a: f
s1: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
step s1_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups1'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;

key  |data         
-----+-------------
key-a|val-a-s1-ups1
(1 row)

s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1 <> text mismatch: t
step s2_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups2'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;
 <waiting ...>
step s1_r: ROLLBACK;
s2: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups2)
s2: NOTICE:  upd: text key-b = text key-a: f
s2: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups2)
step s2_upd_a_data: <... completed>
key  |data         
-----+-------------
key-a|val-a-s1-ups2
(1 row)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data         
-----+-------------
key-a|val-a-s1-ups2
key-b|val-b-s1     
(2 rows)


starting permutation: s1_trig_rep_b_d s1_trig_rep_b_u s1_trig_rep_a_d s1_trig_rep_a_u s1_ins_a s1_ins_b s1_b_rc s2_b_rc s1_del_a s2_upd_a_data s1_c s2_c s0_rep
step s1_trig_rep_b_d: CREATE TRIGGER rep_b_d BEFORE DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_b_u: CREATE TRIGGER rep_b_u BEFORE UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_d: CREATE TRIGGER rep_a_d AFTER DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s1_ins_b: INSERT INTO trigtest VALUES ('key-b', 'val-b-s1') RETURNING *;
key  |data    
-----+--------
key-b|val-b-s1
(1 row)

step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upd: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  trigger: name rep_b_d; when: BEFORE; lev: ROWs; op: DELETE; old: (key-a,val-a-s1) new: <NULL>
s1: NOTICE:  upd: text key-b = text key-a: f
s1: NOTICE:  trigger: name rep_a_d; when: AFTER; lev: ROWs; op: DELETE; old: (key-a,val-a-s1) new: <NULL>
step s1_del_a: 
    DELETE FROM trigtest
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *

key  |data    
-----+--------
key-a|val-a-s1
(1 row)

s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1 <> text mismatch: t
step s2_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups2'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;
 <waiting ...>
step s1_c: COMMIT;
s2: NOTICE:  upd: text key-b = text key-a: f
step s2_upd_a_data: <... completed>
key|data
---+----
(0 rows)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data    
-----+--------
key-b|val-b-s1
(1 row)


starting permutation: s1_trig_rep_b_d s1_trig_rep_b_u s1_trig_rep_a_d s1_trig_rep_a_u s1_ins_a s1_ins_b s1_b_rc s2_b_rc s1_del_a s2_upd_a_data s1_r s2_c s0_rep
step s1_trig_rep_b_d: CREATE TRIGGER rep_b_d BEFORE DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_b_u: CREATE TRIGGER rep_b_u BEFORE UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_d: CREATE TRIGGER rep_a_d AFTER DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s1_ins_b: INSERT INTO trigtest VALUES ('key-b', 'val-b-s1') RETURNING *;
key  |data    
-----+--------
key-b|val-b-s1
(1 row)

step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upd: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  trigger: name rep_b_d; when: BEFORE; lev: ROWs; op: DELETE; old: (key-a,val-a-s1) new: <NULL>
s1: NOTICE:  upd: text key-b = text key-a: f
s1: NOTICE:  trigger: name rep_a_d; when: AFTER; lev: ROWs; op: DELETE; old: (key-a,val-a-s1) new: <NULL>
step s1_del_a: 
    DELETE FROM trigtest
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *

key  |data    
-----+--------
key-a|val-a-s1
(1 row)

s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1 <> text mismatch: t
step s2_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups2'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;
 <waiting ...>
step s1_r: ROLLBACK;
s2: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups2)
s2: NOTICE:  upd: text key-b = text key-a: f
s2: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups2)
step s2_upd_a_data: <... completed>
key  |data         
-----+-------------
key-a|val-a-s1-ups2
(1 row)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data         
-----+-------------
key-a|val-a-s1-ups2
key-b|val-b-s1     
(2 rows)


starting permutation: s1_trig_rep_b_i s1_trig_rep_b_d s1_trig_rep_a_i s1_trig_rep_a_d s1_b_rc s2_b_rc s1_ins_a s2_ins_a s1_c s2_c s0_rep
step s1_trig_rep_b_i: CREATE TRIGGER rep_b_i BEFORE INSERT ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_b_d: CREATE TRIGGER rep_b_d BEFORE DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_i: CREATE TRIGGER rep_a_i AFTER INSERT ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_d: CREATE TRIGGER rep_a_d AFTER DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  trigger: name rep_b_i; when: BEFORE; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-s1)
s1: NOTICE:  trigger: name rep_a_i; when: AFTER; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-s1)
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

s2: NOTICE:  trigger: name rep_b_i; when: BEFORE; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-s2)
step s2_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s2') RETURNING *; <waiting ...>
step s1_c: COMMIT;
step s2_ins_a: <... completed>
ERROR:  duplicate key value violates unique constraint "trigtest_pkey"
step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data    
-----+--------
key-a|val-a-s1
(1 row)


starting permutation: s1_trig_rep_b_i s1_trig_rep_b_d s1_trig_rep_a_i s1_trig_rep_a_d s1_b_rc s2_b_rc s1_ins_a s2_ins_a s1_r s2_c s0_rep
step s1_trig_rep_b_i: CREATE TRIGGER rep_b_i BEFORE INSERT ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_b_d: CREATE TRIGGER rep_b_d BEFORE DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_i: CREATE TRIGGER rep_a_i AFTER INSERT ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_d: CREATE TRIGGER rep_a_d AFTER DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  trigger: name rep_b_i; when: BEFORE; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-s1)
s1: NOTICE:  trigger: name rep_a_i; when: AFTER; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-s1)
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

s2: NOTICE:  trigger: name rep_b_i; when: BEFORE; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-s2)
step s2_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s2') RETURNING *; <waiting ...>
step s1_r: ROLLBACK;
s2: NOTICE:  trigger: name rep_a_i; when: AFTER; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-s2)
step s2_ins_a: <... completed>
key  |data    
-----+--------
key-a|val-a-s2
(1 row)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data    
-----+--------
key-a|val-a-s2
(1 row)


starting permutation: s1_trig_rep_b_i s1_trig_rep_b_d s1_trig_rep_b_u s1_trig_rep_a_i s1_trig_rep_a_d s1_trig_rep_a_u s1_ins_a s1_ins_b s1_b_rc s2_b_rc s1_upd_a_data s2_upsert_a_data s1_c s2_c s0_rep
step s1_trig_rep_b_i: CREATE TRIGGER rep_b_i BEFORE INSERT ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_b_d: CREATE TRIGGER rep_b_d BEFORE DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_b_u: CREATE TRIGGER rep_b_u BEFORE UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_i: CREATE TRIGGER rep_a_i AFTER INSERT ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_d: CREATE TRIGGER rep_a_d AFTER DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
s1: NOTICE:  trigger: name rep_b_i; when: BEFORE; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-s1)
s1: NOTICE:  trigger: name rep_a_i; when: AFTER; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-s1)
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

s1: NOTICE:  trigger: name rep_b_i; when: BEFORE; lev: ROWs; op: INSERT; old: <NULL> new: (key-b,val-b-s1)
s1: NOTICE:  trigger: name rep_a_i; when: AFTER; lev: ROWs; op: INSERT; old: <NULL> new: (key-b,val-b-s1)
step s1_ins_b: INSERT INTO trigtest VALUES ('key-b', 'val-b-s1') RETURNING *;
key  |data    
-----+--------
key-b|val-b-s1
(1 row)

step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upd: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
s1: NOTICE:  upd: text key-b = text key-a: f
s1: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
step s1_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups1'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;

key  |data         
-----+-------------
key-a|val-a-s1-ups1
(1 row)

s2: NOTICE:  trigger: name rep_b_i; when: BEFORE; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-upss2)
step s2_upsert_a_data: 
    INSERT INTO trigtest VALUES ('key-a', 'val-a-upss2')
    ON CONFLICT (key)
        DO UPDATE SET data = trigtest.data || '-upserts2'
        WHERE
            noisy_oper('upd', trigtest.key, '=', 'key-a') AND
            noisy_oper('upk', trigtest.data, '<>', 'mismatch')
    RETURNING *;
 <waiting ...>
step s1_c: COMMIT;
s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1-ups1 <> text mismatch: t
s2: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1-ups1) new: (key-a,val-a-s1-ups1-upserts2)
s2: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1-ups1) new: (key-a,val-a-s1-ups1-upserts2)
step s2_upsert_a_data: <... completed>
key  |data                  
-----+----------------------
key-a|val-a-s1-ups1-upserts2
(1 row)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data                  
-----+----------------------
key-a|val-a-s1-ups1-upserts2
key-b|val-b-s1              
(2 rows)


starting permutation: s1_trig_rep_b_i s1_trig_rep_b_d s1_trig_rep_b_u s1_trig_rep_a_i s1_trig_rep_a_d s1_trig_rep_a_u s1_ins_a s1_ins_b s1_b_rc s2_b_rc s1_upd_a_data s2_upsert_a_data s1_c s2_c s0_rep
step s1_trig_rep_b_i: CREATE TRIGGER rep_b_i BEFORE INSERT ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_b_d: CREATE TRIGGER rep_b_d BEFORE DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_b_u: CREATE TRIGGER rep_b_u BEFORE UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_i: CREATE TRIGGER rep_a_i AFTER INSERT ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_d: CREATE TRIGGER rep_a_d AFTER DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
s1: NOTICE:  trigger: name rep_b_i; when: BEFORE; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-s1)
s1: NOTICE:  trigger: name rep_a_i; when: AFTER; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-s1)
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

s1: NOTICE:  trigger: name rep_b_i; when: BEFORE; lev: ROWs; op: INSERT; old: <NULL> new: (key-b,val-b-s1)
s1: NOTICE:  trigger: name rep_a_i; when: AFTER; lev: ROWs; op: INSERT; old: <NULL> new: (key-b,val-b-s1)
step s1_ins_b: INSERT INTO trigtest VALUES ('key-b', 'val-b-s1') RETURNING *;
key  |data    
-----+--------
key-b|val-b-s1
(1 row)

step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upd: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
s1: NOTICE:  upd: text key-b = text key-a: f
s1: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
step s1_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups1'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;

key  |data         
-----+-------------
key-a|val-a-s1-ups1
(1 row)

s2: NOTICE:  trigger: name rep_b_i; when: BEFORE; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-upss2)
step s2_upsert_a_data: 
    INSERT INTO trigtest VALUES ('key-a', 'val-a-upss2')
    ON CONFLICT (key)
        DO UPDATE SET data = trigtest.data || '-upserts2'
        WHERE
            noisy_oper('upd', trigtest.key, '=', 'key-a') AND
            noisy_oper('upk', trigtest.data, '<>', 'mismatch')
    RETURNING *;
 <waiting ...>
step s1_c: COMMIT;
s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1-ups1 <> text mismatch: t
s2: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1-ups1) new: (key-a,val-a-s1-ups1-upserts2)
s2: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1-ups1) new: (key-a,val-a-s1-ups1-upserts2)
step s2_upsert_a_data: <... completed>
key  |data                  
-----+----------------------
key-a|val-a-s1-ups1-upserts2
(1 row)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data                  
-----+----------------------
key-a|val-a-s1-ups1-upserts2
key-b|val-b-s1              
(2 rows)


starting permutation: s1_trig_rep_b_i s1_trig_rep_b_d s1_trig_rep_b_u s1_trig_rep_a_i s1_trig_rep_a_d s1_trig_rep_a_u s1_b_rc s2_b_rc s1_ins_a s2_upsert_a_data s1_c s2_c s0_rep
step s1_trig_rep_b_i: CREATE TRIGGER rep_b_i BEFORE INSERT ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_b_d: CREATE TRIGGER rep_b_d BEFORE DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_b_u: CREATE TRIGGER rep_b_u BEFORE UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_i: CREATE TRIGGER rep_a_i AFTER INSERT ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_d: CREATE TRIGGER rep_a_d AFTER DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  trigger: name rep_b_i; when: BEFORE; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-s1)
s1: NOTICE:  trigger: name rep_a_i; when: AFTER; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-s1)
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

s2: NOTICE:  trigger: name rep_b_i; when: BEFORE; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-upss2)
step s2_upsert_a_data: 
    INSERT INTO trigtest VALUES ('key-a', 'val-a-upss2')
    ON CONFLICT (key)
        DO UPDATE SET data = trigtest.data || '-upserts2'
        WHERE
            noisy_oper('upd', trigtest.key, '=', 'key-a') AND
            noisy_oper('upk', trigtest.data, '<>', 'mismatch')
    RETURNING *;
 <waiting ...>
step s1_c: COMMIT;
s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s2: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-upserts2)
s2: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-upserts2)
step s2_upsert_a_data: <... completed>
key  |data             
-----+-----------------
key-a|val-a-s1-upserts2
(1 row)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data             
-----+-----------------
key-a|val-a-s1-upserts2
(1 row)


starting permutation: s1_trig_rep_b_i s1_trig_rep_b_d s1_trig_rep_b_u s1_trig_rep_a_i s1_trig_rep_a_d s1_trig_rep_a_u s1_b_rc s2_b_rc s1_ins_a s2_upsert_a_data s1_r s2_c s0_rep
step s1_trig_rep_b_i: CREATE TRIGGER rep_b_i BEFORE INSERT ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_b_d: CREATE TRIGGER rep_b_d BEFORE DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_b_u: CREATE TRIGGER rep_b_u BEFORE UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_i: CREATE TRIGGER rep_a_i AFTER INSERT ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_d: CREATE TRIGGER rep_a_d AFTER DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  trigger: name rep_b_i; when: BEFORE; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-s1)
s1: NOTICE:  trigger: name rep_a_i; when: AFTER; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-s1)
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

s2: NOTICE:  trigger: name rep_b_i; when: BEFORE; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-upss2)
step s2_upsert_a_data: 
    INSERT INTO trigtest VALUES ('key-a', 'val-a-upss2')
    ON CONFLICT (key)
        DO UPDATE SET data = trigtest.data || '-upserts2'
        WHERE
            noisy_oper('upd', trigtest.key, '=', 'key-a') AND
            noisy_oper('upk', trigtest.data, '<>', 'mismatch')
    RETURNING *;
 <waiting ...>
step s1_r: ROLLBACK;
s2: NOTICE:  trigger: name rep_a_i; when: AFTER; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-upss2)
step s2_upsert_a_data: <... completed>
key  |data       
-----+-----------
key-a|val-a-upss2
(1 row)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data       
-----+-----------
key-a|val-a-upss2
(1 row)


starting permutation: s1_trig_rep_b_i s1_trig_rep_b_d s1_trig_rep_b_u s1_trig_rep_a_i s1_trig_rep_a_d s1_trig_rep_a_u s1_b_rc s2_b_rc s1_ins_a s1_upd_a_data s2_upsert_a_data s1_c s2_c s0_rep
step s1_trig_rep_b_i: CREATE TRIGGER rep_b_i BEFORE INSERT ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_b_d: CREATE TRIGGER rep_b_d BEFORE DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_b_u: CREATE TRIGGER rep_b_u BEFORE UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_i: CREATE TRIGGER rep_a_i AFTER INSERT ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_d: CREATE TRIGGER rep_a_d AFTER DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  trigger: name rep_b_i; when: BEFORE; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-s1)
s1: NOTICE:  trigger: name rep_a_i; when: AFTER; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-s1)
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

s1: NOTICE:  upd: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
s1: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
step s1_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups1'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;

key  |data         
-----+-------------
key-a|val-a-s1-ups1
(1 row)

s2: NOTICE:  trigger: name rep_b_i; when: BEFORE; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-upss2)
step s2_upsert_a_data: 
    INSERT INTO trigtest VALUES ('key-a', 'val-a-upss2')
    ON CONFLICT (key)
        DO UPDATE SET data = trigtest.data || '-upserts2'
        WHERE
            noisy_oper('upd', trigtest.key, '=', 'key-a') AND
            noisy_oper('upk', trigtest.data, '<>', 'mismatch')
    RETURNING *;
 <waiting ...>
step s1_c: COMMIT;
s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1-ups1 <> text mismatch: t
s2: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1-ups1) new: (key-a,val-a-s1-ups1-upserts2)
s2: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1-ups1) new: (key-a,val-a-s1-ups1-upserts2)
step s2_upsert_a_data: <... completed>
key  |data                  
-----+----------------------
key-a|val-a-s1-ups1-upserts2
(1 row)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data                  
-----+----------------------
key-a|val-a-s1-ups1-upserts2
(1 row)


starting permutation: s1_trig_rep_b_i s1_trig_rep_b_d s1_trig_rep_b_u s1_trig_rep_a_i s1_trig_rep_a_d s1_trig_rep_a_u s1_b_rc s2_b_rc s1_ins_a s1_upd_a_data s2_upsert_a_data s1_r s2_c s0_rep
step s1_trig_rep_b_i: CREATE TRIGGER rep_b_i BEFORE INSERT ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_b_d: CREATE TRIGGER rep_b_d BEFORE DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_b_u: CREATE TRIGGER rep_b_u BEFORE UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_i: CREATE TRIGGER rep_a_i AFTER INSERT ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_d: CREATE TRIGGER rep_a_d AFTER DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  trigger: name rep_b_i; when: BEFORE; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-s1)
s1: NOTICE:  trigger: name rep_a_i; when: AFTER; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-s1)
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

s1: NOTICE:  upd: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
s1: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
step s1_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups1'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;

key  |data         
-----+-------------
key-a|val-a-s1-ups1
(1 row)

s2: NOTICE:  trigger: name rep_b_i; when: BEFORE; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-upss2)
step s2_upsert_a_data: 
    INSERT INTO trigtest VALUES ('key-a', 'val-a-upss2')
    ON CONFLICT (key)
        DO UPDATE SET data = trigtest.data || '-upserts2'
        WHERE
            noisy_oper('upd', trigtest.key, '=', 'key-a') AND
            noisy_oper('upk', trigtest.data, '<>', 'mismatch')
    RETURNING *;
 <waiting ...>
step s1_r: ROLLBACK;
s2: NOTICE:  trigger: name rep_a_i; when: AFTER; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-upss2)
step s2_upsert_a_data: <... completed>
key  |data       
-----+-----------
key-a|val-a-upss2
(1 row)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data       
-----+-----------
key-a|val-a-upss2
(1 row)


starting permutation: s1_trig_rep_a_u s1_ins_a s1_ins_b s1_b_rc s2_b_rc s1_upd_a_data s2_upd_a_data s1_c s2_c s0_rep
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s1_ins_b: INSERT INTO trigtest VALUES ('key-b', 'val-b-s1') RETURNING *;
key  |data    
-----+--------
key-b|val-b-s1
(1 row)

step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upd: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  upd: text key-b = text key-a: f
s1: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
step s1_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups1'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;

key  |data         
-----+-------------
key-a|val-a-s1-ups1
(1 row)

s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1 <> text mismatch: t
step s2_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups2'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;
 <waiting ...>
step s1_c: COMMIT;
s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1-ups1 <> text mismatch: t
s2: NOTICE:  upd: text key-b = text key-a: f
s2: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1-ups1) new: (key-a,val-a-s1-ups1-ups2)
step s2_upd_a_data: <... completed>
key  |data              
-----+------------------
key-a|val-a-s1-ups1-ups2
(1 row)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data              
-----+------------------
key-a|val-a-s1-ups1-ups2
key-b|val-b-s1          
(2 rows)


starting permutation: s1_trig_rep_a_u s1_ins_a s1_ins_b s1_b_rc s2_b_rc s1_upd_a_data s2_upd_a_data s1_r s2_c s0_rep
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s1_ins_b: INSERT INTO trigtest VALUES ('key-b', 'val-b-s1') RETURNING *;
key  |data    
-----+--------
key-b|val-b-s1
(1 row)

step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upd: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  upd: text key-b = text key-a: f
s1: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
step s1_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups1'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;

key  |data         
-----+-------------
key-a|val-a-s1-ups1
(1 row)

s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1 <> text mismatch: t
step s2_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups2'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;
 <waiting ...>
step s1_r: ROLLBACK;
s2: NOTICE:  upd: text key-b = text key-a: f
s2: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups2)
step s2_upd_a_data: <... completed>
key  |data         
-----+-------------
key-a|val-a-s1-ups2
(1 row)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data         
-----+-------------
key-a|val-a-s1-ups2
key-b|val-b-s1     
(2 rows)


starting permutation: s1_trig_rep_a_d s1_trig_rep_a_u s1_ins_a s1_ins_b s1_b_rc s2_b_rc s1_upd_a_data s2_del_a s1_c s2_c s0_rep
step s1_trig_rep_a_d: CREATE TRIGGER rep_a_d AFTER DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s1_ins_b: INSERT INTO trigtest VALUES ('key-b', 'val-b-s1') RETURNING *;
key  |data    
-----+--------
key-b|val-b-s1
(1 row)

step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upd: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  upd: text key-b = text key-a: f
s1: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
step s1_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups1'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;

key  |data         
-----+-------------
key-a|val-a-s1-ups1
(1 row)

s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1 <> text mismatch: t
step s2_del_a: 
    DELETE FROM trigtest
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *
 <waiting ...>
step s1_c: COMMIT;
s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1-ups1 <> text mismatch: t
s2: NOTICE:  upd: text key-b = text key-a: f
s2: NOTICE:  trigger: name rep_a_d; when: AFTER; lev: ROWs; op: DELETE; old: (key-a,val-a-s1-ups1) new: <NULL>
step s2_del_a: <... completed>
key  |data         
-----+-------------
key-a|val-a-s1-ups1
(1 row)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data    
-----+--------
key-b|val-b-s1
(1 row)


starting permutation: s1_trig_rep_a_d s1_trig_rep_a_u s1_ins_a s1_ins_b s1_b_rc s2_b_rc s1_upd_a_data s2_del_a s1_r s2_c s0_rep
step s1_trig_rep_a_d: CREATE TRIGGER rep_a_d AFTER DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s1_ins_b: INSERT INTO trigtest VALUES ('key-b', 'val-b-s1') RETURNING *;
key  |data    
-----+--------
key-b|val-b-s1
(1 row)

step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upd: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  upd: text key-b = text key-a: f
s1: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
step s1_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups1'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;

key  |data         
-----+-------------
key-a|val-a-s1-ups1
(1 row)

s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1 <> text mismatch: t
step s2_del_a: 
    DELETE FROM trigtest
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *
 <waiting ...>
step s1_r: ROLLBACK;
s2: NOTICE:  upd: text key-b = text key-a: f
s2: NOTICE:  trigger: name rep_a_d; when: AFTER; lev: ROWs; op: DELETE; old: (key-a,val-a-s1) new: <NULL>
step s2_del_a: <... completed>
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data    
-----+--------
key-b|val-b-s1
(1 row)


starting permutation: s1_trig_rep_a_d s1_trig_rep_a_u s1_ins_a s1_ins_b s1_b_rc s2_b_rc s1_del_a s2_upd_a_data s1_c s2_c s0_rep
step s1_trig_rep_a_d: CREATE TRIGGER rep_a_d AFTER DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s1_ins_b: INSERT INTO trigtest VALUES ('key-b', 'val-b-s1') RETURNING *;
key  |data    
-----+--------
key-b|val-b-s1
(1 row)

step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upd: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  upd: text key-b = text key-a: f
s1: NOTICE:  trigger: name rep_a_d; when: AFTER; lev: ROWs; op: DELETE; old: (key-a,val-a-s1) new: <NULL>
step s1_del_a: 
    DELETE FROM trigtest
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *

key  |data    
-----+--------
key-a|val-a-s1
(1 row)

s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1 <> text mismatch: t
step s2_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups2'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;
 <waiting ...>
step s1_c: COMMIT;
s2: NOTICE:  upd: text key-b = text key-a: f
step s2_upd_a_data: <... completed>
key|data
---+----
(0 rows)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data    
-----+--------
key-b|val-b-s1
(1 row)


starting permutation: s1_trig_rep_a_d s1_trig_rep_a_u s1_ins_a s1_ins_b s1_b_rc s2_b_rc s1_del_a s2_upd_a_data s1_r s2_c s0_rep
step s1_trig_rep_a_d: CREATE TRIGGER rep_a_d AFTER DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s1_ins_b: INSERT INTO trigtest VALUES ('key-b', 'val-b-s1') RETURNING *;
key  |data    
-----+--------
key-b|val-b-s1
(1 row)

step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upd: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  upd: text key-b = text key-a: f
s1: NOTICE:  trigger: name rep_a_d; when: AFTER; lev: ROWs; op: DELETE; old: (key-a,val-a-s1) new: <NULL>
step s1_del_a: 
    DELETE FROM trigtest
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *

key  |data    
-----+--------
key-a|val-a-s1
(1 row)

s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1 <> text mismatch: t
step s2_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups2'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;
 <waiting ...>
step s1_r: ROLLBACK;
s2: NOTICE:  upd: text key-b = text key-a: f
s2: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups2)
step s2_upd_a_data: <... completed>
key  |data         
-----+-------------
key-a|val-a-s1-ups2
(1 row)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data         
-----+-------------
key-a|val-a-s1-ups2
key-b|val-b-s1     
(2 rows)


starting permutation: s1_trig_rep_a_d s1_ins_a s1_ins_b s1_b_rc s2_b_rc s1_del_a s2_del_a s1_c s2_c s0_rep
step s1_trig_rep_a_d: CREATE TRIGGER rep_a_d AFTER DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s1_ins_b: INSERT INTO trigtest VALUES ('key-b', 'val-b-s1') RETURNING *;
key  |data    
-----+--------
key-b|val-b-s1
(1 row)

step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upd: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  upd: text key-b = text key-a: f
s1: NOTICE:  trigger: name rep_a_d; when: AFTER; lev: ROWs; op: DELETE; old: (key-a,val-a-s1) new: <NULL>
step s1_del_a: 
    DELETE FROM trigtest
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *

key  |data    
-----+--------
key-a|val-a-s1
(1 row)

s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1 <> text mismatch: t
step s2_del_a: 
    DELETE FROM trigtest
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *
 <waiting ...>
step s1_c: COMMIT;
s2: NOTICE:  upd: text key-b = text key-a: f
step s2_del_a: <... completed>
key|data
---+----
(0 rows)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data    
-----+--------
key-b|val-b-s1
(1 row)


starting permutation: s1_trig_rep_a_d s1_ins_a s1_ins_b s1_b_rc s2_b_rc s1_del_a s2_del_a s1_r s2_c s0_rep
step s1_trig_rep_a_d: CREATE TRIGGER rep_a_d AFTER DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s1_ins_b: INSERT INTO trigtest VALUES ('key-b', 'val-b-s1') RETURNING *;
key  |data    
-----+--------
key-b|val-b-s1
(1 row)

step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upd: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  upd: text key-b = text key-a: f
s1: NOTICE:  trigger: name rep_a_d; when: AFTER; lev: ROWs; op: DELETE; old: (key-a,val-a-s1) new: <NULL>
step s1_del_a: 
    DELETE FROM trigtest
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *

key  |data    
-----+--------
key-a|val-a-s1
(1 row)

s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1 <> text mismatch: t
step s2_del_a: 
    DELETE FROM trigtest
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *
 <waiting ...>
step s1_r: ROLLBACK;
s2: NOTICE:  upd: text key-b = text key-a: f
s2: NOTICE:  trigger: name rep_a_d; when: AFTER; lev: ROWs; op: DELETE; old: (key-a,val-a-s1) new: <NULL>
step s2_del_a: <... completed>
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data    
-----+--------
key-b|val-b-s1
(1 row)


starting permutation: s1_trig_rep_b_u s1_trig_rep_a_u s1_ins_a s1_ins_c s1_b_rc s2_b_rc s1_upd_a_tob s2_upd_a_data s1_c s2_c s0_rep
step s1_trig_rep_b_u: CREATE TRIGGER rep_b_u BEFORE UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s1_ins_c: INSERT INTO trigtest VALUES ('key-c', 'val-c-s1') RETURNING *;
key  |data    
-----+--------
key-c|val-c-s1
(1 row)

step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upk: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-b,val-a-s1-tobs1)
s1: NOTICE:  upk: text key-c = text key-a: f
s1: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-b,val-a-s1-tobs1)
step s1_upd_a_tob: 
    UPDATE trigtest SET key = 'key-b', data = data || '-tobs1'
    WHERE
        noisy_oper('upk', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;

key  |data          
-----+--------------
key-b|val-a-s1-tobs1
(1 row)

s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1 <> text mismatch: t
step s2_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups2'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;
 <waiting ...>
step s1_c: COMMIT;
s2: NOTICE:  upd: text key-b = text key-a: f
s2: NOTICE:  upd: text key-c = text key-a: f
step s2_upd_a_data: <... completed>
key|data
---+----
(0 rows)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data          
-----+--------------
key-b|val-a-s1-tobs1
key-c|val-c-s1      
(2 rows)


starting permutation: s1_trig_rep_b_u s1_trig_rep_a_u s1_ins_a s1_ins_c s1_b_rc s2_b_rc s1_upd_a_tob s2_upd_a_data s1_r s2_c s0_rep
step s1_trig_rep_b_u: CREATE TRIGGER rep_b_u BEFORE UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s1_ins_c: INSERT INTO trigtest VALUES ('key-c', 'val-c-s1') RETURNING *;
key  |data    
-----+--------
key-c|val-c-s1
(1 row)

step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upk: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-b,val-a-s1-tobs1)
s1: NOTICE:  upk: text key-c = text key-a: f
s1: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-b,val-a-s1-tobs1)
step s1_upd_a_tob: 
    UPDATE trigtest SET key = 'key-b', data = data || '-tobs1'
    WHERE
        noisy_oper('upk', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;

key  |data          
-----+--------------
key-b|val-a-s1-tobs1
(1 row)

s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1 <> text mismatch: t
step s2_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups2'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;
 <waiting ...>
step s1_r: ROLLBACK;
s2: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups2)
s2: NOTICE:  upd: text key-c = text key-a: f
s2: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups2)
step s2_upd_a_data: <... completed>
key  |data         
-----+-------------
key-a|val-a-s1-ups2
(1 row)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data         
-----+-------------
key-a|val-a-s1-ups2
key-c|val-c-s1     
(2 rows)


starting permutation: s1_trig_rep_b_u s1_trig_rep_a_u s1_ins_a s1_ins_c s1_b_rc s2_b_rc s1_upd_a_tob s2_upd_b_data s1_c s2_c s0_rep
step s1_trig_rep_b_u: CREATE TRIGGER rep_b_u BEFORE UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s1_ins_c: INSERT INTO trigtest VALUES ('key-c', 'val-c-s1') RETURNING *;
key  |data    
-----+--------
key-c|val-c-s1
(1 row)

step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upk: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-b,val-a-s1-tobs1)
s1: NOTICE:  upk: text key-c = text key-a: f
s1: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-b,val-a-s1-tobs1)
step s1_upd_a_tob: 
    UPDATE trigtest SET key = 'key-b', data = data || '-tobs1'
    WHERE
        noisy_oper('upk', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;

key  |data          
-----+--------------
key-b|val-a-s1-tobs1
(1 row)

s2: NOTICE:  upd: text key-a = text key-b: f
s2: NOTICE:  upd: text key-c = text key-b: f
step s2_upd_b_data: 
    UPDATE trigtest SET data = data || '-ups2'
    WHERE
        noisy_oper('upd', key, '=', 'key-b') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;

key|data
---+----
(0 rows)

step s1_c: COMMIT;
step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data          
-----+--------------
key-b|val-a-s1-tobs1
key-c|val-c-s1      
(2 rows)


starting permutation: s1_trig_rep_b_u s1_trig_rep_a_u s1_ins_a s1_ins_c s1_b_rc s2_b_rc s1_upd_a_tob s2_upd_all_data s1_c s2_c s0_rep
step s1_trig_rep_b_u: CREATE TRIGGER rep_b_u BEFORE UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s1_ins_c: INSERT INTO trigtest VALUES ('key-c', 'val-c-s1') RETURNING *;
key  |data    
-----+--------
key-c|val-c-s1
(1 row)

step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upk: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-b,val-a-s1-tobs1)
s1: NOTICE:  upk: text key-c = text key-a: f
s1: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-b,val-a-s1-tobs1)
step s1_upd_a_tob: 
    UPDATE trigtest SET key = 'key-b', data = data || '-tobs1'
    WHERE
        noisy_oper('upk', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;

key  |data          
-----+--------------
key-b|val-a-s1-tobs1
(1 row)

s2: NOTICE:  upd: text key-a <> text mismatch: t
s2: NOTICE:  upk: text val-a-s1 <> text mismatch: t
step s2_upd_all_data: 
    UPDATE trigtest SET data = data || '-ups2'
    WHERE
        noisy_oper('upd', key, '<>', 'mismatch') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;
 <waiting ...>
step s1_c: COMMIT;
s2: NOTICE:  upd: text key-b <> text mismatch: t
s2: NOTICE:  upk: text val-a-s1-tobs1 <> text mismatch: t
s2: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-b,val-a-s1-tobs1) new: (key-b,val-a-s1-tobs1-ups2)
s2: NOTICE:  upd: text key-c <> text mismatch: t
s2: NOTICE:  upk: text val-c-s1 <> text mismatch: t
s2: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-c,val-c-s1) new: (key-c,val-c-s1-ups2)
s2: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-b,val-a-s1-tobs1) new: (key-b,val-a-s1-tobs1-ups2)
s2: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-c,val-c-s1) new: (key-c,val-c-s1-ups2)
step s2_upd_all_data: <... completed>
key  |data               
-----+-------------------
key-b|val-a-s1-tobs1-ups2
key-c|val-c-s1-ups2      
(2 rows)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data               
-----+-------------------
key-b|val-a-s1-tobs1-ups2
key-c|val-c-s1-ups2      
(2 rows)


starting permutation: s1_trig_rep_b_d s1_trig_rep_b_u s1_trig_rep_a_d s1_trig_rep_a_u s1_ins_a s1_ins_c s1_b_rc s2_b_rc s1_del_a s2_upd_a_data s1_c s2_c s0_rep
step s1_trig_rep_b_d: CREATE TRIGGER rep_b_d BEFORE DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_b_u: CREATE TRIGGER rep_b_u BEFORE UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_d: CREATE TRIGGER rep_a_d AFTER DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s1_ins_c: INSERT INTO trigtest VALUES ('key-c', 'val-c-s1') RETURNING *;
key  |data    
-----+--------
key-c|val-c-s1
(1 row)

step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upd: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  trigger: name rep_b_d; when: BEFORE; lev: ROWs; op: DELETE; old: (key-a,val-a-s1) new: <NULL>
s1: NOTICE:  upd: text key-c = text key-a: f
s1: NOTICE:  trigger: name rep_a_d; when: AFTER; lev: ROWs; op: DELETE; old: (key-a,val-a-s1) new: <NULL>
step s1_del_a: 
    DELETE FROM trigtest
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *

key  |data    
-----+--------
key-a|val-a-s1
(1 row)

s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1 <> text mismatch: t
step s2_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups2'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;
 <waiting ...>
step s1_c: COMMIT;
s2: NOTICE:  upd: text key-c = text key-a: f
step s2_upd_a_data: <... completed>
key|data
---+----
(0 rows)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data    
-----+--------
key-c|val-c-s1
(1 row)


starting permutation: s1_trig_rep_b_d s1_trig_rep_b_u s1_trig_rep_a_d s1_trig_rep_a_u s1_ins_a s1_ins_c s1_b_rc s2_b_rc s1_del_a s2_upd_a_data s1_r s2_c s0_rep
step s1_trig_rep_b_d: CREATE TRIGGER rep_b_d BEFORE DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_b_u: CREATE TRIGGER rep_b_u BEFORE UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_d: CREATE TRIGGER rep_a_d AFTER DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s1_ins_c: INSERT INTO trigtest VALUES ('key-c', 'val-c-s1') RETURNING *;
key  |data    
-----+--------
key-c|val-c-s1
(1 row)

step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upd: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  trigger: name rep_b_d; when: BEFORE; lev: ROWs; op: DELETE; old: (key-a,val-a-s1) new: <NULL>
s1: NOTICE:  upd: text key-c = text key-a: f
s1: NOTICE:  trigger: name rep_a_d; when: AFTER; lev: ROWs; op: DELETE; old: (key-a,val-a-s1) new: <NULL>
step s1_del_a: 
    DELETE FROM trigtest
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *

key  |data    
-----+--------
key-a|val-a-s1
(1 row)

s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1 <> text mismatch: t
step s2_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups2'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;
 <waiting ...>
step s1_r: ROLLBACK;
s2: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups2)
s2: NOTICE:  upd: text key-c = text key-a: f
s2: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups2)
step s2_upd_a_data: <... completed>
key  |data         
-----+-------------
key-a|val-a-s1-ups2
(1 row)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data         
-----+-------------
key-a|val-a-s1-ups2
key-c|val-c-s1     
(2 rows)


starting permutation: s1_trig_rep_b_d s1_trig_rep_a_d s1_ins_a s1_ins_c s1_b_rc s2_b_rc s1_del_a s2_del_a s1_c s2_c s0_rep
step s1_trig_rep_b_d: CREATE TRIGGER rep_b_d BEFORE DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_d: CREATE TRIGGER rep_a_d AFTER DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s1_ins_c: INSERT INTO trigtest VALUES ('key-c', 'val-c-s1') RETURNING *;
key  |data    
-----+--------
key-c|val-c-s1
(1 row)

step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upd: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  trigger: name rep_b_d; when: BEFORE; lev: ROWs; op: DELETE; old: (key-a,val-a-s1) new: <NULL>
s1: NOTICE:  upd: text key-c = text key-a: f
s1: NOTICE:  trigger: name rep_a_d; when: AFTER; lev: ROWs; op: DELETE; old: (key-a,val-a-s1) new: <NULL>
step s1_del_a: 
    DELETE FROM trigtest
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *

key  |data    
-----+--------
key-a|val-a-s1
(1 row)

s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1 <> text mismatch: t
step s2_del_a: 
    DELETE FROM trigtest
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *
 <waiting ...>
step s1_c: COMMIT;
s2: NOTICE:  upd: text key-c = text key-a: f
step s2_del_a: <... completed>
key|data
---+----
(0 rows)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data    
-----+--------
key-c|val-c-s1
(1 row)


starting permutation: s1_trig_rep_b_d s1_trig_rep_a_d s1_ins_a s1_ins_c s1_b_rc s2_b_rc s1_del_a s2_del_a s1_r s2_c s0_rep
step s1_trig_rep_b_d: CREATE TRIGGER rep_b_d BEFORE DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_d: CREATE TRIGGER rep_a_d AFTER DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s1_ins_c: INSERT INTO trigtest VALUES ('key-c', 'val-c-s1') RETURNING *;
key  |data    
-----+--------
key-c|val-c-s1
(1 row)

step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upd: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  trigger: name rep_b_d; when: BEFORE; lev: ROWs; op: DELETE; old: (key-a,val-a-s1) new: <NULL>
s1: NOTICE:  upd: text key-c = text key-a: f
s1: NOTICE:  trigger: name rep_a_d; when: AFTER; lev: ROWs; op: DELETE; old: (key-a,val-a-s1) new: <NULL>
step s1_del_a: 
    DELETE FROM trigtest
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *

key  |data    
-----+--------
key-a|val-a-s1
(1 row)

s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1 <> text mismatch: t
step s2_del_a: 
    DELETE FROM trigtest
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *
 <waiting ...>
step s1_r: ROLLBACK;
s2: NOTICE:  trigger: name rep_b_d; when: BEFORE; lev: ROWs; op: DELETE; old: (key-a,val-a-s1) new: <NULL>
s2: NOTICE:  upd: text key-c = text key-a: f
s2: NOTICE:  trigger: name rep_a_d; when: AFTER; lev: ROWs; op: DELETE; old: (key-a,val-a-s1) new: <NULL>
step s2_del_a: <... completed>
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data    
-----+--------
key-c|val-c-s1
(1 row)


starting permutation: s1_trig_rep_b_i s1_trig_rep_b_d s1_trig_rep_b_u s1_trig_rep_a_i s1_trig_rep_a_d s1_trig_rep_a_u s1_ins_b s1_b_rc s2_b_rc s1_ins_a s1_upd_b_data s2_upd_b_data s1_del_b s1_upd_a_tob s1_c s2_c s0_rep
step s1_trig_rep_b_i: CREATE TRIGGER rep_b_i BEFORE INSERT ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_b_d: CREATE TRIGGER rep_b_d BEFORE DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_b_u: CREATE TRIGGER rep_b_u BEFORE UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_i: CREATE TRIGGER rep_a_i AFTER INSERT ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_d: CREATE TRIGGER rep_a_d AFTER DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
s1: NOTICE:  trigger: name rep_b_i; when: BEFORE; lev: ROWs; op: INSERT; old: <NULL> new: (key-b,val-b-s1)
s1: NOTICE:  trigger: name rep_a_i; when: AFTER; lev: ROWs; op: INSERT; old: <NULL> new: (key-b,val-b-s1)
step s1_ins_b: INSERT INTO trigtest VALUES ('key-b', 'val-b-s1') RETURNING *;
key  |data    
-----+--------
key-b|val-b-s1
(1 row)

step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  trigger: name rep_b_i; when: BEFORE; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-s1)
s1: NOTICE:  trigger: name rep_a_i; when: AFTER; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-s1)
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

s1: NOTICE:  upd: text key-b = text key-b: t
s1: NOTICE:  upk: text val-b-s1 <> text mismatch: t
s1: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-b,val-b-s1) new: (key-b,val-b-s1-ups1)
s1: NOTICE:  upd: text key-a = text key-b: f
s1: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-b,val-b-s1) new: (key-b,val-b-s1-ups1)
step s1_upd_b_data: 
    UPDATE trigtest SET data = data || '-ups1'
    WHERE
        noisy_oper('upd', key, '=', 'key-b') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;

key  |data         
-----+-------------
key-b|val-b-s1-ups1
(1 row)

s2: NOTICE:  upd: text key-b = text key-b: t
s2: NOTICE:  upk: text val-b-s1 <> text mismatch: t
step s2_upd_b_data: 
    UPDATE trigtest SET data = data || '-ups2'
    WHERE
        noisy_oper('upd', key, '=', 'key-b') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;
 <waiting ...>
s1: NOTICE:  upd: text key-a = text key-b: f
s1: NOTICE:  upd: text key-b = text key-b: t
s1: NOTICE:  upk: text val-b-s1-ups1 <> text mismatch: t
s1: NOTICE:  trigger: name rep_b_d; when: BEFORE; lev: ROWs; op: DELETE; old: (key-b,val-b-s1-ups1) new: <NULL>
s1: NOTICE:  trigger: name rep_a_d; when: AFTER; lev: ROWs; op: DELETE; old: (key-b,val-b-s1-ups1) new: <NULL>
step s1_del_b: 
    DELETE FROM trigtest
    WHERE
        noisy_oper('upd', key, '=', 'key-b') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *

key  |data         
-----+-------------
key-b|val-b-s1-ups1
(1 row)

s1: NOTICE:  upk: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-b,val-a-s1-tobs1)
s1: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-b,val-a-s1-tobs1)
step s1_upd_a_tob: 
    UPDATE trigtest SET key = 'key-b', data = data || '-tobs1'
    WHERE
        noisy_oper('upk', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;

key  |data          
-----+--------------
key-b|val-a-s1-tobs1
(1 row)

step s1_c: COMMIT;
step s2_upd_b_data: <... completed>
key|data
---+----
(0 rows)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data          
-----+--------------
key-b|val-a-s1-tobs1
(1 row)


starting permutation: s1_trig_rep_b_u s1_trig_rep_a_u s1_ins_a s1_ins_b s1_b_rr s2_b_rr s1_upd_a_data s2_upd_a_data s1_c s2_c s0_rep
step s1_trig_rep_b_u: CREATE TRIGGER rep_b_u BEFORE UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s1_ins_b: INSERT INTO trigtest VALUES ('key-b', 'val-b-s1') RETURNING *;
key  |data    
-----+--------
key-b|val-b-s1
(1 row)

step s1_b_rr: BEGIN ISOLATION LEVEL REPEATABLE READ; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rr: BEGIN ISOLATION LEVEL REPEATABLE READ; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upd: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
s1: NOTICE:  upd: text key-b = text key-a: f
s1: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
step s1_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups1'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;

key  |data         
-----+-------------
key-a|val-a-s1-ups1
(1 row)

s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1 <> text mismatch: t
step s2_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups2'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;
 <waiting ...>
step s1_c: COMMIT;
step s2_upd_a_data: <... completed>
ERROR:  could not serialize access due to concurrent update
step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data         
-----+-------------
key-a|val-a-s1-ups1
key-b|val-b-s1     
(2 rows)


starting permutation: s1_trig_rep_b_u s1_trig_rep_a_u s1_ins_a s1_ins_b s1_b_rr s2_b_rr s1_upd_a_data s2_upd_a_data s1_r s2_c s0_rep
step s1_trig_rep_b_u: CREATE TRIGGER rep_b_u BEFORE UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s1_ins_b: INSERT INTO trigtest VALUES ('key-b', 'val-b-s1') RETURNING *;
key  |data    
-----+--------
key-b|val-b-s1
(1 row)

step s1_b_rr: BEGIN ISOLATION LEVEL REPEATABLE READ; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rr: BEGIN ISOLATION LEVEL REPEATABLE READ; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upd: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
s1: NOTICE:  upd: text key-b = text key-a: f
s1: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
step s1_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups1'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;

key  |data         
-----+-------------
key-a|val-a-s1-ups1
(1 row)

s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1 <> text mismatch: t
step s2_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups2'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;
 <waiting ...>
step s1_r: ROLLBACK;
s2: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups2)
s2: NOTICE:  upd: text key-b = text key-a: f
s2: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups2)
step s2_upd_a_data: <... completed>
key  |data         
-----+-------------
key-a|val-a-s1-ups2
(1 row)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data         
-----+-------------
key-a|val-a-s1-ups2
key-b|val-b-s1     
(2 rows)


starting permutation: s1_trig_rep_b_d s1_trig_rep_b_u s1_trig_rep_a_d s1_trig_rep_a_u s1_ins_a s1_ins_b s1_b_rr s2_b_rr s1_del_a s2_upd_a_data s1_c s2_c s0_rep
step s1_trig_rep_b_d: CREATE TRIGGER rep_b_d BEFORE DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_b_u: CREATE TRIGGER rep_b_u BEFORE UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_d: CREATE TRIGGER rep_a_d AFTER DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s1_ins_b: INSERT INTO trigtest VALUES ('key-b', 'val-b-s1') RETURNING *;
key  |data    
-----+--------
key-b|val-b-s1
(1 row)

step s1_b_rr: BEGIN ISOLATION LEVEL REPEATABLE READ; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rr: BEGIN ISOLATION LEVEL REPEATABLE READ; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upd: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  trigger: name rep_b_d; when: BEFORE; lev: ROWs; op: DELETE; old: (key-a,val-a-s1) new: <NULL>
s1: NOTICE:  upd: text key-b = text key-a: f
s1: NOTICE:  trigger: name rep_a_d; when: AFTER; lev: ROWs; op: DELETE; old: (key-a,val-a-s1) new: <NULL>
step s1_del_a: 
    DELETE FROM trigtest
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *

key  |data    
-----+--------
key-a|val-a-s1
(1 row)

s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1 <> text mismatch: t
step s2_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups2'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;
 <waiting ...>
step s1_c: COMMIT;
step s2_upd_a_data: <... completed>
ERROR:  could not serialize access due to concurrent delete
step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data    
-----+--------
key-b|val-b-s1
(1 row)


starting permutation: s1_trig_rep_b_d s1_trig_rep_b_u s1_trig_rep_a_d s1_trig_rep_a_u s1_ins_a s1_ins_b s1_b_rr s2_b_rr s1_del_a s2_upd_a_data s1_r s2_c s0_rep
step s1_trig_rep_b_d: CREATE TRIGGER rep_b_d BEFORE DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_b_u: CREATE TRIGGER rep_b_u BEFORE UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_d: CREATE TRIGGER rep_a_d AFTER DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
key  |data    
-----+--------
key-a|val-a-s1
(1 row)

step s1_ins_b: INSERT INTO trigtest VALUES ('key-b', 'val-b-s1') RETURNING *;
key  |data    
-----+--------
key-b|val-b-s1
(1 row)

step s1_b_rr: BEGIN ISOLATION LEVEL REPEATABLE READ; SELECT 1;
?column?
--------
       1
(1 row)

step s2_b_rr: BEGIN ISOLATION LEVEL REPEATABLE READ; SELECT 1;
?column?
--------
       1
(1 row)

s1: NOTICE:  upd: text key-a = text key-a: t
s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
s1: NOTICE:  trigger: name rep_b_d; when: BEFORE; lev: ROWs; op: DELETE; old: (key-a,val-a-s1) new: <NULL>
s1: NOTICE:  upd: text key-b = text key-a: f
s1: NOTICE:  trigger: name rep_a_d; when: AFTER; lev: ROWs; op: DELETE; old: (key-a,val-a-s1) new: <NULL>
step s1_del_a: 
    DELETE FROM trigtest
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *

key  |data    
-----+--------
key-a|val-a-s1
(1 row)

s2: NOTICE:  upd: text key-a = text key-a: t
s2: NOTICE:  upk: text val-a-s1 <> text mismatch: t
step s2_upd_a_data: 
    UPDATE trigtest SET data = data || '-ups2'
    WHERE
        noisy_oper('upd', key, '=', 'key-a') AND
        noisy_oper('upk', data, '<>', 'mismatch')
    RETURNING *;
 <waiting ...>
step s1_r: ROLLBACK;
s2: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups2)
s2: NOTICE:  upd: text key-b = text key-a: f
s2: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups2)
step s2_upd_a_data: <... completed>
key  |data         
-----+-------------
key-a|val-a-s1-ups2
(1 row)

step s2_c: COMMIT;
step s0_rep: SELECT * FROM trigtest ORDER BY key, data
key  |data         
-----+-------------
key-a|val-a-s1-ups2
key-b|val-b-s1     
(2 rows)

