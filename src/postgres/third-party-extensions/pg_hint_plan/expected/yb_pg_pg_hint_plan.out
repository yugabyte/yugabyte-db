-- This test is derived from the pg_hint_plan test in
-- <https://github.com/ossc-db/pg_hint_plan/>.
SET search_path TO public;
SET client_min_messages TO log;
SET yb_enable_bitmapscan = true;
\set SHOW_CONTEXT always
-- In general, for postgres since t1.id and t2.id is sorted, merge joins should be optimal.
-- However, since YB does not support merge join nested loop joins will be used.
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
                            QUERY PLAN
-------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t2.id)
   ->  Seq Scan on t2
   ->  Index Scan using t1_pkey on t1
         Index Cond: (id = ANY (ARRAY[t2.id, $1, $2, ..., $1023]))
(5 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.val = t2.val;
           QUERY PLAN
--------------------------------
 Hash Join
   Hash Cond: (t2.val = t1.val)
   ->  Seq Scan on t2
   ->  Hash
         ->  Seq Scan on t1
(5 rows)

SET pg_hint_plan.debug_print TO on;
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
                            QUERY PLAN
-------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t2.id)
   ->  Seq Scan on t2
   ->  Index Scan using t1_pkey on t1
         Index Cond: (id = ANY (ARRAY[t2.id, $1, $2, ..., $1023]))
(5 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.val = t2.val;
           QUERY PLAN
--------------------------------
 Hash Join
   Hash Cond: (t2.val = t1.val)
   ->  Seq Scan on t2
   ->  Hash
         ->  Seq Scan on t1
(5 rows)

-- pg_hint_plan when enabled recognizes Test as an unknown keyword
/*+ Test (t1 t2) */
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
INFO:  pg_hint_plan: hint syntax error at or near "Test (t1 t2) "
DETAIL:  Unrecognized hint keyword "Test".
                            QUERY PLAN
-------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t2.id)
   ->  Seq Scan on t2
   ->  Index Scan using t1_pkey on t1
         Index Cond: (id = ANY (ARRAY[t2.id, $1, $2, ..., $1023]))
(5 rows)

SET pg_hint_plan.enable_hint TO off;
/*+ Test (t1 t2) */
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
                            QUERY PLAN
-------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t2.id)
   ->  Seq Scan on t2
   ->  Index Scan using t1_pkey on t1
         Index Cond: (id = ANY (ARRAY[t2.id, $1, $2, ..., $1023]))
(5 rows)

SET pg_hint_plan.enable_hint TO on;
-- Planner Method Configuration parameters can be controlled as a part of pg_hint_plan comments.
-- pg_hint_plan comment formatting wrong
/*Set(enable_indexscan off)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
                            QUERY PLAN
-------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t2.id)
   ->  Seq Scan on t2
   ->  Index Scan using t1_pkey on t1
         Index Cond: (id = ANY (ARRAY[t2.id, $1, $2, ..., $1023]))
(5 rows)

-- pg_hint_plan comment formatting wrong
--+Set(enable_indexscan off)
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
                            QUERY PLAN
-------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t2.id)
   ->  Seq Scan on t2
   ->  Index Scan using t1_pkey on t1
         Index Cond: (id = ANY (ARRAY[t2.id, $1, $2, ..., $1023]))
(5 rows)

/*+Set(enable_indexscan off) /* nest comment */ */
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
INFO:  pg_hint_plan: hint syntax error at or near "/* nest comment */ */
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;"
DETAIL:  Nested block comments are not supported.
                            QUERY PLAN
-------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t2.id)
   ->  Seq Scan on t2
   ->  Index Scan using t1_pkey on t1
         Index Cond: (id = ANY (ARRAY[t2.id, $1, $2, ..., $1023]))
(5 rows)

/*+Set(enable_indexscan off)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
Set(enable_indexscan off)
not used hint:
duplication hint:
error hint:

          QUERY PLAN
------------------------------
 Hash Join
   Hash Cond: (t1.id = t2.id)
   ->  Seq Scan on t1
   ->  Hash
         ->  Seq Scan on t2
(5 rows)

-- pg_hint_plan_comments can be used in between queries
EXPLAIN (COSTS false) /*+Set(enable_indexscan off)*/
 SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
Set(enable_indexscan off)
not used hint:
duplication hint:
error hint:

          QUERY PLAN
------------------------------
 Hash Join
   Hash Cond: (t1.id = t2.id)
   ->  Seq Scan on t1
   ->  Hash
         ->  Seq Scan on t2
(5 rows)

-- YB_COMMENT
-- Since t1.id and t2.id is sorted postgres will ideally use merge joins. However, YB does not
-- support merge join for now. Postgres output for the query is as follows.
--           QUERY PLAN
-------------------------------
--  Merge Join
--    Merge Cond: (t1.id = t2.id)
--    ->  Sort
--          Sort Key: t1.id
--          ->  Seq Scan on t1
--    ->  Sort
--          Sort Key: t2.id
--          ->  Seq Scan on t2
-- (8 rows)
/*+ Set(enable_indexscan off) Set(enable_hashjoin off) */
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
Set(enable_hashjoin off)
Set(enable_indexscan off)
not used hint:
duplication hint:
error hint:

          QUERY PLAN
-------------------------------
 Merge Join
   Merge Cond: (t1.id = t2.id)
   ->  Sort
         Sort Key: t1.id
         ->  Seq Scan on t1
   ->  Sort
         Sort Key: t2.id
         ->  Seq Scan on t2
(8 rows)

/*+ 	 Set 	 ( 	 enable_indexscan 	 off 	 ) 	 */
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
Set(enable_indexscan off)
not used hint:
duplication hint:
error hint:

          QUERY PLAN
------------------------------
 Hash Join
   Hash Cond: (t1.id = t2.id)
   ->  Seq Scan on t1
   ->  Hash
         ->  Seq Scan on t2
(5 rows)

/*+
	 	Set
	 	(
	 	enable_indexscan
	 	off
	 	)
	 	*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
Set(enable_indexscan off)
not used hint:
duplication hint:
error hint:

          QUERY PLAN
------------------------------
 Hash Join
   Hash Cond: (t1.id = t2.id)
   ->  Seq Scan on t1
   ->  Hash
         ->  Seq Scan on t2
(5 rows)

-- YB_COMMENT
-- Output of this query is different from postgres. Will change once YB optimizes planner
/*+ Set(enable_indexscan off)Set(enable_nestloop off)Set(enable_mergejoin off)
	 	Set(enable_seqscan off)
	 	*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
Set(enable_indexscan off)
Set(enable_mergejoin off)
Set(enable_nestloop off)
Set(enable_seqscan off)
not used hint:
duplication hint:
error hint:

          QUERY PLAN
------------------------------
 Hash Join
   Hash Cond: (t1.id = t2.id)
   ->  Seq Scan on t1
   ->  Hash
         ->  Seq Scan on t2
(5 rows)

/*+Set(work_mem "1M")*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
INFO:  invalid value for parameter "work_mem": "1M"
HINT:  Valid units for this parameter are "B", "kB", "MB", "GB", and "TB".
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
Set(work_mem 1M)

                            QUERY PLAN
-------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t2.id)
   ->  Seq Scan on t2
   ->  Index Scan using t1_pkey on t1
         Index Cond: (id = ANY (ARRAY[t2.id, $1, $2, ..., $1023]))
(5 rows)

/*+Set(work_mem "1MB")*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
Set(work_mem 1MB)
not used hint:
duplication hint:
error hint:

                            QUERY PLAN
-------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t2.id)
   ->  Seq Scan on t2
   ->  Index Scan using t1_pkey on t1
         Index Cond: (id = ANY (ARRAY[t2.id, $1, $2, ..., $1023]))
(5 rows)

/*+Set(work_mem TO "1MB")*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
INFO:  pg_hint_plan: hint syntax error at or near "Set(work_mem TO "1MB")"
DETAIL:  Set hint requires name and value of GUC parameter.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
Set(work_mem TO 1MB)

                            QUERY PLAN
-------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t2.id)
   ->  Seq Scan on t2
   ->  Index Scan using t1_pkey on t1
         Index Cond: (id = ANY (ARRAY[t2.id, $1, $2, ..., $1023]))
(5 rows)

/*+SeqScan() */ SELECT 1;
INFO:  pg_hint_plan: hint syntax error at or near " "
DETAIL:  SeqScan hint requires a relation.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
SeqScan()

 ?column?
----------
        1
(1 row)

-- SeqScan takes only 1 argument. Hence it appears in error hint and not in used hint in
-- the description.
/*+SeqScan(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
INFO:  pg_hint_plan: hint syntax error at or near ""
DETAIL:  SeqScan hint accepts only one relation.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
SeqScan(t1 t2)

                            QUERY PLAN
-------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t2.id)
   ->  Seq Scan on t2
   ->  Index Scan using t1_pkey on t1
         Index Cond: (id = ANY (ARRAY[t2.id, $1, $2, ..., $1023]))
(5 rows)

/*+SeqScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
not used hint:
duplication hint:
error hint:

          QUERY PLAN
------------------------------
 Hash Join
   Hash Cond: (t1.id = t2.id)
   ->  Seq Scan on t1
   ->  Hash
         ->  Seq Scan on t2
(5 rows)

/*+SeqScan(t1)IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
IndexScan(t2)
not used hint:
duplication hint:
error hint:

                            QUERY PLAN
-------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t2.id)
   ->  Seq Scan on t1
   ->  Index Scan using t2_pkey on t2
         Index Cond: (id = ANY (ARRAY[t1.id, $1, $2, ..., $1023]))
(5 rows)

/*+BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
BitmapScan(t2)
not used hint:
duplication hint:
error hint:

                QUERY PLAN
------------------------------------------
 Nested Loop
   ->  Seq Scan on t1
   ->  YB Bitmap Table Scan on t2
         ->  Bitmap Index Scan on t2_pkey
               Index Cond: (id = t1.id)
(5 rows)

/*+BitmapScan(t2)NoSeqScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
NoSeqScan(t1)
BitmapScan(t2)
not used hint:
duplication hint:
error hint:

                            QUERY PLAN
-------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t2.id)
   ->  Seq Scan on t2
   ->  Index Scan using t1_pkey on t1
         Index Cond: (id = ANY (ARRAY[t2.id, $1, $2, ..., $1023]))
(5 rows)

/*+NoIndexScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
NoIndexScan(t1)
not used hint:
duplication hint:
error hint:

          QUERY PLAN
------------------------------
 Hash Join
   Hash Cond: (t1.id = t2.id)
   ->  Seq Scan on t1
   ->  Hash
         ->  Seq Scan on t2
(5 rows)

/*+NoBitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t4 WHERE t1.val < 10;
LOG:  pg_hint_plan:
used hint:
NoBitmapScan(t1)
not used hint:
duplication hint:
error hint:

             QUERY PLAN
------------------------------------
 Nested Loop
   ->  Seq Scan on t1
         Storage Filter: (val < 10)
   ->  Materialize
         ->  Seq Scan on t4
(5 rows)

-- YB_COMMENT
-- Tid scan not supported by YB
-- /*+TidScan(t4)*/
-- EXPLAIN (COSTS false) SELECT * FROM t3, t4 WHERE t3.id = t4.id AND t4.ctid = '(1,1)';
-- /*+NoTidScan(t1)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)';
/*+ NestLoop() */ SELECT 1;
INFO:  pg_hint_plan: hint syntax error at or near " "
DETAIL:  NestLoop hint requires at least two relations.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
NestLoop()

 ?column?
----------
        1
(1 row)

/*+ NestLoop(x) */ SELECT 1;
INFO:  pg_hint_plan: hint syntax error at or near " "
DETAIL:  NestLoop hint requires at least two relations.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
NestLoop(x)

 ?column?
----------
        1
(1 row)

/*+HashJoin(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
HashJoin(t1 t2)
not used hint:
duplication hint:
error hint:

          QUERY PLAN
------------------------------
 Hash Join
   Hash Cond: (t1.id = t2.id)
   ->  Seq Scan on t1
   ->  Hash
         ->  Seq Scan on t2
(5 rows)

/*+NestLoop(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
NestLoop(t1 t2)
not used hint:
duplication hint:
error hint:

                            QUERY PLAN
-------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t2.id)
   ->  Seq Scan on t2
   ->  Index Scan using t1_pkey on t1
         Index Cond: (id = ANY (ARRAY[t2.id, $1, $2, ..., $1023]))
(5 rows)

/*+NoMergeJoin(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
NoMergeJoin(t1 t2)
not used hint:
duplication hint:
error hint:

                            QUERY PLAN
-------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t2.id)
   ->  Seq Scan on t2
   ->  Index Scan using t1_pkey on t1
         Index Cond: (id = ANY (ARRAY[t2.id, $1, $2, ..., $1023]))
(5 rows)

/*+MergeJoin(t1 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t3 WHERE t1.val = t3.val;
LOG:  pg_hint_plan:
used hint:
MergeJoin(t1 t3)
not used hint:
duplication hint:
error hint:

           QUERY PLAN
---------------------------------
 Merge Join
   Merge Cond: (t3.val = t1.val)
   ->  Sort
         Sort Key: t3.val
         ->  Seq Scan on t3
   ->  Sort
         Sort Key: t1.val
         ->  Seq Scan on t1
(8 rows)

/*+NestLoop(t1 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t3 WHERE t1.val = t3.val;
LOG:  pg_hint_plan:
used hint:
NestLoop(t1 t3)
not used hint:
duplication hint:
error hint:

                             QUERY PLAN
---------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.val = t3.val)
   ->  Seq Scan on t3
   ->  Index Scan using t1_val on t1
         Index Cond: (val = ANY (ARRAY[t3.val, $1, $2, ..., $1023]))
(5 rows)

/*+NoHashJoin(t1 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t3 WHERE t1.val = t3.val;
LOG:  pg_hint_plan:
used hint:
NoHashJoin(t1 t3)
not used hint:
duplication hint:
error hint:

                             QUERY PLAN
---------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.val = t3.val)
   ->  Seq Scan on t3
   ->  Index Scan using t1_val on t1
         Index Cond: (val = ANY (ARRAY[t3.val, $1, $2, ..., $1023]))
(5 rows)

/*+MergeJoin(t4 t1 t2 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  pg_hint_plan:
used hint:
MergeJoin(t1 t2 t3 t4)
not used hint:
duplication hint:
error hint:

                                     QUERY PLAN
-------------------------------------------------------------------------------------
 Merge Join
   Merge Cond: (t1.id = t3.id)
   ->  Sort
         Sort Key: t1.id
         ->  YB Batched Nested Loop Join
               Join Filter: (t1.id = t2.id)
               ->  YB Batched Nested Loop Join
                     Join Filter: (t1.id = t4.id)
                     ->  Seq Scan on t4
                     ->  Index Scan using t1_pkey on t1
                           Index Cond: (id = ANY (ARRAY[t4.id, $1, $2, ..., $1023]))
               ->  Index Scan using t2_pkey on t2
                     Index Cond: (id = ANY (ARRAY[t1.id, $1025, $1026, ..., $2047]))
   ->  Sort
         Sort Key: t3.id
         ->  Seq Scan on t3
(16 rows)

-- YB_COMMENT
-- If Merge joins were present, the inner two tables will utilize merge joins as id is a sorted
-- column. Since YB does not support merge join, the inner tables are joined using Nested Loop.
-- Output after Merge join support will look like this.
--                        QUERY PLAN
-- --------------------------------------------------------
--  Hash Join
--    Hash Cond: (t3.id = t1.id)
--    ->  Seq Scan on t3
--    ->  Hash
--          ->  Merge Join
--                Merge Cond: (t1.id = t4.id)
--                ->  Merge Join
--                      Merge Cond: (t1.id = t2.id)
--                      ->  Index Scan using t1_pkey on t1
--                      ->  Index Scan using t2_pkey on t2
--                ->  Sort
--                      Sort Key: t4.id
--                      ->  Seq Scan on t4
-- (13 rows)
/*+HashJoin(t3 t4 t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  pg_hint_plan:
used hint:
HashJoin(t1 t2 t3 t4)
not used hint:
duplication hint:
error hint:

                                     QUERY PLAN
-------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (t3.id = t1.id)
   ->  Seq Scan on t3
   ->  Hash
         ->  YB Batched Nested Loop Join
               Join Filter: (t1.id = t2.id)
               ->  YB Batched Nested Loop Join
                     Join Filter: (t1.id = t4.id)
                     ->  Seq Scan on t4
                     ->  Index Scan using t1_pkey on t1
                           Index Cond: (id = ANY (ARRAY[t4.id, $1, $2, ..., $1023]))
               ->  Index Scan using t2_pkey on t2
                     Index Cond: (id = ANY (ARRAY[t1.id, $1025, $1026, ..., $2047]))
(13 rows)

/*+NestLoop(t2 t3 t4 t1) IndexScan(t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  pg_hint_plan:
used hint:
IndexScan(t3)
NestLoop(t1 t2 t3 t4)
not used hint:
duplication hint:
error hint:

                                  QUERY PLAN
-------------------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t2.id)
   ->  YB Batched Nested Loop Join
         Join Filter: (t1.id = t3.id)
         ->  YB Batched Nested Loop Join
               Join Filter: (t1.id = t4.id)
               ->  Seq Scan on t4
               ->  Index Scan using t1_pkey on t1
                     Index Cond: (id = ANY (ARRAY[t4.id, $1, $2, ..., $1023]))
         ->  Index Scan using t3_pkey on t3
               Index Cond: (id = ANY (ARRAY[t1.id, $1025, $1026, ..., $2047]))
   ->  Index Scan using t2_pkey on t2
         Index Cond: (id = ANY (ARRAY[t1.id, $2049, $2050, ..., $3071]))
(13 rows)

/*+NoNestLoop(t4 t1 t3 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  pg_hint_plan:
used hint:
NoNestLoop(t1 t2 t3 t4)
not used hint:
duplication hint:
error hint:

                                  QUERY PLAN
-------------------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t2.id)
   ->  YB Batched Nested Loop Join
         Join Filter: (t1.id = t3.id)
         ->  YB Batched Nested Loop Join
               Join Filter: (t1.id = t4.id)
               ->  Seq Scan on t4
               ->  Index Scan using t1_pkey on t1
                     Index Cond: (id = ANY (ARRAY[t4.id, $1, $2, ..., $1023]))
         ->  Index Scan using t3_pkey on t3
               Index Cond: (id = ANY (ARRAY[t1.id, $1025, $1026, ..., $2047]))
   ->  Index Scan using t2_pkey on t2
         Index Cond: (id = ANY (ARRAY[t1.id, $2049, $2050, ..., $3071]))
(13 rows)

/*+Leading( */
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
INFO:  pg_hint_plan: hint syntax error at or near ""
DETAIL:  Closing parenthesis is necessary.
                                  QUERY PLAN
-------------------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t2.id)
   ->  YB Batched Nested Loop Join
         Join Filter: (t1.id = t3.id)
         ->  YB Batched Nested Loop Join
               Join Filter: (t1.id = t4.id)
               ->  Seq Scan on t4
               ->  Index Scan using t1_pkey on t1
                     Index Cond: (id = ANY (ARRAY[t4.id, $1, $2, ..., $1023]))
         ->  Index Scan using t3_pkey on t3
               Index Cond: (id = ANY (ARRAY[t1.id, $1025, $1026, ..., $2047]))
   ->  Index Scan using t2_pkey on t2
         Index Cond: (id = ANY (ARRAY[t1.id, $2049, $2050, ..., $3071]))
(13 rows)

/*+Leading( )*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
INFO:  pg_hint_plan: hint syntax error at or near "Leading( )"
DETAIL:  Leading hint requires at least two relations.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
Leading()

                                  QUERY PLAN
-------------------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t2.id)
   ->  YB Batched Nested Loop Join
         Join Filter: (t1.id = t3.id)
         ->  YB Batched Nested Loop Join
               Join Filter: (t1.id = t4.id)
               ->  Seq Scan on t4
               ->  Index Scan using t1_pkey on t1
                     Index Cond: (id = ANY (ARRAY[t4.id, $1, $2, ..., $1023]))
         ->  Index Scan using t3_pkey on t3
               Index Cond: (id = ANY (ARRAY[t1.id, $1025, $1026, ..., $2047]))
   ->  Index Scan using t2_pkey on t2
         Index Cond: (id = ANY (ARRAY[t1.id, $2049, $2050, ..., $3071]))
(13 rows)

/*+Leading( t3 )*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
INFO:  pg_hint_plan: hint syntax error at or near "Leading( t3 )"
DETAIL:  Leading hint requires at least two relations.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
Leading(t3)

                                  QUERY PLAN
-------------------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t2.id)
   ->  YB Batched Nested Loop Join
         Join Filter: (t1.id = t3.id)
         ->  YB Batched Nested Loop Join
               Join Filter: (t1.id = t4.id)
               ->  Seq Scan on t4
               ->  Index Scan using t1_pkey on t1
                     Index Cond: (id = ANY (ARRAY[t4.id, $1, $2, ..., $1023]))
         ->  Index Scan using t3_pkey on t3
               Index Cond: (id = ANY (ARRAY[t1.id, $1025, $1026, ..., $2047]))
   ->  Index Scan using t2_pkey on t2
         Index Cond: (id = ANY (ARRAY[t1.id, $2049, $2050, ..., $3071]))
(13 rows)

/*+Leading( t3 t4 )*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  pg_hint_plan:
used hint:
Leading(t3 t4)
not used hint:
duplication hint:
error hint:

                               QUERY PLAN
-------------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t2.id)
   ->  YB Batched Nested Loop Join
         Join Filter: (t3.id = t1.id)
         Sort Keys: t1.id
         ->  Merge Join
               Merge Cond: (t3.id = t4.id)
               ->  Sort
                     Sort Key: t3.id
                     ->  Seq Scan on t3
               ->  Sort
                     Sort Key: t4.id
                     ->  Seq Scan on t4
         ->  Index Scan using t1_pkey on t1
               Index Cond: (id = ANY (ARRAY[t3.id, $1, $2, ..., $1023]))
   ->  Index Scan using t2_pkey on t2
         Index Cond: (id = ANY (ARRAY[t1.id, $1025, $1026, ..., $2047]))
(17 rows)

/*+Leading(t3 t4 t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  pg_hint_plan:
used hint:
Leading(t3 t4 t1)
not used hint:
duplication hint:
error hint:

                                  QUERY PLAN
-------------------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t2.id)
   ->  YB Batched Nested Loop Join
         Join Filter: (t3.id = t1.id)
         ->  YB Batched Nested Loop Join
               Join Filter: (t3.id = t4.id)
               ->  Seq Scan on t4
               ->  Index Scan using t3_pkey on t3
                     Index Cond: (id = ANY (ARRAY[t4.id, $1, $2, ..., $1023]))
         ->  Index Scan using t1_pkey on t1
               Index Cond: (id = ANY (ARRAY[t3.id, $1025, $1026, ..., $2047]))
   ->  Index Scan using t2_pkey on t2
         Index Cond: (id = ANY (ARRAY[t1.id, $2049, $2050, ..., $3071]))
(13 rows)

/*+Leading(t3 t4 t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  pg_hint_plan:
used hint:
Leading(t3 t4 t1 t2)
not used hint:
duplication hint:
error hint:

                                  QUERY PLAN
-------------------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t2.id)
   ->  YB Batched Nested Loop Join
         Join Filter: (t3.id = t1.id)
         ->  YB Batched Nested Loop Join
               Join Filter: (t3.id = t4.id)
               ->  Seq Scan on t4
               ->  Index Scan using t3_pkey on t3
                     Index Cond: (id = ANY (ARRAY[t4.id, $1, $2, ..., $1023]))
         ->  Index Scan using t1_pkey on t1
               Index Cond: (id = ANY (ARRAY[t3.id, $1025, $1026, ..., $2047]))
   ->  Index Scan using t2_pkey on t2
         Index Cond: (id = ANY (ARRAY[t1.id, $2049, $2050, ..., $3071]))
(13 rows)

/*+Leading(t3 t4 t1 t2 t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
INFO:  pg_hint_plan: hint syntax error at or near "Leading(t3 t4 t1 t2 t1)"
DETAIL:  Relation name "t1" is duplicated.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
Leading(t3 t4 t1 t2 t1)

                                  QUERY PLAN
-------------------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t2.id)
   ->  YB Batched Nested Loop Join
         Join Filter: (t1.id = t3.id)
         ->  YB Batched Nested Loop Join
               Join Filter: (t1.id = t4.id)
               ->  Seq Scan on t4
               ->  Index Scan using t1_pkey on t1
                     Index Cond: (id = ANY (ARRAY[t4.id, $1, $2, ..., $1023]))
         ->  Index Scan using t3_pkey on t3
               Index Cond: (id = ANY (ARRAY[t1.id, $1025, $1026, ..., $2047]))
   ->  Index Scan using t2_pkey on t2
         Index Cond: (id = ANY (ARRAY[t1.id, $2049, $2050, ..., $3071]))
(13 rows)

/*+Leading(t3 t4 t4)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
INFO:  pg_hint_plan: hint syntax error at or near "Leading(t3 t4 t4)"
DETAIL:  Relation name "t4" is duplicated.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
Leading(t3 t4 t4)

                                  QUERY PLAN
-------------------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t2.id)
   ->  YB Batched Nested Loop Join
         Join Filter: (t1.id = t3.id)
         ->  YB Batched Nested Loop Join
               Join Filter: (t1.id = t4.id)
               ->  Seq Scan on t4
               ->  Index Scan using t1_pkey on t1
                     Index Cond: (id = ANY (ARRAY[t4.id, $1, $2, ..., $1023]))
         ->  Index Scan using t3_pkey on t3
               Index Cond: (id = ANY (ARRAY[t1.id, $1025, $1026, ..., $2047]))
   ->  Index Scan using t2_pkey on t2
         Index Cond: (id = ANY (ARRAY[t1.id, $2049, $2050, ..., $3071]))
(13 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, (VALUES(1,1),(2,2),(3,3)) AS t2(id,val) WHERE t1.id = t2.id;
                                   QUERY PLAN
--------------------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = "*VALUES*".column1)
   ->  Values Scan on "*VALUES*"
   ->  Index Scan using t1_pkey on t1
         Index Cond: (id = ANY (ARRAY["*VALUES*".column1, $1, $2, ..., $1023]))
(5 rows)

/*+HashJoin(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, (VALUES(1,1),(2,2),(3,3)) AS t2(id,val) WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
not used hint:
HashJoin(t1 t2)
duplication hint:
error hint:

                                   QUERY PLAN
--------------------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = "*VALUES*".column1)
   ->  Values Scan on "*VALUES*"
   ->  Index Scan using t1_pkey on t1
         Index Cond: (id = ANY (ARRAY["*VALUES*".column1, $1, $2, ..., $1023]))
(5 rows)

/*+HashJoin(t1 *VALUES*)*/
EXPLAIN (COSTS false) SELECT * FROM t1, (VALUES(1,1),(2,2),(3,3)) AS t2(id,val) WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
HashJoin(*VALUES* t1)
not used hint:
duplication hint:
error hint:

                QUERY PLAN
-------------------------------------------
 Hash Join
   Hash Cond: (t1.id = "*VALUES*".column1)
   ->  Seq Scan on t1
   ->  Hash
         ->  Values Scan on "*VALUES*"
(5 rows)

/*+HashJoin(t1 *VALUES*) IndexScan(t1) IndexScan(*VALUES*)*/
EXPLAIN (COSTS false) SELECT * FROM t1, (VALUES(1,1),(2,2),(3,3)) AS t2(id,val) WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
IndexScan(t1)
HashJoin(*VALUES* t1)
not used hint:
IndexScan(*VALUES*)
duplication hint:
error hint:

                                   QUERY PLAN
--------------------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = "*VALUES*".column1)
   ->  Values Scan on "*VALUES*"
   ->  Index Scan using t1_pkey on t1
         Index Cond: (id = ANY (ARRAY["*VALUES*".column1, $1, $2, ..., $1023]))
(5 rows)

-- single table scan hint test
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
                QUERY PLAN
-------------------------------------------
 Index Scan using t1_pkey on t1
   Index Cond: (id = $1)
   InitPlan 1 (returns $0)
     ->  Finalize Aggregate
           ->  Seq Scan on t1 v_1
                 Storage Filter: (id < 10)
                 Partial Aggregate: true
   InitPlan 2 (returns $1)
     ->  Finalize Aggregate
           ->  Seq Scan on t1 v_2
                 Storage Filter: (id < 10)
                 Partial Aggregate: true
(12 rows)

-- YB_COMMENT
-- The following index is necessary to allow bitmap scans on these tables, since
-- Postgres has an ASC pkey by default.
CREATE INDEX t1_bitmap_index ON t1(id ASC);
LOG:  committing pg_index tuple with indislive=true
LOG:  committing pg_index tuple with indisready=true
/*+BitmapScan(v_1)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  pg_hint_plan:
used hint:
BitmapScan(v_1)
not used hint:
duplication hint:
error hint:

                                   QUERY PLAN
--------------------------------------------------------------------------------
 Index Scan using t1_pkey on t1
   Index Cond: (id = $3)
   InitPlan 1 (returns $1)
     ->  Finalize Aggregate
           ->  YB Bitmap Table Scan on t1 v_1
                 Partial Aggregate: true
                 ->  Bitmap Index Scan on t1_bitmap_index
                       Index Cond: (id < 10)
   InitPlan 3 (returns $3)
     ->  Result
           InitPlan 2 (returns $2)
             ->  Limit
                   ->  Index Only Scan Backward using t1_bitmap_index on t1 v_2
                         Index Cond: ((id IS NOT NULL) AND (id < 10))
(14 rows)

/*+BitmapScan(v_2)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  pg_hint_plan:
used hint:
BitmapScan(v_2)
not used hint:
duplication hint:
error hint:

                                   QUERY PLAN
--------------------------------------------------------------------------------
 Index Scan using t1_pkey on t1
   Index Cond: (id = $3)
   InitPlan 2 (returns $1)
     ->  Result
           InitPlan 1 (returns $0)
             ->  Limit
                   ->  Index Only Scan Backward using t1_bitmap_index on t1 v_1
                         Index Cond: ((id IS NOT NULL) AND (id < 10))
   InitPlan 3 (returns $3)
     ->  Finalize Aggregate
           ->  YB Bitmap Table Scan on t1 v_2
                 Partial Aggregate: true
                 ->  Bitmap Index Scan on t1_bitmap_index
                       Index Cond: (id < 10)
(14 rows)

/*+BitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
not used hint:
duplication hint:
error hint:

                                   QUERY PLAN
--------------------------------------------------------------------------------
 YB Bitmap Table Scan on t1
   InitPlan 2 (returns $1)
     ->  Result
           InitPlan 1 (returns $0)
             ->  Limit
                   ->  Index Only Scan Backward using t1_bitmap_index on t1 v_1
                         Index Cond: ((id IS NOT NULL) AND (id < 10))
   InitPlan 4 (returns $3)
     ->  Result
           InitPlan 3 (returns $2)
             ->  Limit
                   ->  Index Only Scan Backward using t1_bitmap_index on t1 v_2
                         Index Cond: ((id IS NOT NULL) AND (id < 10))
   ->  Bitmap Index Scan on t1_pkey
         Index Cond: (id = $3)
(15 rows)

/*+BitmapScan(v_1)BitmapScan(v_2)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  pg_hint_plan:
used hint:
BitmapScan(v_1)
BitmapScan(v_2)
not used hint:
duplication hint:
error hint:

                        QUERY PLAN
----------------------------------------------------------
 Index Scan using t1_pkey on t1
   Index Cond: (id = $3)
   InitPlan 1 (returns $1)
     ->  Finalize Aggregate
           ->  YB Bitmap Table Scan on t1 v_1
                 Partial Aggregate: true
                 ->  Bitmap Index Scan on t1_bitmap_index
                       Index Cond: (id < 10)
   InitPlan 2 (returns $3)
     ->  Finalize Aggregate
           ->  YB Bitmap Table Scan on t1 v_2
                 Partial Aggregate: true
                 ->  Bitmap Index Scan on t1_bitmap_index
                       Index Cond: (id < 10)
(14 rows)

/*+BitmapScan(v_1)BitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
BitmapScan(v_1)
not used hint:
duplication hint:
error hint:

                                   QUERY PLAN
--------------------------------------------------------------------------------
 YB Bitmap Table Scan on t1
   InitPlan 1 (returns $1)
     ->  Finalize Aggregate
           ->  YB Bitmap Table Scan on t1 v_1
                 Partial Aggregate: true
                 ->  Bitmap Index Scan on t1_bitmap_index
                       Index Cond: (id < 10)
   InitPlan 3 (returns $3)
     ->  Result
           InitPlan 2 (returns $2)
             ->  Limit
                   ->  Index Only Scan Backward using t1_bitmap_index on t1 v_2
                         Index Cond: ((id IS NOT NULL) AND (id < 10))
   ->  Bitmap Index Scan on t1_pkey
         Index Cond: (id = $3)
(15 rows)

/*+BitmapScan(v_2)BitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
BitmapScan(v_2)
not used hint:
duplication hint:
error hint:

                                   QUERY PLAN
--------------------------------------------------------------------------------
 YB Bitmap Table Scan on t1
   InitPlan 2 (returns $1)
     ->  Result
           InitPlan 1 (returns $0)
             ->  Limit
                   ->  Index Only Scan Backward using t1_bitmap_index on t1 v_1
                         Index Cond: ((id IS NOT NULL) AND (id < 10))
   InitPlan 3 (returns $3)
     ->  Finalize Aggregate
           ->  YB Bitmap Table Scan on t1 v_2
                 Partial Aggregate: true
                 ->  Bitmap Index Scan on t1_bitmap_index
                       Index Cond: (id < 10)
   ->  Bitmap Index Scan on t1_pkey
         Index Cond: (id = $3)
(15 rows)

/*+BitmapScan(v_1)BitmapScan(v_2)BitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
BitmapScan(v_1)
BitmapScan(v_2)
not used hint:
duplication hint:
error hint:

                        QUERY PLAN
----------------------------------------------------------
 YB Bitmap Table Scan on t1
   InitPlan 1 (returns $1)
     ->  Finalize Aggregate
           ->  YB Bitmap Table Scan on t1 v_1
                 Partial Aggregate: true
                 ->  Bitmap Index Scan on t1_bitmap_index
                       Index Cond: (id < 10)
   InitPlan 2 (returns $3)
     ->  Finalize Aggregate
           ->  YB Bitmap Table Scan on t1 v_2
                 Partial Aggregate: true
                 ->  Bitmap Index Scan on t1_bitmap_index
                       Index Cond: (id < 10)
   ->  Bitmap Index Scan on t1_pkey
         Index Cond: (id = $3)
(15 rows)

-- YB_COMMENT
-- Drop the index created for the bitmap tests so that we don't introduce more
-- than necessary.
DROP INDEX t1_bitmap_index;
--
-- YB_COMMENT
-- CTID based scans and searches not supported in Yugabyte
-- full scan hint pattern test
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
ERROR:  System column "ctid" is not supported yet
-- /*+SeqScan(t1)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
-- /*+IndexScan(t1)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
-- /*+BitmapScan(t1)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
-- /*+TidScan(t1)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
-- /*+NoSeqScan(t1)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
-- /*+NoIndexScan(t1)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
-- /*+NoBitmapScan(t1)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
-- /*+NoTidScan(t1)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
--
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+SeqScan(t1)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+SeqScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+SeqScan(t1) SeqScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+SeqScan(t1) IndexScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+SeqScan(t1) BitmapScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+SeqScan(t1) TidScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+SeqScan(t1) NoSeqScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+SeqScan(t1) NoIndexScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+SeqScan(t1) NoBitmapScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+SeqScan(t1) NoTidScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
--
-- /*+IndexScan(t1)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+IndexScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+IndexScan(t1) SeqScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+IndexScan(t1) IndexScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+IndexScan(t1) BitmapScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+IndexScan(t1) TidScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+IndexScan(t1) NoSeqScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+IndexScan(t1) NoIndexScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+IndexScan(t1) NoBitmapScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+IndexScan(t1) NoTidScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
--
-- /*+BitmapScan(t1)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+BitmapScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+BitmapScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+BitmapScan(t1) SeqScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+BitmapScan(t1) IndexScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+BitmapScan(t1) BitmapScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+BitmapScan(t1) TidScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+BitmapScan(t1) NoSeqScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+BitmapScan(t1) NoIndexScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+BitmapScan(t1) NoBitmapScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+BitmapScan(t1) NoTidScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
--
-- /*+TidScan(t1)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+TidScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+TidScan(t1) SeqScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+TidScan(t1) IndexScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+TidScan(t1) BitmapScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+TidScan(t1) TidScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+TidScan(t1) NoSeqScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+TidScan(t1) NoIndexScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+TidScan(t1) NoBitmapScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+TidScan(t1) NoTidScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
--
-- /*+NoSeqScan(t1)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoSeqScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoSeqScan(t1) SeqScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoSeqScan(t1) IndexScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoSeqScan(t1) BitmapScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoSeqScan(t1) TidScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoSeqScan(t1) NoSeqScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoSeqScan(t1) NoIndexScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoSeqScan(t1) NoBitmapScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoSeqScan(t1) NoTidScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
--
-- /*+NoIndexScan(t1)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoIndexScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoIndexScan(t1) SeqScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoIndexScan(t1) IndexScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoIndexScan(t1) BitmapScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoIndexScan(t1) TidScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoIndexScan(t1) NoSeqScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoIndexScan(t1) NoIndexScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoIndexScan(t1) NoBitmapScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoIndexScan(t1) NoTidScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
--
-- /*+NoBitmapScan(t1)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoBitmapScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoBitmapScan(t1) SeqScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoBitmapScan(t1) IndexScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoBitmapScan(t1) BitmapScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoBitmapScan(t1) TidScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoBitmapScan(t1) NoSeqScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoBitmapScan(t1) NoIndexScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoBitmapScan(t1) NoBitmapScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoBitmapScan(t1) NoTidScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
--
-- /*+NoTidScan(t1)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoTidScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoTidScan(t1) SeqScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoTidScan(t1) IndexScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoTidScan(t1) BitmapScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoTidScan(t1) TidScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoTidScan(t1) NoSeqScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoTidScan(t1) NoIndexScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoTidScan(t1) NoBitmapScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
-- /*+NoTidScan(t1) NoTidScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
--
-- -- additional test
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)' AND t1.id < 10 AND t2.id < 10;
-- /*+BitmapScan(t1) BitmapScan(t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)' AND t1.id < 10 AND t2.id < 10;
--
-- -- outer join test
-- EXPLAIN (COSTS false) SELECT * FROM t1 FULL OUTER JOIN  t2 ON (t1.id = t2.id);
-- /*+MergeJoin(t1 t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1 FULL OUTER JOIN  t2 ON (t1.id = t2.id);
-- -- Cannot work
-- /*+NestLoop(t1 t2)*/
-- EXPLAIN (COSTS false) SELECT * FROM t1 FULL OUTER JOIN  t2 ON (t1.id = t2.id);
--
-- -- inheritance tables test
-- SET constraint_exclusion TO off;
-- EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
-- SET constraint_exclusion TO on;
-- EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
-- SET constraint_exclusion TO off;
-- /*+SeqScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
-- /*+IndexScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
-- /*+BitmapScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
-- /*+TidScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
-- SET constraint_exclusion TO on;
-- /*+SeqScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
-- /*+IndexScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
-- /*+BitmapScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
-- /*+TidScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
--
-- SET constraint_exclusion TO off;
-- EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
-- SET constraint_exclusion TO on;
-- EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
-- SET constraint_exclusion TO off;
-- /*+SeqScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
-- /*+IndexScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
-- /*+BitmapScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
-- /*+TidScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
-- /*+NestLoop(p1 t1)*/
-- EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
-- /*+MergeJoin(p1 t1)*/
-- EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
-- /*+HashJoin(p1 t1)*/
-- EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
-- SET constraint_exclusion TO on;
-- /*+SeqScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
-- /*+IndexScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
-- /*+BitmapScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
-- /*+TidScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
-- /*+NestLoop(p1 t1)*/
-- EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
-- /*+MergeJoin(p1 t1)*/
-- EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
-- /*+HashJoin(p1 t1)*/
-- EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
--
-- SET constraint_exclusion TO off;
-- EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
-- SET constraint_exclusion TO on;
-- EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
-- SET constraint_exclusion TO off;
-- /*+SeqScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
-- /*+IndexScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
-- /*+BitmapScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
-- /*+TidScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
-- /*+NestLoop(p1 t1)*/
-- EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
-- /*+MergeJoin(p1 t1)*/
-- EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
-- /*+HashJoin(p1 t1)*/
-- EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
-- SET constraint_exclusion TO on;
-- /*+SeqScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
-- /*+IndexScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
-- /*+BitmapScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
-- /*+TidScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
-- /*+NestLoop(p1 t1)*/
-- EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
-- /*+MergeJoin(p1 t1)*/
-- EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
-- /*+HashJoin(p1 t1)*/
-- EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
--
-- SET constraint_exclusion TO off;
-- EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
-- SET constraint_exclusion TO on;
-- EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
-- SET constraint_exclusion TO off;
-- /*+SeqScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
-- /*+IndexScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
-- /*+BitmapScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
-- /*+TidScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
-- SET constraint_exclusion TO on;
-- /*+SeqScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
-- /*+IndexScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
-- /*+BitmapScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
-- /*+TidScan(p1)*/
-- EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
--
-- quote test
/*+SeqScan("""t1 )	")IndexScan("t	2 """)HashJoin("""t1 )	"T3"t	2 """)Leading("""t1 )	"T3"t	2 """)Set(application_name"a	a	a""	a	A")*/
EXPLAIN (COSTS false) SELECT * FROM t1 """t1 )	", t2 "t	2 """, t3 "T3" WHERE """t1 )	".id = "t	2 """.id AND """t1 )	".id = "T3".id;
LOG:  pg_hint_plan:
used hint:
SeqScan("""t1 )	")
IndexScan("t	2 """)
HashJoin("""t1 )	" T3 "t	2 """)
Leading("""t1 )	" T3 "t	2 """)
Set(application_name "a	a	a""	a	A")
not used hint:
duplication hint:
error hint:

                                 QUERY PLAN
-----------------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: ("""t1 ) ".id = "t       2 """.id)
   ->  Hash Join
         Hash Cond: ("""t1 )     ".id = "T3".id)
         ->  Seq Scan on t1 """t1 )      "
         ->  Hash
               ->  Seq Scan on t3 "T3"
   ->  Index Scan using t2_pkey on t2 "t 2 """
         Index Cond: (id = ANY (ARRAY["""t1 )    ".id, $1, $2, ..., $1023]))
(9 rows)

-- duplicate hint test
/*+SeqScan(t1)SeqScan(t2)IndexScan(t1)IndexScan(t2)BitmapScan(t1)BitmapScan(t2)HashJoin(t1 t2)NestLoop(t2 t1)MergeJoin(t1 t2)Leading(t1 t2)Leading(t2 t1)Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
INFO:  pg_hint_plan: hint syntax error at or near "SeqScan(t1)SeqScan(t2)IndexScan(t1)IndexScan(t2)BitmapScan(t1)BitmapScan(t2)HashJoin(t1 t2)NestLoop(t2 t1)MergeJoin(t1 t2)Leading(t1 t2)Leading(t2 t1)Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)"
DETAIL:  Conflict scan method hint.
INFO:  pg_hint_plan: hint syntax error at or near "IndexScan(t1)IndexScan(t2)BitmapScan(t1)BitmapScan(t2)HashJoin(t1 t2)NestLoop(t2 t1)MergeJoin(t1 t2)Leading(t1 t2)Leading(t2 t1)Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)"
DETAIL:  Conflict scan method hint.
INFO:  pg_hint_plan: hint syntax error at or near "SeqScan(t2)IndexScan(t1)IndexScan(t2)BitmapScan(t1)BitmapScan(t2)HashJoin(t1 t2)NestLoop(t2 t1)MergeJoin(t1 t2)Leading(t1 t2)Leading(t2 t1)Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)"
DETAIL:  Conflict scan method hint.
INFO:  pg_hint_plan: hint syntax error at or near "IndexScan(t2)BitmapScan(t1)BitmapScan(t2)HashJoin(t1 t2)NestLoop(t2 t1)MergeJoin(t1 t2)Leading(t1 t2)Leading(t2 t1)Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)"
DETAIL:  Conflict scan method hint.
INFO:  pg_hint_plan: hint syntax error at or near "HashJoin(t1 t2)NestLoop(t2 t1)MergeJoin(t1 t2)Leading(t1 t2)Leading(t2 t1)Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)"
DETAIL:  Conflict join method hint.
INFO:  pg_hint_plan: hint syntax error at or near "NestLoop(t2 t1)MergeJoin(t1 t2)Leading(t1 t2)Leading(t2 t1)Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)"
DETAIL:  Conflict join method hint.
INFO:  pg_hint_plan: hint syntax error at or near "Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)"
DETAIL:  Conflict set hint.
INFO:  pg_hint_plan: hint syntax error at or near "Leading(t1 t2)Leading(t2 t1)Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)"
DETAIL:  Conflict leading hint.
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
BitmapScan(t2)
MergeJoin(t1 t2)
Leading(t2 t1)
Set(enable_mergejoin on)
Set(enable_seqscan on)
not used hint:
duplication hint:
SeqScan(t1)
IndexScan(t1)
SeqScan(t2)
IndexScan(t2)
HashJoin(t1 t2)
NestLoop(t1 t2)
Leading(t1 t2)
Set(enable_seqscan off)
error hint:

          QUERY PLAN
-------------------------------
 Merge Join
   Merge Cond: (t1.id = t2.id)
   ->  Sort
         Sort Key: t1.id
         ->  Seq Scan on t1
   ->  Sort
         Sort Key: t2.id
         ->  Seq Scan on t2
(8 rows)

-- sub query Leading hint test
SET from_collapse_limit TO 100;
SET geqo_threshold TO 100;
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id
);
                                          QUERY PLAN
-----------------------------------------------------------------------------------------------
 Nested Loop
   CTE c1_1
     ->  Aggregate
           ->  YB Batched Nested Loop Join
                 Join Filter: (t1_5.id = t2_5.id)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t1_5.id = t3_5.id)
                       ->  Seq Scan on t3 t3_5
                       ->  Index Scan using t1_pkey on t1 t1_5
                             Index Cond: (id = ANY (ARRAY[t3_5.id, $1, $2, ..., $1023]))
                 ->  Index Scan using t2_pkey on t2 t2_5
                       Index Cond: (id = ANY (ARRAY[t1_5.id, $1025, $1026, ..., $2047]))
   InitPlan 2 (returns $4097)
     ->  Aggregate
           ->  YB Batched Nested Loop Join
                 Join Filter: (t1_2.id = t2_2.id)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t1_2.id = t3_2.id)
                       ->  Seq Scan on t3 t3_2
                       ->  Index Scan using t1_pkey on t1 t1_2
                             Index Cond: (id = ANY (ARRAY[t3_2.id, $2050, $2051, ..., $3072]))
                 ->  Index Scan using t2_pkey on t2 t2_2
                       Index Cond: (id = ANY (ARRAY[t1_2.id, $3074, $3075, ..., $4096]))
   InitPlan 3 (returns $6146)
     ->  Aggregate
           ->  YB Batched Nested Loop Join
                 Join Filter: (t1_4.id = t2_4.id)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t1_4.id = t3_4.id)
                       ->  Seq Scan on t3 t3_4
                       ->  Index Scan using t1_pkey on t1 t1_4
                             Index Cond: (id = ANY (ARRAY[t3_4.id, $4099, $4100, ..., $5121]))
                 ->  Index Scan using t2_pkey on t2 t2_4
                       Index Cond: (id = ANY (ARRAY[t1_4.id, $5123, $5124, ..., $6145]))
   ->  Index Scan using t1_pkey on t1 t1_3
         Index Cond: (id = $6146)
   ->  Nested Loop
         ->  Index Scan using t1_pkey on t1 t1_1
               Index Cond: (id = $6146)
         ->  Nested Loop
               ->  Index Scan using t2_pkey on t2 t2_3
                     Index Cond: (id = $6146)
               ->  Nested Loop
                     ->  Index Scan using t2_pkey on t2 t2_1
                           Index Cond: (id = $6146)
                     ->  Nested Loop
                           ->  Index Scan using t3_pkey on t3 t3_3
                                 Index Cond: (id = $6146)
                           ->  Nested Loop
                                 ->  Index Scan using t3_pkey on t3 t3_1
                                       Index Cond: (id = $6146)
                                 ->  CTE Scan on c1_1
                                       Filter: (id = $6146)
(53 rows)

/*+HashJoin(t1_1 t3_1)MergeJoin(t1_3 t3_3)NestLoop(t1_2 t2_2)NestLoop(t1_4 t2_4)NestLoop(t1_5 t2_5)*/
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id
);
LOG:  pg_hint_plan:
used hint:
HashJoin(t1_1 t3_1)
NestLoop(t1_2 t2_2)
MergeJoin(t1_3 t3_3)
NestLoop(t1_4 t2_4)
NestLoop(t1_5 t2_5)
not used hint:
duplication hint:
error hint:

                                          QUERY PLAN
-----------------------------------------------------------------------------------------------
 Nested Loop
   CTE c1_1
     ->  Aggregate
           ->  YB Batched Nested Loop Join
                 Join Filter: (t1_5.id = t2_5.id)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t1_5.id = t3_5.id)
                       ->  Seq Scan on t3 t3_5
                       ->  Index Scan using t1_pkey on t1 t1_5
                             Index Cond: (id = ANY (ARRAY[t3_5.id, $1, $2, ..., $1023]))
                 ->  Index Scan using t2_pkey on t2 t2_5
                       Index Cond: (id = ANY (ARRAY[t1_5.id, $1025, $1026, ..., $2047]))
   InitPlan 2 (returns $4097)
     ->  Aggregate
           ->  YB Batched Nested Loop Join
                 Join Filter: (t1_2.id = t2_2.id)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t1_2.id = t3_2.id)
                       ->  Seq Scan on t3 t3_2
                       ->  Index Scan using t1_pkey on t1 t1_2
                             Index Cond: (id = ANY (ARRAY[t3_2.id, $2050, $2051, ..., $3072]))
                 ->  Index Scan using t2_pkey on t2 t2_2
                       Index Cond: (id = ANY (ARRAY[t1_2.id, $3074, $3075, ..., $4096]))
   InitPlan 3 (returns $6146)
     ->  Aggregate
           ->  YB Batched Nested Loop Join
                 Join Filter: (t1_4.id = t2_4.id)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t1_4.id = t3_4.id)
                       ->  Seq Scan on t3 t3_4
                       ->  Index Scan using t1_pkey on t1 t1_4
                             Index Cond: (id = ANY (ARRAY[t3_4.id, $4099, $4100, ..., $5121]))
                 ->  Index Scan using t2_pkey on t2 t2_4
                       Index Cond: (id = ANY (ARRAY[t1_4.id, $5123, $5124, ..., $6145]))
   ->  Index Scan using t1_pkey on t1 t1_3
         Index Cond: (id = $6146)
   ->  Nested Loop
         ->  Index Scan using t1_pkey on t1 t1_1
               Index Cond: (id = $6146)
         ->  Nested Loop
               ->  Index Scan using t2_pkey on t2 t2_3
                     Index Cond: (id = $6146)
               ->  Nested Loop
                     ->  Index Scan using t2_pkey on t2 t2_1
                           Index Cond: (id = $6146)
                     ->  Nested Loop
                           ->  Index Scan using t3_pkey on t3 t3_3
                                 Index Cond: (id = $6146)
                           ->  Nested Loop
                                 ->  Index Scan using t3_pkey on t3 t3_1
                                       Index Cond: (id = $6146)
                                 ->  CTE Scan on c1_1
                                       Filter: (id = $6146)
(53 rows)

/*+HashJoin(t1_1 t3_1)MergeJoin(t1_3 t3_3)NestLoop(t1_2 t2_2)NestLoop(t1_4 t2_4)NestLoop(t1_5 t2_5)Leading(a t1_1 t1_2 t1_4 t1_5)*/
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id
);
LOG:  pg_hint_plan:
used hint:
HashJoin(t1_1 t3_1)
NestLoop(t1_2 t2_2)
MergeJoin(t1_3 t3_3)
NestLoop(t1_4 t2_4)
NestLoop(t1_5 t2_5)
not used hint:
Leading(a t1_1 t1_2 t1_4 t1_5)
duplication hint:
error hint:

                                          QUERY PLAN
-----------------------------------------------------------------------------------------------
 Nested Loop
   CTE c1_1
     ->  Aggregate
           ->  YB Batched Nested Loop Join
                 Join Filter: (t1_5.id = t2_5.id)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t1_5.id = t3_5.id)
                       ->  Seq Scan on t3 t3_5
                       ->  Index Scan using t1_pkey on t1 t1_5
                             Index Cond: (id = ANY (ARRAY[t3_5.id, $1, $2, ..., $1023]))
                 ->  Index Scan using t2_pkey on t2 t2_5
                       Index Cond: (id = ANY (ARRAY[t1_5.id, $1025, $1026, ..., $2047]))
   InitPlan 2 (returns $4097)
     ->  Aggregate
           ->  YB Batched Nested Loop Join
                 Join Filter: (t1_2.id = t2_2.id)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t1_2.id = t3_2.id)
                       ->  Seq Scan on t3 t3_2
                       ->  Index Scan using t1_pkey on t1 t1_2
                             Index Cond: (id = ANY (ARRAY[t3_2.id, $2050, $2051, ..., $3072]))
                 ->  Index Scan using t2_pkey on t2 t2_2
                       Index Cond: (id = ANY (ARRAY[t1_2.id, $3074, $3075, ..., $4096]))
   InitPlan 3 (returns $6146)
     ->  Aggregate
           ->  YB Batched Nested Loop Join
                 Join Filter: (t1_4.id = t2_4.id)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t1_4.id = t3_4.id)
                       ->  Seq Scan on t3 t3_4
                       ->  Index Scan using t1_pkey on t1 t1_4
                             Index Cond: (id = ANY (ARRAY[t3_4.id, $4099, $4100, ..., $5121]))
                 ->  Index Scan using t2_pkey on t2 t2_4
                       Index Cond: (id = ANY (ARRAY[t1_4.id, $5123, $5124, ..., $6145]))
   ->  Index Scan using t1_pkey on t1 t1_3
         Index Cond: (id = $6146)
   ->  Nested Loop
         ->  Index Scan using t1_pkey on t1 t1_1
               Index Cond: (id = $6146)
         ->  Nested Loop
               ->  Index Scan using t2_pkey on t2 t2_3
                     Index Cond: (id = $6146)
               ->  Nested Loop
                     ->  Index Scan using t2_pkey on t2 t2_1
                           Index Cond: (id = $6146)
                     ->  Nested Loop
                           ->  Index Scan using t3_pkey on t3 t3_3
                                 Index Cond: (id = $6146)
                           ->  Nested Loop
                                 ->  Index Scan using t3_pkey on t3 t3_1
                                       Index Cond: (id = $6146)
                                 ->  CTE Scan on c1_1
                                       Filter: (id = $6146)
(53 rows)

/*+HashJoin(t1_1 t3_1)MergeJoin(t1_3 t3_3)NestLoop(t1_2 t2_2)NestLoop(t1_4 t2_4)NestLoop(t1_5 t2_5)Leading(a t3_2 t3_5 t2_2 c1_1 t3_4 t3_3 t2_3 t2_4 t1_3 t2_5 t1_2 t3_1 t1_4 t2_1 t1_5 t1_1)*/
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id
);
LOG:  pg_hint_plan:
used hint:
HashJoin(t1_1 t3_1)
NestLoop(t1_2 t2_2)
MergeJoin(t1_3 t3_3)
NestLoop(t1_4 t2_4)
NestLoop(t1_5 t2_5)
not used hint:
Leading(a t3_2 t3_5 t2_2 c1_1 t3_4 t3_3 t2_3 t2_4 t1_3 t2_5 t1_2 t3_1 t1_4 t2_1 t1_5 t1_1)
duplication hint:
error hint:

                                          QUERY PLAN
-----------------------------------------------------------------------------------------------
 Nested Loop
   CTE c1_1
     ->  Aggregate
           ->  YB Batched Nested Loop Join
                 Join Filter: (t1_5.id = t2_5.id)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t1_5.id = t3_5.id)
                       ->  Seq Scan on t3 t3_5
                       ->  Index Scan using t1_pkey on t1 t1_5
                             Index Cond: (id = ANY (ARRAY[t3_5.id, $1, $2, ..., $1023]))
                 ->  Index Scan using t2_pkey on t2 t2_5
                       Index Cond: (id = ANY (ARRAY[t1_5.id, $1025, $1026, ..., $2047]))
   InitPlan 2 (returns $4097)
     ->  Aggregate
           ->  YB Batched Nested Loop Join
                 Join Filter: (t1_2.id = t2_2.id)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t1_2.id = t3_2.id)
                       ->  Seq Scan on t3 t3_2
                       ->  Index Scan using t1_pkey on t1 t1_2
                             Index Cond: (id = ANY (ARRAY[t3_2.id, $2050, $2051, ..., $3072]))
                 ->  Index Scan using t2_pkey on t2 t2_2
                       Index Cond: (id = ANY (ARRAY[t1_2.id, $3074, $3075, ..., $4096]))
   InitPlan 3 (returns $6146)
     ->  Aggregate
           ->  YB Batched Nested Loop Join
                 Join Filter: (t1_4.id = t2_4.id)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t1_4.id = t3_4.id)
                       ->  Seq Scan on t3 t3_4
                       ->  Index Scan using t1_pkey on t1 t1_4
                             Index Cond: (id = ANY (ARRAY[t3_4.id, $4099, $4100, ..., $5121]))
                 ->  Index Scan using t2_pkey on t2 t2_4
                       Index Cond: (id = ANY (ARRAY[t1_4.id, $5123, $5124, ..., $6145]))
   ->  Index Scan using t1_pkey on t1 t1_3
         Index Cond: (id = $6146)
   ->  Nested Loop
         ->  Index Scan using t1_pkey on t1 t1_1
               Index Cond: (id = $6146)
         ->  Nested Loop
               ->  Index Scan using t2_pkey on t2 t2_3
                     Index Cond: (id = $6146)
               ->  Nested Loop
                     ->  Index Scan using t2_pkey on t2 t2_1
                           Index Cond: (id = $6146)
                     ->  Nested Loop
                           ->  Index Scan using t3_pkey on t3 t3_3
                                 Index Cond: (id = $6146)
                           ->  Nested Loop
                                 ->  Index Scan using t3_pkey on t3 t3_1
                                       Index Cond: (id = $6146)
                                 ->  CTE Scan on c1_1
                                       Filter: (id = $6146)
(53 rows)

/*+HashJoin(t1_1 t3_1)MergeJoin(t1_3 t3_3)NestLoop(t1_2 t2_2)NestLoop(t1_4 t2_4)NestLoop(t1_5 t2_5)Leading(t3_5 t2_5 t1_5)Leading(t3_2 t2_2 t1_2)Leading(t3_4 t2_4 t1_4)Leading(c1_1 t3_3 t2_3 t1_3 t3_1 t2_1 t1_1)*/
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id
);
LOG:  pg_hint_plan:
used hint:
Leading(t3_5 t2_5 t1_5)
Leading(t3_2 t2_2 t1_2)
Leading(t3_4 t2_4 t1_4)
Leading(c1_1 t3_3 t2_3 t1_3 t3_1 t2_1 t1_1)
not used hint:
HashJoin(t1_1 t3_1)
NestLoop(t1_2 t2_2)
MergeJoin(t1_3 t3_3)
NestLoop(t1_4 t2_4)
NestLoop(t1_5 t2_5)
duplication hint:
error hint:

                                          QUERY PLAN
-----------------------------------------------------------------------------------------------
 Nested Loop
   CTE c1_1
     ->  Aggregate
           ->  YB Batched Nested Loop Join
                 Join Filter: (t2_5.id = t1_5.id)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t2_5.id = t3_5.id)
                       ->  Seq Scan on t3 t3_5
                       ->  Index Scan using t2_pkey on t2 t2_5
                             Index Cond: (id = ANY (ARRAY[t3_5.id, $1, $2, ..., $1023]))
                 ->  Index Scan using t1_pkey on t1 t1_5
                       Index Cond: (id = ANY (ARRAY[t2_5.id, $1025, $1026, ..., $2047]))
   InitPlan 2 (returns $4097)
     ->  Aggregate
           ->  YB Batched Nested Loop Join
                 Join Filter: (t2_2.id = t1_2.id)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t2_2.id = t3_2.id)
                       ->  Seq Scan on t3 t3_2
                       ->  Index Scan using t2_pkey on t2 t2_2
                             Index Cond: (id = ANY (ARRAY[t3_2.id, $2050, $2051, ..., $3072]))
                 ->  Index Scan using t1_pkey on t1 t1_2
                       Index Cond: (id = ANY (ARRAY[t2_2.id, $3074, $3075, ..., $4096]))
   InitPlan 3 (returns $6146)
     ->  Aggregate
           ->  YB Batched Nested Loop Join
                 Join Filter: (t2_4.id = t1_4.id)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t2_4.id = t3_4.id)
                       ->  Seq Scan on t3 t3_4
                       ->  Index Scan using t2_pkey on t2 t2_4
                             Index Cond: (id = ANY (ARRAY[t3_4.id, $4099, $4100, ..., $5121]))
                 ->  Index Scan using t1_pkey on t1 t1_4
                       Index Cond: (id = ANY (ARRAY[t2_4.id, $5123, $5124, ..., $6145]))
   ->  Index Scan using t1_pkey on t1 t1_1
         Index Cond: (id = $6146)
   ->  Nested Loop
         ->  Index Scan using t2_pkey on t2 t2_1
               Index Cond: (id = $6146)
         ->  Nested Loop
               ->  Index Scan using t3_pkey on t3 t3_1
                     Index Cond: (id = $6146)
               ->  Nested Loop
                     ->  Index Scan using t1_pkey on t1 t1_3
                           Index Cond: (id = $6146)
                     ->  Nested Loop
                           ->  Index Scan using t2_pkey on t2 t2_3
                                 Index Cond: (id = $6146)
                           ->  Nested Loop
                                 ->  Index Scan using t3_pkey on t3 t3_3
                                       Index Cond: (id = $6146)
                                 ->  CTE Scan on c1_1
                                       Filter: (id = $6146)
(53 rows)

SET from_collapse_limit TO 1;
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id
);
                                          QUERY PLAN
-----------------------------------------------------------------------------------------------
 Nested Loop
   CTE c1_1
     ->  Aggregate
           ->  YB Batched Nested Loop Join
                 Join Filter: (t1_5.id = t2_5.id)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t1_5.id = t3_5.id)
                       ->  Seq Scan on t3 t3_5
                       ->  Index Scan using t1_pkey on t1 t1_5
                             Index Cond: (id = ANY (ARRAY[t3_5.id, $1, $2, ..., $1023]))
                 ->  Index Scan using t2_pkey on t2 t2_5
                       Index Cond: (id = ANY (ARRAY[t1_5.id, $1025, $1026, ..., $2047]))
   InitPlan 2 (returns $4097)
     ->  Aggregate
           ->  YB Batched Nested Loop Join
                 Join Filter: (t1_2.id = t2_2.id)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t1_2.id = t3_2.id)
                       ->  Seq Scan on t3 t3_2
                       ->  Index Scan using t1_pkey on t1 t1_2
                             Index Cond: (id = ANY (ARRAY[t3_2.id, $2050, $2051, ..., $3072]))
                 ->  Index Scan using t2_pkey on t2 t2_2
                       Index Cond: (id = ANY (ARRAY[t1_2.id, $3074, $3075, ..., $4096]))
   InitPlan 3 (returns $6146)
     ->  Aggregate
           ->  YB Batched Nested Loop Join
                 Join Filter: (t1_4.id = t2_4.id)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t1_4.id = t3_4.id)
                       ->  Seq Scan on t3 t3_4
                       ->  Index Scan using t1_pkey on t1 t1_4
                             Index Cond: (id = ANY (ARRAY[t3_4.id, $4099, $4100, ..., $5121]))
                 ->  Index Scan using t2_pkey on t2 t2_4
                       Index Cond: (id = ANY (ARRAY[t1_4.id, $5123, $5124, ..., $6145]))
   ->  Index Scan using t1_pkey on t1 t1_1
         Index Cond: (id = $6146)
   ->  Nested Loop
         ->  Index Scan using t2_pkey on t2 t2_1
               Index Cond: (id = $6146)
         ->  Nested Loop
               ->  Index Scan using t3_pkey on t3 t3_1
                     Index Cond: (id = $6146)
               ->  Nested Loop
                     ->  CTE Scan on c1_1
                           Filter: (id = $6146)
                     ->  Nested Loop
                           ->  Index Scan using t1_pkey on t1 t1_3
                                 Index Cond: (id = $6146)
                           ->  Nested Loop
                                 ->  Index Scan using t2_pkey on t2 t2_3
                                       Index Cond: (id = $6146)
                                 ->  Index Scan using t3_pkey on t3 t3_3
                                       Index Cond: (id = $6146)
(53 rows)

/*+HashJoin(t1_1 t3_1)MergeJoin(t1_3 t3_3)NestLoop(t1_2 t2_2)NestLoop(t1_4 t2_4)NestLoop(t1_5 t2_5)*/
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id
);
LOG:  pg_hint_plan:
used hint:
HashJoin(t1_1 t3_1)
NestLoop(t1_2 t2_2)
MergeJoin(t1_3 t3_3)
NestLoop(t1_4 t2_4)
NestLoop(t1_5 t2_5)
not used hint:
duplication hint:
error hint:

                                          QUERY PLAN
-----------------------------------------------------------------------------------------------
 Nested Loop
   CTE c1_1
     ->  Aggregate
           ->  YB Batched Nested Loop Join
                 Join Filter: (t1_5.id = t2_5.id)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t1_5.id = t3_5.id)
                       ->  Seq Scan on t3 t3_5
                       ->  Index Scan using t1_pkey on t1 t1_5
                             Index Cond: (id = ANY (ARRAY[t3_5.id, $1, $2, ..., $1023]))
                 ->  Index Scan using t2_pkey on t2 t2_5
                       Index Cond: (id = ANY (ARRAY[t1_5.id, $1025, $1026, ..., $2047]))
   InitPlan 2 (returns $4097)
     ->  Aggregate
           ->  YB Batched Nested Loop Join
                 Join Filter: (t1_2.id = t2_2.id)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t1_2.id = t3_2.id)
                       ->  Seq Scan on t3 t3_2
                       ->  Index Scan using t1_pkey on t1 t1_2
                             Index Cond: (id = ANY (ARRAY[t3_2.id, $2050, $2051, ..., $3072]))
                 ->  Index Scan using t2_pkey on t2 t2_2
                       Index Cond: (id = ANY (ARRAY[t1_2.id, $3074, $3075, ..., $4096]))
   InitPlan 3 (returns $6146)
     ->  Aggregate
           ->  YB Batched Nested Loop Join
                 Join Filter: (t1_4.id = t2_4.id)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t1_4.id = t3_4.id)
                       ->  Seq Scan on t3 t3_4
                       ->  Index Scan using t1_pkey on t1 t1_4
                             Index Cond: (id = ANY (ARRAY[t3_4.id, $4099, $4100, ..., $5121]))
                 ->  Index Scan using t2_pkey on t2 t2_4
                       Index Cond: (id = ANY (ARRAY[t1_4.id, $5123, $5124, ..., $6145]))
   ->  Index Scan using t1_pkey on t1 t1_1
         Index Cond: (id = $6146)
   ->  Nested Loop
         ->  Index Scan using t2_pkey on t2 t2_1
               Index Cond: (id = $6146)
         ->  Nested Loop
               ->  Index Scan using t3_pkey on t3 t3_1
                     Index Cond: (id = $6146)
               ->  Nested Loop
                     ->  CTE Scan on c1_1
                           Filter: (id = $6146)
                     ->  Nested Loop
                           ->  Index Scan using t1_pkey on t1 t1_3
                                 Index Cond: (id = $6146)
                           ->  Nested Loop
                                 ->  Index Scan using t2_pkey on t2 t2_3
                                       Index Cond: (id = $6146)
                                 ->  Index Scan using t3_pkey on t3 t3_3
                                       Index Cond: (id = $6146)
(53 rows)

/*+HashJoin(t1_1 t3_1)MergeJoin(t1_3 t3_3)NestLoop(t1_2 t2_2)NestLoop(t1_4 t2_4)NestLoop(t1_5 t2_5)Leading(a t1_1 t1_2 t1_4 t1_5)*/
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id
);
LOG:  pg_hint_plan:
used hint:
HashJoin(t1_1 t3_1)
NestLoop(t1_2 t2_2)
MergeJoin(t1_3 t3_3)
NestLoop(t1_4 t2_4)
NestLoop(t1_5 t2_5)
not used hint:
Leading(a t1_1 t1_2 t1_4 t1_5)
duplication hint:
error hint:

                                          QUERY PLAN
-----------------------------------------------------------------------------------------------
 Nested Loop
   CTE c1_1
     ->  Aggregate
           ->  YB Batched Nested Loop Join
                 Join Filter: (t1_5.id = t2_5.id)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t1_5.id = t3_5.id)
                       ->  Seq Scan on t3 t3_5
                       ->  Index Scan using t1_pkey on t1 t1_5
                             Index Cond: (id = ANY (ARRAY[t3_5.id, $1, $2, ..., $1023]))
                 ->  Index Scan using t2_pkey on t2 t2_5
                       Index Cond: (id = ANY (ARRAY[t1_5.id, $1025, $1026, ..., $2047]))
   InitPlan 2 (returns $4097)
     ->  Aggregate
           ->  YB Batched Nested Loop Join
                 Join Filter: (t1_2.id = t2_2.id)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t1_2.id = t3_2.id)
                       ->  Seq Scan on t3 t3_2
                       ->  Index Scan using t1_pkey on t1 t1_2
                             Index Cond: (id = ANY (ARRAY[t3_2.id, $2050, $2051, ..., $3072]))
                 ->  Index Scan using t2_pkey on t2 t2_2
                       Index Cond: (id = ANY (ARRAY[t1_2.id, $3074, $3075, ..., $4096]))
   InitPlan 3 (returns $6146)
     ->  Aggregate
           ->  YB Batched Nested Loop Join
                 Join Filter: (t1_4.id = t2_4.id)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t1_4.id = t3_4.id)
                       ->  Seq Scan on t3 t3_4
                       ->  Index Scan using t1_pkey on t1 t1_4
                             Index Cond: (id = ANY (ARRAY[t3_4.id, $4099, $4100, ..., $5121]))
                 ->  Index Scan using t2_pkey on t2 t2_4
                       Index Cond: (id = ANY (ARRAY[t1_4.id, $5123, $5124, ..., $6145]))
   ->  Index Scan using t1_pkey on t1 t1_1
         Index Cond: (id = $6146)
   ->  Nested Loop
         ->  Index Scan using t2_pkey on t2 t2_1
               Index Cond: (id = $6146)
         ->  Nested Loop
               ->  Index Scan using t3_pkey on t3 t3_1
                     Index Cond: (id = $6146)
               ->  Nested Loop
                     ->  CTE Scan on c1_1
                           Filter: (id = $6146)
                     ->  Nested Loop
                           ->  Index Scan using t1_pkey on t1 t1_3
                                 Index Cond: (id = $6146)
                           ->  Nested Loop
                                 ->  Index Scan using t2_pkey on t2 t2_3
                                       Index Cond: (id = $6146)
                                 ->  Index Scan using t3_pkey on t3 t3_3
                                       Index Cond: (id = $6146)
(53 rows)

/*+HashJoin(t1_1 t3_1)MergeJoin(t1_3 t3_3)NestLoop(t1_2 t2_2)NestLoop(t1_4 t2_4)NestLoop(t1_5 t2_5)Leading(a t3_2 t3_5 t2_2 c1_1 t3_4 t3_3 t2_3 t2_4 t1_3 t2_5 t1_2 t3_1 t1_4 t2_1 t1_5 t1_1)*/
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id
);
LOG:  pg_hint_plan:
used hint:
HashJoin(t1_1 t3_1)
NestLoop(t1_2 t2_2)
MergeJoin(t1_3 t3_3)
NestLoop(t1_4 t2_4)
NestLoop(t1_5 t2_5)
not used hint:
Leading(a t3_2 t3_5 t2_2 c1_1 t3_4 t3_3 t2_3 t2_4 t1_3 t2_5 t1_2 t3_1 t1_4 t2_1 t1_5 t1_1)
duplication hint:
error hint:

                                          QUERY PLAN
-----------------------------------------------------------------------------------------------
 Nested Loop
   CTE c1_1
     ->  Aggregate
           ->  YB Batched Nested Loop Join
                 Join Filter: (t1_5.id = t2_5.id)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t1_5.id = t3_5.id)
                       ->  Seq Scan on t3 t3_5
                       ->  Index Scan using t1_pkey on t1 t1_5
                             Index Cond: (id = ANY (ARRAY[t3_5.id, $1, $2, ..., $1023]))
                 ->  Index Scan using t2_pkey on t2 t2_5
                       Index Cond: (id = ANY (ARRAY[t1_5.id, $1025, $1026, ..., $2047]))
   InitPlan 2 (returns $4097)
     ->  Aggregate
           ->  YB Batched Nested Loop Join
                 Join Filter: (t1_2.id = t2_2.id)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t1_2.id = t3_2.id)
                       ->  Seq Scan on t3 t3_2
                       ->  Index Scan using t1_pkey on t1 t1_2
                             Index Cond: (id = ANY (ARRAY[t3_2.id, $2050, $2051, ..., $3072]))
                 ->  Index Scan using t2_pkey on t2 t2_2
                       Index Cond: (id = ANY (ARRAY[t1_2.id, $3074, $3075, ..., $4096]))
   InitPlan 3 (returns $6146)
     ->  Aggregate
           ->  YB Batched Nested Loop Join
                 Join Filter: (t1_4.id = t2_4.id)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t1_4.id = t3_4.id)
                       ->  Seq Scan on t3 t3_4
                       ->  Index Scan using t1_pkey on t1 t1_4
                             Index Cond: (id = ANY (ARRAY[t3_4.id, $4099, $4100, ..., $5121]))
                 ->  Index Scan using t2_pkey on t2 t2_4
                       Index Cond: (id = ANY (ARRAY[t1_4.id, $5123, $5124, ..., $6145]))
   ->  Index Scan using t1_pkey on t1 t1_1
         Index Cond: (id = $6146)
   ->  Nested Loop
         ->  Index Scan using t2_pkey on t2 t2_1
               Index Cond: (id = $6146)
         ->  Nested Loop
               ->  Index Scan using t3_pkey on t3 t3_1
                     Index Cond: (id = $6146)
               ->  Nested Loop
                     ->  CTE Scan on c1_1
                           Filter: (id = $6146)
                     ->  Nested Loop
                           ->  Index Scan using t1_pkey on t1 t1_3
                                 Index Cond: (id = $6146)
                           ->  Nested Loop
                                 ->  Index Scan using t2_pkey on t2 t2_3
                                       Index Cond: (id = $6146)
                                 ->  Index Scan using t3_pkey on t3 t3_3
                                       Index Cond: (id = $6146)
(53 rows)

/*+HashJoin(t1_1 t3_1)MergeJoin(t1_3 t3_3)NestLoop(t1_2 t2_2)NestLoop(t1_4 t2_4)NestLoop(t1_5 t2_5)Leading(t3_5 t2_5 t1_5)Leading(t3_2 t2_2 t1_2)Leading(t3_4 t2_4 t1_4)Leading(c1_1 t3_3 t2_3 t1_3 t3_1 t2_1 t1_1)*/
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id
);
LOG:  pg_hint_plan:
used hint:
MergeJoin(t1_3 t3_3)
Leading(t3_5 t2_5 t1_5)
Leading(t3_2 t2_2 t1_2)
Leading(t3_4 t2_4 t1_4)
Leading(c1_1 t3_3 t2_3 t1_3 t3_1 t2_1 t1_1)
not used hint:
HashJoin(t1_1 t3_1)
NestLoop(t1_2 t2_2)
NestLoop(t1_4 t2_4)
NestLoop(t1_5 t2_5)
duplication hint:
error hint:

                                          QUERY PLAN
-----------------------------------------------------------------------------------------------
 Nested Loop
   CTE c1_1
     ->  Aggregate
           ->  YB Batched Nested Loop Join
                 Join Filter: (t2_5.id = t1_5.id)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t2_5.id = t3_5.id)
                       ->  Seq Scan on t3 t3_5
                       ->  Index Scan using t2_pkey on t2 t2_5
                             Index Cond: (id = ANY (ARRAY[t3_5.id, $1, $2, ..., $1023]))
                 ->  Index Scan using t1_pkey on t1 t1_5
                       Index Cond: (id = ANY (ARRAY[t2_5.id, $1025, $1026, ..., $2047]))
   InitPlan 2 (returns $4097)
     ->  Aggregate
           ->  YB Batched Nested Loop Join
                 Join Filter: (t2_2.id = t1_2.id)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t2_2.id = t3_2.id)
                       ->  Seq Scan on t3 t3_2
                       ->  Index Scan using t2_pkey on t2 t2_2
                             Index Cond: (id = ANY (ARRAY[t3_2.id, $2050, $2051, ..., $3072]))
                 ->  Index Scan using t1_pkey on t1 t1_2
                       Index Cond: (id = ANY (ARRAY[t2_2.id, $3074, $3075, ..., $4096]))
   InitPlan 3 (returns $6146)
     ->  Aggregate
           ->  YB Batched Nested Loop Join
                 Join Filter: (t2_4.id = t1_4.id)
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t2_4.id = t3_4.id)
                       ->  Seq Scan on t3 t3_4
                       ->  Index Scan using t2_pkey on t2 t2_4
                             Index Cond: (id = ANY (ARRAY[t3_4.id, $4099, $4100, ..., $5121]))
                 ->  Index Scan using t1_pkey on t1 t1_4
                       Index Cond: (id = ANY (ARRAY[t2_4.id, $5123, $5124, ..., $6145]))
   ->  Index Scan using t1_pkey on t1 t1_1
         Index Cond: (id = $6146)
   ->  Nested Loop
         ->  Index Scan using t2_pkey on t2 t2_1
               Index Cond: (id = $6146)
         ->  Nested Loop
               ->  Index Scan using t3_pkey on t3 t3_1
                     Index Cond: (id = $6146)
               ->  Nested Loop
                     ->  CTE Scan on c1_1
                           Filter: (id = $6146)
                     ->  Nested Loop
                           ->  Index Scan using t1_pkey on t1 t1_3
                                 Index Cond: (id = $6146)
                           ->  Nested Loop
                                 ->  Index Scan using t2_pkey on t2 t2_3
                                       Index Cond: (id = $6146)
                                 ->  Index Scan using t3_pkey on t3 t3_3
                                       Index Cond: (id = $6146)
(53 rows)

-- ambigous error
EXPLAIN (COSTS false) SELECT * FROM t1, s0.t1, t2 WHERE public.t1.id = s0.t1.id AND public.t1.id = t2.id;
                                QUERY PLAN
---------------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t2.id)
   ->  YB Batched Nested Loop Join
         Join Filter: (t1.id = t1_1.id)
         ->  Seq Scan on t1 t1_1
         ->  Index Scan using t1_pkey on t1
               Index Cond: (id = ANY (ARRAY[t1_1.id, $1, $2, ..., $1023]))
   ->  Index Scan using t2_pkey on t2
         Index Cond: (id = ANY (ARRAY[t1.id, $1025, $1026, ..., $2047]))
(9 rows)

/*+NestLoop(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, s0.t1, t2 WHERE public.t1.id = s0.t1.id AND public.t1.id = t2.id;
INFO:  pg_hint_plan: hint syntax error at or near "NestLoop(t1 t2)"
DETAIL:  Relation name "t1" is ambiguous.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
NestLoop(t1 t2)

                                QUERY PLAN
---------------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t2.id)
   ->  YB Batched Nested Loop Join
         Join Filter: (t1.id = t1_1.id)
         ->  Seq Scan on t1 t1_1
         ->  Index Scan using t1_pkey on t1
               Index Cond: (id = ANY (ARRAY[t1_1.id, $1, $2, ..., $1023]))
   ->  Index Scan using t2_pkey on t2
         Index Cond: (id = ANY (ARRAY[t1.id, $1025, $1026, ..., $2047]))
(9 rows)

/*+Leading(t1 t2 t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, s0.t1, t2 WHERE public.t1.id = s0.t1.id AND public.t1.id = t2.id;
INFO:  pg_hint_plan: hint syntax error at or near "Leading(t1 t2 t1)"
DETAIL:  Relation name "t1" is ambiguous.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
Leading(t1 t2 t1)

                                QUERY PLAN
---------------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t2.id)
   ->  YB Batched Nested Loop Join
         Join Filter: (t1.id = t1_1.id)
         ->  Seq Scan on t1 t1_1
         ->  Index Scan using t1_pkey on t1
               Index Cond: (id = ANY (ARRAY[t1_1.id, $1, $2, ..., $1023]))
   ->  Index Scan using t2_pkey on t2
         Index Cond: (id = ANY (ARRAY[t1.id, $1025, $1026, ..., $2047]))
(9 rows)

-- identifier length test
EXPLAIN (COSTS false) SELECT * FROM t1 "123456789012345678901234567890123456789012345678901234567890123" JOIN t2 ON ("123456789012345678901234567890123456789012345678901234567890123".id = t2.id) JOIN t3 ON (t2.id = t3.id);
                                                               QUERY PLAN
----------------------------------------------------------------------------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: ("123456789012345678901234567890123456789012345678901234567890123".id = t2.id)
   ->  YB Batched Nested Loop Join
         Join Filter: ("123456789012345678901234567890123456789012345678901234567890123".id = t3.id)
         ->  Seq Scan on t3
         ->  Index Scan using t1_pkey on t1 "123456789012345678901234567890123456789012345678901234567890123"
               Index Cond: (id = ANY (ARRAY[t3.id, $1, $2, ..., $1023]))
   ->  Index Scan using t2_pkey on t2
         Index Cond: (id = ANY (ARRAY["123456789012345678901234567890123456789012345678901234567890123".id, $1025, $1026, ..., $2047]))
(9 rows)

/*+
Leading(123456789012345678901234567890123456789012345678901234567890123 t2 t3)
SeqScan(123456789012345678901234567890123456789012345678901234567890123)
MergeJoin(123456789012345678901234567890123456789012345678901234567890123 t2)
Set(123456789012345678901234567890123456789012345678901234567890123 1)
*/
EXPLAIN (COSTS false) SELECT * FROM t1 "123456789012345678901234567890123456789012345678901234567890123" JOIN t2 ON ("123456789012345678901234567890123456789012345678901234567890123".id = t2.id) JOIN t3 ON (t2.id = t3.id);
INFO:  unrecognized configuration parameter "123456789012345678901234567890123456789012345678901234567890123"
LOG:  pg_hint_plan:
used hint:
SeqScan(123456789012345678901234567890123456789012345678901234567890123)
MergeJoin(123456789012345678901234567890123456789012345678901234567890123 t2)
Leading(123456789012345678901234567890123456789012345678901234567890123 t2 t3)
not used hint:
duplication hint:
error hint:
Set(123456789012345678901234567890123456789012345678901234567890123 1)

                                             QUERY PLAN
----------------------------------------------------------------------------------------------------
 Merge Join
   Merge Cond: ("123456789012345678901234567890123456789012345678901234567890123".id = t3.id)
   ->  Merge Join
         Merge Cond: ("123456789012345678901234567890123456789012345678901234567890123".id = t2.id)
         ->  Sort
               Sort Key: "123456789012345678901234567890123456789012345678901234567890123".id
               ->  Seq Scan on t1 "123456789012345678901234567890123456789012345678901234567890123"
         ->  Sort
               Sort Key: t2.id
               ->  Seq Scan on t2
   ->  Sort
         Sort Key: t3.id
         ->  Seq Scan on t3
(13 rows)

/*+
Leading(1234567890123456789012345678901234567890123456789012345678901234 t2 t3)
SeqScan(1234567890123456789012345678901234567890123456789012345678901234)
MergeJoin(1234567890123456789012345678901234567890123456789012345678901234 t2)
Set(1234567890123456789012345678901234567890123456789012345678901234 1)
Set(cursor_tuple_fraction 0.1234567890123456789012345678901234567890123456789012345678901234)
*/
EXPLAIN (COSTS false) SELECT * FROM t1 "1234567890123456789012345678901234567890123456789012345678901234" JOIN t2 ON ("1234567890123456789012345678901234567890123456789012345678901234".id = t2.id) JOIN t3 ON (t2.id = t3.id);
NOTICE:  identifier "1234567890123456789012345678901234567890123456789012345678901234" will be truncated to "123456789012345678901234567890123456789012345678901234567890123"
NOTICE:  identifier "1234567890123456789012345678901234567890123456789012345678901234" will be truncated to "123456789012345678901234567890123456789012345678901234567890123"
NOTICE:  identifier "1234567890123456789012345678901234567890123456789012345678901234" will be truncated to "123456789012345678901234567890123456789012345678901234567890123"
NOTICE:  identifier "1234567890123456789012345678901234567890123456789012345678901234" will be truncated to "123456789012345678901234567890123456789012345678901234567890123"
NOTICE:  identifier "1234567890123456789012345678901234567890123456789012345678901234" will be truncated to "123456789012345678901234567890123456789012345678901234567890123"
NOTICE:  identifier "1234567890123456789012345678901234567890123456789012345678901234" will be truncated to "123456789012345678901234567890123456789012345678901234567890123"
INFO:  unrecognized configuration parameter "123456789012345678901234567890123456789012345678901234567890123"
LOG:  pg_hint_plan:
used hint:
SeqScan(123456789012345678901234567890123456789012345678901234567890123)
MergeJoin(123456789012345678901234567890123456789012345678901234567890123 t2)
Leading(123456789012345678901234567890123456789012345678901234567890123 t2 t3)
Set(cursor_tuple_fraction 0.1234567890123456789012345678901234567890123456789012345678901234)
not used hint:
duplication hint:
error hint:
Set(123456789012345678901234567890123456789012345678901234567890123 1)

                                             QUERY PLAN
----------------------------------------------------------------------------------------------------
 Merge Join
   Merge Cond: ("123456789012345678901234567890123456789012345678901234567890123".id = t3.id)
   ->  Merge Join
         Merge Cond: ("123456789012345678901234567890123456789012345678901234567890123".id = t2.id)
         ->  Sort
               Sort Key: "123456789012345678901234567890123456789012345678901234567890123".id
               ->  Seq Scan on t1 "123456789012345678901234567890123456789012345678901234567890123"
         ->  Sort
               Sort Key: t2.id
               ->  Seq Scan on t2
   ->  Sort
         Sort Key: t3.id
         ->  Seq Scan on t3
(13 rows)

SET "123456789012345678901234567890123456789012345678901234567890123" TO 1;
ERROR:  unrecognized configuration parameter "123456789012345678901234567890123456789012345678901234567890123"
SET "1234567890123456789012345678901234567890123456789012345678901234" TO 1;
NOTICE:  identifier "1234567890123456789012345678901234567890123456789012345678901234" will be truncated to "123456789012345678901234567890123456789012345678901234567890123"
ERROR:  unrecognized configuration parameter "123456789012345678901234567890123456789012345678901234567890123"
SET cursor_tuple_fraction TO 1234567890123456789012345678901234567890123456789012345678901234;
ERROR:  1.23457e+63 is outside the valid range for parameter "cursor_tuple_fraction" (0 .. 1)
-- multi error
/*+ Set(enable_seqscan 100)Set(seq_page_cost on)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
INFO:  parameter "enable_seqscan" requires a Boolean value
INFO:  parameter "seq_page_cost" requires a numeric value
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
Set(enable_seqscan 100)
Set(seq_page_cost on)

                            QUERY PLAN
-------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t2.id)
   ->  Seq Scan on t2
   ->  Index Scan using t1_pkey on t1
         Index Cond: (id = ANY (ARRAY[t2.id, $1, $2, ..., $1023]))
(5 rows)

-- debug log of candidate index to use IndexScan
EXPLAIN (COSTS false) SELECT * FROM t5 WHERE t5.id = 1;
           QUERY PLAN
--------------------------------
 Index Scan using t5_pkey on t5
   Index Cond: (id = 1)
(2 rows)

/*+IndexScan(t5 t5_id2)*/
EXPLAIN (COSTS false) SELECT * FROM t5 WHERE t5.id = 1;
LOG:  available indexes for IndexScan(t5): t5_id2
LOG:  pg_hint_plan:
used hint:
IndexScan(t5 t5_id2)
not used hint:
duplication hint:
error hint:

          QUERY PLAN
-------------------------------
 Index Scan using t5_id2 on t5
   Index Cond: (id = 1)
(2 rows)

/*+IndexScan(t5 no_exist)*/
EXPLAIN (COSTS false) SELECT * FROM t5 WHERE t5.id = 1;
LOG:  available indexes for IndexScan(t5):
LOG:  pg_hint_plan:
used hint:
IndexScan(t5 no_exist)
not used hint:
duplication hint:
error hint:

         QUERY PLAN
----------------------------
 Seq Scan on t5
   Storage Filter: (id = 1)
(2 rows)

/*+IndexScan(t5 t5_id1 t5_id2)*/
EXPLAIN (COSTS false) SELECT * FROM t5 WHERE t5.id = 1;
LOG:  available indexes for IndexScan(t5): t5_id2 t5_id1
LOG:  pg_hint_plan:
used hint:
IndexScan(t5 t5_id1 t5_id2)
not used hint:
duplication hint:
error hint:

          QUERY PLAN
-------------------------------
 Index Scan using t5_id2 on t5
   Index Cond: (id = 1)
(2 rows)

/*+IndexScan(t5 no_exist t5_id2)*/
EXPLAIN (COSTS false) SELECT * FROM t5 WHERE t5.id = 1;
LOG:  available indexes for IndexScan(t5): t5_id2
LOG:  pg_hint_plan:
used hint:
IndexScan(t5 no_exist t5_id2)
not used hint:
duplication hint:
error hint:

          QUERY PLAN
-------------------------------
 Index Scan using t5_id2 on t5
   Index Cond: (id = 1)
(2 rows)

/*+IndexScan(t5 no_exist5 no_exist2)*/
EXPLAIN (COSTS false) SELECT * FROM t5 WHERE t5.id = 1;
LOG:  available indexes for IndexScan(t5):
LOG:  pg_hint_plan:
used hint:
IndexScan(t5 no_exist5 no_exist2)
not used hint:
duplication hint:
error hint:

         QUERY PLAN
----------------------------
 Seq Scan on t5
   Storage Filter: (id = 1)
(2 rows)

-- outer inner
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
                               QUERY PLAN
-------------------------------------------------------------------------
 Hash Join
   Hash Cond: (t2.val = t3.val)
   ->  YB Batched Nested Loop Join
         Join Filter: (t1.id = t2.id)
         ->  Seq Scan on t2
         ->  Index Scan using t1_pkey on t1
               Index Cond: (id = ANY (ARRAY[t2.id, $1, $2, ..., $1023]))
               Storage Filter: (id < 10)
   ->  Hash
         ->  Seq Scan on t3
(10 rows)

/*+Leading((t1))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
INFO:  pg_hint_plan: hint syntax error at or near "Leading((t1))"
DETAIL:  Leading hint requires two sets of relations when parentheses nests.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
Leading((t1))

                               QUERY PLAN
-------------------------------------------------------------------------
 Hash Join
   Hash Cond: (t2.val = t3.val)
   ->  YB Batched Nested Loop Join
         Join Filter: (t1.id = t2.id)
         ->  Seq Scan on t2
         ->  Index Scan using t1_pkey on t1
               Index Cond: (id = ANY (ARRAY[t2.id, $1, $2, ..., $1023]))
               Storage Filter: (id < 10)
   ->  Hash
         ->  Seq Scan on t3
(10 rows)

/*+Leading((t1 t2))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
Leading((t1 t2))
not used hint:
duplication hint:
error hint:

               QUERY PLAN
-----------------------------------------
 Nested Loop
   Join Filter: (t2.val = t3.val)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Storage Filter: (id < 10)
         ->  Hash
               ->  Seq Scan on t2
   ->  Materialize
         ->  Seq Scan on t3
(10 rows)

/*+Leading((t1 t2 t3))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
INFO:  pg_hint_plan: hint syntax error at or near "Leading((t1 t2 t3))"
DETAIL:  Leading hint requires two sets of relations when parentheses nests.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
Leading((t1 t2 t3))

                               QUERY PLAN
-------------------------------------------------------------------------
 Hash Join
   Hash Cond: (t2.val = t3.val)
   ->  YB Batched Nested Loop Join
         Join Filter: (t1.id = t2.id)
         ->  Seq Scan on t2
         ->  Index Scan using t1_pkey on t1
               Index Cond: (id = ANY (ARRAY[t2.id, $1, $2, ..., $1023]))
               Storage Filter: (id < 10)
   ->  Hash
         ->  Seq Scan on t3
(10 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.id < 10;
                            QUERY PLAN
-------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t2.id)
   ->  Seq Scan on t2
   ->  Index Scan using t1_pkey on t1
         Index Cond: (id = ANY (ARRAY[t2.id, $1, $2, ..., $1023]))
         Storage Filter: (id < 10)
(6 rows)

/*+Leading((t1 t2))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
Leading((t1 t2))
not used hint:
duplication hint:
error hint:

            QUERY PLAN
-----------------------------------
 Hash Join
   Hash Cond: (t1.id = t2.id)
   ->  Seq Scan on t1
         Storage Filter: (id < 10)
   ->  Hash
         ->  Seq Scan on t2
(6 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
                               QUERY PLAN
-------------------------------------------------------------------------
 Hash Join
   Hash Cond: (t2.val = t3.val)
   ->  YB Batched Nested Loop Join
         Join Filter: (t1.id = t2.id)
         ->  Seq Scan on t2
         ->  Index Scan using t1_pkey on t1
               Index Cond: (id = ANY (ARRAY[t2.id, $1, $2, ..., $1023]))
               Storage Filter: (id < 10)
   ->  Hash
         ->  Seq Scan on t3
(10 rows)

/*+Leading(((t1 t2) t3))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
Leading(((t1 t2) t3))
not used hint:
duplication hint:
error hint:

               QUERY PLAN
-----------------------------------------
 Hash Join
   Hash Cond: (t2.val = t3.val)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Storage Filter: (id < 10)
         ->  Hash
               ->  Seq Scan on t2
   ->  Hash
         ->  Seq Scan on t3
(10 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
                                     QUERY PLAN
-------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (t1.val = t3.val)
   ->  YB Batched Nested Loop Join
         Join Filter: (t1.id = t2.id)
         ->  Seq Scan on t2
         ->  Index Scan using t1_pkey on t1
               Index Cond: (id = ANY (ARRAY[t2.id, $1, $2, ..., $1023]))
               Storage Filter: (id < 10)
   ->  Hash
         ->  YB Batched Nested Loop Join
               Join Filter: (t3.id = t4.id)
               ->  Seq Scan on t4
               ->  Index Scan using t3_pkey on t3
                     Index Cond: (id = ANY (ARRAY[t4.id, $1025, $1026, ..., $2047]))
(14 rows)

/*+Leading((((t1 t2) t3) t4))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
Leading((((t1 t2) t3) t4))
not used hint:
duplication hint:
error hint:

                  QUERY PLAN
-----------------------------------------------
 Hash Join
   Hash Cond: (t3.id = t4.id)
   ->  Hash Join
         Hash Cond: (t1.val = t3.val)
         ->  Hash Join
               Hash Cond: (t1.id = t2.id)
               ->  Seq Scan on t1
                     Storage Filter: (id < 10)
               ->  Hash
                     ->  Seq Scan on t2
         ->  Hash
               ->  Seq Scan on t3
   ->  Hash
         ->  Seq Scan on t4
(14 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
                               QUERY PLAN
-------------------------------------------------------------------------
 Hash Join
   Hash Cond: (t2.val = t3.val)
   ->  YB Batched Nested Loop Join
         Join Filter: (t1.id = t2.id)
         ->  Seq Scan on t2
         ->  Index Scan using t1_pkey on t1
               Index Cond: (id = ANY (ARRAY[t2.id, $1, $2, ..., $1023]))
               Storage Filter: (id < 10)
   ->  Hash
         ->  Seq Scan on t3
(10 rows)

/*+Leading(((t1 t2) t3))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
Leading(((t1 t2) t3))
not used hint:
duplication hint:
error hint:

               QUERY PLAN
-----------------------------------------
 Hash Join
   Hash Cond: (t2.val = t3.val)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Storage Filter: (id < 10)
         ->  Hash
               ->  Seq Scan on t2
   ->  Hash
         ->  Seq Scan on t3
(10 rows)

/*+Leading((t1 (t2 t3)))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
Leading((t1 (t2 t3)))
not used hint:
duplication hint:
error hint:

                 QUERY PLAN
--------------------------------------------
 Hash Join
   Hash Cond: (t1.id = t2.id)
   ->  Seq Scan on t1
         Storage Filter: (id < 10)
   ->  Hash
         ->  Hash Join
               Hash Cond: (t2.val = t3.val)
               ->  Seq Scan on t2
               ->  Hash
                     ->  Seq Scan on t3
(10 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
                                     QUERY PLAN
-------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (t1.val = t3.val)
   ->  YB Batched Nested Loop Join
         Join Filter: (t1.id = t2.id)
         ->  Seq Scan on t2
         ->  Index Scan using t1_pkey on t1
               Index Cond: (id = ANY (ARRAY[t2.id, $1, $2, ..., $1023]))
               Storage Filter: (id < 10)
   ->  Hash
         ->  YB Batched Nested Loop Join
               Join Filter: (t3.id = t4.id)
               ->  Seq Scan on t4
               ->  Index Scan using t3_pkey on t3
                     Index Cond: (id = ANY (ARRAY[t4.id, $1025, $1026, ..., $2047]))
(14 rows)

/*+Leading(((t1 t2) (t3 t4)))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
Leading(((t1 t2) (t3 t4)))
not used hint:
duplication hint:
error hint:

                QUERY PLAN
------------------------------------------
 Hash Join
   Hash Cond: (t1.val = t3.val)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Storage Filter: (id < 10)
         ->  Hash
               ->  Seq Scan on t2
   ->  Hash
         ->  Hash Join
               Hash Cond: (t3.id = t4.id)
               ->  Seq Scan on t3
               ->  Hash
                     ->  Seq Scan on t4
(14 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < ( SELECT t1_2.id FROM t1 t1_2, t2 t2_2 WHERE t1_2.id = t2_2.id AND t2_2.val > 100 ORDER BY t1_2.id LIMIT 1);
                                       QUERY PLAN
-----------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (t2.val = t3.val)
   InitPlan 1 (returns $1024)
     ->  Limit
           ->  Sort
                 Sort Key: t1_2.id
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t1_2.id = t2_2.id)
                       ->  Seq Scan on t2 t2_2
                             Storage Filter: (val > 100)
                       ->  Index Scan using t1_pkey on t1 t1_2
                             Index Cond: (id = ANY (ARRAY[t2_2.id, $1, $2, ..., $1023]))
   ->  YB Batched Nested Loop Join
         Join Filter: (t1.id = t2.id)
         ->  Seq Scan on t2
         ->  Index Scan using t1_pkey on t1
               Index Cond: (id = ANY (ARRAY[t2.id, $1026, $1027, ..., $2048]))
               Storage Filter: (id < $1024)
   ->  Hash
         ->  Seq Scan on t3
(20 rows)

/*+Leading(((t1 t2) t3)) Leading(((t3 t1) t2))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t1.val = t3.val AND t1.id < ( SELECT t1_2.id FROM t1 t1_2, t2 t2_2 WHERE t1_2.id = t2_2.id AND t2_2.val > 100 ORDER BY t1_2.id LIMIT 1);
INFO:  pg_hint_plan: hint syntax error at or near "Leading(((t1 t2) t3)) Leading(((t3 t1) t2))"
DETAIL:  Conflict leading hint.
LOG:  pg_hint_plan:
used hint:
Leading(((t3 t1) t2))
not used hint:
duplication hint:
Leading(((t1 t2) t3))
error hint:

                                       QUERY PLAN
-----------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (t1.id = t2.id)
   InitPlan 1 (returns $1024)
     ->  Limit
           ->  Sort
                 Sort Key: t1_2.id
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t1_2.id = t2_2.id)
                       ->  Seq Scan on t2 t2_2
                             Storage Filter: (val > 100)
                       ->  Index Scan using t1_pkey on t1 t1_2
                             Index Cond: (id = ANY (ARRAY[t2_2.id, $1, $2, ..., $1023]))
   ->  Hash Join
         Hash Cond: (t3.val = t1.val)
         ->  Seq Scan on t3
         ->  Hash
               ->  Seq Scan on t1
                     Storage Filter: (id < $1024)
   ->  Hash
         ->  Seq Scan on t2
(20 rows)

/*+Leading(((t1 t2) t3)) Leading((t1_2 t2_2))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < ( SELECT t1_2.id FROM t1 t1_2, t2 t2_2 WHERE t1_2.id = t2_2.id AND t2_2.val > 100 ORDER BY t1_2.id LIMIT 1);
LOG:  pg_hint_plan:
used hint:
Leading(((t1 t2) t3))
Leading((t1_2 t2_2))
not used hint:
duplication hint:
error hint:

                          QUERY PLAN
---------------------------------------------------------------
 Hash Join
   Hash Cond: (t2.val = t3.val)
   InitPlan 1 (returns $0)
     ->  Limit
           ->  Sort
                 Sort Key: t1_2.id
                 ->  Hash Join
                       Hash Cond: (t1_2.id = t2_2.id)
                       ->  Seq Scan on t1 t1_2
                       ->  Hash
                             ->  Seq Scan on t2 t2_2
                                   Storage Filter: (val > 100)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Storage Filter: (id < $0)
         ->  Hash
               ->  Seq Scan on t2
   ->  Hash
         ->  Seq Scan on t3
(20 rows)

/*+Leading(((((t1 t2) t3) t1_2) t2_2))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < ( SELECT t1_2.id FROM t1 t1_2, t2 t2_2 WHERE t1_2.id = t2_2.id AND t2_2.val > 100 ORDER BY t1_2.id LIMIT 1);
LOG:  pg_hint_plan:
used hint:
not used hint:
Leading(((((t1 t2) t3) t1_2) t2_2))
duplication hint:
error hint:

                                       QUERY PLAN
-----------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (t2.val = t3.val)
   InitPlan 1 (returns $1024)
     ->  Limit
           ->  Sort
                 Sort Key: t1_2.id
                 ->  YB Batched Nested Loop Join
                       Join Filter: (t1_2.id = t2_2.id)
                       ->  Seq Scan on t2 t2_2
                             Storage Filter: (val > 100)
                       ->  Index Scan using t1_pkey on t1 t1_2
                             Index Cond: (id = ANY (ARRAY[t2_2.id, $1, $2, ..., $1023]))
   ->  YB Batched Nested Loop Join
         Join Filter: (t1.id = t2.id)
         ->  Seq Scan on t2
         ->  Index Scan using t1_pkey on t1
               Index Cond: (id = ANY (ARRAY[t2.id, $1026, $1027, ..., $2048]))
               Storage Filter: (id < $1024)
   ->  Hash
         ->  Seq Scan on t3
(20 rows)

-- Specified outer/inner leading hint and join method hint at the same time
/*+Leading(((t1 t2) t3))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
Leading(((t1 t2) t3))
not used hint:
duplication hint:
error hint:

               QUERY PLAN
-----------------------------------------
 Hash Join
   Hash Cond: (t2.val = t3.val)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Storage Filter: (id < 10)
         ->  Hash
               ->  Seq Scan on t2
   ->  Hash
         ->  Seq Scan on t3
(10 rows)

/*+Leading(((t1 t2) t3)) MergeJoin(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
MergeJoin(t1 t2)
Leading(((t1 t2) t3))
not used hint:
duplication hint:
error hint:

                  QUERY PLAN
-----------------------------------------------
 Hash Join
   Hash Cond: (t2.val = t3.val)
   ->  Merge Join
         Merge Cond: (t1.id = t2.id)
         ->  Sort
               Sort Key: t1.id
               ->  Seq Scan on t1
                     Storage Filter: (id < 10)
         ->  Sort
               Sort Key: t2.id
               ->  Seq Scan on t2
   ->  Hash
         ->  Seq Scan on t3
(13 rows)

/*+Leading(((t1 t2) t3)) MergeJoin(t1 t2 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
MergeJoin(t1 t2 t3)
Leading(((t1 t2) t3))
not used hint:
duplication hint:
error hint:

                  QUERY PLAN
-----------------------------------------------
 Merge Join
   Merge Cond: (t2.val = t3.val)
   ->  Sort
         Sort Key: t2.val
         ->  Hash Join
               Hash Cond: (t1.id = t2.id)
               ->  Seq Scan on t1
                     Storage Filter: (id < 10)
               ->  Hash
                     ->  Seq Scan on t2
   ->  Sort
         Sort Key: t3.val
         ->  Seq Scan on t3
(13 rows)

/*+Leading(((t1 t2) t3)) MergeJoin(t1 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
Leading(((t1 t2) t3))
not used hint:
MergeJoin(t1 t3)
duplication hint:
error hint:

               QUERY PLAN
-----------------------------------------
 Hash Join
   Hash Cond: (t2.val = t3.val)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Storage Filter: (id < 10)
         ->  Hash
               ->  Seq Scan on t2
   ->  Hash
         ->  Seq Scan on t3
(10 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
                                     QUERY PLAN
-------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (t1.val = t3.val)
   ->  YB Batched Nested Loop Join
         Join Filter: (t1.id = t2.id)
         ->  Seq Scan on t2
         ->  Index Scan using t1_pkey on t1
               Index Cond: (id = ANY (ARRAY[t2.id, $1, $2, ..., $1023]))
               Storage Filter: (id < 10)
   ->  Hash
         ->  YB Batched Nested Loop Join
               Join Filter: (t3.id = t4.id)
               ->  Seq Scan on t4
               ->  Index Scan using t3_pkey on t3
                     Index Cond: (id = ANY (ARRAY[t4.id, $1025, $1026, ..., $2047]))
(14 rows)

/*+Leading(((t1 t2) t3)) MergeJoin(t3 t4)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
Leading(((t1 t2) t3))
not used hint:
MergeJoin(t3 t4)
duplication hint:
error hint:

                            QUERY PLAN
-------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t3.id = t4.id)
   ->  Hash Join
         Hash Cond: (t1.val = t3.val)
         ->  Hash Join
               Hash Cond: (t1.id = t2.id)
               ->  Seq Scan on t1
                     Storage Filter: (id < 10)
               ->  Hash
                     ->  Seq Scan on t2
         ->  Hash
               ->  Seq Scan on t3
   ->  Index Scan using t4_pkey on t4
         Index Cond: (id = ANY (ARRAY[t3.id, $1, $2, ..., $1023]))
(14 rows)

/*+Leading(((t1 t2) t3)) MergeJoin(t1 t2 t3 t4)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
MergeJoin(t1 t2 t3 t4)
Leading(((t1 t2) t3))
not used hint:
duplication hint:
error hint:

                     QUERY PLAN
-----------------------------------------------------
 Merge Join
   Merge Cond: (t3.id = t4.id)
   ->  Sort
         Sort Key: t3.id
         ->  Hash Join
               Hash Cond: (t1.val = t3.val)
               ->  Hash Join
                     Hash Cond: (t1.id = t2.id)
                     ->  Seq Scan on t1
                           Storage Filter: (id < 10)
                     ->  Hash
                           ->  Seq Scan on t2
               ->  Hash
                     ->  Seq Scan on t3
   ->  Sort
         Sort Key: t4.id
         ->  Seq Scan on t4
(17 rows)

/*+ Leading ( ( t1 ( t2 t3 ) ) ) */
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
Leading((t1 (t2 t3)))
not used hint:
duplication hint:
error hint:

                 QUERY PLAN
--------------------------------------------
 Hash Join
   Hash Cond: (t1.id = t2.id)
   ->  Seq Scan on t1
         Storage Filter: (id < 10)
   ->  Hash
         ->  Hash Join
               Hash Cond: (t2.val = t3.val)
               ->  Seq Scan on t2
               ->  Hash
                     ->  Seq Scan on t3
(10 rows)

/*+Leading((t1(t2 t3)))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
Leading((t1 (t2 t3)))
not used hint:
duplication hint:
error hint:

                 QUERY PLAN
--------------------------------------------
 Hash Join
   Hash Cond: (t1.id = t2.id)
   ->  Seq Scan on t1
         Storage Filter: (id < 10)
   ->  Hash
         ->  Hash Join
               Hash Cond: (t2.val = t3.val)
               ->  Seq Scan on t2
               ->  Hash
                     ->  Seq Scan on t3
(10 rows)

/*+Leading(("t1(t2" "t3)"))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
not used hint:
Leading(("t1(t2" "t3)"))
duplication hint:
error hint:

                               QUERY PLAN
-------------------------------------------------------------------------
 Hash Join
   Hash Cond: (t2.val = t3.val)
   ->  YB Batched Nested Loop Join
         Join Filter: (t1.id = t2.id)
         ->  Seq Scan on t2
         ->  Index Scan using t1_pkey on t1
               Index Cond: (id = ANY (ARRAY[t2.id, $1, $2, ..., $1023]))
               Storage Filter: (id < 10)
   ->  Hash
         ->  Seq Scan on t3
(10 rows)

/*+ Leading ( ( ( t1 t2 ) t3 ) ) */
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
Leading(((t1 t2) t3))
not used hint:
duplication hint:
error hint:

               QUERY PLAN
-----------------------------------------
 Hash Join
   Hash Cond: (t2.val = t3.val)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Storage Filter: (id < 10)
         ->  Hash
               ->  Seq Scan on t2
   ->  Hash
         ->  Seq Scan on t3
(10 rows)

/*+Leading(((t1 t2)t3))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
Leading(((t1 t2) t3))
not used hint:
duplication hint:
error hint:

               QUERY PLAN
-----------------------------------------
 Hash Join
   Hash Cond: (t2.val = t3.val)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Storage Filter: (id < 10)
         ->  Hash
               ->  Seq Scan on t2
   ->  Hash
         ->  Seq Scan on t3
(10 rows)

/*+Leading(("(t1" "t2)t3"))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
not used hint:
Leading(("(t1" "t2)t3"))
duplication hint:
error hint:

                               QUERY PLAN
-------------------------------------------------------------------------
 Hash Join
   Hash Cond: (t2.val = t3.val)
   ->  YB Batched Nested Loop Join
         Join Filter: (t1.id = t2.id)
         ->  Seq Scan on t2
         ->  Index Scan using t1_pkey on t1
               Index Cond: (id = ANY (ARRAY[t2.id, $1, $2, ..., $1023]))
               Storage Filter: (id < 10)
   ->  Hash
         ->  Seq Scan on t3
(10 rows)

/*+Leading((t1(t2(t3(t4 t5)))))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  pg_hint_plan:
used hint:
Leading((t1 (t2 (t3 (t4 t5)))))
not used hint:
duplication hint:
error hint:

                                              QUERY PLAN
-------------------------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (t1.id = t2.id)
   ->  Seq Scan on t1
   ->  Hash
         ->  Hash Join
               Hash Cond: (t2.id = t3.id)
               ->  Seq Scan on t2
               ->  Hash
                     ->  Hash Join
                           Hash Cond: (t3.id = t4.id)
                           ->  Seq Scan on t3
                           ->  Hash
                                 ->  YB Batched Nested Loop Join
                                       Join Filter: (t4.id = t5.id)
                                       ->  Seq Scan on t4
                                       ->  Index Scan using t5_pkey on t5
                                             Index Cond: (id = ANY (ARRAY[t4.id, $1, $2, ..., $1023]))
(17 rows)

/*+Leading((t5(t4(t3(t2 t1)))))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  pg_hint_plan:
used hint:
Leading((t5 (t4 (t3 (t2 t1)))))
not used hint:
duplication hint:
error hint:

                                              QUERY PLAN
-------------------------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (t5.id = t1.id)
   ->  Seq Scan on t5
   ->  Hash
         ->  Merge Join
               Merge Cond: (t4.id = t1.id)
               ->  Sort
                     Sort Key: t4.id
                     ->  Seq Scan on t4
               ->  Sort
                     Sort Key: t1.id
                     ->  Hash Join
                           Hash Cond: (t3.id = t1.id)
                           ->  Seq Scan on t3
                           ->  Hash
                                 ->  YB Batched Nested Loop Join
                                       Join Filter: (t1.id = t2.id)
                                       ->  Seq Scan on t2
                                       ->  Index Scan using t1_pkey on t1
                                             Index Cond: (id = ANY (ARRAY[t2.id, $1, $2, ..., $1023]))
(20 rows)

/*+Leading(((((t1 t2)t3)t4)t5))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  pg_hint_plan:
used hint:
Leading(((((t1 t2) t3) t4) t5))
not used hint:
duplication hint:
error hint:

                               QUERY PLAN
-------------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t5.id)
   ->  YB Batched Nested Loop Join
         Join Filter: (t1.id = t4.id)
         ->  Hash Join
               Hash Cond: (t1.id = t3.id)
               ->  Hash Join
                     Hash Cond: (t1.id = t2.id)
                     ->  Seq Scan on t1
                     ->  Hash
                           ->  Seq Scan on t2
               ->  Hash
                     ->  Seq Scan on t3
         ->  Index Scan using t4_pkey on t4
               Index Cond: (id = ANY (ARRAY[t1.id, $1, $2, ..., $1023]))
   ->  Index Scan using t5_pkey on t5
         Index Cond: (id = ANY (ARRAY[t1.id, $1025, $1026, ..., $2047]))
(17 rows)

/*+Leading(((((t5 t4)t3)t2)t1))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  pg_hint_plan:
used hint:
Leading(((((t5 t4) t3) t2) t1))
not used hint:
duplication hint:
error hint:

                                  QUERY PLAN
-------------------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t2.id = t1.id)
   ->  YB Batched Nested Loop Join
         Join Filter: (t3.id = t2.id)
         ->  YB Batched Nested Loop Join
               Join Filter: (t4.id = t3.id)
               ->  Hash Join
                     Hash Cond: (t5.id = t4.id)
                     ->  Seq Scan on t5
                     ->  Hash
                           ->  Seq Scan on t4
               ->  Index Scan using t3_pkey on t3
                     Index Cond: (id = ANY (ARRAY[t5.id, $1, $2, ..., $1023]))
         ->  Index Scan using t2_pkey on t2
               Index Cond: (id = ANY (ARRAY[t5.id, $1025, $1026, ..., $2047]))
   ->  Index Scan using t1_pkey on t1
         Index Cond: (id = ANY (ARRAY[t5.id, $2049, $2050, ..., $3071]))
(17 rows)

/*+Leading(((t1 t2)(t3(t4 t5))))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  pg_hint_plan:
used hint:
Leading(((t1 t2) (t3 (t4 t5))))
not used hint:
duplication hint:
error hint:

                                        QUERY PLAN
-------------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (t1.id = t3.id)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
   ->  Hash
         ->  Hash Join
               Hash Cond: (t3.id = t4.id)
               ->  Seq Scan on t3
               ->  Hash
                     ->  YB Batched Nested Loop Join
                           Join Filter: (t4.id = t5.id)
                           ->  Seq Scan on t4
                           ->  Index Scan using t5_pkey on t5
                                 Index Cond: (id = ANY (ARRAY[t4.id, $1, $2, ..., $1023]))
(17 rows)

/*+Leading(((t5 t4)(t3(t2 t1))))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  pg_hint_plan:
used hint:
Leading(((t5 t4) (t3 (t2 t1))))
not used hint:
duplication hint:
error hint:

                                        QUERY PLAN
-------------------------------------------------------------------------------------------
 Nested Loop
   Join Filter: (t4.id = t1.id)
   ->  Hash Join
         Hash Cond: (t5.id = t4.id)
         ->  Seq Scan on t5
         ->  Hash
               ->  Seq Scan on t4
   ->  Materialize
         ->  Hash Join
               Hash Cond: (t3.id = t1.id)
               ->  Seq Scan on t3
               ->  Hash
                     ->  YB Batched Nested Loop Join
                           Join Filter: (t1.id = t2.id)
                           ->  Seq Scan on t2
                           ->  Index Scan using t1_pkey on t1
                                 Index Cond: (id = ANY (ARRAY[t2.id, $1, $2, ..., $1023]))
(17 rows)

/*+Leading((((t1 t2)t3)(t4 t5)))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  pg_hint_plan:
used hint:
Leading((((t1 t2) t3) (t4 t5)))
not used hint:
duplication hint:
error hint:

                                  QUERY PLAN
-------------------------------------------------------------------------------
 Nested Loop
   Join Filter: (t4.id = t1.id)
   ->  Hash Join
         Hash Cond: (t1.id = t3.id)
         ->  Hash Join
               Hash Cond: (t1.id = t2.id)
               ->  Seq Scan on t1
               ->  Hash
                     ->  Seq Scan on t2
         ->  Hash
               ->  Seq Scan on t3
   ->  Materialize
         ->  YB Batched Nested Loop Join
               Join Filter: (t4.id = t5.id)
               ->  Seq Scan on t4
               ->  Index Scan using t5_pkey on t5
                     Index Cond: (id = ANY (ARRAY[t4.id, $1, $2, ..., $1023]))
(17 rows)

/*+Leading((((t5 t4)t3)(t2 t1)))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  pg_hint_plan:
used hint:
Leading((((t5 t4) t3) (t2 t1)))
not used hint:
duplication hint:
error hint:

                                     QUERY PLAN
-------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (t3.id = t1.id)
   ->  YB Batched Nested Loop Join
         Join Filter: (t4.id = t3.id)
         ->  Hash Join
               Hash Cond: (t5.id = t4.id)
               ->  Seq Scan on t5
               ->  Hash
                     ->  Seq Scan on t4
         ->  Index Scan using t3_pkey on t3
               Index Cond: (id = ANY (ARRAY[t5.id, $1, $2, ..., $1023]))
   ->  Hash
         ->  YB Batched Nested Loop Join
               Join Filter: (t1.id = t2.id)
               ->  Seq Scan on t2
               ->  Index Scan using t1_pkey on t1
                     Index Cond: (id = ANY (ARRAY[t2.id, $1025, $1026, ..., $2047]))
(17 rows)

-- YB_COMMENT
-- Inheritance not supported by Yugabyte
-- Inherited table test to specify the index's name
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
ERROR:  System column "ctid" is not supported yet
-- /*+IndexScan(p2 p2_pkey)*/
-- EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
-- /*+IndexScan(p2 p2_id_val_idx)*/
-- EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
-- /*+IndexScan(p2 p2_val_id_idx)*/
-- EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
--
-- EXPLAIN (COSTS false) SELECT val FROM p2 WHERE val >= '50' AND val <= '51' AND p2.ctid = '(1,1)';
--
-- Inhibit parallel execution to avoid inheriting the hint
set max_parallel_workers_per_gather to 0;
-- /*+ IndexScan(p2 p2_val)*/
-- EXPLAIN (COSTS false) SELECT val FROM p2 WHERE val >= '50' AND val <= '51' AND p2.ctid = '(1,1)';
-- /*+IndexScan(p2 p2_pkey)*/
-- EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
-- /*+IndexScan(p2 p2_id2_val)*/
-- EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
-- /*+IndexScan(p2 p2_val2_id)*/
-- EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
--
-- /*+IndexScan(p2 p2_pkey)*/
-- EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
-- /*+IndexScan(p2 p2_c1_id_val_idx)*/
-- EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
-- /*+IndexScan(p2 no_exist)*/
-- EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
-- /*+IndexScan(p2 p2_pkey p2_c1_id_val_idx)*/
-- EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
-- /*+IndexScan(p2 p2_pkey no_exist)*/
-- EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
-- /*+IndexScan(p2 p2_c1_id_val_idx no_exist)*/
-- EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
-- /*+IndexScan(p2 p2_pkey p2_c1_id_val_idx no_exist)*/
-- EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
--
-- /*+IndexScan(p2 p2_val_idx)*/
-- EXPLAIN (COSTS false) SELECT val FROM p2 WHERE val >= '50' AND val <= '51' AND p2.ctid = '(1,1)';
-- /*+IndexScan(p2 p2_expr)*/
-- EXPLAIN (COSTS false) SELECT val FROM p2 WHERE val >= '50' AND val <= '51' AND p2.ctid = '(1,1)';
-- /*+IndexScan(p2 p2_val_idx6)*/
-- EXPLAIN (COSTS false) SELECT val FROM p2 WHERE val >= '50' AND val <= '51' AND p2.ctid = '(1,1)';
-- /*+IndexScan(p2 p2_val_idx p2_val_idx6)*/
-- EXPLAIN (COSTS false) SELECT val FROM p2 WHERE val >= '50' AND val <= '51' AND p2.ctid = '(1,1)';
--
-- regular expression
-- ordinary table
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
           QUERY PLAN
--------------------------------
 Index Scan using t5_pkey on t5
   Index Cond: (id = 1)
(2 rows)

/*+ IndexScanRegexp(t5 t5_[^i].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  available indexes for IndexScanRegexp(t5): t5_val t5_pkey
LOG:  pg_hint_plan:
used hint:
IndexScanRegexp(t5 t5_[^i].*)
not used hint:
duplication hint:
error hint:

           QUERY PLAN
--------------------------------
 Index Scan using t5_pkey on t5
   Index Cond: (id = 1)
(2 rows)

/*+ IndexScanRegexp(t5 t5_id[0-9].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  available indexes for IndexScanRegexp(t5): t5_id3 t5_id2 t5_id1
LOG:  pg_hint_plan:
used hint:
IndexScanRegexp(t5 t5_id[0-9].*)
not used hint:
duplication hint:
error hint:

          QUERY PLAN
-------------------------------
 Index Scan using t5_id3 on t5
   Index Cond: (id = 1)
(2 rows)

/*+ IndexScanRegexp(t5 t5[^_].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  available indexes for IndexScanRegexp(t5):
LOG:  pg_hint_plan:
used hint:
IndexScanRegexp(t5 t5[^_].*)
not used hint:
duplication hint:
error hint:

         QUERY PLAN
----------------------------
 Seq Scan on t5
   Storage Filter: (id = 1)
(2 rows)

/*+ IndexScanRegexp(t5 ^.*t5_idaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  available indexes for IndexScanRegexp(t5):
LOG:  pg_hint_plan:
used hint:
IndexScanRegexp(t5 ^.*t5_idaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab)
not used hint:
duplication hint:
error hint:

         QUERY PLAN
----------------------------
 Seq Scan on t5
   Storage Filter: (id = 1)
(2 rows)

/*+ IndexScan(t5 t5_id[0-9].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  available indexes for IndexScan(t5):
LOG:  pg_hint_plan:
used hint:
IndexScan(t5 t5_id[0-9].*)
not used hint:
duplication hint:
error hint:

         QUERY PLAN
----------------------------
 Seq Scan on t5
   Storage Filter: (id = 1)
(2 rows)

/*+ IndexOnlyScanRegexp(t5 t5_[^i].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  available indexes for IndexOnlyScanRegexp(t5): t5_val t5_pkey
LOG:  pg_hint_plan:
used hint:
IndexOnlyScanRegexp(t5 t5_[^i].*)
not used hint:
duplication hint:
error hint:

           QUERY PLAN
--------------------------------
 Index Scan using t5_pkey on t5
   Index Cond: (id = 1)
(2 rows)

/*+ IndexOnlyScanRegexp(t5 t5_id[0-9].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  available indexes for IndexOnlyScanRegexp(t5): t5_id3 t5_id2 t5_id1
LOG:  pg_hint_plan:
used hint:
IndexOnlyScanRegexp(t5 t5_id[0-9].*)
not used hint:
duplication hint:
error hint:

             QUERY PLAN
------------------------------------
 Index Only Scan using t5_id3 on t5
   Index Cond: (id = 1)
(2 rows)

/*+ IndexOnlyScanRegexp(t5 t5[^_].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  available indexes for IndexOnlyScanRegexp(t5):
LOG:  pg_hint_plan:
used hint:
IndexOnlyScanRegexp(t5 t5[^_].*)
not used hint:
duplication hint:
error hint:

         QUERY PLAN
----------------------------
 Seq Scan on t5
   Storage Filter: (id = 1)
(2 rows)

/*+ IndexOnlyScanRegexp(t5 ^.*t5_idaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  available indexes for IndexOnlyScanRegexp(t5):
LOG:  pg_hint_plan:
used hint:
IndexOnlyScanRegexp(t5 ^.*t5_idaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab)
not used hint:
duplication hint:
error hint:

         QUERY PLAN
----------------------------
 Seq Scan on t5
   Storage Filter: (id = 1)
(2 rows)

/*+ IndexOnlyScan(t5 t5_id[0-9].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  available indexes for IndexOnlyScan(t5):
LOG:  pg_hint_plan:
used hint:
IndexOnlyScan(t5 t5_id[0-9].*)
not used hint:
duplication hint:
error hint:

         QUERY PLAN
----------------------------
 Seq Scan on t5
   Storage Filter: (id = 1)
(2 rows)

/*+ BitmapScanRegexp(t5 t5_[^i].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  available indexes for BitmapScanRegexp(t5): t5_val t5_pkey
LOG:  pg_hint_plan:
used hint:
BitmapScanRegexp(t5 t5_[^i].*)
not used hint:
duplication hint:
error hint:

             QUERY PLAN
------------------------------------
 YB Bitmap Table Scan on t5
   ->  Bitmap Index Scan on t5_pkey
         Index Cond: (id = 1)
(3 rows)

/*+ BitmapScanRegexp(t5 t5_id[0-9].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  available indexes for BitmapScanRegexp(t5): t5_id3 t5_id2 t5_id1
LOG:  pg_hint_plan:
used hint:
BitmapScanRegexp(t5 t5_id[0-9].*)
not used hint:
duplication hint:
error hint:

            QUERY PLAN
-----------------------------------
 YB Bitmap Table Scan on t5
   ->  Bitmap Index Scan on t5_id3
         Index Cond: (id = 1)
(3 rows)

/*+ BitmapScanRegexp(t5 t5[^_].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  available indexes for BitmapScanRegexp(t5):
LOG:  pg_hint_plan:
used hint:
BitmapScanRegexp(t5 t5[^_].*)
not used hint:
duplication hint:
error hint:

         QUERY PLAN
----------------------------
 Seq Scan on t5
   Storage Filter: (id = 1)
(2 rows)

/*+ BitmapScanRegexp(t5 ^.*t5_idaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  available indexes for BitmapScanRegexp(t5):
LOG:  pg_hint_plan:
used hint:
BitmapScanRegexp(t5 ^.*t5_idaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab)
not used hint:
duplication hint:
error hint:

         QUERY PLAN
----------------------------
 Seq Scan on t5
   Storage Filter: (id = 1)
(2 rows)

/*+ BitmapScan(t5 t5_id[0-9].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  available indexes for BitmapScan(t5):
LOG:  pg_hint_plan:
used hint:
BitmapScan(t5 t5_id[0-9].*)
not used hint:
duplication hint:
error hint:

         QUERY PLAN
----------------------------
 Seq Scan on t5
   Storage Filter: (id = 1)
(2 rows)

-- YB_COMMENT
-- Inheritance
EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
             QUERY PLAN
-------------------------------------
 Index Only Scan using p1_val3 on p1
   Index Cond: (val = 1)
(2 rows)

-- /*+ IndexScanRegexp(p1 p1_.*[^0-9]$)*/
-- EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
-- /*+ IndexScanRegexp(p1 p1_.*val2.*)*/
-- EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
-- /*+ IndexScanRegexp(p1 p1[^_].*)*/
-- EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
-- /*+ IndexScan(p1 p1_.*val2.*)*/
-- EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
-- /*+ IndexOnlyScanRegexp(p1 p1_.*[^0-9]$)*/
-- EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
-- /*+ IndexOnlyScanRegexp(p1 p1_.*val2.*)*/
-- EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
-- /*+ IndexOnlyScanRegexp(p1 p1[^_].*)*/
-- EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
-- /*+ IndexOnlyScan(p1 p1_.*val2.*)*/
-- EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
-- /*+ BitmapScanRegexp(p1 p1_.*[^0-9]$)*/
-- EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
-- /*+ BitmapScanRegexp(p1 p1_.*val2.*)*/
-- EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
-- /*+ BitmapScanRegexp(p1 p1[^_].*)*/
-- EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
-- /*+ BitmapScan(p1 p1_.*val2.*)*/
-- EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
--
-- search from hint table
INSERT INTO hint_plan.hints (norm_query_string, application_name, hints) VALUES ('EXPLAIN (COSTS false) SELECT * FROM t1 WHERE t1.id = ?;', '', 'SeqScan(t1)');
INSERT INTO hint_plan.hints (norm_query_string, application_name, hints) VALUES ('EXPLAIN (COSTS false) SELECT id FROM t1 WHERE t1.id = ?;', '', 'IndexScan(t1)');
INSERT INTO hint_plan.hints (norm_query_string, application_name, hints) VALUES ('EXPLAIN SELECT * FROM t1 WHERE t1.id = ?;', '', 'BitmapScan(t1)');
SELECT * FROM hint_plan.hints ORDER BY id;
 id |                    norm_query_string                     | application_name |     hints
----+----------------------------------------------------------+------------------+----------------
  1 | EXPLAIN (COSTS false) SELECT * FROM t1 WHERE t1.id = ?;  |                  | SeqScan(t1)
  2 | EXPLAIN (COSTS false) SELECT id FROM t1 WHERE t1.id = ?; |                  | IndexScan(t1)
  3 | EXPLAIN SELECT * FROM t1 WHERE t1.id = ?;                |                  | BitmapScan(t1)
(3 rows)

SET pg_hint_plan.enable_hint_table = on;
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE t1.id = 1;
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
not used hint:
duplication hint:
error hint:

         QUERY PLAN
----------------------------
 Seq Scan on t1
   Storage Filter: (id = 1)
(2 rows)

SET pg_hint_plan.enable_hint_table = off;
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE t1.id = 1;
           QUERY PLAN
--------------------------------
 Index Scan using t1_pkey on t1
   Index Cond: (id = 1)
(2 rows)

TRUNCATE hint_plan.hints;
VACUUM ANALYZE hint_plan.hints;
NOTICE:  VACUUM is a no-op statement since YugabyteDB performs garbage collection of dead tuples automatically
-- plpgsql test
EXPLAIN (COSTS false) SELECT id FROM t1 WHERE t1.id = 1;
           QUERY PLAN
--------------------------------
 Index Scan using t1_pkey on t1
   Index Cond: (id = 1)
(2 rows)

-- static function
CREATE FUNCTION testfunc() RETURNS RECORD AS $$
DECLARE
  ret record;
BEGIN
  SELECT /*+ SeqScan(t1) */ * INTO ret FROM t1 LIMIT 1;
  RETURN ret;
END;
$$ LANGUAGE plpgsql;
SELECT testfunc();
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
not used hint:
duplication hint:
error hint:

CONTEXT:  SQL statement "SELECT /*+ SeqScan(t1) */ *          FROM t1 LIMIT 1"
PL/pgSQL function testfunc() line 5 at SQL statement
 testfunc
----------
 (854,54)
(1 row)

-- dynamic function
DROP FUNCTION testfunc();
CREATE FUNCTION testfunc() RETURNS void AS $$
BEGIN
  EXECUTE format('/*+ SeqScan(t1) */ SELECT * FROM t1');
END;
$$ LANGUAGE plpgsql;
SELECT testfunc();
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
not used hint:
duplication hint:
error hint:

CONTEXT:  SQL statement "/*+ SeqScan(t1) */ SELECT * FROM t1"
PL/pgSQL function testfunc() line 3 at EXECUTE
 testfunc
----------

(1 row)

-- This should not use SeqScan(t1)
/*+ IndexScan(t1) */ SELECT * from t1 LIMIT 1;
LOG:  pg_hint_plan:
used hint:
IndexScan(t1)
not used hint:
duplication hint:
error hint:

 id  | val
-----+-----
 854 |  54
(1 row)

-- Perform
DROP FUNCTION testfunc();
CREATE FUNCTION testfunc() RETURNS void AS $$
BEGIN
  PERFORM  1, /*+ SeqScan(t1) */ * from t1;
END;
$$ LANGUAGE plpgsql;
SELECT testfunc();
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
not used hint:
duplication hint:
error hint:

CONTEXT:  SQL statement "SELECT 1, /*+ SeqScan(t1) */ * from t1"
PL/pgSQL function testfunc() line 3 at PERFORM
 testfunc
----------

(1 row)

-- FOR loop
DROP FUNCTION testfunc();
CREATE FUNCTION testfunc() RETURNS int AS $$
DECLARE
  sum int;
  v int;
BEGIN
  sum := 0;
  FOR v IN SELECT /*+ SeqScan(t1) */ v FROM t1 ORDER BY id LOOP
    sum := sum + v;
  END LOOP;
  RETURN v;
END;
$$ LANGUAGE plpgsql;
SELECT testfunc();
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
not used hint:
duplication hint:
error hint:

CONTEXT:  SQL statement "SELECT /*+ SeqScan(t1) */ v FROM t1 ORDER BY id"
PL/pgSQL function testfunc() line 7 at FOR over SELECT rows
 testfunc
----------

(1 row)

-- Dynamic FOR loop
DROP FUNCTION testfunc();
CREATE FUNCTION testfunc() RETURNS int AS $$
DECLARE
  sum int;
  v int;
  i   int;
BEGIN
  sum := 0;
  FOR v IN EXECUTE 'SELECT /*+ SeqScan(t1) */ val FROM t1 ORDER BY id' LOOP
    sum := sum + v;
  END LOOP;
  RETURN v;
END;
$$ LANGUAGE plpgsql;
SELECT testfunc();
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
not used hint:
duplication hint:
error hint:

CONTEXT:  SQL statement "SELECT /*+ SeqScan(t1) */ val FROM t1 ORDER BY id"
PL/pgSQL function testfunc() line 8 at FOR over EXECUTE statement
 testfunc
----------
        0
(1 row)

-- Cursor FOR loop
DROP FUNCTION testfunc();
CREATE FUNCTION testfunc() RETURNS int AS $$
DECLARE
  ref CURSOR FOR SELECT /*+ SeqScan(t1) */ * FROM t1 ORDER BY id;
  rec record;
  sum int := 0;
BEGIN
  FOR rec IN ref LOOP
    sum := sum + rec.val;
  END LOOP;
  RETURN sum;
END;
$$ LANGUAGE plpgsql;
SELECT testfunc();
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
not used hint:
duplication hint:
error hint:

CONTEXT:  SQL statement "SELECT /*+ SeqScan(t1) */ * FROM t1 ORDER BY id"
PL/pgSQL function testfunc() line 7 at FOR over cursor
 testfunc
----------
   495000
(1 row)

-- RETURN QUERY
DROP FUNCTION testfunc();
CREATE FUNCTION testfunc() RETURNS SETOF t1 AS $$
BEGIN
  RETURN QUERY SELECT /*+ SeqScan(t1) */ * FROM t1 ORDER BY id;
END;
$$ LANGUAGE plpgsql;
SELECT * FROM testfunc() LIMIT 1;
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
not used hint:
duplication hint:
error hint:

CONTEXT:  SQL statement "SELECT /*+ SeqScan(t1) */ * FROM t1 ORDER BY id"
PL/pgSQL function testfunc() line 3 at RETURN QUERY
 id | val
----+-----
  1 |   1
(1 row)

-- Test for error exit from inner SQL statement.
DROP FUNCTION testfunc();
CREATE FUNCTION testfunc() RETURNS SETOF t1 AS $$
BEGIN
  RETURN QUERY SELECT /*+ SeqScan(t1) */ * FROM ttx ORDER BY id;
END;
$$ LANGUAGE plpgsql;
SELECT * FROM testfunc() LIMIT 1;
ERROR:  relation "ttx" does not exist
LINE 1: SELECT /*+ SeqScan(t1) */ * FROM ttx ORDER BY id
                                         ^
QUERY:  SELECT /*+ SeqScan(t1) */ * FROM ttx ORDER BY id
CONTEXT:  PL/pgSQL function testfunc() line 3 at RETURN QUERY
-- this should not use SeqScan(t1) hint.
/*+ IndexScan(t1) */ SELECT * from t1 LIMIT 1;
LOG:  pg_hint_plan:
used hint:
IndexScan(t1)
not used hint:
duplication hint:
error hint:

 id  | val
-----+-----
 854 |  54
(1 row)

DROP FUNCTION testfunc();
DROP EXTENSION pg_hint_plan;
CREATE FUNCTION reset_stats_and_wait() RETURNS void AS $$
DECLARE
  rows int;
BEGIN
  rows = 1;
  while rows > 0 LOOP
   PERFORM pg_stat_reset();
   PERFORM pg_sleep(0.5);
   SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables into rows;
  END LOOP;
END;
$$ LANGUAGE plpgsql;
-- YB_COMMENT
-- pg_stat_user_tables not supportd by YB
-- Dynamic query in pl/pgsql
-- CREATE OR REPLACE FUNCTION dynsql1(x int) RETURNS int AS $$
-- DECLARE c int;
-- BEGIN
--   EXECUTE '/*+ IndexScan(t1) */ SELECT count(*) FROM t1 WHERE id < $1'
--   	INTO c USING x;
--   RETURN c;
-- END;
-- $$ VOLATILE LANGUAGE plpgsql;
-- vacuum analyze t1;
-- SET pg_hint_plan.enable_hint = false;
-- SELECT pg_sleep(1);
-- SELECT reset_stats_and_wait();
-- SELECT dynsql1(9000);
-- SELECT pg_sleep(1);
-- SELECT relname, seq_scan > 0 as seq_scan, idx_scan > 0 as idx_scan FROM pg_stat_user_tables WHERE schemaname = 'public' AND relname = 't1';
-- SET pg_hint_plan.enable_hint = true;
-- SELECT pg_sleep(1);
-- SELECT reset_stats_and_wait();
-- SELECT dynsql1(9000);
-- SELECT pg_sleep(1);
-- SELECT relname, seq_scan > 0 as seq_scan, idx_scan > 0 as idx_scan FROM pg_stat_user_tables WHERE schemaname = 'public' AND relname = 't1';
--
-- Dependent on inheritance
-- -- Looped dynamic query in pl/pgsql
-- CREATE OR REPLACE FUNCTION dynsql2(x int, OUT r int) AS $$
-- DECLARE
--   c text;
--   s int;
-- BEGIN
--   r := 0;
--   FOR c IN SELECT f.f FROM (VALUES ('p1_c1'), ('p1_c2')) f(f) LOOP
--     FOR s IN EXECUTE '/*+ IndexScan(' || c || ' ' || c || '_pkey) */ SELECT sum(val) FROM ' || c || ' WHERE id < ' || x LOOP
--       r := r + s;
--     END LOOP;
--   END LOOP;
-- END;
-- $$ VOLATILE LANGUAGE plpgsql;
-- SET pg_hint_plan.enable_hint = false;
-- SELECT pg_sleep(1);
-- SELECT reset_stats_and_wait();
-- SELECT dynsql2(9000);
-- SELECT pg_sleep(1);
-- -- one of the index scans happened while planning.
-- SELECT relname, seq_scan, idx_scan FROM pg_stat_user_tables WHERE schemaname = 'public' AND (relname = 'p1_c1' OR relname = 'p1_c2');
-- SET pg_hint_plan.enable_hint = true;
-- SELECT pg_sleep(1);
-- SELECT reset_stats_and_wait();
-- SELECT dynsql2(9000);
-- SELECT pg_sleep(1);
-- -- the index scan happened while planning.
-- SELECT relname, seq_scan, idx_scan FROM pg_stat_user_tables WHERE schemaname = 'public' AND (relname = 'p1_c1' OR relname = 'p1_c2');
--
-- -- Subqueries on inheritance tables under UNION
-- EXPLAIN (COSTS off) SELECT val FROM p1 WHERE val < 1000
-- UNION ALL
-- SELECT val::int FROM p2 WHERE id < 1000;
--
-- /*+ IndexScan(p1 p1_val2) */
-- EXPLAIN (COSTS off) SELECT val FROM p1 WHERE val < 1000
-- UNION ALL
-- SELECT val::int FROM p2 WHERE id < 1000;
--
-- /*+ IndexScan(p1 p1_val2) IndexScan(p2 p2_id_val_idx) */
-- EXPLAIN (COSTS off) SELECT val FROM p1 WHERE val < 1000
-- UNION ALL
-- SELECT val::int FROM p2 WHERE id < 1000;
--
-- -- union all case
-- EXPLAIN (COSTS off) SELECT val FROM p1 WHERE val < 1000
-- UNION
-- SELECT val::int FROM p2 WHERE id < 1000;
--
-- /*+ IndexScan(p2 p2_id_val_idx) */
-- EXPLAIN (COSTS off) SELECT val FROM p1 WHERE val < 1000
-- UNION
-- SELECT val::int FROM p2 WHERE id < 1000;
--
-- /*+ IndexScan(p1 p1_val2) IndexScan(p2 p2_id_val_idx) */
-- EXPLAIN (COSTS off) SELECT val FROM p1 WHERE val < 1000
-- UNION
-- SELECT val::int FROM p2 WHERE id < 1000;
--
-- --
-- -- Rows hint tests
-- --
-- -- Explain result includes "Planning time" if COSTS is enabled, but
-- -- this test needs it enabled for get rows count. So do tests via psql
-- -- and grep -v the mutable line.
--
-- -- Parse error check
-- /*+ Rows() */ SELECT 1;
-- /*+ Rows(x) */ SELECT 1;
--
-- -- value types
-- \o results/pg_hint_plan.tmpout
-- EXPLAIN SELECT * FROM t1 JOIN t2 ON (t1.id = t2.id);
-- \o
-- \! sql/maskout.sh results/pg_hint_plan.tmpout
--
-- \o results/pg_hint_plan.tmpout
-- /*+ Rows(t1 t2 #99) */
-- EXPLAIN SELECT * FROM t1 JOIN t2 ON (t1.id = t2.id);
-- \o
-- \! sql/maskout.sh results/pg_hint_plan.tmpout
--
-- \o results/pg_hint_plan.tmpout
-- /*+ Rows(t1 t2 +99) */
-- EXPLAIN SELECT * FROM t1 JOIN t2 ON (t1.id = t2.id);
-- \o
-- \! sql/maskout.sh results/pg_hint_plan.tmpout
--
-- \o results/pg_hint_plan.tmpout
-- /*+ Rows(t1 t2 -99) */
-- EXPLAIN SELECT * FROM t1 JOIN t2 ON (t1.id = t2.id);
-- \o
-- \! sql/maskout.sh results/pg_hint_plan.tmpout
--
-- \o results/pg_hint_plan.tmpout
-- /*+ Rows(t1 t2 *99) */
-- EXPLAIN SELECT * FROM t1 JOIN t2 ON (t1.id = t2.id);
-- \o
-- \! sql/maskout.sh results/pg_hint_plan.tmpout
--
-- \o results/pg_hint_plan.tmpout
-- /*+ Rows(t1 t2 *0.01) */
-- EXPLAIN SELECT * FROM t1 JOIN t2 ON (t1.id = t2.id);
-- \o
-- \! sql/maskout.sh results/pg_hint_plan.tmpout
--
-- \o results/pg_hint_plan.tmpout
-- /*+ Rows(t1 t2 #aa) */
-- EXPLAIN SELECT * FROM t1 JOIN t2 ON (t1.id = t2.id); -- ERROR
-- \o
-- \! sql/maskout.sh results/pg_hint_plan.tmpout
--
-- \o results/pg_hint_plan.tmpout
-- /*+ Rows(t1 t2 /99) */
-- EXPLAIN SELECT * FROM t1 JOIN t2 ON (t1.id = t2.id); -- ERROR
-- \o
-- \! sql/maskout.sh results/pg_hint_plan.tmpout
--
-- -- round up to 1
-- \o results/pg_hint_plan.tmpout
-- /*+ Rows(t1 t2 -99999) */
-- EXPLAIN SELECT * FROM t1 JOIN t2 ON (t1.id = t2.id);
-- \o
-- \! sql/maskout.sh results/pg_hint_plan.tmpout
--
-- -- complex join tree
-- \o results/pg_hint_plan.tmpout
-- EXPLAIN SELECT * FROM t1 JOIN t2 ON (t1.id = t2.id) JOIN t3 ON (t3.id = t2.id);
-- \o
-- \! sql/maskout.sh results/pg_hint_plan.tmpout
--
-- \o results/pg_hint_plan.tmpout
-- /*+ Rows(t1 t2 #22) */
-- EXPLAIN SELECT * FROM t1 JOIN t2 ON (t1.id = t2.id) JOIN t3 ON (t3.id = t2.id);
-- \o
-- \! sql/maskout.sh results/pg_hint_plan.tmpout
--
-- \o results/pg_hint_plan.tmpout
-- /*+ Rows(t1 t3 *10) */
-- EXPLAIN SELECT * FROM t1 JOIN t2 ON (t1.id = t2.id) JOIN t3 ON (t3.id = t2.id);
-- \o
-- set max_parallel_workers_per_gather to DEFAULT;
-- \! sql/maskout.sh results/pg_hint_plan.tmpout
-- \! rm results/pg_hint_plan.tmpout
--
-- hint error level
set client_min_messages to 'DEBUG1';
set pg_hint_plan.debug_level to 'verbose';
/*+ SeqScan( */ SELECT 1;
INFO:  pg_hint_plan: hint syntax error at or near ""
DETAIL:  Closing parenthesis is necessary.
 ?column?
----------
        1
(1 row)

/*+ SeqScan(t1) */ SELECT * FROM t1 LIMIT 0;
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
not used hint:
duplication hint:
error hint:

 id | val
----+-----
(0 rows)

set pg_hint_plan.message_level to 'DEBUG1';
set pg_hint_plan.parse_messages to 'NOTICE';
/*+ SeqScan( */ SELECT 1;
NOTICE:  pg_hint_plan: hint syntax error at or near ""
DETAIL:  Closing parenthesis is necessary.
 ?column?
----------
        1
(1 row)

/*+ SeqScan(t1) */ SELECT * FROM t1 LIMIT 0;
DEBUG:  pg_hint_plan:
used hint:
SeqScan(t1)
not used hint:
duplication hint:
error hint:

 id | val
----+-----
(0 rows)

-- all hint types together
/*+ SeqScan(t1) MergeJoin(t1 t2) Leading(t1 t2) Rows(t1 t2 +10) Parallel(t1 8 hard) Set(random_page_cost 2.0)*/
EXPLAIN (costs off) SELECT * FROM t1 JOIN t2 ON (t1.id = t2.id) JOIN t3 ON (t3.id = t2.id);
DEBUG:  adjusted rows 1000 to 1010
DEBUG:  pg_hint_plan:
used hint:
SeqScan(t1)
MergeJoin(t1 t2)
Leading(t1 t2)
Set(random_page_cost 2.0)
Rows(t1 t2 +10)
Parallel(t1 8 hard)
not used hint:
duplication hint:
error hint:

                            QUERY PLAN
-------------------------------------------------------------------
 YB Batched Nested Loop Join
   Join Filter: (t1.id = t3.id)
   ->  Merge Join
         Merge Cond: (t1.id = t2.id)
         ->  Sort
               Sort Key: t1.id
               ->  Seq Scan on t1
         ->  Sort
               Sort Key: t2.id
               ->  Seq Scan on t2
   ->  Index Scan using t3_pkey on t3
         Index Cond: (id = ANY (ARRAY[t1.id, $1, $2, ..., $1023]))
(12 rows)
