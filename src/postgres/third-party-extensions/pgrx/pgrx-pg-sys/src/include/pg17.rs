/* Automatically generated by bindgen. Do not hand-edit.

This code is generated for documentation purposes, so that it is
easy to reference on docs.rs. Bindings are regenerated for your
build of pgrx, and the values of your Postgres version may differ.
*/
use crate as pg_sys;
use crate::{Datum, MultiXactId, Oid, PgNode, TransactionId};
#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") { 7 - (index % 8) } else { index % 8 };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") { 7 - (index % 8) } else { index % 8 };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index =
                    if cfg!(target_endian = "big") { bit_width as usize - 1 - i } else { i };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index =
                    if cfg!(target_endian = "big") { bit_width as usize - 1 - i } else { i };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") { bit_width as usize - 1 - i } else { i };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") { bit_width as usize - 1 - i } else { i };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        unsafe { ::core::slice::from_raw_parts(self.as_ptr(), len) }
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        unsafe { ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len) }
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const PG_DIAG_SEVERITY: u8 = 83u8;
pub const PG_DIAG_SEVERITY_NONLOCALIZED: u8 = 86u8;
pub const PG_DIAG_SQLSTATE: u8 = 67u8;
pub const PG_DIAG_MESSAGE_PRIMARY: u8 = 77u8;
pub const PG_DIAG_MESSAGE_DETAIL: u8 = 68u8;
pub const PG_DIAG_MESSAGE_HINT: u8 = 72u8;
pub const PG_DIAG_STATEMENT_POSITION: u8 = 80u8;
pub const PG_DIAG_INTERNAL_POSITION: u8 = 112u8;
pub const PG_DIAG_INTERNAL_QUERY: u8 = 113u8;
pub const PG_DIAG_CONTEXT: u8 = 87u8;
pub const PG_DIAG_SCHEMA_NAME: u8 = 115u8;
pub const PG_DIAG_TABLE_NAME: u8 = 116u8;
pub const PG_DIAG_COLUMN_NAME: u8 = 99u8;
pub const PG_DIAG_DATATYPE_NAME: u8 = 100u8;
pub const PG_DIAG_CONSTRAINT_NAME: u8 = 110u8;
pub const PG_DIAG_SOURCE_FILE: u8 = 70u8;
pub const PG_DIAG_SOURCE_LINE: u8 = 76u8;
pub const PG_DIAG_SOURCE_FUNCTION: u8 = 82u8;
pub const ALIGNOF_DOUBLE: u32 = 8;
pub const ALIGNOF_INT: u32 = 4;
pub const ALIGNOF_LONG: u32 = 8;
pub const ALIGNOF_PG_INT128_TYPE: u32 = 16;
pub const ALIGNOF_SHORT: u32 = 2;
pub const BLCKSZ: u32 = 8192;
pub const DEF_PGPORT: u32 = 28817;
pub const DEF_PGPORT_STR: &::core::ffi::CStr = c"28817";
pub const DLSUFFIX: &::core::ffi::CStr = c".so";
pub const INT64_MODIFIER: &::core::ffi::CStr = c"l";
pub const MAXIMUM_ALIGNOF: u32 = 8;
pub const MEMSET_LOOP_LIMIT: u32 = 1024;
pub const PACKAGE_BUGREPORT: &::core::ffi::CStr = c"pgsql-bugs@lists.postgresql.org";
pub const PACKAGE_NAME: &::core::ffi::CStr = c"PostgreSQL";
pub const PACKAGE_STRING: &::core::ffi::CStr = c"PostgreSQL 17.4";
pub const PACKAGE_TARNAME: &::core::ffi::CStr = c"postgresql";
pub const PACKAGE_URL: &::core::ffi::CStr = c"https://www.postgresql.org/";
pub const PACKAGE_VERSION: &::core::ffi::CStr = c"17.4";
pub const PG_KRB_SRVNAM: &::core::ffi::CStr = c"postgres";
pub const PG_MAJORVERSION: &::core::ffi::CStr = c"17";
pub const PG_MAJORVERSION_NUM: u32 = 17;
pub const PG_MINORVERSION_NUM: u32 = 4;
pub const PG_USE_STDBOOL: u32 = 1;
pub const PG_VERSION: &::core::ffi::CStr = c"17.4";
pub const PG_VERSION_NUM: u32 = 170004;
pub const PG_VERSION_STR : & :: core :: ffi :: CStr = c"PostgreSQL 17.4 on x86_64-pc-linux-gnu, compiled by gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0, 64-bit" ;
pub const RELSEG_SIZE: u32 = 131072;
pub const SIZEOF_BOOL: u32 = 1;
pub const SIZEOF_LONG: u32 = 8;
pub const SIZEOF_OFF_T: u32 = 8;
pub const SIZEOF_SIZE_T: u32 = 8;
pub const SIZEOF_VOID_P: u32 = 8;
pub const STDC_HEADERS: u32 = 1;
pub const USE_ASSERT_CHECKING: u32 = 1;
pub const USE_AVX512_POPCNT_WITH_RUNTIME_CHECK: u32 = 1;
pub const USE_ICU: u32 = 1;
pub const USE_SSE42_CRC32C_WITH_RUNTIME_CHECK: u32 = 1;
pub const USE_SYSV_SHARED_MEMORY: u32 = 1;
pub const USE_UNNAMED_POSIX_SEMAPHORES: u32 = 1;
pub const XLOG_BLCKSZ: u32 = 8192;
pub const DEFAULT_XLOG_SEG_SIZE: u32 = 16777216;
pub const NAMEDATALEN: u32 = 64;
pub const FUNC_MAX_ARGS: u32 = 100;
pub const FMGR_ABI_EXTRA: &::core::ffi::CStr = c"PostgreSQL";
pub const INDEX_MAX_KEYS: u32 = 32;
pub const PARTITION_MAX_KEYS: u32 = 32;
pub const USE_FLOAT8_BYVAL: u32 = 1;
pub const NUM_SPINLOCK_SEMAPHORES: u32 = 128;
pub const NUM_ATOMICS_SEMAPHORES: u32 = 64;
pub const MAXPGPATH: u32 = 1024;
pub const BITS_PER_BYTE: u32 = 8;
pub const ALIGNOF_BUFFER: u32 = 32;
pub const DEFAULT_BACKEND_FLUSH_AFTER: u32 = 0;
pub const DEFAULT_BGWRITER_FLUSH_AFTER: u32 = 64;
pub const DEFAULT_CHECKPOINT_FLUSH_AFTER: u32 = 32;
pub const WRITEBACK_MAX_PENDING_FLUSHES: u32 = 256;
pub const DEFAULT_PGSOCKET_DIR: &::core::ffi::CStr = c"/tmp";
pub const DEFAULT_EVENT_SOURCE: &::core::ffi::CStr = c"PostgreSQL";
pub const PG_CACHE_LINE_SIZE: u32 = 128;
pub const PG_IO_ALIGN_SIZE: u32 = 4096;
pub const TRACE_SORT: u32 = 1;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_WIDTH: u32 = 32;
pub const INT64_FORMAT: &::core::ffi::CStr = c"%ld";
pub const UINT64_FORMAT: &::core::ffi::CStr = c"%lu";
pub const PG_INT8_MIN: i32 = -128;
pub const PG_INT8_MAX: u32 = 127;
pub const PG_UINT8_MAX: u32 = 255;
pub const PG_INT16_MIN: i32 = -32768;
pub const PG_INT16_MAX: u32 = 32767;
pub const PG_UINT16_MAX: u32 = 65535;
pub const PG_INT32_MIN: i32 = -2147483648;
pub const PG_INT32_MAX: u32 = 2147483647;
pub const PG_UINT32_MAX: u32 = 4294967295;
pub const FLOAT8PASSBYVAL: u32 = 1;
pub const HIGHBIT: u32 = 128;
pub const ESCAPE_STRING_SYNTAX: u8 = 69u8;
pub const STATUS_OK: u32 = 0;
pub const STATUS_ERROR: i32 = -1;
pub const STATUS_EOF: i32 = -2;
pub const PG_BINARY: u32 = 0;
pub const PG_BINARY_A: &::core::ffi::CStr = c"a";
pub const PG_BINARY_R: &::core::ffi::CStr = c"r";
pub const PG_BINARY_W: &::core::ffi::CStr = c"w";
pub const PGINVALID_SOCKET: i32 = -1;
pub const PG_BACKEND_VERSIONSTR: &::core::ffi::CStr = c"postgres (PostgreSQL) 17.4\n";
pub const EXE: &::core::ffi::CStr = c"";
pub const DEVNULL: &::core::ffi::CStr = c"/dev/null";
pub const USE_REPL_SNPRINTF: u32 = 1;
pub const PG_STRERROR_R_BUFLEN: u32 = 256;
pub const PG_IOLBF: u32 = 1;
pub const DEBUG5: u32 = 10;
pub const DEBUG4: u32 = 11;
pub const DEBUG3: u32 = 12;
pub const DEBUG2: u32 = 13;
pub const DEBUG1: u32 = 14;
pub const LOG: u32 = 15;
pub const LOG_SERVER_ONLY: u32 = 16;
pub const COMMERROR: u32 = 16;
pub const INFO: u32 = 17;
pub const NOTICE: u32 = 18;
pub const WARNING: u32 = 19;
pub const PGWARNING: u32 = 19;
pub const WARNING_CLIENT_ONLY: u32 = 20;
pub const PGERROR: u32 = 21;
pub const FATAL: u32 = 22;
pub const PANIC: u32 = 23;
pub const LOG_DESTINATION_STDERR: u32 = 1;
pub const LOG_DESTINATION_SYSLOG: u32 = 2;
pub const LOG_DESTINATION_EVENTLOG: u32 = 4;
pub const LOG_DESTINATION_CSVLOG: u32 = 8;
pub const LOG_DESTINATION_JSONLOG: u32 = 16;
pub const MCXT_ALLOC_HUGE: u32 = 1;
pub const MCXT_ALLOC_NO_OOM: u32 = 2;
pub const MCXT_ALLOC_ZERO: u32 = 4;
pub const FIELDNO_NULLABLE_DATUM_DATUM: u32 = 0;
pub const FIELDNO_NULLABLE_DATUM_ISNULL: u32 = 1;
pub const SIZEOF_DATUM: u32 = 8;
pub const InvalidAttrNumber: u32 = 0;
pub const MaxAttrNumber: u32 = 32767;
pub const AttributeRelationId: Oid = Oid(1249);
pub const AttributeRelation_Rowtype_Id: u32 = 75;
pub const AttributeRelidNameIndexId: u32 = 2658;
pub const AttributeRelidNumIndexId: u32 = 2659;
pub const Anum_pg_attribute_attrelid: u32 = 1;
pub const Anum_pg_attribute_attname: u32 = 2;
pub const Anum_pg_attribute_atttypid: u32 = 3;
pub const Anum_pg_attribute_attlen: u32 = 4;
pub const Anum_pg_attribute_attnum: u32 = 5;
pub const Anum_pg_attribute_attcacheoff: u32 = 6;
pub const Anum_pg_attribute_atttypmod: u32 = 7;
pub const Anum_pg_attribute_attndims: u32 = 8;
pub const Anum_pg_attribute_attbyval: u32 = 9;
pub const Anum_pg_attribute_attalign: u32 = 10;
pub const Anum_pg_attribute_attstorage: u32 = 11;
pub const Anum_pg_attribute_attcompression: u32 = 12;
pub const Anum_pg_attribute_attnotnull: u32 = 13;
pub const Anum_pg_attribute_atthasdef: u32 = 14;
pub const Anum_pg_attribute_atthasmissing: u32 = 15;
pub const Anum_pg_attribute_attidentity: u32 = 16;
pub const Anum_pg_attribute_attgenerated: u32 = 17;
pub const Anum_pg_attribute_attisdropped: u32 = 18;
pub const Anum_pg_attribute_attislocal: u32 = 19;
pub const Anum_pg_attribute_attinhcount: u32 = 20;
pub const Anum_pg_attribute_attcollation: u32 = 21;
pub const Anum_pg_attribute_attstattarget: u32 = 22;
pub const Anum_pg_attribute_attacl: u32 = 23;
pub const Anum_pg_attribute_attoptions: u32 = 24;
pub const Anum_pg_attribute_attfdwoptions: u32 = 25;
pub const Anum_pg_attribute_attmissingval: u32 = 26;
pub const Natts_pg_attribute: u32 = 26;
pub const ATTRIBUTE_IDENTITY_ALWAYS: u8 = 97u8;
pub const ATTRIBUTE_IDENTITY_BY_DEFAULT: u8 = 100u8;
pub const ATTRIBUTE_GENERATED_STORED: u8 = 115u8;
pub const AGGSPLITOP_COMBINE: u32 = 1;
pub const AGGSPLITOP_SKIPFINAL: u32 = 2;
pub const AGGSPLITOP_SERIALIZE: u32 = 4;
pub const AGGSPLITOP_DESERIALIZE: u32 = 8;
pub const LP_UNUSED: u32 = 0;
pub const LP_NORMAL: u32 = 1;
pub const LP_REDIRECT: u32 = 2;
pub const LP_DEAD: u32 = 3;
pub const SpecTokenOffsetNumber: u32 = 65534;
pub const MovedPartitionsOffsetNumber: u32 = 65533;
pub const FIELDNO_HEAPTUPLEDATA_DATA: u32 = 3;
pub const InvalidXLogRecPtr: u32 = 0;
pub const FirstGenbkiObjectId: u32 = 10000;
pub const FirstUnpinnedObjectId: u32 = 12000;
pub const FirstNormalObjectId: u32 = 16384;
pub const TypeRelationId: Oid = Oid(1247);
pub const TypeRelation_Rowtype_Id: u32 = 71;
pub const TypeOidIndexId: u32 = 2703;
pub const TypeNameNspIndexId: u32 = 2704;
pub const Anum_pg_type_oid: u32 = 1;
pub const Anum_pg_type_typname: u32 = 2;
pub const Anum_pg_type_typnamespace: u32 = 3;
pub const Anum_pg_type_typowner: u32 = 4;
pub const Anum_pg_type_typlen: u32 = 5;
pub const Anum_pg_type_typbyval: u32 = 6;
pub const Anum_pg_type_typtype: u32 = 7;
pub const Anum_pg_type_typcategory: u32 = 8;
pub const Anum_pg_type_typispreferred: u32 = 9;
pub const Anum_pg_type_typisdefined: u32 = 10;
pub const Anum_pg_type_typdelim: u32 = 11;
pub const Anum_pg_type_typrelid: u32 = 12;
pub const Anum_pg_type_typsubscript: u32 = 13;
pub const Anum_pg_type_typelem: u32 = 14;
pub const Anum_pg_type_typarray: u32 = 15;
pub const Anum_pg_type_typinput: u32 = 16;
pub const Anum_pg_type_typoutput: u32 = 17;
pub const Anum_pg_type_typreceive: u32 = 18;
pub const Anum_pg_type_typsend: u32 = 19;
pub const Anum_pg_type_typmodin: u32 = 20;
pub const Anum_pg_type_typmodout: u32 = 21;
pub const Anum_pg_type_typanalyze: u32 = 22;
pub const Anum_pg_type_typalign: u32 = 23;
pub const Anum_pg_type_typstorage: u32 = 24;
pub const Anum_pg_type_typnotnull: u32 = 25;
pub const Anum_pg_type_typbasetype: u32 = 26;
pub const Anum_pg_type_typtypmod: u32 = 27;
pub const Anum_pg_type_typndims: u32 = 28;
pub const Anum_pg_type_typcollation: u32 = 29;
pub const Anum_pg_type_typdefaultbin: u32 = 30;
pub const Anum_pg_type_typdefault: u32 = 31;
pub const Anum_pg_type_typacl: u32 = 32;
pub const Natts_pg_type: u32 = 32;
pub const TYPTYPE_BASE: u8 = 98u8;
pub const TYPTYPE_COMPOSITE: u8 = 99u8;
pub const TYPTYPE_DOMAIN: u8 = 100u8;
pub const TYPTYPE_ENUM: u8 = 101u8;
pub const TYPTYPE_MULTIRANGE: u8 = 109u8;
pub const TYPTYPE_PSEUDO: u8 = 112u8;
pub const TYPTYPE_RANGE: u8 = 114u8;
pub const TYPCATEGORY_INVALID: u8 = 0u8;
pub const TYPCATEGORY_ARRAY: u8 = 65u8;
pub const TYPCATEGORY_BOOLEAN: u8 = 66u8;
pub const TYPCATEGORY_COMPOSITE: u8 = 67u8;
pub const TYPCATEGORY_DATETIME: u8 = 68u8;
pub const TYPCATEGORY_ENUM: u8 = 69u8;
pub const TYPCATEGORY_GEOMETRIC: u8 = 71u8;
pub const TYPCATEGORY_NETWORK: u8 = 73u8;
pub const TYPCATEGORY_NUMERIC: u8 = 78u8;
pub const TYPCATEGORY_PSEUDOTYPE: u8 = 80u8;
pub const TYPCATEGORY_RANGE: u8 = 82u8;
pub const TYPCATEGORY_STRING: u8 = 83u8;
pub const TYPCATEGORY_TIMESPAN: u8 = 84u8;
pub const TYPCATEGORY_USER: u8 = 85u8;
pub const TYPCATEGORY_BITSTRING: u8 = 86u8;
pub const TYPCATEGORY_UNKNOWN: u8 = 88u8;
pub const TYPCATEGORY_INTERNAL: u8 = 90u8;
pub const TYPALIGN_CHAR: u8 = 99u8;
pub const TYPALIGN_SHORT: u8 = 115u8;
pub const TYPALIGN_INT: u8 = 105u8;
pub const TYPALIGN_DOUBLE: u8 = 100u8;
pub const TYPSTORAGE_PLAIN: u8 = 112u8;
pub const TYPSTORAGE_EXTERNAL: u8 = 101u8;
pub const TYPSTORAGE_EXTENDED: u8 = 120u8;
pub const TYPSTORAGE_MAIN: u8 = 109u8;
pub const BOOLOID: Oid = Oid(16);
pub const BYTEAOID: Oid = Oid(17);
pub const CHAROID: Oid = Oid(18);
pub const NAMEOID: Oid = Oid(19);
pub const INT8OID: Oid = Oid(20);
pub const INT2OID: Oid = Oid(21);
pub const INT2VECTOROID: Oid = Oid(22);
pub const INT4OID: Oid = Oid(23);
pub const REGPROCOID: Oid = Oid(24);
pub const TEXTOID: Oid = Oid(25);
pub const OIDOID: Oid = Oid(26);
pub const TIDOID: Oid = Oid(27);
pub const XIDOID: Oid = Oid(28);
pub const CIDOID: Oid = Oid(29);
pub const OIDVECTOROID: Oid = Oid(30);
pub const JSONOID: Oid = Oid(114);
pub const XMLOID: Oid = Oid(142);
pub const PG_NODE_TREEOID: Oid = Oid(194);
pub const PG_NDISTINCTOID: Oid = Oid(3361);
pub const PG_DEPENDENCIESOID: Oid = Oid(3402);
pub const PG_MCV_LISTOID: Oid = Oid(5017);
pub const PG_DDL_COMMANDOID: Oid = Oid(32);
pub const XID8OID: Oid = Oid(5069);
pub const POINTOID: Oid = Oid(600);
pub const LSEGOID: Oid = Oid(601);
pub const PATHOID: Oid = Oid(602);
pub const BOXOID: Oid = Oid(603);
pub const POLYGONOID: Oid = Oid(604);
pub const LINEOID: Oid = Oid(628);
pub const FLOAT4OID: Oid = Oid(700);
pub const FLOAT8OID: Oid = Oid(701);
pub const UNKNOWNOID: Oid = Oid(705);
pub const CIRCLEOID: Oid = Oid(718);
pub const MONEYOID: Oid = Oid(790);
pub const MACADDROID: Oid = Oid(829);
pub const INETOID: Oid = Oid(869);
pub const CIDROID: Oid = Oid(650);
pub const MACADDR8OID: Oid = Oid(774);
pub const ACLITEMOID: Oid = Oid(1033);
pub const BPCHAROID: Oid = Oid(1042);
pub const VARCHAROID: Oid = Oid(1043);
pub const DATEOID: Oid = Oid(1082);
pub const TIMEOID: Oid = Oid(1083);
pub const TIMESTAMPOID: Oid = Oid(1114);
pub const TIMESTAMPTZOID: Oid = Oid(1184);
pub const INTERVALOID: Oid = Oid(1186);
pub const TIMETZOID: Oid = Oid(1266);
pub const BITOID: Oid = Oid(1560);
pub const VARBITOID: Oid = Oid(1562);
pub const NUMERICOID: Oid = Oid(1700);
pub const REFCURSOROID: Oid = Oid(1790);
pub const REGPROCEDUREOID: Oid = Oid(2202);
pub const REGOPEROID: Oid = Oid(2203);
pub const REGOPERATOROID: Oid = Oid(2204);
pub const REGCLASSOID: Oid = Oid(2205);
pub const REGCOLLATIONOID: Oid = Oid(4191);
pub const REGTYPEOID: Oid = Oid(2206);
pub const REGROLEOID: Oid = Oid(4096);
pub const REGNAMESPACEOID: Oid = Oid(4089);
pub const UUIDOID: Oid = Oid(2950);
pub const PG_LSNOID: Oid = Oid(3220);
pub const TSVECTOROID: Oid = Oid(3614);
pub const GTSVECTOROID: Oid = Oid(3642);
pub const TSQUERYOID: Oid = Oid(3615);
pub const REGCONFIGOID: Oid = Oid(3734);
pub const REGDICTIONARYOID: Oid = Oid(3769);
pub const JSONBOID: Oid = Oid(3802);
pub const JSONPATHOID: Oid = Oid(4072);
pub const TXID_SNAPSHOTOID: Oid = Oid(2970);
pub const PG_SNAPSHOTOID: Oid = Oid(5038);
pub const INT4RANGEOID: Oid = Oid(3904);
pub const NUMRANGEOID: Oid = Oid(3906);
pub const TSRANGEOID: Oid = Oid(3908);
pub const TSTZRANGEOID: Oid = Oid(3910);
pub const DATERANGEOID: Oid = Oid(3912);
pub const INT8RANGEOID: Oid = Oid(3926);
pub const INT4MULTIRANGEOID: Oid = Oid(4451);
pub const NUMMULTIRANGEOID: Oid = Oid(4532);
pub const TSMULTIRANGEOID: Oid = Oid(4533);
pub const TSTZMULTIRANGEOID: Oid = Oid(4534);
pub const DATEMULTIRANGEOID: Oid = Oid(4535);
pub const INT8MULTIRANGEOID: Oid = Oid(4536);
pub const RECORDOID: Oid = Oid(2249);
pub const RECORDARRAYOID: Oid = Oid(2287);
pub const CSTRINGOID: Oid = Oid(2275);
pub const ANYOID: Oid = Oid(2276);
pub const ANYARRAYOID: Oid = Oid(2277);
pub const VOIDOID: Oid = Oid(2278);
pub const TRIGGEROID: Oid = Oid(2279);
pub const EVENT_TRIGGEROID: Oid = Oid(3838);
pub const LANGUAGE_HANDLEROID: Oid = Oid(2280);
pub const INTERNALOID: Oid = Oid(2281);
pub const ANYELEMENTOID: Oid = Oid(2283);
pub const ANYNONARRAYOID: Oid = Oid(2776);
pub const ANYENUMOID: Oid = Oid(3500);
pub const FDW_HANDLEROID: Oid = Oid(3115);
pub const INDEX_AM_HANDLEROID: Oid = Oid(325);
pub const TSM_HANDLEROID: Oid = Oid(3310);
pub const TABLE_AM_HANDLEROID: Oid = Oid(269);
pub const ANYRANGEOID: Oid = Oid(3831);
pub const ANYCOMPATIBLEOID: Oid = Oid(5077);
pub const ANYCOMPATIBLEARRAYOID: Oid = Oid(5078);
pub const ANYCOMPATIBLENONARRAYOID: Oid = Oid(5079);
pub const ANYCOMPATIBLERANGEOID: Oid = Oid(5080);
pub const ANYMULTIRANGEOID: Oid = Oid(4537);
pub const ANYCOMPATIBLEMULTIRANGEOID: Oid = Oid(4538);
pub const PG_BRIN_BLOOM_SUMMARYOID: Oid = Oid(4600);
pub const PG_BRIN_MINMAX_MULTI_SUMMARYOID: Oid = Oid(4601);
pub const BOOLARRAYOID: Oid = Oid(1000);
pub const BYTEAARRAYOID: Oid = Oid(1001);
pub const CHARARRAYOID: Oid = Oid(1002);
pub const NAMEARRAYOID: Oid = Oid(1003);
pub const INT8ARRAYOID: Oid = Oid(1016);
pub const INT2ARRAYOID: Oid = Oid(1005);
pub const INT2VECTORARRAYOID: Oid = Oid(1006);
pub const INT4ARRAYOID: Oid = Oid(1007);
pub const REGPROCARRAYOID: Oid = Oid(1008);
pub const TEXTARRAYOID: Oid = Oid(1009);
pub const OIDARRAYOID: Oid = Oid(1028);
pub const TIDARRAYOID: Oid = Oid(1010);
pub const XIDARRAYOID: Oid = Oid(1011);
pub const CIDARRAYOID: Oid = Oid(1012);
pub const OIDVECTORARRAYOID: Oid = Oid(1013);
pub const PG_TYPEARRAYOID: Oid = Oid(210);
pub const PG_ATTRIBUTEARRAYOID: Oid = Oid(270);
pub const PG_PROCARRAYOID: Oid = Oid(272);
pub const PG_CLASSARRAYOID: Oid = Oid(273);
pub const JSONARRAYOID: Oid = Oid(199);
pub const XMLARRAYOID: Oid = Oid(143);
pub const XID8ARRAYOID: Oid = Oid(271);
pub const POINTARRAYOID: Oid = Oid(1017);
pub const LSEGARRAYOID: Oid = Oid(1018);
pub const PATHARRAYOID: Oid = Oid(1019);
pub const BOXARRAYOID: Oid = Oid(1020);
pub const POLYGONARRAYOID: Oid = Oid(1027);
pub const LINEARRAYOID: Oid = Oid(629);
pub const FLOAT4ARRAYOID: Oid = Oid(1021);
pub const FLOAT8ARRAYOID: Oid = Oid(1022);
pub const CIRCLEARRAYOID: Oid = Oid(719);
pub const MONEYARRAYOID: Oid = Oid(791);
pub const MACADDRARRAYOID: Oid = Oid(1040);
pub const INETARRAYOID: Oid = Oid(1041);
pub const CIDRARRAYOID: Oid = Oid(651);
pub const MACADDR8ARRAYOID: Oid = Oid(775);
pub const ACLITEMARRAYOID: Oid = Oid(1034);
pub const BPCHARARRAYOID: Oid = Oid(1014);
pub const VARCHARARRAYOID: Oid = Oid(1015);
pub const DATEARRAYOID: Oid = Oid(1182);
pub const TIMEARRAYOID: Oid = Oid(1183);
pub const TIMESTAMPARRAYOID: Oid = Oid(1115);
pub const TIMESTAMPTZARRAYOID: Oid = Oid(1185);
pub const INTERVALARRAYOID: Oid = Oid(1187);
pub const TIMETZARRAYOID: Oid = Oid(1270);
pub const BITARRAYOID: Oid = Oid(1561);
pub const VARBITARRAYOID: Oid = Oid(1563);
pub const NUMERICARRAYOID: Oid = Oid(1231);
pub const REFCURSORARRAYOID: Oid = Oid(2201);
pub const REGPROCEDUREARRAYOID: Oid = Oid(2207);
pub const REGOPERARRAYOID: Oid = Oid(2208);
pub const REGOPERATORARRAYOID: Oid = Oid(2209);
pub const REGCLASSARRAYOID: Oid = Oid(2210);
pub const REGCOLLATIONARRAYOID: Oid = Oid(4192);
pub const REGTYPEARRAYOID: Oid = Oid(2211);
pub const REGROLEARRAYOID: Oid = Oid(4097);
pub const REGNAMESPACEARRAYOID: Oid = Oid(4090);
pub const UUIDARRAYOID: Oid = Oid(2951);
pub const PG_LSNARRAYOID: Oid = Oid(3221);
pub const TSVECTORARRAYOID: Oid = Oid(3643);
pub const GTSVECTORARRAYOID: Oid = Oid(3644);
pub const TSQUERYARRAYOID: Oid = Oid(3645);
pub const REGCONFIGARRAYOID: Oid = Oid(3735);
pub const REGDICTIONARYARRAYOID: Oid = Oid(3770);
pub const JSONBARRAYOID: Oid = Oid(3807);
pub const JSONPATHARRAYOID: Oid = Oid(4073);
pub const TXID_SNAPSHOTARRAYOID: Oid = Oid(2949);
pub const PG_SNAPSHOTARRAYOID: Oid = Oid(5039);
pub const INT4RANGEARRAYOID: Oid = Oid(3905);
pub const NUMRANGEARRAYOID: Oid = Oid(3907);
pub const TSRANGEARRAYOID: Oid = Oid(3909);
pub const TSTZRANGEARRAYOID: Oid = Oid(3911);
pub const DATERANGEARRAYOID: Oid = Oid(3913);
pub const INT8RANGEARRAYOID: Oid = Oid(3927);
pub const INT4MULTIRANGEARRAYOID: Oid = Oid(6150);
pub const NUMMULTIRANGEARRAYOID: Oid = Oid(6151);
pub const TSMULTIRANGEARRAYOID: Oid = Oid(6152);
pub const TSTZMULTIRANGEARRAYOID: Oid = Oid(6153);
pub const DATEMULTIRANGEARRAYOID: Oid = Oid(6155);
pub const INT8MULTIRANGEARRAYOID: Oid = Oid(6157);
pub const CSTRINGARRAYOID: Oid = Oid(1263);
pub const PD_HAS_FREE_LINES: u32 = 1;
pub const PD_PAGE_FULL: u32 = 2;
pub const PD_ALL_VISIBLE: u32 = 4;
pub const PD_VALID_FLAG_BITS: u32 = 7;
pub const PG_PAGE_LAYOUT_VERSION: u32 = 4;
pub const PG_DATA_CHECKSUM_VERSION: u32 = 1;
pub const PAI_OVERWRITE: u32 = 1;
pub const PAI_IS_HEAP: u32 = 2;
pub const PIV_LOG_WARNING: u32 = 1;
pub const PIV_REPORT_STAT: u32 = 2;
pub const VARLENA_EXTSIZE_BITS: u32 = 30;
pub const VARLENA_EXTSIZE_MASK: u32 = 1073741823;
pub const VARATT_SHORT_MAX: u32 = 127;
pub const MaxTupleAttributeNumber: u32 = 1664;
pub const MaxHeapAttributeNumber: u32 = 1600;
pub const FIELDNO_HEAPTUPLEHEADERDATA_INFOMASK2: u32 = 2;
pub const FIELDNO_HEAPTUPLEHEADERDATA_INFOMASK: u32 = 3;
pub const FIELDNO_HEAPTUPLEHEADERDATA_HOFF: u32 = 4;
pub const FIELDNO_HEAPTUPLEHEADERDATA_BITS: u32 = 5;
pub const HEAP_HASNULL: u32 = 1;
pub const HEAP_HASVARWIDTH: u32 = 2;
pub const HEAP_HASEXTERNAL: u32 = 4;
pub const HEAP_HASOID_OLD: u32 = 8;
pub const HEAP_XMAX_KEYSHR_LOCK: u32 = 16;
pub const HEAP_COMBOCID: u32 = 32;
pub const HEAP_XMAX_EXCL_LOCK: u32 = 64;
pub const HEAP_XMAX_LOCK_ONLY: u32 = 128;
pub const HEAP_XMAX_SHR_LOCK: u32 = 80;
pub const HEAP_LOCK_MASK: u32 = 80;
pub const HEAP_XMIN_COMMITTED: u32 = 256;
pub const HEAP_XMIN_INVALID: u32 = 512;
pub const HEAP_XMIN_FROZEN: u32 = 768;
pub const HEAP_XMAX_COMMITTED: u32 = 1024;
pub const HEAP_XMAX_INVALID: u32 = 2048;
pub const HEAP_XMAX_IS_MULTI: u32 = 4096;
pub const HEAP_UPDATED: u32 = 8192;
pub const HEAP_MOVED_OFF: u32 = 16384;
pub const HEAP_MOVED_IN: u32 = 32768;
pub const HEAP_MOVED: u32 = 49152;
pub const HEAP_XACT_MASK: u32 = 65520;
pub const HEAP_XMAX_BITS: u32 = 7376;
pub const HEAP_NATTS_MASK: u32 = 2047;
pub const HEAP_KEYS_UPDATED: u32 = 8192;
pub const HEAP_HOT_UPDATED: u32 = 16384;
pub const HEAP_ONLY_TUPLE: u32 = 32768;
pub const HEAP2_XACT_MASK: u32 = 57344;
pub const HEAP_TUPLE_HAS_MATCH: u32 = 32768;
pub const MaxAttrSize: u32 = 10485760;
pub const SelfItemPointerAttributeNumber: i32 = -1;
pub const MinTransactionIdAttributeNumber: i32 = -2;
pub const MinCommandIdAttributeNumber: i32 = -3;
pub const MaxTransactionIdAttributeNumber: i32 = -4;
pub const MaxCommandIdAttributeNumber: i32 = -5;
pub const TableOidAttributeNumber: i32 = -6;
pub const FirstLowInvalidHeapAttributeNumber: i32 = -7;
pub const InvalidBuffer: u32 = 0;
pub const TTS_FLAG_EMPTY: u32 = 2;
pub const TTS_FLAG_SHOULDFREE: u32 = 4;
pub const TTS_FLAG_SLOW: u32 = 8;
pub const TTS_FLAG_FIXED: u32 = 16;
pub const FIELDNO_TUPLETABLESLOT_FLAGS: u32 = 1;
pub const FIELDNO_TUPLETABLESLOT_NVALID: u32 = 2;
pub const FIELDNO_TUPLETABLESLOT_TUPLEDESCRIPTOR: u32 = 4;
pub const FIELDNO_TUPLETABLESLOT_VALUES: u32 = 5;
pub const FIELDNO_TUPLETABLESLOT_ISNULL: u32 = 6;
pub const FIELDNO_HEAPTUPLETABLESLOT_TUPLE: u32 = 1;
pub const FIELDNO_HEAPTUPLETABLESLOT_OFF: u32 = 2;
pub const FIELDNO_MINIMALTUPLETABLESLOT_TUPLE: u32 = 1;
pub const FIELDNO_MINIMALTUPLETABLESLOT_OFF: u32 = 4;
pub const BITS_PER_BITMAPWORD: u32 = 64;
pub const PG_INSTR_CLOCK: u32 = 1;
pub const FIELDNO_FUNCTIONCALLINFODATA_ISNULL: u32 = 4;
pub const FIELDNO_FUNCTIONCALLINFODATA_ARGS: u32 = 6;
pub const PG_MAGIC_FUNCTION_NAME_STRING: &::core::ffi::CStr = c"Pg_magic_func";
pub const AGG_CONTEXT_AGGREGATE: u32 = 1;
pub const AGG_CONTEXT_WINDOW: u32 = 2;
pub const PARAM_FLAG_CONST: u32 = 1;
pub const BTLessStrategyNumber: u32 = 1;
pub const BTLessEqualStrategyNumber: u32 = 2;
pub const BTEqualStrategyNumber: u32 = 3;
pub const BTGreaterEqualStrategyNumber: u32 = 4;
pub const BTGreaterStrategyNumber: u32 = 5;
pub const BTMaxStrategyNumber: u32 = 5;
pub const HTEqualStrategyNumber: u32 = 1;
pub const HTMaxStrategyNumber: u32 = 1;
pub const RTLeftStrategyNumber: u32 = 1;
pub const RTOverLeftStrategyNumber: u32 = 2;
pub const RTOverlapStrategyNumber: u32 = 3;
pub const RTOverRightStrategyNumber: u32 = 4;
pub const RTRightStrategyNumber: u32 = 5;
pub const RTSameStrategyNumber: u32 = 6;
pub const RTContainsStrategyNumber: u32 = 7;
pub const RTContainedByStrategyNumber: u32 = 8;
pub const RTOverBelowStrategyNumber: u32 = 9;
pub const RTBelowStrategyNumber: u32 = 10;
pub const RTAboveStrategyNumber: u32 = 11;
pub const RTOverAboveStrategyNumber: u32 = 12;
pub const RTOldContainsStrategyNumber: u32 = 13;
pub const RTOldContainedByStrategyNumber: u32 = 14;
pub const RTKNNSearchStrategyNumber: u32 = 15;
pub const RTContainsElemStrategyNumber: u32 = 16;
pub const RTAdjacentStrategyNumber: u32 = 17;
pub const RTEqualStrategyNumber: u32 = 18;
pub const RTNotEqualStrategyNumber: u32 = 19;
pub const RTLessStrategyNumber: u32 = 20;
pub const RTLessEqualStrategyNumber: u32 = 21;
pub const RTGreaterStrategyNumber: u32 = 22;
pub const RTGreaterEqualStrategyNumber: u32 = 23;
pub const RTSubStrategyNumber: u32 = 24;
pub const RTSubEqualStrategyNumber: u32 = 25;
pub const RTSuperStrategyNumber: u32 = 26;
pub const RTSuperEqualStrategyNumber: u32 = 27;
pub const RTPrefixStrategyNumber: u32 = 28;
pub const RTOldBelowStrategyNumber: u32 = 29;
pub const RTOldAboveStrategyNumber: u32 = 30;
pub const RTMaxStrategyNumber: u32 = 30;
pub const CATALOG_VERSION_NO: u32 = 202406281;
pub const OIDCHARS: u32 = 10;
pub const FORKNAMECHARS: u32 = 4;
pub const INNER_VAR: i32 = -1;
pub const OUTER_VAR: i32 = -2;
pub const INDEX_VAR: i32 = -3;
pub const ROWID_VAR: i32 = -4;
pub const PRS2_OLD_VARNO: u32 = 1;
pub const PRS2_NEW_VARNO: u32 = 2;
pub const DSM_IMPL_POSIX: u32 = 1;
pub const DSM_IMPL_SYSV: u32 = 2;
pub const DSM_IMPL_WINDOWS: u32 = 3;
pub const DSM_IMPL_MMAP: u32 = 4;
pub const DEFAULT_DYNAMIC_SHARED_MEMORY_TYPE: u32 = 1;
pub const PG_DYNSHMEM_DIR: &::core::ffi::CStr = c"pg_dynshmem";
pub const PG_DYNSHMEM_MMAP_FILE_PREFIX: &::core::ffi::CStr = c"mmap.";
pub const DSM_CREATE_NULL_IF_MAXSEGMENTS: u32 = 1;
pub const SIZEOF_DSA_POINTER: u32 = 8;
pub const DSA_POINTER_FORMAT: &::core::ffi::CStr = c"%016lx";
pub const DSA_ALLOC_HUGE: u32 = 1;
pub const DSA_ALLOC_NO_OOM: u32 = 2;
pub const DSA_ALLOC_ZERO: u32 = 4;
pub const DSA_OFFSET_WIDTH: u32 = 40;
pub const INVALID_PROC_NUMBER: i32 = -1;
pub const DEFAULT_SPINS_PER_DELAY: u32 = 100;
pub const HASH_PARTITION: u32 = 1;
pub const HASH_SEGMENT: u32 = 2;
pub const HASH_DIRSIZE: u32 = 4;
pub const HASH_ELEM: u32 = 8;
pub const HASH_STRINGS: u32 = 16;
pub const HASH_BLOBS: u32 = 32;
pub const HASH_FUNCTION: u32 = 64;
pub const HASH_COMPARE: u32 = 128;
pub const HASH_KEYCOPY: u32 = 256;
pub const HASH_ALLOC: u32 = 512;
pub const HASH_CONTEXT: u32 = 1024;
pub const HASH_SHARED_MEM: u32 = 2048;
pub const HASH_ATTACH: u32 = 4096;
pub const HASH_FIXED_SIZE: u32 = 8192;
pub const NO_MAX_DSIZE: i32 = -1;
pub const IO_DIRECT_DATA: u32 = 1;
pub const IO_DIRECT_WAL: u32 = 2;
pub const IO_DIRECT_WAL_INIT: u32 = 4;
pub const PG_O_DIRECT: u32 = 16384;
pub const SHARED_TUPLESTORE_SINGLE_PASS: u32 = 1;
pub const MAX_TIMESTAMP_PRECISION: u32 = 6;
pub const MAX_INTERVAL_PRECISION: u32 = 6;
pub const TS_PREC_INV: f64 = 1000000.0;
pub const DAYS_PER_YEAR: f64 = 365.25;
pub const MONTHS_PER_YEAR: u32 = 12;
pub const DAYS_PER_MONTH: u32 = 30;
pub const DAYS_PER_WEEK: u32 = 7;
pub const HOURS_PER_DAY: u32 = 24;
pub const SECS_PER_YEAR: u32 = 31557600;
pub const SECS_PER_DAY: u32 = 86400;
pub const SECS_PER_HOUR: u32 = 3600;
pub const SECS_PER_MINUTE: u32 = 60;
pub const MINS_PER_HOUR: u32 = 60;
pub const MAX_TZDISP_HOUR: u32 = 15;
pub const TZDISP_LIMIT: u32 = 57600;
pub const JULIAN_MINYEAR: i32 = -4713;
pub const JULIAN_MINMONTH: u32 = 11;
pub const JULIAN_MINDAY: u32 = 24;
pub const JULIAN_MAXYEAR: u32 = 5874898;
pub const JULIAN_MAXMONTH: u32 = 6;
pub const JULIAN_MAXDAY: u32 = 3;
pub const UNIX_EPOCH_JDATE: u32 = 2440588;
pub const POSTGRES_EPOCH_JDATE: u32 = 2451545;
pub const DATETIME_MIN_JULIAN: u32 = 0;
pub const DATE_END_JULIAN: u32 = 2147483494;
pub const TIMESTAMP_END_JULIAN: u32 = 109203528;
pub const RELCACHE_INIT_FILENAME: &::core::ffi::CStr = c"pg_internal.init";
pub const SK_ISNULL: u32 = 1;
pub const SK_UNARY: u32 = 2;
pub const SK_ROW_HEADER: u32 = 4;
pub const SK_ROW_MEMBER: u32 = 8;
pub const SK_ROW_END: u32 = 16;
pub const SK_SEARCHARRAY: u32 = 32;
pub const SK_SEARCHNULL: u32 = 64;
pub const SK_SEARCHNOTNULL: u32 = 128;
pub const SK_ORDER_BY: u32 = 256;
pub const NoLock: u32 = 0;
pub const AccessShareLock: u32 = 1;
pub const RowShareLock: u32 = 2;
pub const RowExclusiveLock: u32 = 3;
pub const ShareUpdateExclusiveLock: u32 = 4;
pub const ShareLock: u32 = 5;
pub const ShareRowExclusiveLock: u32 = 6;
pub const ExclusiveLock: u32 = 7;
pub const AccessExclusiveLock: u32 = 8;
pub const MaxLockMode: u32 = 8;
pub const InplaceUpdateTupleLock: u32 = 7;
pub const TYPECACHE_EQ_OPR: u32 = 1;
pub const TYPECACHE_LT_OPR: u32 = 2;
pub const TYPECACHE_GT_OPR: u32 = 4;
pub const TYPECACHE_CMP_PROC: u32 = 8;
pub const TYPECACHE_HASH_PROC: u32 = 16;
pub const TYPECACHE_EQ_OPR_FINFO: u32 = 32;
pub const TYPECACHE_CMP_PROC_FINFO: u32 = 64;
pub const TYPECACHE_HASH_PROC_FINFO: u32 = 128;
pub const TYPECACHE_TUPDESC: u32 = 256;
pub const TYPECACHE_BTREE_OPFAMILY: u32 = 512;
pub const TYPECACHE_HASH_OPFAMILY: u32 = 1024;
pub const TYPECACHE_RANGE_INFO: u32 = 2048;
pub const TYPECACHE_DOMAIN_BASE_INFO: u32 = 4096;
pub const TYPECACHE_DOMAIN_CONSTR_INFO: u32 = 8192;
pub const TYPECACHE_HASH_EXTENDED_PROC: u32 = 16384;
pub const TYPECACHE_HASH_EXTENDED_PROC_FINFO: u32 = 32768;
pub const TYPECACHE_MULTIRANGE_INFO: u32 = 65536;
pub const BRIN_PROCNUM_OPCINFO: u32 = 1;
pub const BRIN_PROCNUM_ADDVALUE: u32 = 2;
pub const BRIN_PROCNUM_CONSISTENT: u32 = 3;
pub const BRIN_PROCNUM_UNION: u32 = 4;
pub const BRIN_MANDATORY_NPROCS: u32 = 4;
pub const BRIN_PROCNUM_OPTIONS: u32 = 5;
pub const BRIN_FIRST_OPTIONAL_PROCNUM: u32 = 11;
pub const BRIN_LAST_OPTIONAL_PROCNUM: u32 = 15;
pub const BRIN_OFFSET_MASK: u32 = 31;
pub const BRIN_EMPTY_RANGE_MASK: u32 = 32;
pub const BRIN_PLACEHOLDER_MASK: u32 = 64;
pub const BRIN_NULLS_MASK: u32 = 128;
pub const INDEX_SIZE_MASK: u32 = 8191;
pub const INDEX_AM_RESERVED_BIT: u32 = 8192;
pub const INDEX_VAR_MASK: u32 = 16384;
pub const INDEX_NULL_MASK: u32 = 32768;
pub const NUM_TUPLESORTMETHODS: u32 = 4;
pub const TUPLESORT_NONE: u32 = 0;
pub const TUPLESORT_RANDOMACCESS: u32 = 1;
pub const TUPLESORT_ALLOWBOUNDED: u32 = 2;
pub const EEO_FLAG_IS_QUAL: u32 = 1;
pub const FIELDNO_EXPRSTATE_RESNULL: u32 = 2;
pub const FIELDNO_EXPRSTATE_RESVALUE: u32 = 3;
pub const FIELDNO_EXPRSTATE_RESULTSLOT: u32 = 4;
pub const FIELDNO_EXPRSTATE_PARENT: u32 = 11;
pub const FIELDNO_EXPRCONTEXT_SCANTUPLE: u32 = 1;
pub const FIELDNO_EXPRCONTEXT_INNERTUPLE: u32 = 2;
pub const FIELDNO_EXPRCONTEXT_OUTERTUPLE: u32 = 3;
pub const FIELDNO_EXPRCONTEXT_AGGVALUES: u32 = 8;
pub const FIELDNO_EXPRCONTEXT_AGGNULLS: u32 = 9;
pub const FIELDNO_EXPRCONTEXT_CASEDATUM: u32 = 10;
pub const FIELDNO_EXPRCONTEXT_CASENULL: u32 = 11;
pub const FIELDNO_EXPRCONTEXT_DOMAINDATUM: u32 = 12;
pub const FIELDNO_EXPRCONTEXT_DOMAINNULL: u32 = 13;
pub const TRY_POPCNT_FAST: u32 = 1;
pub const MERGE_INSERT: u32 = 1;
pub const MERGE_UPDATE: u32 = 2;
pub const MERGE_DELETE: u32 = 4;
pub const FIELDNO_AGGSTATE_CURAGGCONTEXT: u32 = 14;
pub const FIELDNO_AGGSTATE_CURPERTRANS: u32 = 16;
pub const FIELDNO_AGGSTATE_CURRENT_SET: u32 = 20;
pub const FIELDNO_AGGSTATE_ALL_PERGROUPS: u32 = 53;
pub const COMPLETION_TAG_BUFSIZE: u32 = 64;
pub const ACL_INSERT: u32 = 1;
pub const ACL_SELECT: u32 = 2;
pub const ACL_UPDATE: u32 = 4;
pub const ACL_DELETE: u32 = 8;
pub const ACL_TRUNCATE: u32 = 16;
pub const ACL_REFERENCES: u32 = 32;
pub const ACL_TRIGGER: u32 = 64;
pub const ACL_EXECUTE: u32 = 128;
pub const ACL_USAGE: u32 = 256;
pub const ACL_CREATE: u32 = 512;
pub const ACL_CREATE_TEMP: u32 = 1024;
pub const ACL_CONNECT: u32 = 2048;
pub const ACL_SET: u32 = 4096;
pub const ACL_ALTER_SYSTEM: u32 = 8192;
pub const ACL_MAINTAIN: u32 = 16384;
pub const N_ACL_RIGHTS: u32 = 15;
pub const ACL_NO_RIGHTS: u32 = 0;
pub const ACL_SELECT_FOR_UPDATE: u32 = 4;
pub const FRAMEOPTION_NONDEFAULT: u32 = 1;
pub const FRAMEOPTION_RANGE: u32 = 2;
pub const FRAMEOPTION_ROWS: u32 = 4;
pub const FRAMEOPTION_GROUPS: u32 = 8;
pub const FRAMEOPTION_BETWEEN: u32 = 16;
pub const FRAMEOPTION_START_UNBOUNDED_PRECEDING: u32 = 32;
pub const FRAMEOPTION_END_UNBOUNDED_PRECEDING: u32 = 64;
pub const FRAMEOPTION_START_UNBOUNDED_FOLLOWING: u32 = 128;
pub const FRAMEOPTION_END_UNBOUNDED_FOLLOWING: u32 = 256;
pub const FRAMEOPTION_START_CURRENT_ROW: u32 = 512;
pub const FRAMEOPTION_END_CURRENT_ROW: u32 = 1024;
pub const FRAMEOPTION_START_OFFSET_PRECEDING: u32 = 2048;
pub const FRAMEOPTION_END_OFFSET_PRECEDING: u32 = 4096;
pub const FRAMEOPTION_START_OFFSET_FOLLOWING: u32 = 8192;
pub const FRAMEOPTION_END_OFFSET_FOLLOWING: u32 = 16384;
pub const FRAMEOPTION_EXCLUDE_CURRENT_ROW: u32 = 32768;
pub const FRAMEOPTION_EXCLUDE_GROUP: u32 = 65536;
pub const FRAMEOPTION_EXCLUDE_TIES: u32 = 131072;
pub const FRAMEOPTION_START_OFFSET: u32 = 10240;
pub const FRAMEOPTION_END_OFFSET: u32 = 20480;
pub const FRAMEOPTION_EXCLUSION: u32 = 229376;
pub const FRAMEOPTION_DEFAULTS: u32 = 1058;
pub const FKCONSTR_ACTION_NOACTION: u8 = 97u8;
pub const FKCONSTR_ACTION_RESTRICT: u8 = 114u8;
pub const FKCONSTR_ACTION_CASCADE: u8 = 99u8;
pub const FKCONSTR_ACTION_SETNULL: u8 = 110u8;
pub const FKCONSTR_ACTION_SETDEFAULT: u8 = 100u8;
pub const FKCONSTR_MATCH_FULL: u8 = 102u8;
pub const FKCONSTR_MATCH_PARTIAL: u8 = 112u8;
pub const FKCONSTR_MATCH_SIMPLE: u8 = 115u8;
pub const OPCLASS_ITEM_OPERATOR: u32 = 1;
pub const OPCLASS_ITEM_FUNCTION: u32 = 2;
pub const OPCLASS_ITEM_STORAGETYPE: u32 = 3;
pub const CURSOR_OPT_BINARY: u32 = 1;
pub const CURSOR_OPT_SCROLL: u32 = 2;
pub const CURSOR_OPT_NO_SCROLL: u32 = 4;
pub const CURSOR_OPT_INSENSITIVE: u32 = 8;
pub const CURSOR_OPT_ASENSITIVE: u32 = 16;
pub const CURSOR_OPT_HOLD: u32 = 32;
pub const CURSOR_OPT_FAST_PLAN: u32 = 256;
pub const CURSOR_OPT_GENERIC_PLAN: u32 = 512;
pub const CURSOR_OPT_CUSTOM_PLAN: u32 = 1024;
pub const CURSOR_OPT_PARALLEL_OK: u32 = 2048;
pub const MaxAllocHugeSize: u32 = 0;
pub const InvalidAllocSize: i32 = -1;
pub const ALLOCSET_DEFAULT_MINSIZE: u32 = 0;
pub const ALLOCSET_DEFAULT_INITSIZE: u32 = 8192;
pub const ALLOCSET_DEFAULT_MAXSIZE: u32 = 8388608;
pub const ALLOCSET_SMALL_MINSIZE: u32 = 0;
pub const ALLOCSET_SMALL_INITSIZE: u32 = 1024;
pub const ALLOCSET_SMALL_MAXSIZE: u32 = 8192;
pub const ALLOCSET_SEPARATE_THRESHOLD: u32 = 8192;
pub const SLAB_DEFAULT_BLOCK_SIZE: u32 = 8192;
pub const SLAB_LARGE_BLOCK_SIZE: u32 = 8388608;
pub const EXEC_FLAG_EXPLAIN_ONLY: u32 = 1;
pub const EXEC_FLAG_EXPLAIN_GENERIC: u32 = 2;
pub const EXEC_FLAG_REWIND: u32 = 4;
pub const EXEC_FLAG_BACKWARD: u32 = 8;
pub const EXEC_FLAG_MARK: u32 = 16;
pub const EXEC_FLAG_SKIP_TRIGGERS: u32 = 32;
pub const EXEC_FLAG_WITH_NO_DATA: u32 = 64;
pub const MAT_SRF_USE_EXPECTED_DESC: u32 = 1;
pub const MAT_SRF_BLESS: u32 = 2;
pub const SIGINT: u32 = 2;
pub const SIGILL: u32 = 4;
pub const SIGABRT: u32 = 6;
pub const SIGFPE: u32 = 8;
pub const SIGSEGV: u32 = 11;
pub const SIGTERM: u32 = 15;
pub const SIGHUP: u32 = 1;
pub const SIGQUIT: u32 = 3;
pub const SIGTRAP: u32 = 5;
pub const SIGKILL: u32 = 9;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGIOT: u32 = 6;
pub const SIGSTKFLT: u32 = 16;
pub const SIGPWR: u32 = 30;
pub const SIGBUS: u32 = 7;
pub const SIGSYS: u32 = 31;
pub const SIGURG: u32 = 23;
pub const SIGSTOP: u32 = 19;
pub const SIGTSTP: u32 = 20;
pub const SIGCONT: u32 = 18;
pub const SIGCHLD: u32 = 17;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGPOLL: u32 = 29;
pub const SIGXFSZ: u32 = 25;
pub const SIGXCPU: u32 = 24;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGUSR1: u32 = 10;
pub const SIGUSR2: u32 = 12;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 29;
pub const SIGCLD: u32 = 17;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const SIGSTKSZ: u32 = 8192;
pub const TZ_STRLEN_MAX: u32 = 255;
pub const InvalidPid: i32 = -1;
pub const USE_POSTGRES_DATES: u32 = 0;
pub const USE_ISO_DATES: u32 = 1;
pub const USE_SQL_DATES: u32 = 2;
pub const USE_GERMAN_DATES: u32 = 3;
pub const USE_XSD_DATES: u32 = 4;
pub const DATEORDER_YMD: u32 = 0;
pub const DATEORDER_DMY: u32 = 1;
pub const DATEORDER_MDY: u32 = 2;
pub const INTSTYLE_POSTGRES: u32 = 0;
pub const INTSTYLE_POSTGRES_VERBOSE: u32 = 1;
pub const INTSTYLE_SQL_STANDARD: u32 = 2;
pub const INTSTYLE_ISO_8601: u32 = 3;
pub const MAXTZLEN: u32 = 10;
pub const MIN_BAS_VAC_RING_SIZE_KB: u32 = 128;
pub const MAX_BAS_VAC_RING_SIZE_KB: u32 = 16777216;
pub const SECURITY_LOCAL_USERID_CHANGE: u32 = 1;
pub const SECURITY_RESTRICTED_OPERATION: u32 = 2;
pub const SECURITY_NOFORCE_RLS: u32 = 4;
pub const INIT_PG_LOAD_SESSION_LIBS: u32 = 1;
pub const INIT_PG_OVERRIDE_ALLOW_CONNS: u32 = 2;
pub const INIT_PG_OVERRIDE_ROLE_LOGIN: u32 = 4;
pub const MIN_XFN_CHARS: u32 = 16;
pub const MAX_XFN_CHARS: u32 = 40;
pub const VALID_XFN_CHARS: &::core::ffi::CStr = c"0123456789ABCDEF.history.backup.partial";
pub const PGSTAT_NUM_PROGRESS_PARAM: u32 = 20;
pub const PqMsg_Bind: u8 = 66u8;
pub const PqMsg_Close: u8 = 67u8;
pub const PqMsg_Describe: u8 = 68u8;
pub const PqMsg_Execute: u8 = 69u8;
pub const PqMsg_FunctionCall: u8 = 70u8;
pub const PqMsg_Flush: u8 = 72u8;
pub const PqMsg_Parse: u8 = 80u8;
pub const PqMsg_Query: u8 = 81u8;
pub const PqMsg_Sync: u8 = 83u8;
pub const PqMsg_Terminate: u8 = 88u8;
pub const PqMsg_CopyFail: u8 = 102u8;
pub const PqMsg_GSSResponse: u8 = 112u8;
pub const PqMsg_PasswordMessage: u8 = 112u8;
pub const PqMsg_SASLInitialResponse: u8 = 112u8;
pub const PqMsg_SASLResponse: u8 = 112u8;
pub const PqMsg_ParseComplete: u8 = 49u8;
pub const PqMsg_BindComplete: u8 = 50u8;
pub const PqMsg_CloseComplete: u8 = 51u8;
pub const PqMsg_NotificationResponse: u8 = 65u8;
pub const PqMsg_CommandComplete: u8 = 67u8;
pub const PqMsg_DataRow: u8 = 68u8;
pub const PqMsg_ErrorResponse: u8 = 69u8;
pub const PqMsg_CopyInResponse: u8 = 71u8;
pub const PqMsg_CopyOutResponse: u8 = 72u8;
pub const PqMsg_EmptyQueryResponse: u8 = 73u8;
pub const PqMsg_BackendKeyData: u8 = 75u8;
pub const PqMsg_NoticeResponse: u8 = 78u8;
pub const PqMsg_AuthenticationRequest: u8 = 82u8;
pub const PqMsg_ParameterStatus: u8 = 83u8;
pub const PqMsg_RowDescription: u8 = 84u8;
pub const PqMsg_FunctionCallResponse: u8 = 86u8;
pub const PqMsg_CopyBothResponse: u8 = 87u8;
pub const PqMsg_ReadyForQuery: u8 = 90u8;
pub const PqMsg_NoData: u8 = 110u8;
pub const PqMsg_PortalSuspended: u8 = 115u8;
pub const PqMsg_ParameterDescription: u8 = 116u8;
pub const PqMsg_NegotiateProtocolVersion: u8 = 118u8;
pub const PqMsg_CopyDone: u8 = 99u8;
pub const PqMsg_CopyData: u8 = 100u8;
pub const PqMsg_Progress: u8 = 80u8;
pub const AUTH_REQ_OK: u32 = 0;
pub const AUTH_REQ_KRB4: u32 = 1;
pub const AUTH_REQ_KRB5: u32 = 2;
pub const AUTH_REQ_PASSWORD: u32 = 3;
pub const AUTH_REQ_CRYPT: u32 = 4;
pub const AUTH_REQ_MD5: u32 = 5;
pub const AUTH_REQ_GSS: u32 = 7;
pub const AUTH_REQ_GSS_CONT: u32 = 8;
pub const AUTH_REQ_SSPI: u32 = 9;
pub const AUTH_REQ_SASL: u32 = 10;
pub const AUTH_REQ_SASL_CONT: u32 = 11;
pub const AUTH_REQ_SASL_FIN: u32 = 12;
pub const AUTH_REQ_MAX: u32 = 12;
pub const MAX_STARTUP_PACKET_LENGTH: u32 = 10000;
pub const PG_ALPN_PROTOCOL: &::core::ffi::CStr = c"postgresql";
pub const PG_WAIT_LWLOCK: u32 = 16777216;
pub const PG_WAIT_LOCK: u32 = 50331648;
pub const PG_WAIT_BUFFERPIN: u32 = 67108864;
pub const PG_WAIT_ACTIVITY: u32 = 83886080;
pub const PG_WAIT_CLIENT: u32 = 100663296;
pub const PG_WAIT_EXTENSION: u32 = 117440512;
pub const PG_WAIT_IPC: u32 = 134217728;
pub const PG_WAIT_TIMEOUT: u32 = 150994944;
pub const PG_WAIT_IO: u32 = 167772160;
pub const PG_WAIT_INJECTIONPOINT: u32 = 184549376;
pub const PGSTAT_STAT_PERMANENT_DIRECTORY: &::core::ffi::CStr = c"pg_stat";
pub const PGSTAT_STAT_PERMANENT_FILENAME: &::core::ffi::CStr = c"pg_stat/pgstat.stat";
pub const PGSTAT_STAT_PERMANENT_TMPFILE: &::core::ffi::CStr = c"pg_stat/pgstat.tmp";
pub const PG_STAT_TMP_DIR: &::core::ffi::CStr = c"pg_stat_tmp";
pub const PGSTAT_FILE_FORMAT_ID: u32 = 27638956;
pub const CHECKPOINT_IS_SHUTDOWN: u32 = 1;
pub const CHECKPOINT_END_OF_RECOVERY: u32 = 2;
pub const CHECKPOINT_IMMEDIATE: u32 = 4;
pub const CHECKPOINT_FORCE: u32 = 8;
pub const CHECKPOINT_FLUSH_ALL: u32 = 16;
pub const CHECKPOINT_WAIT: u32 = 32;
pub const CHECKPOINT_REQUESTED: u32 = 64;
pub const CHECKPOINT_CAUSE_XLOG: u32 = 128;
pub const CHECKPOINT_CAUSE_TIME: u32 = 256;
pub const XLOG_INCLUDE_ORIGIN: u32 = 1;
pub const XLOG_MARK_UNIMPORTANT: u32 = 2;
pub const RECOVERY_SIGNAL_FILE: &::core::ffi::CStr = c"recovery.signal";
pub const STANDBY_SIGNAL_FILE: &::core::ffi::CStr = c"standby.signal";
pub const BACKUP_LABEL_FILE: &::core::ffi::CStr = c"backup_label";
pub const BACKUP_LABEL_OLD: &::core::ffi::CStr = c"backup_label.old";
pub const TABLESPACE_MAP: &::core::ffi::CStr = c"tablespace_map";
pub const TABLESPACE_MAP_OLD: &::core::ffi::CStr = c"tablespace_map.old";
pub const PROMOTE_SIGNAL_FILE: &::core::ffi::CStr = c"promote";
pub const RM_MAX_ID: u32 = 255;
pub const RM_MIN_CUSTOM_ID: u32 = 128;
pub const RM_MAX_CUSTOM_ID: u32 = 255;
pub const RM_N_IDS: u32 = 256;
pub const RM_N_CUSTOM_IDS: u32 = 128;
pub const RM_EXPERIMENTAL_ID: u32 = 128;
pub const XLR_INFO_MASK: u32 = 15;
pub const XLR_RMGR_INFO_MASK: u32 = 240;
pub const XLogRecordMaxSize: u32 = 1069547520;
pub const XLR_SPECIAL_REL_UPDATE: u32 = 1;
pub const XLR_CHECK_CONSISTENCY: u32 = 2;
pub const BKPIMAGE_HAS_HOLE: u32 = 1;
pub const BKPIMAGE_APPLY: u32 = 2;
pub const BKPIMAGE_COMPRESS_PGLZ: u32 = 4;
pub const BKPIMAGE_COMPRESS_LZ4: u32 = 8;
pub const BKPIMAGE_COMPRESS_ZSTD: u32 = 16;
pub const BKPBLOCK_FORK_MASK: u32 = 15;
pub const BKPBLOCK_FLAG_MASK: u32 = 240;
pub const BKPBLOCK_HAS_IMAGE: u32 = 16;
pub const BKPBLOCK_HAS_DATA: u32 = 32;
pub const BKPBLOCK_WILL_INIT: u32 = 64;
pub const BKPBLOCK_SAME_REL: u32 = 128;
pub const XLR_MAX_BLOCK_ID: u32 = 32;
pub const XLR_BLOCK_ID_DATA_SHORT: u32 = 255;
pub const XLR_BLOCK_ID_DATA_LONG: u32 = 254;
pub const XLR_BLOCK_ID_ORIGIN: u32 = 253;
pub const XLR_BLOCK_ID_TOPLEVEL_XID: u32 = 252;
pub const XLR_NORMAL_MAX_BLOCK_ID: u32 = 4;
pub const XLR_NORMAL_RDATAS: u32 = 20;
pub const REGBUF_FORCE_IMAGE: u32 = 1;
pub const REGBUF_NO_IMAGE: u32 = 2;
pub const REGBUF_WILL_INIT: u32 = 6;
pub const REGBUF_STANDARD: u32 = 8;
pub const REGBUF_KEEP_DATA: u32 = 16;
pub const REGBUF_NO_CHANGE: u32 = 32;
pub const RelationRelationId: Oid = Oid(1259);
pub const RelationRelation_Rowtype_Id: u32 = 83;
pub const ClassOidIndexId: u32 = 2662;
pub const ClassNameNspIndexId: u32 = 2663;
pub const ClassTblspcRelfilenodeIndexId: u32 = 3455;
pub const Anum_pg_class_oid: u32 = 1;
pub const Anum_pg_class_relname: u32 = 2;
pub const Anum_pg_class_relnamespace: u32 = 3;
pub const Anum_pg_class_reltype: u32 = 4;
pub const Anum_pg_class_reloftype: u32 = 5;
pub const Anum_pg_class_relowner: u32 = 6;
pub const Anum_pg_class_relam: u32 = 7;
pub const Anum_pg_class_relfilenode: u32 = 8;
pub const Anum_pg_class_reltablespace: u32 = 9;
pub const Anum_pg_class_relpages: u32 = 10;
pub const Anum_pg_class_reltuples: u32 = 11;
pub const Anum_pg_class_relallvisible: u32 = 12;
pub const Anum_pg_class_reltoastrelid: u32 = 13;
pub const Anum_pg_class_relhasindex: u32 = 14;
pub const Anum_pg_class_relisshared: u32 = 15;
pub const Anum_pg_class_relpersistence: u32 = 16;
pub const Anum_pg_class_relkind: u32 = 17;
pub const Anum_pg_class_relnatts: u32 = 18;
pub const Anum_pg_class_relchecks: u32 = 19;
pub const Anum_pg_class_relhasrules: u32 = 20;
pub const Anum_pg_class_relhastriggers: u32 = 21;
pub const Anum_pg_class_relhassubclass: u32 = 22;
pub const Anum_pg_class_relrowsecurity: u32 = 23;
pub const Anum_pg_class_relforcerowsecurity: u32 = 24;
pub const Anum_pg_class_relispopulated: u32 = 25;
pub const Anum_pg_class_relreplident: u32 = 26;
pub const Anum_pg_class_relispartition: u32 = 27;
pub const Anum_pg_class_relrewrite: u32 = 28;
pub const Anum_pg_class_relfrozenxid: u32 = 29;
pub const Anum_pg_class_relminmxid: u32 = 30;
pub const Anum_pg_class_relacl: u32 = 31;
pub const Anum_pg_class_reloptions: u32 = 32;
pub const Anum_pg_class_relpartbound: u32 = 33;
pub const Natts_pg_class: u32 = 33;
pub const RELKIND_RELATION: u8 = 114u8;
pub const RELKIND_INDEX: u8 = 105u8;
pub const RELKIND_SEQUENCE: u8 = 83u8;
pub const RELKIND_TOASTVALUE: u8 = 116u8;
pub const RELKIND_VIEW: u8 = 118u8;
pub const RELKIND_MATVIEW: u8 = 109u8;
pub const RELKIND_COMPOSITE_TYPE: u8 = 99u8;
pub const RELKIND_FOREIGN_TABLE: u8 = 102u8;
pub const RELKIND_PARTITIONED_TABLE: u8 = 112u8;
pub const RELKIND_PARTITIONED_INDEX: u8 = 73u8;
pub const RELPERSISTENCE_PERMANENT: u8 = 112u8;
pub const RELPERSISTENCE_UNLOGGED: u8 = 117u8;
pub const RELPERSISTENCE_TEMP: u8 = 116u8;
pub const REPLICA_IDENTITY_DEFAULT: u8 = 100u8;
pub const REPLICA_IDENTITY_NOTHING: u8 = 110u8;
pub const REPLICA_IDENTITY_FULL: u8 = 102u8;
pub const REPLICA_IDENTITY_INDEX: u8 = 105u8;
pub const IndexRelationId: Oid = Oid(2610);
pub const IndexIndrelidIndexId: u32 = 2678;
pub const IndexRelidIndexId: u32 = 2679;
pub const Anum_pg_index_indexrelid: u32 = 1;
pub const Anum_pg_index_indrelid: u32 = 2;
pub const Anum_pg_index_indnatts: u32 = 3;
pub const Anum_pg_index_indnkeyatts: u32 = 4;
pub const Anum_pg_index_indisunique: u32 = 5;
pub const Anum_pg_index_indnullsnotdistinct: u32 = 6;
pub const Anum_pg_index_indisprimary: u32 = 7;
pub const Anum_pg_index_indisexclusion: u32 = 8;
pub const Anum_pg_index_indimmediate: u32 = 9;
pub const Anum_pg_index_indisclustered: u32 = 10;
pub const Anum_pg_index_indisvalid: u32 = 11;
pub const Anum_pg_index_indcheckxmin: u32 = 12;
pub const Anum_pg_index_indisready: u32 = 13;
pub const Anum_pg_index_indislive: u32 = 14;
pub const Anum_pg_index_indisreplident: u32 = 15;
pub const Anum_pg_index_indkey: u32 = 16;
pub const Anum_pg_index_indcollation: u32 = 17;
pub const Anum_pg_index_indclass: u32 = 18;
pub const Anum_pg_index_indoption: u32 = 19;
pub const Anum_pg_index_indexprs: u32 = 20;
pub const Anum_pg_index_indpred: u32 = 21;
pub const Natts_pg_index: u32 = 21;
pub const INDOPTION_DESC: u32 = 1;
pub const INDOPTION_NULLS_FIRST: u32 = 2;
pub const PublicationRelationId: Oid = Oid(6104);
pub const PublicationObjectIndexId: u32 = 6110;
pub const PublicationNameIndexId: u32 = 6111;
pub const Anum_pg_publication_oid: u32 = 1;
pub const Anum_pg_publication_pubname: u32 = 2;
pub const Anum_pg_publication_pubowner: u32 = 3;
pub const Anum_pg_publication_puballtables: u32 = 4;
pub const Anum_pg_publication_pubinsert: u32 = 5;
pub const Anum_pg_publication_pubupdate: u32 = 6;
pub const Anum_pg_publication_pubdelete: u32 = 7;
pub const Anum_pg_publication_pubtruncate: u32 = 8;
pub const Anum_pg_publication_pubviaroot: u32 = 9;
pub const Natts_pg_publication: u32 = 9;
pub const HEAP_MIN_FILLFACTOR: u32 = 10;
pub const HEAP_DEFAULT_FILLFACTOR: u32 = 100;
pub const MAX_GENERIC_XLOG_PAGES: u32 = 4;
pub const GENERIC_XLOG_FULL_IMAGE: u32 = 1;
pub const GIN_COMPARE_PROC: u32 = 1;
pub const GIN_EXTRACTVALUE_PROC: u32 = 2;
pub const GIN_EXTRACTQUERY_PROC: u32 = 3;
pub const GIN_CONSISTENT_PROC: u32 = 4;
pub const GIN_COMPARE_PARTIAL_PROC: u32 = 5;
pub const GIN_TRICONSISTENT_PROC: u32 = 6;
pub const GIN_OPTIONS_PROC: u32 = 7;
pub const GINNProcs: u32 = 7;
pub const GIN_SEARCH_MODE_DEFAULT: u32 = 0;
pub const GIN_SEARCH_MODE_INCLUDE_EMPTY: u32 = 1;
pub const GIN_SEARCH_MODE_ALL: u32 = 2;
pub const GIN_SEARCH_MODE_EVERYTHING: u32 = 3;
pub const GIN_FALSE: u32 = 0;
pub const GIN_TRUE: u32 = 1;
pub const GIN_MAYBE: u32 = 2;
pub const GIST_CONSISTENT_PROC: u32 = 1;
pub const GIST_UNION_PROC: u32 = 2;
pub const GIST_COMPRESS_PROC: u32 = 3;
pub const GIST_DECOMPRESS_PROC: u32 = 4;
pub const GIST_PENALTY_PROC: u32 = 5;
pub const GIST_PICKSPLIT_PROC: u32 = 6;
pub const GIST_EQUAL_PROC: u32 = 7;
pub const GIST_DISTANCE_PROC: u32 = 8;
pub const GIST_FETCH_PROC: u32 = 9;
pub const GIST_OPTIONS_PROC: u32 = 10;
pub const GIST_SORTSUPPORT_PROC: u32 = 11;
pub const GISTNProcs: u32 = 11;
pub const F_LEAF: u32 = 1;
pub const F_DELETED: u32 = 2;
pub const F_TUPLES_DELETED: u32 = 4;
pub const F_FOLLOW_RIGHT: u32 = 8;
pub const F_HAS_GARBAGE: u32 = 16;
pub const GIST_PAGE_ID: u32 = 65409;
pub const SHAREDINVALCATALOG_ID: i32 = -1;
pub const SHAREDINVALRELCACHE_ID: i32 = -2;
pub const SHAREDINVALSMGR_ID: i32 = -3;
pub const SHAREDINVALRELMAP_ID: i32 = -4;
pub const SHAREDINVALSNAPSHOT_ID: i32 = -5;
pub const GIDSIZE: u32 = 200;
pub const XACT_READ_UNCOMMITTED: u32 = 0;
pub const XACT_READ_COMMITTED: u32 = 1;
pub const XACT_REPEATABLE_READ: u32 = 2;
pub const XACT_SERIALIZABLE: u32 = 3;
pub const XACT_FLAGS_ACCESSEDTEMPNAMESPACE: u32 = 1;
pub const XACT_FLAGS_ACQUIREDACCESSEXCLUSIVELOCK: u32 = 2;
pub const XACT_FLAGS_NEEDIMMEDIATECOMMIT: u32 = 4;
pub const XACT_FLAGS_PIPELINING: u32 = 8;
pub const XLOG_XACT_COMMIT: u32 = 0;
pub const XLOG_XACT_PREPARE: u32 = 16;
pub const XLOG_XACT_ABORT: u32 = 32;
pub const XLOG_XACT_COMMIT_PREPARED: u32 = 48;
pub const XLOG_XACT_ABORT_PREPARED: u32 = 64;
pub const XLOG_XACT_ASSIGNMENT: u32 = 80;
pub const XLOG_XACT_INVALIDATIONS: u32 = 96;
pub const XLOG_XACT_OPMASK: u32 = 112;
pub const XLOG_XACT_HAS_INFO: u32 = 128;
pub const XACT_XINFO_HAS_DBINFO: u32 = 1;
pub const XACT_XINFO_HAS_SUBXACTS: u32 = 2;
pub const XACT_XINFO_HAS_RELFILELOCATORS: u32 = 4;
pub const XACT_XINFO_HAS_INVALS: u32 = 8;
pub const XACT_XINFO_HAS_TWOPHASE: u32 = 16;
pub const XACT_XINFO_HAS_ORIGIN: u32 = 32;
pub const XACT_XINFO_HAS_AE_LOCKS: u32 = 64;
pub const XACT_XINFO_HAS_GID: u32 = 128;
pub const XACT_XINFO_HAS_DROPPED_STATS: u32 = 256;
pub const XACT_COMPLETION_APPLY_FEEDBACK: u32 = 536870912;
pub const XACT_COMPLETION_UPDATE_RELCACHE_FILE: u32 = 1073741824;
pub const XACT_COMPLETION_FORCE_SYNC_COMMIT: u32 = 2147483648;
pub const RELEASE_PRIO_BUFFER_IOS: u32 = 100;
pub const RELEASE_PRIO_BUFFER_PINS: u32 = 200;
pub const RELEASE_PRIO_RELCACHE_REFS: u32 = 300;
pub const RELEASE_PRIO_DSMS: u32 = 400;
pub const RELEASE_PRIO_JIT_CONTEXTS: u32 = 500;
pub const RELEASE_PRIO_CRYPTOHASH_CONTEXTS: u32 = 600;
pub const RELEASE_PRIO_HMAC_CONTEXTS: u32 = 700;
pub const RELEASE_PRIO_CATCACHE_REFS: u32 = 100;
pub const RELEASE_PRIO_CATCACHE_LIST_REFS: u32 = 200;
pub const RELEASE_PRIO_PLANCACHE_REFS: u32 = 300;
pub const RELEASE_PRIO_TUPDESC_REFS: u32 = 400;
pub const RELEASE_PRIO_SNAPSHOT_REFS: u32 = 500;
pub const RELEASE_PRIO_FILES: u32 = 600;
pub const RELEASE_PRIO_WAITEVENTSETS: u32 = 700;
pub const RELEASE_PRIO_FIRST: u32 = 1;
pub const RELEASE_PRIO_LAST: u32 = 4294967295;
pub const READ_BUFFERS_ZERO_ON_ERROR: u32 = 1;
pub const READ_BUFFERS_ISSUE_ADVICE: u32 = 2;
pub const DEFAULT_EFFECTIVE_IO_CONCURRENCY: u32 = 1;
pub const DEFAULT_MAINTENANCE_IO_CONCURRENCY: u32 = 10;
pub const MAX_IO_CONCURRENCY: u32 = 1000;
pub const BUFFER_LOCK_UNLOCK: u32 = 0;
pub const BUFFER_LOCK_SHARE: u32 = 1;
pub const BUFFER_LOCK_EXCLUSIVE: u32 = 2;
pub const READ_STREAM_DEFAULT: u32 = 0;
pub const READ_STREAM_MAINTENANCE: u32 = 1;
pub const READ_STREAM_SEQUENTIAL: u32 = 2;
pub const READ_STREAM_FULL: u32 = 4;
pub const DEFAULT_TABLE_ACCESS_METHOD: &::core::ffi::CStr = c"heap";
pub const TABLE_INSERT_SKIP_FSM: u32 = 2;
pub const TABLE_INSERT_FROZEN: u32 = 4;
pub const TABLE_INSERT_NO_LOGICAL: u32 = 8;
pub const TUPLE_LOCK_FLAG_LOCK_UPDATE_IN_PROGRESS: u32 = 1;
pub const TUPLE_LOCK_FLAG_FIND_LAST_VERSION: u32 = 2;
pub const SHMEM_INDEX_KEYSIZE: u32 = 48;
pub const SHMEM_INDEX_SIZE: u32 = 64;
pub const HEAP_INSERT_SKIP_FSM: u32 = 2;
pub const HEAP_INSERT_FROZEN: u32 = 4;
pub const HEAP_INSERT_NO_LOGICAL: u32 = 8;
pub const HEAP_INSERT_SPECULATIVE: u32 = 16;
pub const HEAP_PAGE_PRUNE_MARK_UNUSED_NOW: u32 = 1;
pub const HEAP_PAGE_PRUNE_FREEZE: u32 = 2;
pub const HEAP_FREEZE_CHECK_XMIN_COMMITTED: u32 = 1;
pub const HEAP_FREEZE_CHECK_XMAX_ABORTED: u32 = 2;
pub const XLOG_MULTIXACT_ZERO_OFF_PAGE: u32 = 0;
pub const XLOG_MULTIXACT_ZERO_MEM_PAGE: u32 = 16;
pub const XLOG_MULTIXACT_CREATE_ID: u32 = 32;
pub const XLOG_MULTIXACT_TRUNCATE_ID: u32 = 48;
pub const NUM_INDIVIDUAL_LWLOCKS: u32 = 53;
pub const LWLOCK_PADDED_SIZE: u32 = 128;
pub const NUM_BUFFER_PARTITIONS: u32 = 128;
pub const LOG2_NUM_LOCK_PARTITIONS: u32 = 4;
pub const NUM_LOCK_PARTITIONS: u32 = 16;
pub const LOG2_NUM_PREDICATELOCK_PARTITIONS: u32 = 4;
pub const NUM_PREDICATELOCK_PARTITIONS: u32 = 16;
pub const BUFFER_MAPPING_LWLOCK_OFFSET: u32 = 53;
pub const LOCK_MANAGER_LWLOCK_OFFSET: u32 = 181;
pub const PREDICATELOCK_MANAGER_LWLOCK_OFFSET: u32 = 197;
pub const NUM_FIXED_LWLOCKS: u32 = 213;
pub const INTERVAL_FULL_RANGE: u32 = 32767;
pub const INTERVAL_RANGE_MASK: u32 = 32767;
pub const INTERVAL_FULL_PRECISION: u32 = 65535;
pub const INTERVAL_PRECISION_MASK: u32 = 65535;
pub const InvalidLocalTransactionId: u32 = 0;
pub const MAX_LOCKMODES: u32 = 10;
pub const DEFAULT_LOCKMETHOD: u32 = 1;
pub const USER_LOCKMETHOD: u32 = 2;
pub const BITS_PER_HEAPBLOCK: u32 = 2;
pub const VISIBILITYMAP_ALL_VISIBLE: u32 = 1;
pub const VISIBILITYMAP_ALL_FROZEN: u32 = 2;
pub const VISIBILITYMAP_VALID_BITS: u32 = 3;
pub const VISIBILITYMAP_XLOG_CATALOG_REL: u32 = 4;
pub const VISIBILITYMAP_XLOG_VALID_BITS: u32 = 7;
pub const XLOG_PAGE_MAGIC: u32 = 53526;
pub const XLP_FIRST_IS_CONTRECORD: u32 = 1;
pub const XLP_LONG_HEADER: u32 = 2;
pub const XLP_BKP_REMOVABLE: u32 = 4;
pub const XLP_FIRST_IS_OVERWRITE_CONTRECORD: u32 = 8;
pub const XLP_ALL_FLAGS: u32 = 15;
pub const WalSegMinSize: u32 = 1048576;
pub const WalSegMaxSize: u32 = 1073741824;
pub const DEFAULT_MIN_WAL_SEGS: u32 = 5;
pub const DEFAULT_MAX_WAL_SEGS: u32 = 64;
pub const XLOGDIR: &::core::ffi::CStr = c"pg_wal";
pub const XLOG_CONTROL_FILE: &::core::ffi::CStr = c"global/pg_control";
pub const MAXFNAMELEN: u32 = 64;
pub const XLOG_FNAME_LEN: u32 = 24;
pub const PG_CONTROL_VERSION: u32 = 1700;
pub const MOCK_AUTH_NONCE_LEN: u32 = 32;
pub const XLOG_CHECKPOINT_SHUTDOWN: u32 = 0;
pub const XLOG_CHECKPOINT_ONLINE: u32 = 16;
pub const XLOG_NOOP: u32 = 32;
pub const XLOG_NEXTOID: Oid = Oid(48);
pub const XLOG_SWITCH: u32 = 64;
pub const XLOG_BACKUP_END: u32 = 80;
pub const XLOG_PARAMETER_CHANGE: u32 = 96;
pub const XLOG_RESTORE_POINT: u32 = 112;
pub const XLOG_FPW_CHANGE: u32 = 128;
pub const XLOG_END_OF_RECOVERY: u32 = 144;
pub const XLOG_FPI_FOR_HINT: u32 = 160;
pub const XLOG_FPI: u32 = 176;
pub const XLOG_OVERWRITE_CONTRECORD: u32 = 208;
pub const XLOG_CHECKPOINT_REDO: u32 = 224;
pub const FLOATFORMAT_VALUE: f64 = 1234567.0;
pub const PG_CONTROL_MAX_SAFE_SIZE: u32 = 512;
pub const PG_CONTROL_FILE_SIZE: u32 = 8192;
pub const PERFORM_DELETION_INTERNAL: u32 = 1;
pub const PERFORM_DELETION_CONCURRENTLY: u32 = 2;
pub const PERFORM_DELETION_QUIETLY: u32 = 4;
pub const PERFORM_DELETION_SKIP_ORIGINAL: u32 = 8;
pub const PERFORM_DELETION_SKIP_EXTENSIONS: u32 = 16;
pub const PERFORM_DELETION_CONCURRENT_LOCK: u32 = 32;
pub const DEFAULT_INDEX_TYPE: &::core::ffi::CStr = c"btree";
pub const REINDEXOPT_VERBOSE: u32 = 1;
pub const REINDEXOPT_REPORT_PROGRESS: u32 = 2;
pub const REINDEXOPT_MISSING_OK: u32 = 4;
pub const REINDEXOPT_CONCURRENTLY: u32 = 8;
pub const INDEX_CREATE_IS_PRIMARY: u32 = 1;
pub const INDEX_CREATE_ADD_CONSTRAINT: u32 = 2;
pub const INDEX_CREATE_SKIP_BUILD: u32 = 4;
pub const INDEX_CREATE_CONCURRENT: u32 = 8;
pub const INDEX_CREATE_IF_NOT_EXISTS: u32 = 16;
pub const INDEX_CREATE_PARTITIONED: u32 = 32;
pub const INDEX_CREATE_INVALID: u32 = 64;
pub const INDEX_CONSTR_CREATE_MARK_AS_PRIMARY: u32 = 1;
pub const INDEX_CONSTR_CREATE_DEFERRABLE: u32 = 2;
pub const INDEX_CONSTR_CREATE_INIT_DEFERRED: u32 = 4;
pub const INDEX_CONSTR_CREATE_UPDATE_INDEX: u32 = 8;
pub const INDEX_CONSTR_CREATE_REMOVE_OLD_DEPS: u32 = 16;
pub const REINDEX_REL_PROCESS_TOAST: u32 = 1;
pub const REINDEX_REL_SUPPRESS_INDEX_USE: u32 = 2;
pub const REINDEX_REL_CHECK_CONSTRAINTS: u32 = 4;
pub const REINDEX_REL_FORCE_INDEXES_UNLOGGED: u32 = 8;
pub const REINDEX_REL_FORCE_INDEXES_PERMANENT: u32 = 16;
pub const MAX_CATALOG_MULTI_INSERT_BYTES: u32 = 65535;
pub const AccessMethodRelationId: Oid = Oid(2601);
pub const AmNameIndexId: u32 = 2651;
pub const AmOidIndexId: u32 = 2652;
pub const Anum_pg_am_oid: u32 = 1;
pub const Anum_pg_am_amname: u32 = 2;
pub const Anum_pg_am_amhandler: u32 = 3;
pub const Anum_pg_am_amtype: u32 = 4;
pub const Natts_pg_am: u32 = 4;
pub const AMTYPE_INDEX: u8 = 105u8;
pub const AMTYPE_TABLE: u8 = 116u8;
pub const HEAP_TABLE_AM_OID: Oid = Oid(2);
pub const BTREE_AM_OID: Oid = Oid(403);
pub const HASH_AM_OID: Oid = Oid(405);
pub const GIST_AM_OID: Oid = Oid(783);
pub const GIN_AM_OID: Oid = Oid(2742);
pub const SPGIST_AM_OID: Oid = Oid(4000);
pub const BRIN_AM_OID: Oid = Oid(3580);
pub const AccessMethodOperatorRelationId: Oid = Oid(2602);
pub const AccessMethodStrategyIndexId: u32 = 2653;
pub const AccessMethodOperatorIndexId: u32 = 2654;
pub const AccessMethodOperatorOidIndexId: u32 = 2756;
pub const Anum_pg_amop_oid: u32 = 1;
pub const Anum_pg_amop_amopfamily: u32 = 2;
pub const Anum_pg_amop_amoplefttype: u32 = 3;
pub const Anum_pg_amop_amoprighttype: u32 = 4;
pub const Anum_pg_amop_amopstrategy: u32 = 5;
pub const Anum_pg_amop_amoppurpose: u32 = 6;
pub const Anum_pg_amop_amopopr: u32 = 7;
pub const Anum_pg_amop_amopmethod: u32 = 8;
pub const Anum_pg_amop_amopsortfamily: u32 = 9;
pub const Natts_pg_amop: u32 = 9;
pub const AMOP_SEARCH: u8 = 115u8;
pub const AMOP_ORDER: u8 = 111u8;
pub const AccessMethodProcedureRelationId: Oid = Oid(2603);
pub const AccessMethodProcedureIndexId: u32 = 2655;
pub const AccessMethodProcedureOidIndexId: u32 = 2757;
pub const Anum_pg_amproc_oid: u32 = 1;
pub const Anum_pg_amproc_amprocfamily: u32 = 2;
pub const Anum_pg_amproc_amproclefttype: u32 = 3;
pub const Anum_pg_amproc_amprocrighttype: u32 = 4;
pub const Anum_pg_amproc_amprocnum: u32 = 5;
pub const Anum_pg_amproc_amproc: u32 = 6;
pub const Natts_pg_amproc: u32 = 6;
pub const AuthIdRelationId: Oid = Oid(1260);
pub const AuthIdRelation_Rowtype_Id: u32 = 2842;
pub const PgAuthidToastTable: u32 = 4175;
pub const PgAuthidToastIndex: u32 = 4176;
pub const AuthIdRolnameIndexId: u32 = 2676;
pub const AuthIdOidIndexId: u32 = 2677;
pub const Anum_pg_authid_oid: u32 = 1;
pub const Anum_pg_authid_rolname: u32 = 2;
pub const Anum_pg_authid_rolsuper: u32 = 3;
pub const Anum_pg_authid_rolinherit: u32 = 4;
pub const Anum_pg_authid_rolcreaterole: u32 = 5;
pub const Anum_pg_authid_rolcreatedb: u32 = 6;
pub const Anum_pg_authid_rolcanlogin: u32 = 7;
pub const Anum_pg_authid_rolreplication: u32 = 8;
pub const Anum_pg_authid_rolbypassrls: u32 = 9;
pub const Anum_pg_authid_rolconnlimit: u32 = 10;
pub const Anum_pg_authid_rolpassword: u32 = 11;
pub const Anum_pg_authid_rolvaliduntil: u32 = 12;
pub const Natts_pg_authid: u32 = 12;
pub const BOOTSTRAP_SUPERUSERID: u32 = 10;
pub const ROLE_PG_DATABASE_OWNER: u32 = 6171;
pub const ROLE_PG_READ_ALL_DATA: u32 = 6181;
pub const ROLE_PG_WRITE_ALL_DATA: u32 = 6182;
pub const ROLE_PG_MONITOR: u32 = 3373;
pub const ROLE_PG_READ_ALL_SETTINGS: u32 = 3374;
pub const ROLE_PG_READ_ALL_STATS: u32 = 3375;
pub const ROLE_PG_STAT_SCAN_TABLES: u32 = 3377;
pub const ROLE_PG_READ_SERVER_FILES: u32 = 4569;
pub const ROLE_PG_WRITE_SERVER_FILES: u32 = 4570;
pub const ROLE_PG_EXECUTE_SERVER_PROGRAM: u32 = 4571;
pub const ROLE_PG_SIGNAL_BACKEND: u32 = 4200;
pub const ROLE_PG_CHECKPOINT: u32 = 4544;
pub const ROLE_PG_MAINTAIN: u32 = 6337;
pub const ROLE_PG_USE_RESERVED_CONNECTIONS: u32 = 4550;
pub const ROLE_PG_CREATE_SUBSCRIPTION: u32 = 6304;
pub const CollationRelationId: Oid = Oid(3456);
pub const CollationNameEncNspIndexId: u32 = 3164;
pub const CollationOidIndexId: u32 = 3085;
pub const Anum_pg_collation_oid: u32 = 1;
pub const Anum_pg_collation_collname: u32 = 2;
pub const Anum_pg_collation_collnamespace: u32 = 3;
pub const Anum_pg_collation_collowner: u32 = 4;
pub const Anum_pg_collation_collprovider: u32 = 5;
pub const Anum_pg_collation_collisdeterministic: u32 = 6;
pub const Anum_pg_collation_collencoding: u32 = 7;
pub const Anum_pg_collation_collcollate: u32 = 8;
pub const Anum_pg_collation_collctype: u32 = 9;
pub const Anum_pg_collation_colllocale: u32 = 10;
pub const Anum_pg_collation_collicurules: u32 = 11;
pub const Anum_pg_collation_collversion: u32 = 12;
pub const Natts_pg_collation: u32 = 12;
pub const COLLPROVIDER_DEFAULT: u8 = 100u8;
pub const COLLPROVIDER_BUILTIN: u8 = 98u8;
pub const COLLPROVIDER_ICU: u8 = 105u8;
pub const COLLPROVIDER_LIBC: u8 = 99u8;
pub const DEFAULT_COLLATION_OID: Oid = Oid(100);
pub const C_COLLATION_OID: Oid = Oid(950);
pub const POSIX_COLLATION_OID: Oid = Oid(951);
pub const DatabaseRelationId: Oid = Oid(1262);
pub const DatabaseRelation_Rowtype_Id: u32 = 1248;
pub const PgDatabaseToastTable: u32 = 4177;
pub const PgDatabaseToastIndex: u32 = 4178;
pub const DatabaseNameIndexId: u32 = 2671;
pub const DatabaseOidIndexId: u32 = 2672;
pub const Template0DbOid: u32 = 4;
pub const PostgresDbOid: u32 = 5;
pub const Anum_pg_database_oid: u32 = 1;
pub const Anum_pg_database_datname: u32 = 2;
pub const Anum_pg_database_datdba: u32 = 3;
pub const Anum_pg_database_encoding: u32 = 4;
pub const Anum_pg_database_datlocprovider: u32 = 5;
pub const Anum_pg_database_datistemplate: u32 = 6;
pub const Anum_pg_database_datallowconn: u32 = 7;
pub const Anum_pg_database_dathasloginevt: u32 = 8;
pub const Anum_pg_database_datconnlimit: u32 = 9;
pub const Anum_pg_database_datfrozenxid: u32 = 10;
pub const Anum_pg_database_datminmxid: u32 = 11;
pub const Anum_pg_database_dattablespace: u32 = 12;
pub const Anum_pg_database_datcollate: u32 = 13;
pub const Anum_pg_database_datctype: u32 = 14;
pub const Anum_pg_database_datlocale: u32 = 15;
pub const Anum_pg_database_daticurules: u32 = 16;
pub const Anum_pg_database_datcollversion: u32 = 17;
pub const Anum_pg_database_datacl: u32 = 18;
pub const Natts_pg_database: u32 = 18;
pub const Template1DbOid: u32 = 1;
pub const DATCONNLIMIT_UNLIMITED: i32 = -1;
pub const DATCONNLIMIT_INVALID_DB: i32 = -2;
pub const EnumRelationId: Oid = Oid(3501);
pub const EnumOidIndexId: u32 = 3502;
pub const EnumTypIdLabelIndexId: u32 = 3503;
pub const EnumTypIdSortOrderIndexId: u32 = 3534;
pub const Anum_pg_enum_oid: u32 = 1;
pub const Anum_pg_enum_enumtypid: u32 = 2;
pub const Anum_pg_enum_enumsortorder: u32 = 3;
pub const Anum_pg_enum_enumlabel: u32 = 4;
pub const Natts_pg_enum: u32 = 4;
pub const ExtensionRelationId: Oid = Oid(3079);
pub const ExtensionOidIndexId: u32 = 3080;
pub const ExtensionNameIndexId: u32 = 3081;
pub const Anum_pg_extension_oid: u32 = 1;
pub const Anum_pg_extension_extname: u32 = 2;
pub const Anum_pg_extension_extowner: u32 = 3;
pub const Anum_pg_extension_extnamespace: u32 = 4;
pub const Anum_pg_extension_extrelocatable: u32 = 5;
pub const Anum_pg_extension_extversion: u32 = 6;
pub const Anum_pg_extension_extconfig: u32 = 7;
pub const Anum_pg_extension_extcondition: u32 = 8;
pub const Natts_pg_extension: u32 = 8;
pub const ForeignDataWrapperRelationId: Oid = Oid(2328);
pub const ForeignDataWrapperOidIndexId: u32 = 112;
pub const ForeignDataWrapperNameIndexId: u32 = 548;
pub const Anum_pg_foreign_data_wrapper_oid: u32 = 1;
pub const Anum_pg_foreign_data_wrapper_fdwname: u32 = 2;
pub const Anum_pg_foreign_data_wrapper_fdwowner: u32 = 3;
pub const Anum_pg_foreign_data_wrapper_fdwhandler: u32 = 4;
pub const Anum_pg_foreign_data_wrapper_fdwvalidator: u32 = 5;
pub const Anum_pg_foreign_data_wrapper_fdwacl: u32 = 6;
pub const Anum_pg_foreign_data_wrapper_fdwoptions: u32 = 7;
pub const Natts_pg_foreign_data_wrapper: u32 = 7;
pub const ForeignServerRelationId: Oid = Oid(1417);
pub const ForeignServerOidIndexId: u32 = 113;
pub const ForeignServerNameIndexId: u32 = 549;
pub const Anum_pg_foreign_server_oid: u32 = 1;
pub const Anum_pg_foreign_server_srvname: u32 = 2;
pub const Anum_pg_foreign_server_srvowner: u32 = 3;
pub const Anum_pg_foreign_server_srvfdw: u32 = 4;
pub const Anum_pg_foreign_server_srvtype: u32 = 5;
pub const Anum_pg_foreign_server_srvversion: u32 = 6;
pub const Anum_pg_foreign_server_srvacl: u32 = 7;
pub const Anum_pg_foreign_server_srvoptions: u32 = 8;
pub const Natts_pg_foreign_server: u32 = 8;
pub const ForeignTableRelationId: Oid = Oid(3118);
pub const ForeignTableRelidIndexId: u32 = 3119;
pub const Anum_pg_foreign_table_ftrelid: u32 = 1;
pub const Anum_pg_foreign_table_ftserver: u32 = 2;
pub const Anum_pg_foreign_table_ftoptions: u32 = 3;
pub const Natts_pg_foreign_table: u32 = 3;
pub const OperatorRelationId: Oid = Oid(2617);
pub const OperatorOidIndexId: u32 = 2688;
pub const OperatorNameNspIndexId: u32 = 2689;
pub const Anum_pg_operator_oid: u32 = 1;
pub const Anum_pg_operator_oprname: u32 = 2;
pub const Anum_pg_operator_oprnamespace: u32 = 3;
pub const Anum_pg_operator_oprowner: u32 = 4;
pub const Anum_pg_operator_oprkind: u32 = 5;
pub const Anum_pg_operator_oprcanmerge: u32 = 6;
pub const Anum_pg_operator_oprcanhash: u32 = 7;
pub const Anum_pg_operator_oprleft: u32 = 8;
pub const Anum_pg_operator_oprright: u32 = 9;
pub const Anum_pg_operator_oprresult: u32 = 10;
pub const Anum_pg_operator_oprcom: u32 = 11;
pub const Anum_pg_operator_oprnegate: u32 = 12;
pub const Anum_pg_operator_oprcode: u32 = 13;
pub const Anum_pg_operator_oprrest: u32 = 14;
pub const Anum_pg_operator_oprjoin: u32 = 15;
pub const Natts_pg_operator: u32 = 15;
pub const BooleanNotEqualOperator: u32 = 85;
pub const BooleanEqualOperator: u32 = 91;
pub const Int4EqualOperator: u32 = 96;
pub const Int4LessOperator: u32 = 97;
pub const TextEqualOperator: u32 = 98;
pub const TextPrefixOperator: u32 = 3877;
pub const NameEqualTextOperator: u32 = 254;
pub const NameLessTextOperator: u32 = 255;
pub const NameGreaterEqualTextOperator: u32 = 257;
pub const TIDEqualOperator: u32 = 387;
pub const TIDLessOperator: u32 = 2799;
pub const TIDGreaterOperator: u32 = 2800;
pub const TIDLessEqOperator: u32 = 2801;
pub const TIDGreaterEqOperator: u32 = 2802;
pub const Int8LessOperator: u32 = 412;
pub const OID_NAME_REGEXEQ_OP: u32 = 639;
pub const OID_TEXT_REGEXEQ_OP: u32 = 641;
pub const TextLessOperator: u32 = 664;
pub const TextGreaterEqualOperator: u32 = 667;
pub const Float8LessOperator: u32 = 672;
pub const BpcharEqualOperator: u32 = 1054;
pub const OID_BPCHAR_REGEXEQ_OP: u32 = 1055;
pub const BpcharLessOperator: u32 = 1058;
pub const BpcharGreaterEqualOperator: u32 = 1061;
pub const ARRAY_EQ_OP: u32 = 1070;
pub const ARRAY_LT_OP: u32 = 1072;
pub const ARRAY_GT_OP: u32 = 1073;
pub const OID_NAME_LIKE_OP: u32 = 1207;
pub const OID_TEXT_LIKE_OP: u32 = 1209;
pub const OID_BPCHAR_LIKE_OP: u32 = 1211;
pub const OID_NAME_ICREGEXEQ_OP: u32 = 1226;
pub const OID_TEXT_ICREGEXEQ_OP: u32 = 1228;
pub const OID_BPCHAR_ICREGEXEQ_OP: u32 = 1234;
pub const OID_INET_SUB_OP: u32 = 931;
pub const OID_INET_SUBEQ_OP: u32 = 932;
pub const OID_INET_SUP_OP: u32 = 933;
pub const OID_INET_SUPEQ_OP: u32 = 934;
pub const OID_INET_OVERLAP_OP: u32 = 3552;
pub const OID_NAME_ICLIKE_OP: u32 = 1625;
pub const OID_TEXT_ICLIKE_OP: u32 = 1627;
pub const OID_BPCHAR_ICLIKE_OP: u32 = 1629;
pub const ByteaEqualOperator: u32 = 1955;
pub const ByteaLessOperator: u32 = 1957;
pub const ByteaGreaterEqualOperator: u32 = 1960;
pub const OID_BYTEA_LIKE_OP: u32 = 2016;
pub const TextPatternLessOperator: u32 = 2314;
pub const TextPatternGreaterEqualOperator: u32 = 2317;
pub const BpcharPatternLessOperator: u32 = 2326;
pub const BpcharPatternGreaterEqualOperator: u32 = 2329;
pub const OID_ARRAY_OVERLAP_OP: u32 = 2750;
pub const OID_ARRAY_CONTAINS_OP: u32 = 2751;
pub const OID_ARRAY_CONTAINED_OP: u32 = 2752;
pub const RECORD_EQ_OP: u32 = 2988;
pub const RECORD_LT_OP: u32 = 2990;
pub const RECORD_GT_OP: u32 = 2991;
pub const OID_RANGE_LESS_OP: u32 = 3884;
pub const OID_RANGE_LESS_EQUAL_OP: u32 = 3885;
pub const OID_RANGE_GREATER_EQUAL_OP: u32 = 3886;
pub const OID_RANGE_GREATER_OP: u32 = 3887;
pub const OID_RANGE_OVERLAP_OP: u32 = 3888;
pub const OID_RANGE_CONTAINS_ELEM_OP: u32 = 3889;
pub const OID_RANGE_CONTAINS_OP: u32 = 3890;
pub const OID_RANGE_ELEM_CONTAINED_OP: u32 = 3891;
pub const OID_RANGE_CONTAINED_OP: u32 = 3892;
pub const OID_RANGE_LEFT_OP: u32 = 3893;
pub const OID_RANGE_RIGHT_OP: u32 = 3894;
pub const OID_RANGE_OVERLAPS_LEFT_OP: u32 = 3895;
pub const OID_RANGE_OVERLAPS_RIGHT_OP: u32 = 3896;
pub const OID_MULTIRANGE_LESS_OP: u32 = 2862;
pub const OID_MULTIRANGE_LESS_EQUAL_OP: u32 = 2863;
pub const OID_MULTIRANGE_GREATER_EQUAL_OP: u32 = 2864;
pub const OID_MULTIRANGE_GREATER_OP: u32 = 2865;
pub const OID_RANGE_OVERLAPS_MULTIRANGE_OP: u32 = 2866;
pub const OID_MULTIRANGE_OVERLAPS_RANGE_OP: u32 = 2867;
pub const OID_MULTIRANGE_OVERLAPS_MULTIRANGE_OP: u32 = 2868;
pub const OID_MULTIRANGE_CONTAINS_ELEM_OP: u32 = 2869;
pub const OID_MULTIRANGE_CONTAINS_RANGE_OP: u32 = 2870;
pub const OID_MULTIRANGE_CONTAINS_MULTIRANGE_OP: u32 = 2871;
pub const OID_MULTIRANGE_ELEM_CONTAINED_OP: u32 = 2872;
pub const OID_MULTIRANGE_RANGE_CONTAINED_OP: u32 = 2873;
pub const OID_MULTIRANGE_MULTIRANGE_CONTAINED_OP: u32 = 2874;
pub const OID_RANGE_CONTAINS_MULTIRANGE_OP: u32 = 4539;
pub const OID_RANGE_MULTIRANGE_CONTAINED_OP: u32 = 4540;
pub const OID_RANGE_OVERLAPS_LEFT_MULTIRANGE_OP: u32 = 2875;
pub const OID_MULTIRANGE_OVERLAPS_LEFT_RANGE_OP: u32 = 2876;
pub const OID_MULTIRANGE_OVERLAPS_LEFT_MULTIRANGE_OP: u32 = 2877;
pub const OID_RANGE_OVERLAPS_RIGHT_MULTIRANGE_OP: u32 = 3585;
pub const OID_MULTIRANGE_OVERLAPS_RIGHT_RANGE_OP: u32 = 4035;
pub const OID_MULTIRANGE_OVERLAPS_RIGHT_MULTIRANGE_OP: u32 = 4142;
pub const OID_RANGE_ADJACENT_MULTIRANGE_OP: u32 = 4179;
pub const OID_MULTIRANGE_ADJACENT_RANGE_OP: u32 = 4180;
pub const OID_MULTIRANGE_ADJACENT_MULTIRANGE_OP: u32 = 4198;
pub const OID_RANGE_LEFT_MULTIRANGE_OP: u32 = 4395;
pub const OID_MULTIRANGE_LEFT_RANGE_OP: u32 = 4396;
pub const OID_MULTIRANGE_LEFT_MULTIRANGE_OP: u32 = 4397;
pub const OID_RANGE_RIGHT_MULTIRANGE_OP: u32 = 4398;
pub const OID_MULTIRANGE_RIGHT_RANGE_OP: u32 = 4399;
pub const OID_MULTIRANGE_RIGHT_MULTIRANGE_OP: u32 = 4400;
pub const OperatorClassRelationId: Oid = Oid(2616);
pub const OpclassAmNameNspIndexId: u32 = 2686;
pub const OpclassOidIndexId: u32 = 2687;
pub const Anum_pg_opclass_oid: u32 = 1;
pub const Anum_pg_opclass_opcmethod: u32 = 2;
pub const Anum_pg_opclass_opcname: u32 = 3;
pub const Anum_pg_opclass_opcnamespace: u32 = 4;
pub const Anum_pg_opclass_opcowner: u32 = 5;
pub const Anum_pg_opclass_opcfamily: u32 = 6;
pub const Anum_pg_opclass_opcintype: u32 = 7;
pub const Anum_pg_opclass_opcdefault: u32 = 8;
pub const Anum_pg_opclass_opckeytype: u32 = 9;
pub const Natts_pg_opclass: u32 = 9;
pub const DATE_BTREE_OPS_OID: Oid = Oid(3122);
pub const FLOAT8_BTREE_OPS_OID: Oid = Oid(3123);
pub const INT2_BTREE_OPS_OID: Oid = Oid(1979);
pub const INT4_BTREE_OPS_OID: Oid = Oid(1978);
pub const INT8_BTREE_OPS_OID: Oid = Oid(3124);
pub const NUMERIC_BTREE_OPS_OID: Oid = Oid(3125);
pub const OID_BTREE_OPS_OID: Oid = Oid(1981);
pub const TEXT_BTREE_OPS_OID: Oid = Oid(3126);
pub const TIMESTAMPTZ_BTREE_OPS_OID: Oid = Oid(3127);
pub const TIMESTAMP_BTREE_OPS_OID: Oid = Oid(3128);
pub const TEXT_BTREE_PATTERN_OPS_OID: Oid = Oid(4217);
pub const VARCHAR_BTREE_PATTERN_OPS_OID: Oid = Oid(4218);
pub const BPCHAR_BTREE_PATTERN_OPS_OID: Oid = Oid(4219);
pub const OperatorFamilyRelationId: Oid = Oid(2753);
pub const OpfamilyAmNameNspIndexId: u32 = 2754;
pub const OpfamilyOidIndexId: u32 = 2755;
pub const Anum_pg_opfamily_oid: u32 = 1;
pub const Anum_pg_opfamily_opfmethod: u32 = 2;
pub const Anum_pg_opfamily_opfname: u32 = 3;
pub const Anum_pg_opfamily_opfnamespace: u32 = 4;
pub const Anum_pg_opfamily_opfowner: u32 = 5;
pub const Natts_pg_opfamily: u32 = 5;
pub const BOOL_BTREE_FAM_OID: Oid = Oid(424);
pub const BPCHAR_BTREE_FAM_OID: Oid = Oid(426);
pub const BYTEA_BTREE_FAM_OID: Oid = Oid(428);
pub const NETWORK_BTREE_FAM_OID: Oid = Oid(1974);
pub const INTEGER_BTREE_FAM_OID: Oid = Oid(1976);
pub const INTERVAL_BTREE_FAM_OID: Oid = Oid(1982);
pub const OID_BTREE_FAM_OID: Oid = Oid(1989);
pub const TEXT_BTREE_FAM_OID: Oid = Oid(1994);
pub const TEXT_PATTERN_BTREE_FAM_OID: Oid = Oid(2095);
pub const BPCHAR_PATTERN_BTREE_FAM_OID: Oid = Oid(2097);
pub const BOOL_HASH_FAM_OID: Oid = Oid(2222);
pub const TEXT_SPGIST_FAM_OID: Oid = Oid(4017);
pub const ProcedureRelationId: Oid = Oid(1255);
pub const ProcedureRelation_Rowtype_Id: u32 = 81;
pub const ProcedureOidIndexId: u32 = 2690;
pub const ProcedureNameArgsNspIndexId: u32 = 2691;
pub const Anum_pg_proc_oid: u32 = 1;
pub const Anum_pg_proc_proname: u32 = 2;
pub const Anum_pg_proc_pronamespace: u32 = 3;
pub const Anum_pg_proc_proowner: u32 = 4;
pub const Anum_pg_proc_prolang: u32 = 5;
pub const Anum_pg_proc_procost: u32 = 6;
pub const Anum_pg_proc_prorows: u32 = 7;
pub const Anum_pg_proc_provariadic: u32 = 8;
pub const Anum_pg_proc_prosupport: u32 = 9;
pub const Anum_pg_proc_prokind: u32 = 10;
pub const Anum_pg_proc_prosecdef: u32 = 11;
pub const Anum_pg_proc_proleakproof: u32 = 12;
pub const Anum_pg_proc_proisstrict: u32 = 13;
pub const Anum_pg_proc_proretset: u32 = 14;
pub const Anum_pg_proc_provolatile: u32 = 15;
pub const Anum_pg_proc_proparallel: u32 = 16;
pub const Anum_pg_proc_pronargs: u32 = 17;
pub const Anum_pg_proc_pronargdefaults: u32 = 18;
pub const Anum_pg_proc_prorettype: u32 = 19;
pub const Anum_pg_proc_proargtypes: u32 = 20;
pub const Anum_pg_proc_proallargtypes: u32 = 21;
pub const Anum_pg_proc_proargmodes: u32 = 22;
pub const Anum_pg_proc_proargnames: u32 = 23;
pub const Anum_pg_proc_proargdefaults: u32 = 24;
pub const Anum_pg_proc_protrftypes: u32 = 25;
pub const Anum_pg_proc_prosrc: u32 = 26;
pub const Anum_pg_proc_probin: u32 = 27;
pub const Anum_pg_proc_prosqlbody: u32 = 28;
pub const Anum_pg_proc_proconfig: u32 = 29;
pub const Anum_pg_proc_proacl: u32 = 30;
pub const Natts_pg_proc: u32 = 30;
pub const PROKIND_FUNCTION: u8 = 102u8;
pub const PROKIND_AGGREGATE: u8 = 97u8;
pub const PROKIND_WINDOW: u8 = 119u8;
pub const PROKIND_PROCEDURE: u8 = 112u8;
pub const PROVOLATILE_IMMUTABLE: u8 = 105u8;
pub const PROVOLATILE_STABLE: u8 = 115u8;
pub const PROVOLATILE_VOLATILE: u8 = 118u8;
pub const PROPARALLEL_SAFE: u8 = 115u8;
pub const PROPARALLEL_RESTRICTED: u8 = 114u8;
pub const PROPARALLEL_UNSAFE: u8 = 117u8;
pub const PROARGMODE_IN: u8 = 105u8;
pub const PROARGMODE_OUT: u8 = 111u8;
pub const PROARGMODE_INOUT: u8 = 98u8;
pub const PROARGMODE_VARIADIC: u8 = 118u8;
pub const PROARGMODE_TABLE: u8 = 116u8;
pub const NamespaceRelationId: Oid = Oid(2615);
pub const NamespaceNameIndexId: u32 = 2684;
pub const NamespaceOidIndexId: u32 = 2685;
pub const Anum_pg_namespace_oid: u32 = 1;
pub const Anum_pg_namespace_nspname: u32 = 2;
pub const Anum_pg_namespace_nspowner: u32 = 3;
pub const Anum_pg_namespace_nspacl: u32 = 4;
pub const Natts_pg_namespace: u32 = 4;
pub const PG_CATALOG_NAMESPACE: u32 = 11;
pub const PG_TOAST_NAMESPACE: u32 = 99;
pub const PG_PUBLIC_NAMESPACE: u32 = 2200;
pub const ACL_ID_PUBLIC: u32 = 0;
pub const ACL_MODECHG_ADD: u32 = 1;
pub const ACL_MODECHG_DEL: u32 = 2;
pub const ACL_MODECHG_EQL: u32 = 3;
pub const ACL_INSERT_CHR: u8 = 97u8;
pub const ACL_SELECT_CHR: u8 = 114u8;
pub const ACL_UPDATE_CHR: u8 = 119u8;
pub const ACL_DELETE_CHR: u8 = 100u8;
pub const ACL_TRUNCATE_CHR: u8 = 68u8;
pub const ACL_REFERENCES_CHR: u8 = 120u8;
pub const ACL_TRIGGER_CHR: u8 = 116u8;
pub const ACL_EXECUTE_CHR: u8 = 88u8;
pub const ACL_USAGE_CHR: u8 = 85u8;
pub const ACL_CREATE_CHR: u8 = 67u8;
pub const ACL_CREATE_TEMP_CHR: u8 = 84u8;
pub const ACL_CONNECT_CHR: u8 = 99u8;
pub const ACL_SET_CHR: u8 = 115u8;
pub const ACL_ALTER_SYSTEM_CHR: u8 = 65u8;
pub const ACL_MAINTAIN_CHR: u8 = 109u8;
pub const ACL_ALL_RIGHTS_STR: &::core::ffi::CStr = c"arwdDxtXUCTcsAm";
pub const ACL_ALL_RIGHTS_COLUMN: u32 = 39;
pub const ACL_ALL_RIGHTS_RELATION: u32 = 16511;
pub const ACL_ALL_RIGHTS_SEQUENCE: u32 = 262;
pub const ACL_ALL_RIGHTS_DATABASE: u32 = 3584;
pub const ACL_ALL_RIGHTS_FDW: u32 = 256;
pub const ACL_ALL_RIGHTS_FOREIGN_SERVER: u32 = 256;
pub const ACL_ALL_RIGHTS_FUNCTION: u32 = 128;
pub const ACL_ALL_RIGHTS_LANGUAGE: u32 = 256;
pub const ACL_ALL_RIGHTS_LARGEOBJECT: u32 = 6;
pub const ACL_ALL_RIGHTS_PARAMETER_ACL: u32 = 12288;
pub const ACL_ALL_RIGHTS_SCHEMA: u32 = 768;
pub const ACL_ALL_RIGHTS_TABLESPACE: u32 = 512;
pub const ACL_ALL_RIGHTS_TYPE: u32 = 256;
pub const SecLabelRelationId: Oid = Oid(3596);
pub const SecLabelObjectIndexId: u32 = 3597;
pub const Anum_pg_seclabel_objoid: u32 = 1;
pub const Anum_pg_seclabel_classoid: u32 = 2;
pub const Anum_pg_seclabel_objsubid: u32 = 3;
pub const Anum_pg_seclabel_provider: u32 = 4;
pub const Anum_pg_seclabel_label: u32 = 5;
pub const Natts_pg_seclabel: u32 = 5;
pub const TableSpaceRelationId: Oid = Oid(1213);
pub const PgTablespaceToastTable: u32 = 4185;
pub const PgTablespaceToastIndex: u32 = 4186;
pub const TablespaceOidIndexId: u32 = 2697;
pub const TablespaceNameIndexId: u32 = 2698;
pub const Anum_pg_tablespace_oid: u32 = 1;
pub const Anum_pg_tablespace_spcname: u32 = 2;
pub const Anum_pg_tablespace_spcowner: u32 = 3;
pub const Anum_pg_tablespace_spcacl: u32 = 4;
pub const Anum_pg_tablespace_spcoptions: u32 = 5;
pub const Natts_pg_tablespace: u32 = 5;
pub const DEFAULTTABLESPACE_OID: Oid = Oid(1663);
pub const GLOBALTABLESPACE_OID: Oid = Oid(1664);
pub const TriggerRelationId: Oid = Oid(2620);
pub const TriggerConstraintIndexId: u32 = 2699;
pub const TriggerRelidNameIndexId: u32 = 2701;
pub const TriggerOidIndexId: u32 = 2702;
pub const Anum_pg_trigger_oid: u32 = 1;
pub const Anum_pg_trigger_tgrelid: u32 = 2;
pub const Anum_pg_trigger_tgparentid: u32 = 3;
pub const Anum_pg_trigger_tgname: u32 = 4;
pub const Anum_pg_trigger_tgfoid: u32 = 5;
pub const Anum_pg_trigger_tgtype: u32 = 6;
pub const Anum_pg_trigger_tgenabled: u32 = 7;
pub const Anum_pg_trigger_tgisinternal: u32 = 8;
pub const Anum_pg_trigger_tgconstrrelid: u32 = 9;
pub const Anum_pg_trigger_tgconstrindid: u32 = 10;
pub const Anum_pg_trigger_tgconstraint: u32 = 11;
pub const Anum_pg_trigger_tgdeferrable: u32 = 12;
pub const Anum_pg_trigger_tginitdeferred: u32 = 13;
pub const Anum_pg_trigger_tgnargs: u32 = 14;
pub const Anum_pg_trigger_tgattr: u32 = 15;
pub const Anum_pg_trigger_tgargs: u32 = 16;
pub const Anum_pg_trigger_tgqual: u32 = 17;
pub const Anum_pg_trigger_tgoldtable: u32 = 18;
pub const Anum_pg_trigger_tgnewtable: u32 = 19;
pub const Natts_pg_trigger: u32 = 19;
pub const TRIGGER_TYPE_ROW: u32 = 1;
pub const TRIGGER_TYPE_BEFORE: u32 = 2;
pub const TRIGGER_TYPE_INSERT: u32 = 4;
pub const TRIGGER_TYPE_DELETE: u32 = 8;
pub const TRIGGER_TYPE_UPDATE: u32 = 16;
pub const TRIGGER_TYPE_TRUNCATE: u32 = 32;
pub const TRIGGER_TYPE_INSTEAD: u32 = 64;
pub const TRIGGER_TYPE_LEVEL_MASK: u32 = 1;
pub const TRIGGER_TYPE_STATEMENT: u32 = 0;
pub const TRIGGER_TYPE_TIMING_MASK: u32 = 66;
pub const TRIGGER_TYPE_AFTER: u32 = 0;
pub const TRIGGER_TYPE_EVENT_MASK: u32 = 60;
pub const UserMappingRelationId: Oid = Oid(1418);
pub const UserMappingOidIndexId: u32 = 174;
pub const UserMappingUserServerIndexId: u32 = 175;
pub const Anum_pg_user_mapping_oid: u32 = 1;
pub const Anum_pg_user_mapping_umuser: u32 = 2;
pub const Anum_pg_user_mapping_umserver: u32 = 3;
pub const Anum_pg_user_mapping_umoptions: u32 = 4;
pub const Natts_pg_user_mapping: u32 = 4;
pub const EOH_HEADER_MAGIC: i32 = -1;
pub const MAXDIM: u32 = 6;
pub const EA_MAGIC: u32 = 689375833;
pub const EventTriggerRelationId: Oid = Oid(3466);
pub const EventTriggerNameIndexId: u32 = 3467;
pub const EventTriggerOidIndexId: u32 = 3468;
pub const Anum_pg_event_trigger_oid: u32 = 1;
pub const Anum_pg_event_trigger_evtname: u32 = 2;
pub const Anum_pg_event_trigger_evtevent: u32 = 3;
pub const Anum_pg_event_trigger_evtowner: u32 = 4;
pub const Anum_pg_event_trigger_evtfoid: u32 = 5;
pub const Anum_pg_event_trigger_evtenabled: u32 = 6;
pub const Anum_pg_event_trigger_evttags: u32 = 7;
pub const Natts_pg_event_trigger: u32 = 7;
pub const AT_REWRITE_ALTER_PERSISTENCE: u32 = 1;
pub const AT_REWRITE_DEFAULT_VAL: u32 = 2;
pub const AT_REWRITE_COLUMN_REWRITE: u32 = 4;
pub const AT_REWRITE_ACCESS_METHOD: u32 = 8;
pub const CACHEDPLANSOURCE_MAGIC: u32 = 195726186;
pub const CACHEDPLAN_MAGIC: u32 = 953717834;
pub const CACHEDEXPR_MAGIC: u32 = 838275847;
pub const PROGRESS_VACUUM_PHASE: u32 = 0;
pub const PROGRESS_VACUUM_TOTAL_HEAP_BLKS: u32 = 1;
pub const PROGRESS_VACUUM_HEAP_BLKS_SCANNED: u32 = 2;
pub const PROGRESS_VACUUM_HEAP_BLKS_VACUUMED: u32 = 3;
pub const PROGRESS_VACUUM_NUM_INDEX_VACUUMS: u32 = 4;
pub const PROGRESS_VACUUM_MAX_DEAD_TUPLE_BYTES: u32 = 5;
pub const PROGRESS_VACUUM_DEAD_TUPLE_BYTES: u32 = 6;
pub const PROGRESS_VACUUM_NUM_DEAD_ITEM_IDS: u32 = 7;
pub const PROGRESS_VACUUM_INDEXES_TOTAL: u32 = 8;
pub const PROGRESS_VACUUM_INDEXES_PROCESSED: u32 = 9;
pub const PROGRESS_VACUUM_PHASE_SCAN_HEAP: u32 = 1;
pub const PROGRESS_VACUUM_PHASE_VACUUM_INDEX: u32 = 2;
pub const PROGRESS_VACUUM_PHASE_VACUUM_HEAP: u32 = 3;
pub const PROGRESS_VACUUM_PHASE_INDEX_CLEANUP: u32 = 4;
pub const PROGRESS_VACUUM_PHASE_TRUNCATE: u32 = 5;
pub const PROGRESS_VACUUM_PHASE_FINAL_CLEANUP: u32 = 6;
pub const PROGRESS_ANALYZE_PHASE: u32 = 0;
pub const PROGRESS_ANALYZE_BLOCKS_TOTAL: u32 = 1;
pub const PROGRESS_ANALYZE_BLOCKS_DONE: u32 = 2;
pub const PROGRESS_ANALYZE_EXT_STATS_TOTAL: u32 = 3;
pub const PROGRESS_ANALYZE_EXT_STATS_COMPUTED: u32 = 4;
pub const PROGRESS_ANALYZE_CHILD_TABLES_TOTAL: u32 = 5;
pub const PROGRESS_ANALYZE_CHILD_TABLES_DONE: u32 = 6;
pub const PROGRESS_ANALYZE_CURRENT_CHILD_TABLE_RELID: u32 = 7;
pub const PROGRESS_ANALYZE_PHASE_ACQUIRE_SAMPLE_ROWS: u32 = 1;
pub const PROGRESS_ANALYZE_PHASE_ACQUIRE_SAMPLE_ROWS_INH: u32 = 2;
pub const PROGRESS_ANALYZE_PHASE_COMPUTE_STATS: u32 = 3;
pub const PROGRESS_ANALYZE_PHASE_COMPUTE_EXT_STATS: u32 = 4;
pub const PROGRESS_ANALYZE_PHASE_FINALIZE_ANALYZE: u32 = 5;
pub const PROGRESS_CLUSTER_COMMAND: u32 = 0;
pub const PROGRESS_CLUSTER_PHASE: u32 = 1;
pub const PROGRESS_CLUSTER_INDEX_RELID: u32 = 2;
pub const PROGRESS_CLUSTER_HEAP_TUPLES_SCANNED: u32 = 3;
pub const PROGRESS_CLUSTER_HEAP_TUPLES_WRITTEN: u32 = 4;
pub const PROGRESS_CLUSTER_TOTAL_HEAP_BLKS: u32 = 5;
pub const PROGRESS_CLUSTER_HEAP_BLKS_SCANNED: u32 = 6;
pub const PROGRESS_CLUSTER_INDEX_REBUILD_COUNT: u32 = 7;
pub const PROGRESS_CLUSTER_PHASE_SEQ_SCAN_HEAP: u32 = 1;
pub const PROGRESS_CLUSTER_PHASE_INDEX_SCAN_HEAP: u32 = 2;
pub const PROGRESS_CLUSTER_PHASE_SORT_TUPLES: u32 = 3;
pub const PROGRESS_CLUSTER_PHASE_WRITE_NEW_HEAP: u32 = 4;
pub const PROGRESS_CLUSTER_PHASE_SWAP_REL_FILES: u32 = 5;
pub const PROGRESS_CLUSTER_PHASE_REBUILD_INDEX: u32 = 6;
pub const PROGRESS_CLUSTER_PHASE_FINAL_CLEANUP: u32 = 7;
pub const PROGRESS_CLUSTER_COMMAND_CLUSTER: u32 = 1;
pub const PROGRESS_CLUSTER_COMMAND_VACUUM_FULL: u32 = 2;
pub const PROGRESS_CREATEIDX_COMMAND: u32 = 0;
pub const PROGRESS_CREATEIDX_INDEX_OID: Oid = Oid(6);
pub const PROGRESS_CREATEIDX_ACCESS_METHOD_OID: Oid = Oid(8);
pub const PROGRESS_CREATEIDX_PHASE: u32 = 9;
pub const PROGRESS_CREATEIDX_SUBPHASE: u32 = 10;
pub const PROGRESS_CREATEIDX_TUPLES_TOTAL: u32 = 11;
pub const PROGRESS_CREATEIDX_TUPLES_DONE: u32 = 12;
pub const PROGRESS_CREATEIDX_PARTITIONS_TOTAL: u32 = 13;
pub const PROGRESS_CREATEIDX_PARTITIONS_DONE: u32 = 14;
pub const PROGRESS_CREATEIDX_PHASE_WAIT_1: u32 = 1;
pub const PROGRESS_CREATEIDX_PHASE_BUILD: u32 = 2;
pub const PROGRESS_CREATEIDX_PHASE_WAIT_2: u32 = 3;
pub const PROGRESS_CREATEIDX_PHASE_VALIDATE_IDXSCAN: u32 = 4;
pub const PROGRESS_CREATEIDX_PHASE_VALIDATE_SORT: u32 = 5;
pub const PROGRESS_CREATEIDX_PHASE_VALIDATE_TABLESCAN: u32 = 6;
pub const PROGRESS_CREATEIDX_PHASE_WAIT_3: u32 = 7;
pub const PROGRESS_CREATEIDX_PHASE_WAIT_4: u32 = 8;
pub const PROGRESS_CREATEIDX_PHASE_WAIT_5: u32 = 9;
pub const PROGRESS_CREATEIDX_SUBPHASE_INITIALIZE: u32 = 1;
pub const PROGRESS_CREATEIDX_COMMAND_CREATE: u32 = 1;
pub const PROGRESS_CREATEIDX_COMMAND_CREATE_CONCURRENTLY: u32 = 2;
pub const PROGRESS_CREATEIDX_COMMAND_REINDEX: u32 = 3;
pub const PROGRESS_CREATEIDX_COMMAND_REINDEX_CONCURRENTLY: u32 = 4;
pub const PROGRESS_WAITFOR_TOTAL: u32 = 3;
pub const PROGRESS_WAITFOR_DONE: u32 = 4;
pub const PROGRESS_WAITFOR_CURRENT_PID: u32 = 5;
pub const PROGRESS_SCAN_BLOCKS_TOTAL: u32 = 15;
pub const PROGRESS_SCAN_BLOCKS_DONE: u32 = 16;
pub const PROGRESS_BASEBACKUP_PHASE: u32 = 0;
pub const PROGRESS_BASEBACKUP_BACKUP_TOTAL: u32 = 1;
pub const PROGRESS_BASEBACKUP_BACKUP_STREAMED: u32 = 2;
pub const PROGRESS_BASEBACKUP_TBLSPC_TOTAL: u32 = 3;
pub const PROGRESS_BASEBACKUP_TBLSPC_STREAMED: u32 = 4;
pub const PROGRESS_BASEBACKUP_PHASE_WAIT_CHECKPOINT: u32 = 1;
pub const PROGRESS_BASEBACKUP_PHASE_ESTIMATE_BACKUP_SIZE: u32 = 2;
pub const PROGRESS_BASEBACKUP_PHASE_STREAM_BACKUP: u32 = 3;
pub const PROGRESS_BASEBACKUP_PHASE_WAIT_WAL_ARCHIVE: u32 = 4;
pub const PROGRESS_BASEBACKUP_PHASE_TRANSFER_WAL: u32 = 5;
pub const PROGRESS_COPY_BYTES_PROCESSED: u32 = 0;
pub const PROGRESS_COPY_BYTES_TOTAL: u32 = 1;
pub const PROGRESS_COPY_TUPLES_PROCESSED: u32 = 2;
pub const PROGRESS_COPY_TUPLES_EXCLUDED: u32 = 3;
pub const PROGRESS_COPY_COMMAND: u32 = 4;
pub const PROGRESS_COPY_TYPE: u32 = 5;
pub const PROGRESS_COPY_TUPLES_SKIPPED: u32 = 6;
pub const PROGRESS_COPY_COMMAND_FROM: u32 = 1;
pub const PROGRESS_COPY_COMMAND_TO: u32 = 2;
pub const PROGRESS_COPY_TYPE_FILE: u32 = 1;
pub const PROGRESS_COPY_TYPE_PROGRAM: u32 = 2;
pub const PROGRESS_COPY_TYPE_PIPE: u32 = 3;
pub const PROGRESS_COPY_TYPE_CALLBACK: u32 = 4;
pub const XLOG_TBLSPC_CREATE: u32 = 0;
pub const XLOG_TBLSPC_DROP: u32 = 16;
pub const TRIGGER_EVENT_INSERT: u32 = 0;
pub const TRIGGER_EVENT_DELETE: u32 = 1;
pub const TRIGGER_EVENT_UPDATE: u32 = 2;
pub const TRIGGER_EVENT_TRUNCATE: u32 = 3;
pub const TRIGGER_EVENT_OPMASK: u32 = 3;
pub const TRIGGER_EVENT_ROW: u32 = 4;
pub const TRIGGER_EVENT_BEFORE: u32 = 8;
pub const TRIGGER_EVENT_AFTER: u32 = 0;
pub const TRIGGER_EVENT_INSTEAD: u32 = 16;
pub const TRIGGER_EVENT_TIMINGMASK: u32 = 24;
pub const AFTER_TRIGGER_DEFERRABLE: u32 = 32;
pub const AFTER_TRIGGER_INITDEFERRED: u32 = 64;
pub const SESSION_REPLICATION_ROLE_ORIGIN: u32 = 0;
pub const SESSION_REPLICATION_ROLE_REPLICA: u32 = 1;
pub const SESSION_REPLICATION_ROLE_LOCAL: u32 = 2;
pub const TRIGGER_FIRES_ON_ORIGIN: u8 = 79u8;
pub const TRIGGER_FIRES_ALWAYS: u8 = 65u8;
pub const TRIGGER_FIRES_ON_REPLICA: u8 = 82u8;
pub const TRIGGER_DISABLED: u8 = 68u8;
pub const RI_TRIGGER_PK: u32 = 1;
pub const RI_TRIGGER_FK: u32 = 2;
pub const RI_TRIGGER_NONE: u32 = 0;
pub const PG_AUTOCONF_FILENAME: &::core::ffi::CStr = c"postgresql.auto.conf";
pub const GUC_QUALIFIER_SEPARATOR: u8 = 46u8;
pub const GUC_LIST_INPUT: u32 = 1;
pub const GUC_LIST_QUOTE: u32 = 2;
pub const GUC_NO_SHOW_ALL: u32 = 4;
pub const GUC_NO_RESET: u32 = 8;
pub const GUC_NO_RESET_ALL: u32 = 16;
pub const GUC_EXPLAIN: u32 = 32;
pub const GUC_REPORT: u32 = 64;
pub const GUC_NOT_IN_SAMPLE: u32 = 128;
pub const GUC_DISALLOW_IN_FILE: u32 = 256;
pub const GUC_CUSTOM_PLACEHOLDER: u32 = 512;
pub const GUC_SUPERUSER_ONLY: u32 = 1024;
pub const GUC_IS_NAME: u32 = 2048;
pub const GUC_NOT_WHILE_SEC_REST: u32 = 4096;
pub const GUC_DISALLOW_IN_AUTO_FILE: u32 = 8192;
pub const GUC_RUNTIME_COMPUTED: u32 = 16384;
pub const GUC_ALLOW_IN_PARALLEL: u32 = 32768;
pub const GUC_UNIT_KB: u32 = 16777216;
pub const GUC_UNIT_BLOCKS: u32 = 33554432;
pub const GUC_UNIT_XBLOCKS: u32 = 50331648;
pub const GUC_UNIT_MB: u32 = 67108864;
pub const GUC_UNIT_BYTE: u32 = 83886080;
pub const GUC_UNIT_MEMORY: u32 = 251658240;
pub const GUC_UNIT_MS: u32 = 268435456;
pub const GUC_UNIT_S: u32 = 536870912;
pub const GUC_UNIT_MIN: u32 = 805306368;
pub const GUC_UNIT_TIME: u32 = 1879048192;
pub const GUC_UNIT: u32 = 2130706432;
pub const BGWORKER_SHMEM_ACCESS: u32 = 1;
pub const BGWORKER_BACKEND_DATABASE_CONNECTION: u32 = 2;
pub const BGWORKER_CLASS_PARALLEL: u32 = 16;
pub const BGW_DEFAULT_RESTART_INTERVAL: u32 = 60;
pub const BGW_NEVER_RESTART: i32 = -1;
pub const BGW_MAXLEN: u32 = 96;
pub const BGW_EXTRALEN: u32 = 128;
pub const BGWORKER_BYPASS_ALLOWCONN: u32 = 1;
pub const BGWORKER_BYPASS_ROLELOGINCHECK: u32 = 2;
pub const TRANSACTION_STATUS_IN_PROGRESS: u32 = 0;
pub const TRANSACTION_STATUS_COMMITTED: u32 = 1;
pub const TRANSACTION_STATUS_ABORTED: u32 = 2;
pub const TRANSACTION_STATUS_SUB_COMMITTED: u32 = 3;
pub const CLOG_ZEROPAGE: u32 = 0;
pub const CLOG_TRUNCATE: u32 = 16;
pub const WL_LATCH_SET: u32 = 1;
pub const WL_SOCKET_READABLE: u32 = 2;
pub const WL_SOCKET_WRITEABLE: u32 = 4;
pub const WL_TIMEOUT: u32 = 8;
pub const WL_POSTMASTER_DEATH: u32 = 16;
pub const WL_EXIT_ON_PM_DEATH: u32 = 32;
pub const WL_SOCKET_CONNECTED: u32 = 4;
pub const WL_SOCKET_CLOSED: u32 = 128;
pub const WL_SOCKET_ACCEPT: u32 = 2;
pub const WL_SOCKET_MASK: u32 = 134;
pub const PGPROC_MAX_CACHED_SUBXIDS: u32 = 64;
pub const PROC_IS_AUTOVACUUM: u32 = 1;
pub const PROC_IN_VACUUM: u32 = 2;
pub const PROC_IN_SAFE_IC: u32 = 4;
pub const PROC_VACUUM_FOR_WRAPAROUND: u32 = 8;
pub const PROC_IN_LOGICAL_DECODING: u32 = 16;
pub const PROC_AFFECTS_ALL_HORIZONS: u32 = 32;
pub const PROC_VACUUM_STATE_MASK: u32 = 14;
pub const PROC_XMIN_FLAGS: u32 = 6;
pub const FP_LOCK_SLOTS_PER_BACKEND: u32 = 16;
pub const DELAY_CHKPT_START: u32 = 1;
pub const DELAY_CHKPT_COMPLETE: u32 = 2;
pub const NUM_SPECIAL_WORKER_PROCS: u32 = 2;
pub const NUM_AUXILIARY_PROCS: u32 = 6;
pub const StatisticRelationId: Oid = Oid(2619);
pub const StatisticRelidAttnumInhIndexId: u32 = 2696;
pub const Anum_pg_statistic_starelid: u32 = 1;
pub const Anum_pg_statistic_staattnum: u32 = 2;
pub const Anum_pg_statistic_stainherit: u32 = 3;
pub const Anum_pg_statistic_stanullfrac: u32 = 4;
pub const Anum_pg_statistic_stawidth: u32 = 5;
pub const Anum_pg_statistic_stadistinct: u32 = 6;
pub const Anum_pg_statistic_stakind1: u32 = 7;
pub const Anum_pg_statistic_stakind2: u32 = 8;
pub const Anum_pg_statistic_stakind3: u32 = 9;
pub const Anum_pg_statistic_stakind4: u32 = 10;
pub const Anum_pg_statistic_stakind5: u32 = 11;
pub const Anum_pg_statistic_staop1: u32 = 12;
pub const Anum_pg_statistic_staop2: u32 = 13;
pub const Anum_pg_statistic_staop3: u32 = 14;
pub const Anum_pg_statistic_staop4: u32 = 15;
pub const Anum_pg_statistic_staop5: u32 = 16;
pub const Anum_pg_statistic_stacoll1: u32 = 17;
pub const Anum_pg_statistic_stacoll2: u32 = 18;
pub const Anum_pg_statistic_stacoll3: u32 = 19;
pub const Anum_pg_statistic_stacoll4: u32 = 20;
pub const Anum_pg_statistic_stacoll5: u32 = 21;
pub const Anum_pg_statistic_stanumbers1: u32 = 22;
pub const Anum_pg_statistic_stanumbers2: u32 = 23;
pub const Anum_pg_statistic_stanumbers3: u32 = 24;
pub const Anum_pg_statistic_stanumbers4: u32 = 25;
pub const Anum_pg_statistic_stanumbers5: u32 = 26;
pub const Anum_pg_statistic_stavalues1: u32 = 27;
pub const Anum_pg_statistic_stavalues2: u32 = 28;
pub const Anum_pg_statistic_stavalues3: u32 = 29;
pub const Anum_pg_statistic_stavalues4: u32 = 30;
pub const Anum_pg_statistic_stavalues5: u32 = 31;
pub const Natts_pg_statistic: u32 = 31;
pub const STATISTIC_KIND_MCV: u32 = 1;
pub const STATISTIC_KIND_HISTOGRAM: u32 = 2;
pub const STATISTIC_KIND_CORRELATION: u32 = 3;
pub const STATISTIC_KIND_MCELEM: u32 = 4;
pub const STATISTIC_KIND_DECHIST: u32 = 5;
pub const STATISTIC_KIND_RANGE_LENGTH_HISTOGRAM: u32 = 6;
pub const STATISTIC_KIND_BOUNDS_HISTOGRAM: u32 = 7;
pub const STATISTIC_NUM_SLOTS: u32 = 5;
pub const VACUUM_OPTION_NO_PARALLEL: u32 = 0;
pub const VACUUM_OPTION_PARALLEL_BULKDEL: u32 = 1;
pub const VACUUM_OPTION_PARALLEL_COND_CLEANUP: u32 = 2;
pub const VACUUM_OPTION_PARALLEL_CLEANUP: u32 = 4;
pub const VACUUM_OPTION_MAX_VALID_VALUE: u32 = 7;
pub const VACOPT_VACUUM: u32 = 1;
pub const VACOPT_ANALYZE: u32 = 2;
pub const VACOPT_VERBOSE: u32 = 4;
pub const VACOPT_FREEZE: u32 = 8;
pub const VACOPT_FULL: u32 = 16;
pub const VACOPT_SKIP_LOCKED: u32 = 32;
pub const VACOPT_PROCESS_MAIN: u32 = 64;
pub const VACOPT_PROCESS_TOAST: u32 = 128;
pub const VACOPT_DISABLE_PAGE_SKIPPING: u32 = 256;
pub const VACOPT_SKIP_DATABASE_STATS: u32 = 512;
pub const VACOPT_ONLY_DATABASE_STATS: u32 = 1024;
pub const MAX_STATISTICS_TARGET: u32 = 10000;
pub const FIELDNO_AGGSTATEPERGROUPDATA_TRANSVALUE: u32 = 0;
pub const FIELDNO_AGGSTATEPERGROUPDATA_TRANSVALUEISNULL: u32 = 1;
pub const FIELDNO_AGGSTATEPERGROUPDATA_NOTRANSVALUE: u32 = 2;
pub const EEO_FLAG_INTERPRETER_INITIALIZED: u32 = 2;
pub const EEO_FLAG_DIRECT_THREADED: u32 = 4;
pub const SPI_ERROR_CONNECT: i32 = -1;
pub const SPI_ERROR_COPY: i32 = -2;
pub const SPI_ERROR_OPUNKNOWN: i32 = -3;
pub const SPI_ERROR_UNCONNECTED: i32 = -4;
pub const SPI_ERROR_CURSOR: i32 = -5;
pub const SPI_ERROR_ARGUMENT: i32 = -6;
pub const SPI_ERROR_PARAM: i32 = -7;
pub const SPI_ERROR_TRANSACTION: i32 = -8;
pub const SPI_ERROR_NOATTRIBUTE: i32 = -9;
pub const SPI_ERROR_NOOUTFUNC: i32 = -10;
pub const SPI_ERROR_TYPUNKNOWN: i32 = -11;
pub const SPI_ERROR_REL_DUPLICATE: i32 = -12;
pub const SPI_ERROR_REL_NOT_FOUND: i32 = -13;
pub const SPI_OK_CONNECT: u32 = 1;
pub const SPI_OK_FINISH: u32 = 2;
pub const SPI_OK_FETCH: u32 = 3;
pub const SPI_OK_UTILITY: u32 = 4;
pub const SPI_OK_SELECT: u32 = 5;
pub const SPI_OK_SELINTO: u32 = 6;
pub const SPI_OK_INSERT: u32 = 7;
pub const SPI_OK_DELETE: u32 = 8;
pub const SPI_OK_UPDATE: u32 = 9;
pub const SPI_OK_CURSOR: u32 = 10;
pub const SPI_OK_INSERT_RETURNING: u32 = 11;
pub const SPI_OK_DELETE_RETURNING: u32 = 12;
pub const SPI_OK_UPDATE_RETURNING: u32 = 13;
pub const SPI_OK_REWRITTEN: u32 = 14;
pub const SPI_OK_REL_REGISTER: u32 = 15;
pub const SPI_OK_REL_UNREGISTER: u32 = 16;
pub const SPI_OK_TD_REGISTER: u32 = 17;
pub const SPI_OK_MERGE: u32 = 18;
pub const SPI_OK_MERGE_RETURNING: u32 = 19;
pub const SPI_OPT_NONATOMIC: u32 = 1;
pub const AMFLAG_HAS_TID_RANGE: u32 = 1;
pub const GROUPING_CAN_USE_SORT: u32 = 1;
pub const GROUPING_CAN_USE_HASH: u32 = 2;
pub const GROUPING_CAN_PARTIAL_AGG: u32 = 4;
pub const FSV_MISSING_OK: u32 = 1;
pub const FDW_MISSING_OK: u32 = 1;
pub const PGJIT_NONE: u32 = 0;
pub const PGJIT_PERFORM: u32 = 1;
pub const PGJIT_OPT3: u32 = 2;
pub const PGJIT_INLINE: u32 = 4;
pub const PGJIT_EXPR: u32 = 8;
pub const PGJIT_DEFORM: u32 = 16;
pub const MAX_MULTIBYTE_CHAR_LEN: u32 = 4;
pub const SS2: u32 = 142;
pub const SS3: u32 = 143;
pub const LC_ISO8859_1: u32 = 129;
pub const LC_ISO8859_2: u32 = 130;
pub const LC_ISO8859_3: u32 = 131;
pub const LC_ISO8859_4: u32 = 132;
pub const LC_TIS620: u32 = 133;
pub const LC_ISO8859_7: u32 = 134;
pub const LC_ISO8859_6: u32 = 135;
pub const LC_ISO8859_8: u32 = 136;
pub const LC_JISX0201K: u32 = 137;
pub const LC_JISX0201R: u32 = 138;
pub const LC_KOI8_R: u32 = 139;
pub const LC_ISO8859_5: u32 = 140;
pub const LC_ISO8859_9: u32 = 141;
pub const LC_ISO8859_15: u32 = 142;
pub const LC_JISX0208_1978: u32 = 144;
pub const LC_GB2312_80: u32 = 145;
pub const LC_JISX0208: u32 = 146;
pub const LC_KS5601: u32 = 147;
pub const LC_JISX0212: u32 = 148;
pub const LC_CNS11643_1: u32 = 149;
pub const LC_CNS11643_2: u32 = 150;
pub const LC_JISX0213_1: u32 = 151;
pub const LC_BIG5_1: u32 = 152;
pub const LC_BIG5_2: u32 = 153;
pub const LCPRV1_A: u32 = 154;
pub const LCPRV1_B: u32 = 155;
pub const LCPRV2_A: u32 = 156;
pub const LCPRV2_B: u32 = 157;
pub const LC_SISHENG: u32 = 160;
pub const LC_IPA: u32 = 161;
pub const LC_VISCII_LOWER: u32 = 162;
pub const LC_VISCII_UPPER: u32 = 163;
pub const LC_ARABIC_DIGIT: u32 = 164;
pub const LC_ARABIC_1_COLUMN: u32 = 165;
pub const LC_ASCII_RIGHT_TO_LEFT: u32 = 166;
pub const LC_LAO: u32 = 167;
pub const LC_ARABIC_2_COLUMN: u32 = 168;
pub const LC_INDIAN_1_COLUMN: u32 = 240;
pub const LC_TIBETAN_1_COLUMN: u32 = 241;
pub const LC_UNICODE_SUBSET_2: u32 = 242;
pub const LC_UNICODE_SUBSET_3: u32 = 243;
pub const LC_UNICODE_SUBSET: u32 = 244;
pub const LC_ETHIOPIC: u32 = 245;
pub const LC_CNS11643_3: u32 = 246;
pub const LC_CNS11643_4: u32 = 247;
pub const LC_CNS11643_5: u32 = 248;
pub const LC_CNS11643_6: u32 = 249;
pub const LC_CNS11643_7: u32 = 250;
pub const LC_INDIAN_2_COLUMN: u32 = 251;
pub const LC_TIBETAN: u32 = 252;
pub const MAX_CONVERSION_GROWTH: u32 = 4;
pub const MAX_CONVERSION_INPUT_LENGTH: u32 = 16;
pub const MAX_UNICODE_EQUIVALENT_STRING: u32 = 16;
pub const EXTNODENAME_MAX_LEN: u32 = 64;
pub const CUSTOMPATH_SUPPORT_BACKWARD_SCAN: u32 = 1;
pub const CUSTOMPATH_SUPPORT_MARK_RESTORE: u32 = 2;
pub const CUSTOMPATH_SUPPORT_PROJECTION: u32 = 4;
pub const QTW_IGNORE_RT_SUBQUERIES: u32 = 1;
pub const QTW_IGNORE_CTE_SUBQUERIES: u32 = 2;
pub const QTW_IGNORE_RC_SUBQUERIES: u32 = 3;
pub const QTW_IGNORE_JOINALIASES: u32 = 4;
pub const QTW_IGNORE_RANGE_TABLE: u32 = 8;
pub const QTW_EXAMINE_RTES_BEFORE: u32 = 16;
pub const QTW_EXAMINE_RTES_AFTER: u32 = 32;
pub const QTW_DONT_COPY_QUERY: u32 = 64;
pub const QTW_EXAMINE_SORTGROUP: u32 = 128;
pub const DEFAULT_SEQ_PAGE_COST: f64 = 1.0;
pub const DEFAULT_RANDOM_PAGE_COST: f64 = 4.0;
pub const DEFAULT_CPU_TUPLE_COST: f64 = 0.01;
pub const DEFAULT_CPU_INDEX_TUPLE_COST: f64 = 0.005;
pub const DEFAULT_CPU_OPERATOR_COST: f64 = 0.0025;
pub const DEFAULT_PARALLEL_TUPLE_COST: f64 = 0.1;
pub const DEFAULT_PARALLEL_SETUP_COST: f64 = 1000.0;
pub const DEFAULT_RECURSIVE_WORKTABLE_FACTOR: f64 = 10.0;
pub const DEFAULT_EFFECTIVE_CACHE_SIZE: u32 = 524288;
pub const PVC_INCLUDE_AGGREGATES: u32 = 1;
pub const PVC_RECURSE_AGGREGATES: u32 = 2;
pub const PVC_INCLUDE_WINDOWFUNCS: u32 = 4;
pub const PVC_RECURSE_WINDOWFUNCS: u32 = 8;
pub const PVC_INCLUDE_PLACEHOLDERS: u32 = 16;
pub const PVC_RECURSE_PLACEHOLDERS: u32 = 32;
pub const DEFAULT_CURSOR_TUPLE_FRACTION: f64 = 0.1;
pub const ER_MAGIC: u32 = 1384727874;
pub const ER_FLAG_FVALUE_VALID: u32 = 1;
pub const ER_FLAG_FVALUE_ALLOCED: u32 = 2;
pub const ER_FLAG_DVALUES_VALID: u32 = 4;
pub const ER_FLAG_DVALUES_ALLOCED: u32 = 8;
pub const ER_FLAG_HAVE_EXTERNAL: u32 = 16;
pub const ER_FLAG_TUPDESC_ALLOCED: u32 = 32;
pub const ER_FLAG_IS_DOMAIN: u32 = 64;
pub const ER_FLAG_IS_DUMMY: u32 = 128;
pub const ER_FLAGS_NON_DATA: u32 = 224;
pub const PLPGSQL_XCHECK_NONE: u32 = 0;
pub const PLPGSQL_XCHECK_SHADOWVAR: u32 = 2;
pub const PLPGSQL_XCHECK_TOOMANYROWS: u32 = 4;
pub const PLPGSQL_XCHECK_STRICTMULTIASSIGNMENT: u32 = 8;
pub const POSTMASTER_FD_WATCH: u32 = 0;
pub const POSTMASTER_FD_OWN: u32 = 1;
pub const MAX_BACKENDS: u32 = 262143;
pub const PIPE_PROTO_IS_LAST: u32 = 1;
pub const PIPE_PROTO_DEST_STDERR: u32 = 16;
pub const PIPE_PROTO_DEST_CSVLOG: u32 = 32;
pub const PIPE_PROTO_DEST_JSONLOG: u32 = 64;
pub const LOG_METAINFO_DATAFILE: &::core::ffi::CStr = c"current_logfiles";
pub const LOG_METAINFO_DATAFILE_TMP: &::core::ffi::CStr = c"current_logfiles.tmp";
pub const RBTXN_HAS_CATALOG_CHANGES: u32 = 1;
pub const RBTXN_IS_SUBXACT: u32 = 2;
pub const RBTXN_IS_SERIALIZED: u32 = 4;
pub const RBTXN_IS_SERIALIZED_CLEAR: u32 = 8;
pub const RBTXN_IS_STREAMED: u32 = 16;
pub const RBTXN_HAS_PARTIAL_CHANGE: u32 = 32;
pub const RBTXN_PREPARE: u32 = 64;
pub const RBTXN_SKIPPED_PREPARE: u32 = 128;
pub const RBTXN_HAS_STREAMABLE_CHANGE: u32 = 256;
pub const LOGICALREP_PROTO_MIN_VERSION_NUM: u32 = 1;
pub const LOGICALREP_PROTO_VERSION_NUM: u32 = 1;
pub const LOGICALREP_PROTO_STREAM_VERSION_NUM: u32 = 2;
pub const LOGICALREP_PROTO_TWOPHASE_VERSION_NUM: u32 = 3;
pub const LOGICALREP_PROTO_STREAM_PARALLEL_VERSION_NUM: u32 = 4;
pub const LOGICALREP_PROTO_MAX_VERSION_NUM: u32 = 4;
pub const LOGICALREP_COLUMN_NULL: u8 = 110u8;
pub const LOGICALREP_COLUMN_UNCHANGED: u8 = 117u8;
pub const LOGICALREP_COLUMN_TEXT: u8 = 116u8;
pub const LOGICALREP_COLUMN_BINARY: u8 = 98u8;
pub const MAXCONNINFO: u32 = 1024;
pub const BUF_REFCOUNT_ONE: u32 = 1;
pub const BUF_REFCOUNT_MASK: u32 = 262143;
pub const BUF_USAGECOUNT_MASK: u32 = 3932160;
pub const BUF_USAGECOUNT_ONE: u32 = 262144;
pub const BUF_USAGECOUNT_SHIFT: u32 = 18;
pub const BUF_FLAG_MASK: u32 = 4290772992;
pub const BM_LOCKED: u32 = 4194304;
pub const BM_DIRTY: u32 = 8388608;
pub const BM_VALID: u32 = 16777216;
pub const BM_TAG_VALID: u32 = 33554432;
pub const BM_IO_IN_PROGRESS: u32 = 67108864;
pub const BM_IO_ERROR: u32 = 134217728;
pub const BM_JUST_DIRTIED: u32 = 268435456;
pub const BM_PIN_COUNT_WAITER: u32 = 536870912;
pub const BM_CHECKPOINT_NEEDED: u32 = 1073741824;
pub const BM_PERMANENT: u32 = 2147483648;
pub const BM_MAX_USAGE_COUNT: u32 = 5;
pub const FREENEXT_END_OF_LIST: i32 = -1;
pub const FREENEXT_NOT_IN_LIST: i32 = -2;
pub const XLOG_STANDBY_LOCK: u32 = 0;
pub const XLOG_RUNNING_XACTS: u32 = 16;
pub const XLOG_INVALIDATIONS: u32 = 32;
pub const STACK_DEPTH_SLOP: u32 = 524288;
pub const RESTRICT_RELKIND_VIEW: u32 = 1;
pub const RESTRICT_RELKIND_FOREIGN_TABLE: u32 = 2;
pub const COMMAND_OK_IN_READ_ONLY_TXN: u32 = 1;
pub const COMMAND_OK_IN_PARALLEL_MODE: u32 = 2;
pub const COMMAND_OK_IN_RECOVERY: u32 = 4;
pub const COMMAND_IS_STRICTLY_READ_ONLY: u32 = 7;
pub const COMMAND_IS_NOT_READ_ONLY: u32 = 0;
pub const MAXSTRLEN: u32 = 2047;
pub const MAXSTRPOS: u32 = 1048575;
pub const MAXENTRYPOS: u32 = 16384;
pub const MAXNUMPOS: u32 = 256;
pub const QI_VAL: u32 = 1;
pub const QI_OPR: u32 = 2;
pub const QI_VALSTOP: u32 = 3;
pub const OP_NOT: u32 = 1;
pub const OP_AND: u32 = 2;
pub const OP_OR: u32 = 3;
pub const OP_PHRASE: u32 = 4;
pub const OP_COUNT: u32 = 4;
pub const TSL_ADDPOS: u32 = 1;
pub const TSL_PREFIX: u32 = 2;
pub const TSL_FILTER: u32 = 4;
pub const P_TSV_OPR_IS_DELIM: u32 = 1;
pub const P_TSV_IS_TSQUERY: u32 = 2;
pub const P_TSV_IS_WEB: u32 = 4;
pub const P_TSQ_PLAIN: u32 = 1;
pub const P_TSQ_WEB: u32 = 2;
pub const TS_EXEC_EMPTY: u32 = 0;
pub const TS_EXEC_SKIP_NOT: u32 = 1;
pub const TS_EXEC_PHRASE_NO_POS: u32 = 2;
pub const TSearchStrategyNumber: u32 = 1;
pub const TSearchWithClassStrategyNumber: u32 = 2;
pub const QTN_NEEDFREE: u32 = 1;
pub const QTN_NOCHANGE: u32 = 2;
pub const QTN_WORDFREE: u32 = 4;
pub const MAXINT8LEN: u32 = 20;
pub const FORMAT_TYPE_TYPEMOD_GIVEN: u32 = 1;
pub const FORMAT_TYPE_ALLOW_INVALID: u32 = 2;
pub const FORMAT_TYPE_FORCE_QUALIFY: u32 = 4;
pub const FORMAT_TYPE_INVALID_AS_NULL: u32 = 8;
pub const MAX_TIME_PRECISION: u32 = 6;
pub const DAGO: &::core::ffi::CStr = c"ago";
pub const DCURRENT: &::core::ffi::CStr = c"current";
pub const EPOCH: &::core::ffi::CStr = c"epoch";
pub const INVALID: &::core::ffi::CStr = c"invalid";
pub const EARLY: &::core::ffi::CStr = c"-infinity";
pub const LATE: &::core::ffi::CStr = c"infinity";
pub const NOW: &::core::ffi::CStr = c"now";
pub const TODAY: &::core::ffi::CStr = c"today";
pub const TOMORROW: &::core::ffi::CStr = c"tomorrow";
pub const YESTERDAY: &::core::ffi::CStr = c"yesterday";
pub const ZULU: &::core::ffi::CStr = c"zulu";
pub const DMICROSEC: &::core::ffi::CStr = c"usecond";
pub const DMILLISEC: &::core::ffi::CStr = c"msecond";
pub const DSECOND: &::core::ffi::CStr = c"second";
pub const DMINUTE: &::core::ffi::CStr = c"minute";
pub const DHOUR: &::core::ffi::CStr = c"hour";
pub const DDAY: &::core::ffi::CStr = c"day";
pub const DWEEK: &::core::ffi::CStr = c"week";
pub const DMONTH: &::core::ffi::CStr = c"month";
pub const DQUARTER: &::core::ffi::CStr = c"quarter";
pub const DYEAR: &::core::ffi::CStr = c"year";
pub const DDECADE: &::core::ffi::CStr = c"decade";
pub const DCENTURY: &::core::ffi::CStr = c"century";
pub const DMILLENNIUM: &::core::ffi::CStr = c"millennium";
pub const DA_D: &::core::ffi::CStr = c"ad";
pub const DB_C: &::core::ffi::CStr = c"bc";
pub const DTIMEZONE: &::core::ffi::CStr = c"timezone";
pub const AM: u32 = 0;
pub const PM: u32 = 1;
pub const HR24: u32 = 2;
pub const AD: u32 = 0;
pub const BC: u32 = 1;
pub const RESERV: u32 = 0;
pub const MONTH: u32 = 1;
pub const YEAR: u32 = 2;
pub const DAY: u32 = 3;
pub const JULIAN: u32 = 4;
pub const TZ: u32 = 5;
pub const DTZ: u32 = 6;
pub const DYNTZ: u32 = 7;
pub const IGNORE_DTF: u32 = 8;
pub const AMPM: u32 = 9;
pub const HOUR: u32 = 10;
pub const MINUTE: u32 = 11;
pub const SECOND: u32 = 12;
pub const MILLISECOND: u32 = 13;
pub const MICROSECOND: u32 = 14;
pub const DOY: u32 = 15;
pub const DOW: u32 = 16;
pub const UNITS: u32 = 17;
pub const ADBC: u32 = 18;
pub const AGO: u32 = 19;
pub const ABS_BEFORE: u32 = 20;
pub const ABS_AFTER: u32 = 21;
pub const ISODATE: u32 = 22;
pub const ISOTIME: u32 = 23;
pub const WEEK: u32 = 24;
pub const DECADE: u32 = 25;
pub const CENTURY: u32 = 26;
pub const MILLENNIUM: u32 = 27;
pub const DTZMOD: u32 = 28;
pub const UNKNOWN_FIELD: u32 = 31;
pub const DTK_NUMBER: u32 = 0;
pub const DTK_STRING: u32 = 1;
pub const DTK_DATE: u32 = 2;
pub const DTK_TIME: u32 = 3;
pub const DTK_TZ: u32 = 4;
pub const DTK_AGO: u32 = 5;
pub const DTK_SPECIAL: u32 = 6;
pub const DTK_EARLY: u32 = 9;
pub const DTK_LATE: u32 = 10;
pub const DTK_EPOCH: u32 = 11;
pub const DTK_NOW: u32 = 12;
pub const DTK_YESTERDAY: u32 = 13;
pub const DTK_TODAY: u32 = 14;
pub const DTK_TOMORROW: u32 = 15;
pub const DTK_ZULU: u32 = 16;
pub const DTK_DELTA: u32 = 17;
pub const DTK_SECOND: u32 = 18;
pub const DTK_MINUTE: u32 = 19;
pub const DTK_HOUR: u32 = 20;
pub const DTK_DAY: u32 = 21;
pub const DTK_WEEK: u32 = 22;
pub const DTK_MONTH: u32 = 23;
pub const DTK_QUARTER: u32 = 24;
pub const DTK_YEAR: u32 = 25;
pub const DTK_DECADE: u32 = 26;
pub const DTK_CENTURY: u32 = 27;
pub const DTK_MILLENNIUM: u32 = 28;
pub const DTK_MILLISEC: u32 = 29;
pub const DTK_MICROSEC: u32 = 30;
pub const DTK_JULIAN: u32 = 31;
pub const DTK_DOW: u32 = 32;
pub const DTK_DOY: u32 = 33;
pub const DTK_TZ_HOUR: u32 = 34;
pub const DTK_TZ_MINUTE: u32 = 35;
pub const DTK_ISOYEAR: u32 = 36;
pub const DTK_ISODOW: u32 = 37;
pub const MAXDATELEN: u32 = 128;
pub const MAXDATEFIELDS: u32 = 25;
pub const TOKMAXLEN: u32 = 10;
pub const DTERR_BAD_FORMAT: i32 = -1;
pub const DTERR_FIELD_OVERFLOW: i32 = -2;
pub const DTERR_MD_FIELD_OVERFLOW: i32 = -3;
pub const DTERR_INTERVAL_OVERFLOW: i32 = -4;
pub const DTERR_TZDISP_OVERFLOW: i32 = -5;
pub const DTERR_BAD_TIMEZONE: i32 = -6;
pub const DTERR_BAD_ZONE_ABBREV: i32 = -7;
pub const TZNAME_FIXED_OFFSET: u32 = 0;
pub const TZNAME_DYNTZ: u32 = 1;
pub const TZNAME_ZONE: u32 = 2;
pub const RADIANS_PER_DEGREE: f64 = 0.017453292519943295;
pub const F_HEAP_TABLEAM_HANDLER: u32 = 3;
pub const F_BYTEAOUT: u32 = 31;
pub const F_CHAROUT: u32 = 33;
pub const F_NAMEIN: u32 = 34;
pub const F_NAMEOUT: u32 = 35;
pub const F_INT2IN: u32 = 38;
pub const F_INT2OUT: u32 = 39;
pub const F_INT2VECTORIN: u32 = 40;
pub const F_INT2VECTOROUT: u32 = 41;
pub const F_INT4IN: u32 = 42;
pub const F_INT4OUT: u32 = 43;
pub const F_REGPROCIN: u32 = 44;
pub const F_REGPROCOUT: u32 = 45;
pub const F_TEXTIN: u32 = 46;
pub const F_TEXTOUT: u32 = 47;
pub const F_TIDIN: u32 = 48;
pub const F_TIDOUT: u32 = 49;
pub const F_XIDIN: u32 = 50;
pub const F_XIDOUT: u32 = 51;
pub const F_CIDIN: u32 = 52;
pub const F_CIDOUT: u32 = 53;
pub const F_OIDVECTORIN: u32 = 54;
pub const F_OIDVECTOROUT: u32 = 55;
pub const F_BOOLLT: u32 = 56;
pub const F_BOOLGT: u32 = 57;
pub const F_BOOLEQ: u32 = 60;
pub const F_CHAREQ: u32 = 61;
pub const F_NAMEEQ: u32 = 62;
pub const F_INT2EQ: u32 = 63;
pub const F_INT2LT: u32 = 64;
pub const F_INT4EQ: u32 = 65;
pub const F_INT4LT: u32 = 66;
pub const F_TEXTEQ: u32 = 67;
pub const F_XIDEQ: u32 = 68;
pub const F_CIDEQ: u32 = 69;
pub const F_CHARNE: u32 = 70;
pub const F_CHARLE: u32 = 72;
pub const F_CHARGT: u32 = 73;
pub const F_CHARGE: u32 = 74;
pub const F_INT4_CHAR: u32 = 77;
pub const F_CHAR_INT4: u32 = 78;
pub const F_NAMEREGEXEQ: u32 = 79;
pub const F_BOOLNE: u32 = 84;
pub const F_PG_DDL_COMMAND_IN: u32 = 86;
pub const F_PG_DDL_COMMAND_OUT: u32 = 87;
pub const F_PG_DDL_COMMAND_RECV: u32 = 88;
pub const F_VERSION: u32 = 89;
pub const F_PG_DDL_COMMAND_SEND: u32 = 90;
pub const F_EQSEL: u32 = 101;
pub const F_NEQSEL: u32 = 102;
pub const F_SCALARLTSEL: u32 = 103;
pub const F_SCALARGTSEL: u32 = 104;
pub const F_EQJOINSEL: u32 = 105;
pub const F_NEQJOINSEL: u32 = 106;
pub const F_SCALARLTJOINSEL: u32 = 107;
pub const F_SCALARGTJOINSEL: u32 = 108;
pub const F_UNKNOWNIN: u32 = 109;
pub const F_UNKNOWNOUT: u32 = 110;
pub const F_BOX_ABOVE_EQ: u32 = 115;
pub const F_BOX_BELOW_EQ: u32 = 116;
pub const F_POINT_IN: u32 = 117;
pub const F_POINT_OUT: u32 = 118;
pub const F_LSEG_IN: u32 = 119;
pub const F_LSEG_OUT: u32 = 120;
pub const F_PATH_IN: u32 = 121;
pub const F_PATH_OUT: u32 = 122;
pub const F_BOX_IN: u32 = 123;
pub const F_BOX_OUT: u32 = 124;
pub const F_BOX_OVERLAP: u32 = 125;
pub const F_BOX_GE: u32 = 126;
pub const F_BOX_GT: u32 = 127;
pub const F_BOX_EQ: u32 = 128;
pub const F_BOX_LT: u32 = 129;
pub const F_BOX_LE: u32 = 130;
pub const F_POINT_ABOVE: u32 = 131;
pub const F_POINT_LEFT: u32 = 132;
pub const F_POINT_RIGHT: u32 = 133;
pub const F_POINT_BELOW: u32 = 134;
pub const F_POINT_EQ: u32 = 135;
pub const F_ON_PB: u32 = 136;
pub const F_ON_PPATH: u32 = 137;
pub const F_BOX_CENTER: u32 = 138;
pub const F_AREASEL: u32 = 139;
pub const F_AREAJOINSEL: u32 = 140;
pub const F_INT4MUL: u32 = 141;
pub const F_INT4NE: u32 = 144;
pub const F_INT2NE: u32 = 145;
pub const F_INT2GT: u32 = 146;
pub const F_INT4GT: u32 = 147;
pub const F_INT2LE: u32 = 148;
pub const F_INT4LE: u32 = 149;
pub const F_INT4GE: u32 = 150;
pub const F_INT2GE: u32 = 151;
pub const F_INT2MUL: u32 = 152;
pub const F_INT2DIV: u32 = 153;
pub const F_INT4DIV: u32 = 154;
pub const F_INT2MOD: u32 = 155;
pub const F_INT4MOD: u32 = 156;
pub const F_TEXTNE: u32 = 157;
pub const F_INT24EQ: u32 = 158;
pub const F_INT42EQ: u32 = 159;
pub const F_INT24LT: u32 = 160;
pub const F_INT42LT: u32 = 161;
pub const F_INT24GT: u32 = 162;
pub const F_INT42GT: u32 = 163;
pub const F_INT24NE: u32 = 164;
pub const F_INT42NE: u32 = 165;
pub const F_INT24LE: u32 = 166;
pub const F_INT42LE: u32 = 167;
pub const F_INT24GE: u32 = 168;
pub const F_INT42GE: u32 = 169;
pub const F_INT24MUL: u32 = 170;
pub const F_INT42MUL: u32 = 171;
pub const F_INT24DIV: u32 = 172;
pub const F_INT42DIV: u32 = 173;
pub const F_INT2PL: u32 = 176;
pub const F_INT4PL: u32 = 177;
pub const F_INT24PL: u32 = 178;
pub const F_INT42PL: u32 = 179;
pub const F_INT2MI: u32 = 180;
pub const F_INT4MI: u32 = 181;
pub const F_INT24MI: u32 = 182;
pub const F_INT42MI: u32 = 183;
pub const F_OIDEQ: u32 = 184;
pub const F_OIDNE: u32 = 185;
pub const F_BOX_SAME: u32 = 186;
pub const F_BOX_CONTAIN: u32 = 187;
pub const F_BOX_LEFT: u32 = 188;
pub const F_BOX_OVERLEFT: u32 = 189;
pub const F_BOX_OVERRIGHT: u32 = 190;
pub const F_BOX_RIGHT: u32 = 191;
pub const F_BOX_CONTAINED: u32 = 192;
pub const F_BOX_CONTAIN_PT: u32 = 193;
pub const F_PG_NODE_TREE_IN: u32 = 195;
pub const F_PG_NODE_TREE_OUT: u32 = 196;
pub const F_PG_NODE_TREE_RECV: u32 = 197;
pub const F_PG_NODE_TREE_SEND: u32 = 198;
pub const F_FLOAT4IN: u32 = 200;
pub const F_FLOAT4OUT: u32 = 201;
pub const F_FLOAT4MUL: u32 = 202;
pub const F_FLOAT4DIV: u32 = 203;
pub const F_FLOAT4PL: u32 = 204;
pub const F_FLOAT4MI: u32 = 205;
pub const F_FLOAT4UM: u32 = 206;
pub const F_FLOAT4ABS: u32 = 207;
pub const F_FLOAT4_ACCUM: u32 = 208;
pub const F_FLOAT4LARGER: u32 = 209;
pub const F_FLOAT4SMALLER: u32 = 211;
pub const F_INT4UM: u32 = 212;
pub const F_INT2UM: u32 = 213;
pub const F_FLOAT8IN: u32 = 214;
pub const F_FLOAT8OUT: u32 = 215;
pub const F_FLOAT8MUL: u32 = 216;
pub const F_FLOAT8DIV: u32 = 217;
pub const F_FLOAT8PL: u32 = 218;
pub const F_FLOAT8MI: u32 = 219;
pub const F_FLOAT8UM: u32 = 220;
pub const F_FLOAT8ABS: u32 = 221;
pub const F_FLOAT8_ACCUM: u32 = 222;
pub const F_FLOAT8LARGER: u32 = 223;
pub const F_FLOAT8SMALLER: u32 = 224;
pub const F_LSEG_CENTER: u32 = 225;
pub const F_POLY_CENTER: u32 = 227;
pub const F_DROUND: u32 = 228;
pub const F_DTRUNC: u32 = 229;
pub const F_DSQRT: u32 = 230;
pub const F_DCBRT: u32 = 231;
pub const F_DPOW: u32 = 232;
pub const F_DEXP: u32 = 233;
pub const F_DLOG1: u32 = 234;
pub const F_FLOAT8_INT2: u32 = 235;
pub const F_FLOAT4_INT2: u32 = 236;
pub const F_INT2_FLOAT8: u32 = 237;
pub const F_INT2_FLOAT4: u32 = 238;
pub const F_LINE_DISTANCE: u32 = 239;
pub const F_NAMEEQTEXT: u32 = 240;
pub const F_NAMELTTEXT: u32 = 241;
pub const F_NAMELETEXT: u32 = 242;
pub const F_NAMEGETEXT: u32 = 243;
pub const F_NAMEGTTEXT: u32 = 244;
pub const F_NAMENETEXT: u32 = 245;
pub const F_BTNAMETEXTCMP: u32 = 246;
pub const F_TEXTEQNAME: u32 = 247;
pub const F_TEXTLTNAME: u32 = 248;
pub const F_TEXTLENAME: u32 = 249;
pub const F_TEXTGENAME: u32 = 250;
pub const F_TEXTGTNAME: u32 = 251;
pub const F_TEXTNENAME: u32 = 252;
pub const F_BTTEXTNAMECMP: u32 = 253;
pub const F_NAMECONCATOID: Oid = Oid(266);
pub const F_TABLE_AM_HANDLER_IN: u32 = 267;
pub const F_TABLE_AM_HANDLER_OUT: u32 = 268;
pub const F_TIMEOFDAY: u32 = 274;
pub const F_PG_NEXTOID: Oid = Oid(275);
pub const F_FLOAT8_COMBINE: u32 = 276;
pub const F_INTER_SL: u32 = 277;
pub const F_INTER_LB: u32 = 278;
pub const F_FLOAT48MUL: u32 = 279;
pub const F_FLOAT48DIV: u32 = 280;
pub const F_FLOAT48PL: u32 = 281;
pub const F_FLOAT48MI: u32 = 282;
pub const F_FLOAT84MUL: u32 = 283;
pub const F_FLOAT84DIV: u32 = 284;
pub const F_FLOAT84PL: u32 = 285;
pub const F_FLOAT84MI: u32 = 286;
pub const F_FLOAT4EQ: u32 = 287;
pub const F_FLOAT4NE: u32 = 288;
pub const F_FLOAT4LT: u32 = 289;
pub const F_FLOAT4LE: u32 = 290;
pub const F_FLOAT4GT: u32 = 291;
pub const F_FLOAT4GE: u32 = 292;
pub const F_FLOAT8EQ: u32 = 293;
pub const F_FLOAT8NE: u32 = 294;
pub const F_FLOAT8LT: u32 = 295;
pub const F_FLOAT8LE: u32 = 296;
pub const F_FLOAT8GT: u32 = 297;
pub const F_FLOAT8GE: u32 = 298;
pub const F_FLOAT48EQ: u32 = 299;
pub const F_FLOAT48NE: u32 = 300;
pub const F_FLOAT48LT: u32 = 301;
pub const F_FLOAT48LE: u32 = 302;
pub const F_FLOAT48GT: u32 = 303;
pub const F_FLOAT48GE: u32 = 304;
pub const F_FLOAT84EQ: u32 = 305;
pub const F_FLOAT84NE: u32 = 306;
pub const F_FLOAT84LT: u32 = 307;
pub const F_FLOAT84LE: u32 = 308;
pub const F_FLOAT84GT: u32 = 309;
pub const F_FLOAT84GE: u32 = 310;
pub const F_FLOAT8_FLOAT4: u32 = 311;
pub const F_FLOAT4_FLOAT8: u32 = 312;
pub const F_INT4_INT2: u32 = 313;
pub const F_INT2_INT4: u32 = 314;
pub const F_PG_JIT_AVAILABLE: u32 = 315;
pub const F_FLOAT8_INT4: u32 = 316;
pub const F_INT4_FLOAT8: u32 = 317;
pub const F_FLOAT4_INT4: u32 = 318;
pub const F_INT4_FLOAT4: u32 = 319;
pub const F_WIDTH_BUCKET_FLOAT8_FLOAT8_FLOAT8_INT4: u32 = 320;
pub const F_JSON_IN: u32 = 321;
pub const F_JSON_OUT: u32 = 322;
pub const F_JSON_RECV: u32 = 323;
pub const F_JSON_SEND: u32 = 324;
pub const F_INDEX_AM_HANDLER_IN: u32 = 326;
pub const F_INDEX_AM_HANDLER_OUT: u32 = 327;
pub const F_HASHMACADDR8: u32 = 328;
pub const F_HASH_ACLITEM: u32 = 329;
pub const F_BTHANDLER: u32 = 330;
pub const F_HASHHANDLER: u32 = 331;
pub const F_GISTHANDLER: u32 = 332;
pub const F_GINHANDLER: u32 = 333;
pub const F_SPGHANDLER: u32 = 334;
pub const F_BRINHANDLER: u32 = 335;
pub const F_SCALARLESEL: u32 = 336;
pub const F_SCALARGESEL: u32 = 337;
pub const F_AMVALIDATE: u32 = 338;
pub const F_POLY_SAME: u32 = 339;
pub const F_POLY_CONTAIN: u32 = 340;
pub const F_POLY_LEFT: u32 = 341;
pub const F_POLY_OVERLEFT: u32 = 342;
pub const F_POLY_OVERRIGHT: u32 = 343;
pub const F_POLY_RIGHT: u32 = 344;
pub const F_POLY_CONTAINED: u32 = 345;
pub const F_POLY_OVERLAP: u32 = 346;
pub const F_POLY_IN: u32 = 347;
pub const F_POLY_OUT: u32 = 348;
pub const F_BTINT2CMP: u32 = 350;
pub const F_BTINT4CMP: u32 = 351;
pub const F_BTFLOAT4CMP: u32 = 354;
pub const F_BTFLOAT8CMP: u32 = 355;
pub const F_BTOIDCMP: u32 = 356;
pub const F_DIST_BP: u32 = 357;
pub const F_BTCHARCMP: u32 = 358;
pub const F_BTNAMECMP: u32 = 359;
pub const F_BTTEXTCMP: u32 = 360;
pub const F_LSEG_DISTANCE: u32 = 361;
pub const F_LSEG_INTERPT: u32 = 362;
pub const F_DIST_PS: u32 = 363;
pub const F_DIST_PB: u32 = 364;
pub const F_DIST_SB: u32 = 365;
pub const F_CLOSE_PS: u32 = 366;
pub const F_CLOSE_PB: u32 = 367;
pub const F_CLOSE_SB: u32 = 368;
pub const F_ON_PS: u32 = 369;
pub const F_PATH_DISTANCE: u32 = 370;
pub const F_DIST_PPATH: u32 = 371;
pub const F_ON_SB: u32 = 372;
pub const F_INTER_SB: u32 = 373;
pub const F_STRING_TO_ARRAY_TEXT_TEXT_TEXT: u32 = 376;
pub const F_CASH_CMP: u32 = 377;
pub const F_ARRAY_APPEND: u32 = 378;
pub const F_ARRAY_PREPEND: u32 = 379;
pub const F_DIST_SP: u32 = 380;
pub const F_DIST_BS: u32 = 381;
pub const F_BTARRAYCMP: u32 = 382;
pub const F_ARRAY_CAT: u32 = 383;
pub const F_ARRAY_TO_STRING_ANYARRAY_TEXT_TEXT: u32 = 384;
pub const F_SCALARLEJOINSEL: u32 = 386;
pub const F_ARRAY_NE: u32 = 390;
pub const F_ARRAY_LT: u32 = 391;
pub const F_ARRAY_GT: u32 = 392;
pub const F_ARRAY_LE: u32 = 393;
pub const F_STRING_TO_ARRAY_TEXT_TEXT: u32 = 394;
pub const F_ARRAY_TO_STRING_ANYARRAY_TEXT: u32 = 395;
pub const F_ARRAY_GE: u32 = 396;
pub const F_SCALARGEJOINSEL: u32 = 398;
pub const F_HASHMACADDR: u32 = 399;
pub const F_HASHTEXT: u32 = 400;
pub const F_TEXT_BPCHAR: u32 = 401;
pub const F_BTOIDVECTORCMP: u32 = 404;
pub const F_TEXT_NAME: u32 = 406;
pub const F_NAME_TEXT: u32 = 407;
pub const F_BPCHAR_NAME: u32 = 408;
pub const F_NAME_BPCHAR: u32 = 409;
pub const F_DIST_PATHP: u32 = 421;
pub const F_HASHINET: u32 = 422;
pub const F_HASHINT4EXTENDED: u32 = 425;
pub const F_HASH_NUMERIC: u32 = 432;
pub const F_MACADDR_IN: u32 = 436;
pub const F_MACADDR_OUT: u32 = 437;
pub const F_NUM_NULLS: u32 = 438;
pub const F_NUM_NONNULLS: u32 = 440;
pub const F_HASHINT2EXTENDED: u32 = 441;
pub const F_HASHINT8EXTENDED: u32 = 442;
pub const F_HASHFLOAT4EXTENDED: u32 = 443;
pub const F_HASHFLOAT8EXTENDED: u32 = 444;
pub const F_HASHOIDEXTENDED: u32 = 445;
pub const F_HASHCHAREXTENDED: u32 = 446;
pub const F_HASHNAMEEXTENDED: u32 = 447;
pub const F_HASHTEXTEXTENDED: u32 = 448;
pub const F_HASHINT2: u32 = 449;
pub const F_HASHINT4: u32 = 450;
pub const F_HASHFLOAT4: u32 = 451;
pub const F_HASHFLOAT8: u32 = 452;
pub const F_HASHOID: Oid = Oid(453);
pub const F_HASHCHAR: u32 = 454;
pub const F_HASHNAME: u32 = 455;
pub const F_HASHVARLENA: u32 = 456;
pub const F_HASHOIDVECTOR: u32 = 457;
pub const F_TEXT_LARGER: u32 = 458;
pub const F_TEXT_SMALLER: u32 = 459;
pub const F_INT8IN: u32 = 460;
pub const F_INT8OUT: u32 = 461;
pub const F_INT8UM: u32 = 462;
pub const F_INT8PL: u32 = 463;
pub const F_INT8MI: u32 = 464;
pub const F_INT8MUL: u32 = 465;
pub const F_INT8DIV: u32 = 466;
pub const F_INT8EQ: u32 = 467;
pub const F_INT8NE: u32 = 468;
pub const F_INT8LT: u32 = 469;
pub const F_INT8GT: u32 = 470;
pub const F_INT8LE: u32 = 471;
pub const F_INT8GE: u32 = 472;
pub const F_INT84EQ: u32 = 474;
pub const F_INT84NE: u32 = 475;
pub const F_INT84LT: u32 = 476;
pub const F_INT84GT: u32 = 477;
pub const F_INT84LE: u32 = 478;
pub const F_INT84GE: u32 = 479;
pub const F_INT4_INT8: u32 = 480;
pub const F_INT8_INT4: u32 = 481;
pub const F_FLOAT8_INT8: u32 = 482;
pub const F_INT8_FLOAT8: u32 = 483;
pub const F_ARRAY_LARGER: u32 = 515;
pub const F_ARRAY_SMALLER: u32 = 516;
pub const F_ABBREV_INET: u32 = 598;
pub const F_ABBREV_CIDR: u32 = 599;
pub const F_SET_MASKLEN_INET_INT4: u32 = 605;
pub const F_OIDVECTORNE: u32 = 619;
pub const F_HASH_ARRAY: u32 = 626;
pub const F_SET_MASKLEN_CIDR_INT4: u32 = 635;
pub const F_PG_INDEXAM_HAS_PROPERTY: u32 = 636;
pub const F_PG_INDEX_HAS_PROPERTY: u32 = 637;
pub const F_PG_INDEX_COLUMN_HAS_PROPERTY: u32 = 638;
pub const F_FLOAT4_INT8: u32 = 652;
pub const F_INT8_FLOAT4: u32 = 653;
pub const F_NAMELT: u32 = 655;
pub const F_NAMELE: u32 = 656;
pub const F_NAMEGT: u32 = 657;
pub const F_NAMEGE: u32 = 658;
pub const F_NAMENE: u32 = 659;
pub const F_BPCHAR_BPCHAR_INT4_BOOL: u32 = 668;
pub const F_VARCHAR_VARCHAR_INT4_BOOL: u32 = 669;
pub const F_PG_INDEXAM_PROGRESS_PHASENAME: u32 = 676;
pub const F_OIDVECTORLT: u32 = 677;
pub const F_OIDVECTORLE: u32 = 678;
pub const F_OIDVECTOREQ: u32 = 679;
pub const F_OIDVECTORGE: u32 = 680;
pub const F_OIDVECTORGT: u32 = 681;
pub const F_NETWORK: u32 = 683;
pub const F_NETMASK: u32 = 696;
pub const F_MASKLEN: u32 = 697;
pub const F_BROADCAST: u32 = 698;
pub const F_HOST: u32 = 699;
pub const F_DIST_LP: u32 = 702;
pub const F_DIST_LS: u32 = 704;
pub const F_GETPGUSERNAME: u32 = 710;
pub const F_FAMILY: u32 = 711;
pub const F_INT2_INT8: u32 = 714;
pub const F_LO_CREATE: u32 = 715;
pub const F_OIDLT: u32 = 716;
pub const F_OIDLE: u32 = 717;
pub const F_OCTET_LENGTH_BYTEA: u32 = 720;
pub const F_GET_BYTE: u32 = 721;
pub const F_SET_BYTE: u32 = 722;
pub const F_GET_BIT_BYTEA_INT8: u32 = 723;
pub const F_SET_BIT_BYTEA_INT8_INT4: u32 = 724;
pub const F_DIST_PL: u32 = 725;
pub const F_DIST_SL: u32 = 727;
pub const F_DIST_CPOLY: u32 = 728;
pub const F_POLY_DISTANCE: u32 = 729;
pub const F_TEXT_INET: u32 = 730;
pub const F_TEXT_LT: u32 = 740;
pub const F_TEXT_LE: u32 = 741;
pub const F_TEXT_GT: u32 = 742;
pub const F_TEXT_GE: u32 = 743;
pub const F_ARRAY_EQ: u32 = 744;
pub const F_CURRENT_USER: u32 = 745;
pub const F_SESSION_USER: u32 = 746;
pub const F_ARRAY_DIMS: u32 = 747;
pub const F_ARRAY_NDIMS: u32 = 748;
pub const F_OVERLAY_BYTEA_BYTEA_INT4_INT4: u32 = 749;
pub const F_ARRAY_IN: u32 = 750;
pub const F_ARRAY_OUT: u32 = 751;
pub const F_OVERLAY_BYTEA_BYTEA_INT4: u32 = 752;
pub const F_TRUNC_MACADDR: u32 = 753;
pub const F_INT8_INT2: u32 = 754;
pub const F_LO_IMPORT_TEXT: u32 = 764;
pub const F_LO_EXPORT: u32 = 765;
pub const F_INT4INC: u32 = 766;
pub const F_LO_IMPORT_TEXT_OID: Oid = Oid(767);
pub const F_INT4LARGER: u32 = 768;
pub const F_INT4SMALLER: u32 = 769;
pub const F_INT2LARGER: u32 = 770;
pub const F_INT2SMALLER: u32 = 771;
pub const F_HASHVARLENAEXTENDED: u32 = 772;
pub const F_HASHOIDVECTOREXTENDED: u32 = 776;
pub const F_HASH_ACLITEM_EXTENDED: u32 = 777;
pub const F_HASHMACADDREXTENDED: u32 = 778;
pub const F_HASHINETEXTENDED: u32 = 779;
pub const F_HASH_NUMERIC_EXTENDED: u32 = 780;
pub const F_HASHMACADDR8EXTENDED: u32 = 781;
pub const F_HASH_ARRAY_EXTENDED: u32 = 782;
pub const F_DIST_POLYC: u32 = 785;
pub const F_PG_CLIENT_ENCODING: u32 = 810;
pub const F_CURRENT_QUERY: u32 = 817;
pub const F_MACADDR_EQ: u32 = 830;
pub const F_MACADDR_LT: u32 = 831;
pub const F_MACADDR_LE: u32 = 832;
pub const F_MACADDR_GT: u32 = 833;
pub const F_MACADDR_GE: u32 = 834;
pub const F_MACADDR_NE: u32 = 835;
pub const F_MACADDR_CMP: u32 = 836;
pub const F_INT82PL: u32 = 837;
pub const F_INT82MI: u32 = 838;
pub const F_INT82MUL: u32 = 839;
pub const F_INT82DIV: u32 = 840;
pub const F_INT28PL: u32 = 841;
pub const F_BTINT8CMP: u32 = 842;
pub const F_CASH_MUL_FLT4: u32 = 846;
pub const F_CASH_DIV_FLT4: u32 = 847;
pub const F_FLT4_MUL_CASH: u32 = 848;
pub const F_POSITION_TEXT_TEXT: u32 = 849;
pub const F_TEXTLIKE: u32 = 850;
pub const F_TEXTNLIKE: u32 = 851;
pub const F_INT48EQ: u32 = 852;
pub const F_INT48NE: u32 = 853;
pub const F_INT48LT: u32 = 854;
pub const F_INT48GT: u32 = 855;
pub const F_INT48LE: u32 = 856;
pub const F_INT48GE: u32 = 857;
pub const F_NAMELIKE: u32 = 858;
pub const F_NAMENLIKE: u32 = 859;
pub const F_BPCHAR_CHAR: u32 = 860;
pub const F_CURRENT_DATABASE: u32 = 861;
pub const F_INT4_MUL_CASH: u32 = 862;
pub const F_INT2_MUL_CASH: u32 = 863;
pub const F_CASH_MUL_INT4: u32 = 864;
pub const F_CASH_DIV_INT4: u32 = 865;
pub const F_CASH_MUL_INT2: u32 = 866;
pub const F_CASH_DIV_INT2: u32 = 867;
pub const F_STRPOS: u32 = 868;
pub const F_LOWER_TEXT: u32 = 870;
pub const F_UPPER_TEXT: u32 = 871;
pub const F_INITCAP: u32 = 872;
pub const F_LPAD_TEXT_INT4_TEXT: u32 = 873;
pub const F_RPAD_TEXT_INT4_TEXT: u32 = 874;
pub const F_LTRIM_TEXT_TEXT: u32 = 875;
pub const F_RTRIM_TEXT_TEXT: u32 = 876;
pub const F_SUBSTR_TEXT_INT4_INT4: u32 = 877;
pub const F_TRANSLATE: u32 = 878;
pub const F_LPAD_TEXT_INT4: u32 = 879;
pub const F_RPAD_TEXT_INT4: u32 = 880;
pub const F_LTRIM_TEXT: u32 = 881;
pub const F_RTRIM_TEXT: u32 = 882;
pub const F_SUBSTR_TEXT_INT4: u32 = 883;
pub const F_BTRIM_TEXT_TEXT: u32 = 884;
pub const F_BTRIM_TEXT: u32 = 885;
pub const F_CASH_IN: u32 = 886;
pub const F_CASH_OUT: u32 = 887;
pub const F_CASH_EQ: u32 = 888;
pub const F_CASH_NE: u32 = 889;
pub const F_CASH_LT: u32 = 890;
pub const F_CASH_LE: u32 = 891;
pub const F_CASH_GT: u32 = 892;
pub const F_CASH_GE: u32 = 893;
pub const F_CASH_PL: u32 = 894;
pub const F_CASH_MI: u32 = 895;
pub const F_CASH_MUL_FLT8: u32 = 896;
pub const F_CASH_DIV_FLT8: u32 = 897;
pub const F_CASHLARGER: u32 = 898;
pub const F_CASHSMALLER: u32 = 899;
pub const F_INET_IN: u32 = 910;
pub const F_INET_OUT: u32 = 911;
pub const F_FLT8_MUL_CASH: u32 = 919;
pub const F_NETWORK_EQ: u32 = 920;
pub const F_NETWORK_LT: u32 = 921;
pub const F_NETWORK_LE: u32 = 922;
pub const F_NETWORK_GT: u32 = 923;
pub const F_NETWORK_GE: u32 = 924;
pub const F_NETWORK_NE: u32 = 925;
pub const F_NETWORK_CMP: u32 = 926;
pub const F_NETWORK_SUB: u32 = 927;
pub const F_NETWORK_SUBEQ: u32 = 928;
pub const F_NETWORK_SUP: u32 = 929;
pub const F_NETWORK_SUPEQ: u32 = 930;
pub const F_CASH_WORDS: u32 = 935;
pub const F_SUBSTRING_TEXT_INT4_INT4: u32 = 936;
pub const F_SUBSTRING_TEXT_INT4: u32 = 937;
pub const F_GENERATE_SERIES_TIMESTAMP_TIMESTAMP_INTERVAL: u32 = 938;
pub const F_GENERATE_SERIES_TIMESTAMPTZ_TIMESTAMPTZ_INTERVAL: u32 = 939;
pub const F_MOD_INT2_INT2: u32 = 940;
pub const F_MOD_INT4_INT4: u32 = 941;
pub const F_INT28MI: u32 = 942;
pub const F_INT28MUL: u32 = 943;
pub const F_CHAR_TEXT: u32 = 944;
pub const F_INT8MOD: u32 = 945;
pub const F_TEXT_CHAR: u32 = 946;
pub const F_MOD_INT8_INT8: u32 = 947;
pub const F_INT28DIV: u32 = 948;
pub const F_HASHINT8: u32 = 949;
pub const F_LO_OPEN: u32 = 952;
pub const F_LO_CLOSE: u32 = 953;
pub const F_LOREAD: u32 = 954;
pub const F_LOWRITE: u32 = 955;
pub const F_LO_LSEEK: u32 = 956;
pub const F_LO_CREAT: u32 = 957;
pub const F_LO_TELL: u32 = 958;
pub const F_ON_PL: u32 = 959;
pub const F_ON_SL: u32 = 960;
pub const F_CLOSE_PL: u32 = 961;
pub const F_LO_UNLINK: u32 = 964;
pub const F_HASHBPCHAREXTENDED: u32 = 972;
pub const F_PATH_INTER: u32 = 973;
pub const F_AREA_BOX: u32 = 975;
pub const F_WIDTH: u32 = 976;
pub const F_HEIGHT: u32 = 977;
pub const F_BOX_DISTANCE: u32 = 978;
pub const F_AREA_PATH: u32 = 979;
pub const F_BOX_INTERSECT: u32 = 980;
pub const F_DIAGONAL: u32 = 981;
pub const F_PATH_N_LT: u32 = 982;
pub const F_PATH_N_GT: u32 = 983;
pub const F_PATH_N_EQ: u32 = 984;
pub const F_PATH_N_LE: u32 = 985;
pub const F_PATH_N_GE: u32 = 986;
pub const F_PATH_LENGTH: u32 = 987;
pub const F_POINT_NE: u32 = 988;
pub const F_POINT_VERT: u32 = 989;
pub const F_POINT_HORIZ: u32 = 990;
pub const F_POINT_DISTANCE: u32 = 991;
pub const F_SLOPE: u32 = 992;
pub const F_LSEG_POINT_POINT: u32 = 993;
pub const F_LSEG_INTERSECT: u32 = 994;
pub const F_LSEG_PARALLEL: u32 = 995;
pub const F_LSEG_PERP: u32 = 996;
pub const F_LSEG_VERTICAL: u32 = 997;
pub const F_LSEG_HORIZONTAL: u32 = 998;
pub const F_LSEG_EQ: u32 = 999;
pub const F_LO_TRUNCATE: u32 = 1004;
pub const F_TEXTLIKE_SUPPORT: u32 = 1023;
pub const F_TEXTICREGEXEQ_SUPPORT: u32 = 1024;
pub const F_TEXTICLIKE_SUPPORT: u32 = 1025;
pub const F_TIMEZONE_INTERVAL_TIMESTAMPTZ: u32 = 1026;
pub const F_GIST_POINT_COMPRESS: u32 = 1030;
pub const F_ACLITEMIN: u32 = 1031;
pub const F_ACLITEMOUT: u32 = 1032;
pub const F_ACLINSERT: u32 = 1035;
pub const F_ACLREMOVE: u32 = 1036;
pub const F_ACLCONTAINS: u32 = 1037;
pub const F_GETDATABASEENCODING: u32 = 1039;
pub const F_BPCHARIN: u32 = 1044;
pub const F_BPCHAROUT: u32 = 1045;
pub const F_VARCHARIN: u32 = 1046;
pub const F_VARCHAROUT: u32 = 1047;
pub const F_BPCHAREQ: u32 = 1048;
pub const F_BPCHARLT: u32 = 1049;
pub const F_BPCHARLE: u32 = 1050;
pub const F_BPCHARGT: u32 = 1051;
pub const F_BPCHARGE: u32 = 1052;
pub const F_BPCHARNE: u32 = 1053;
pub const F_ACLITEMEQ: u32 = 1062;
pub const F_BPCHAR_LARGER: u32 = 1063;
pub const F_BPCHAR_SMALLER: u32 = 1064;
pub const F_PG_PREPARED_XACT: u32 = 1065;
pub const F_GENERATE_SERIES_INT4_INT4_INT4: u32 = 1066;
pub const F_GENERATE_SERIES_INT4_INT4: u32 = 1067;
pub const F_GENERATE_SERIES_INT8_INT8_INT8: u32 = 1068;
pub const F_GENERATE_SERIES_INT8_INT8: u32 = 1069;
pub const F_BPCHARCMP: u32 = 1078;
pub const F_REGCLASS: u32 = 1079;
pub const F_HASHBPCHAR: u32 = 1080;
pub const F_FORMAT_TYPE: u32 = 1081;
pub const F_DATE_IN: u32 = 1084;
pub const F_DATE_OUT: u32 = 1085;
pub const F_DATE_EQ: u32 = 1086;
pub const F_DATE_LT: u32 = 1087;
pub const F_DATE_LE: u32 = 1088;
pub const F_DATE_GT: u32 = 1089;
pub const F_DATE_GE: u32 = 1090;
pub const F_DATE_NE: u32 = 1091;
pub const F_DATE_CMP: u32 = 1092;
pub const F_TIME_LT: u32 = 1102;
pub const F_TIME_LE: u32 = 1103;
pub const F_TIME_GT: u32 = 1104;
pub const F_TIME_GE: u32 = 1105;
pub const F_TIME_NE: u32 = 1106;
pub const F_TIME_CMP: u32 = 1107;
pub const F_PG_STAT_GET_WAL: u32 = 1136;
pub const F_PG_GET_WAL_REPLAY_PAUSE_STATE: u32 = 1137;
pub const F_DATE_LARGER: u32 = 1138;
pub const F_DATE_SMALLER: u32 = 1139;
pub const F_DATE_MI: u32 = 1140;
pub const F_DATE_PLI: u32 = 1141;
pub const F_DATE_MII: u32 = 1142;
pub const F_TIME_IN: u32 = 1143;
pub const F_TIME_OUT: u32 = 1144;
pub const F_TIME_EQ: u32 = 1145;
pub const F_CIRCLE_ADD_PT: u32 = 1146;
pub const F_CIRCLE_SUB_PT: u32 = 1147;
pub const F_CIRCLE_MUL_PT: u32 = 1148;
pub const F_CIRCLE_DIV_PT: u32 = 1149;
pub const F_TIMESTAMPTZ_IN: u32 = 1150;
pub const F_TIMESTAMPTZ_OUT: u32 = 1151;
pub const F_TIMESTAMPTZ_EQ: u32 = 1152;
pub const F_TIMESTAMPTZ_NE: u32 = 1153;
pub const F_TIMESTAMPTZ_LT: u32 = 1154;
pub const F_TIMESTAMPTZ_LE: u32 = 1155;
pub const F_TIMESTAMPTZ_GE: u32 = 1156;
pub const F_TIMESTAMPTZ_GT: u32 = 1157;
pub const F_TO_TIMESTAMP_FLOAT8: u32 = 1158;
pub const F_TIMEZONE_TEXT_TIMESTAMPTZ: u32 = 1159;
pub const F_INTERVAL_IN: u32 = 1160;
pub const F_INTERVAL_OUT: u32 = 1161;
pub const F_INTERVAL_EQ: u32 = 1162;
pub const F_INTERVAL_NE: u32 = 1163;
pub const F_INTERVAL_LT: u32 = 1164;
pub const F_INTERVAL_LE: u32 = 1165;
pub const F_INTERVAL_GE: u32 = 1166;
pub const F_INTERVAL_GT: u32 = 1167;
pub const F_INTERVAL_UM: u32 = 1168;
pub const F_INTERVAL_PL: u32 = 1169;
pub const F_INTERVAL_MI: u32 = 1170;
pub const F_DATE_PART_TEXT_TIMESTAMPTZ: u32 = 1171;
pub const F_DATE_PART_TEXT_INTERVAL: u32 = 1172;
pub const F_NETWORK_SUBSET_SUPPORT: u32 = 1173;
pub const F_TIMESTAMPTZ_DATE: u32 = 1174;
pub const F_JUSTIFY_HOURS: u32 = 1175;
pub const F_TIMESTAMPTZ_DATE_TIME: u32 = 1176;
pub const F_JSONB_PATH_EXISTS_TZ: u32 = 1177;
pub const F_DATE_TIMESTAMPTZ: u32 = 1178;
pub const F_JSONB_PATH_QUERY_TZ: u32 = 1179;
pub const F_JSONB_PATH_QUERY_ARRAY_TZ: u32 = 1180;
pub const F_AGE_XID: u32 = 1181;
pub const F_TIMESTAMPTZ_MI: u32 = 1188;
pub const F_TIMESTAMPTZ_PL_INTERVAL: u32 = 1189;
pub const F_TIMESTAMPTZ_MI_INTERVAL: u32 = 1190;
pub const F_GENERATE_SUBSCRIPTS_ANYARRAY_INT4_BOOL: u32 = 1191;
pub const F_GENERATE_SUBSCRIPTS_ANYARRAY_INT4: u32 = 1192;
pub const F_ARRAY_FILL_ANYELEMENT__INT4: u32 = 1193;
pub const F_LOG10_FLOAT8: u32 = 1194;
pub const F_TIMESTAMPTZ_SMALLER: u32 = 1195;
pub const F_TIMESTAMPTZ_LARGER: u32 = 1196;
pub const F_INTERVAL_SMALLER: u32 = 1197;
pub const F_INTERVAL_LARGER: u32 = 1198;
pub const F_AGE_TIMESTAMPTZ_TIMESTAMPTZ: u32 = 1199;
pub const F_INTERVAL_INTERVAL_INT4: u32 = 1200;
pub const F_OBJ_DESCRIPTION_OID_NAME: u32 = 1215;
pub const F_COL_DESCRIPTION: u32 = 1216;
pub const F_DATE_TRUNC_TEXT_TIMESTAMPTZ: u32 = 1217;
pub const F_DATE_TRUNC_TEXT_INTERVAL: u32 = 1218;
pub const F_INT8INC: u32 = 1219;
pub const F_INT8ABS: u32 = 1230;
pub const F_INT8LARGER: u32 = 1236;
pub const F_INT8SMALLER: u32 = 1237;
pub const F_TEXTICREGEXEQ: u32 = 1238;
pub const F_TEXTICREGEXNE: u32 = 1239;
pub const F_NAMEICREGEXEQ: u32 = 1240;
pub const F_NAMEICREGEXNE: u32 = 1241;
pub const F_BOOLIN: u32 = 1242;
pub const F_BOOLOUT: u32 = 1243;
pub const F_BYTEAIN: u32 = 1244;
pub const F_CHARIN: u32 = 1245;
pub const F_CHARLT: u32 = 1246;
pub const F_UNIQUE_KEY_RECHECK: u32 = 1250;
pub const F_INT4ABS: u32 = 1251;
pub const F_NAMEREGEXNE: u32 = 1252;
pub const F_INT2ABS: u32 = 1253;
pub const F_TEXTREGEXEQ: u32 = 1254;
pub const F_TEXTREGEXNE: u32 = 1256;
pub const F_TEXTLEN: u32 = 1257;
pub const F_TEXTCAT: u32 = 1258;
pub const F_PG_CHAR_TO_ENCODING: u32 = 1264;
pub const F_TIDNE: u32 = 1265;
pub const F_CIDR_IN: u32 = 1267;
pub const F_PARSE_IDENT: u32 = 1268;
pub const F_PG_COLUMN_SIZE: u32 = 1269;
pub const F_OVERLAPS_TIMETZ_TIMETZ_TIMETZ_TIMETZ: u32 = 1271;
pub const F_DATETIME_PL: u32 = 1272;
pub const F_DATE_PART_TEXT_TIMETZ: u32 = 1273;
pub const F_INT84PL: u32 = 1274;
pub const F_INT84MI: u32 = 1275;
pub const F_INT84MUL: u32 = 1276;
pub const F_INT84DIV: u32 = 1277;
pub const F_INT48PL: u32 = 1278;
pub const F_INT48MI: u32 = 1279;
pub const F_INT48MUL: u32 = 1280;
pub const F_INT48DIV: u32 = 1281;
pub const F_QUOTE_IDENT: u32 = 1282;
pub const F_QUOTE_LITERAL_TEXT: u32 = 1283;
pub const F_DATE_TRUNC_TEXT_TIMESTAMPTZ_TEXT: u32 = 1284;
pub const F_QUOTE_LITERAL_ANYELEMENT: u32 = 1285;
pub const F_ARRAY_FILL_ANYELEMENT__INT4__INT4: u32 = 1286;
pub const F_OID: Oid = Oid(1287);
pub const F_INT8_OID: Oid = Oid(1288);
pub const F_QUOTE_NULLABLE_TEXT: u32 = 1289;
pub const F_QUOTE_NULLABLE_ANYELEMENT: u32 = 1290;
pub const F_SUPPRESS_REDUNDANT_UPDATES_TRIGGER: u32 = 1291;
pub const F_TIDEQ: u32 = 1292;
pub const F_UNNEST_ANYMULTIRANGE: u32 = 1293;
pub const F_CURRTID2: u32 = 1294;
pub const F_JUSTIFY_DAYS: u32 = 1295;
pub const F_TIMEDATE_PL: u32 = 1296;
pub const F_DATETIMETZ_PL: u32 = 1297;
pub const F_TIMETZDATE_PL: u32 = 1298;
pub const F_NOW: u32 = 1299;
pub const F_POSITIONSEL: u32 = 1300;
pub const F_POSITIONJOINSEL: u32 = 1301;
pub const F_CONTSEL: u32 = 1302;
pub const F_CONTJOINSEL: u32 = 1303;
pub const F_OVERLAPS_TIMESTAMPTZ_TIMESTAMPTZ_TIMESTAMPTZ_TIMESTAMPTZ: u32 = 1304;
pub const F_OVERLAPS_TIMESTAMPTZ_INTERVAL_TIMESTAMPTZ_INTERVAL: u32 = 1305;
pub const F_OVERLAPS_TIMESTAMPTZ_TIMESTAMPTZ_TIMESTAMPTZ_INTERVAL: u32 = 1306;
pub const F_OVERLAPS_TIMESTAMPTZ_INTERVAL_TIMESTAMPTZ_TIMESTAMPTZ: u32 = 1307;
pub const F_OVERLAPS_TIME_TIME_TIME_TIME: u32 = 1308;
pub const F_OVERLAPS_TIME_INTERVAL_TIME_INTERVAL: u32 = 1309;
pub const F_OVERLAPS_TIME_TIME_TIME_INTERVAL: u32 = 1310;
pub const F_OVERLAPS_TIME_INTERVAL_TIME_TIME: u32 = 1311;
pub const F_TIMESTAMP_IN: u32 = 1312;
pub const F_TIMESTAMP_OUT: u32 = 1313;
pub const F_TIMESTAMPTZ_CMP: u32 = 1314;
pub const F_INTERVAL_CMP: u32 = 1315;
pub const F_TIME_TIMESTAMP: u32 = 1316;
pub const F_LENGTH_TEXT: u32 = 1317;
pub const F_LENGTH_BPCHAR: u32 = 1318;
pub const F_XIDEQINT4: u32 = 1319;
pub const F_INTERVAL_DIV: u32 = 1326;
pub const F_DLOG10: u32 = 1339;
pub const F_LOG_FLOAT8: u32 = 1340;
pub const F_LN_FLOAT8: u32 = 1341;
pub const F_ROUND_FLOAT8: u32 = 1342;
pub const F_TRUNC_FLOAT8: u32 = 1343;
pub const F_SQRT_FLOAT8: u32 = 1344;
pub const F_CBRT: u32 = 1345;
pub const F_POW_FLOAT8_FLOAT8: u32 = 1346;
pub const F_EXP_FLOAT8: u32 = 1347;
pub const F_OBJ_DESCRIPTION_OID: Oid = Oid(1348);
pub const F_OIDVECTORTYPES: u32 = 1349;
pub const F_TIMETZ_IN: u32 = 1350;
pub const F_TIMETZ_OUT: u32 = 1351;
pub const F_TIMETZ_EQ: u32 = 1352;
pub const F_TIMETZ_NE: u32 = 1353;
pub const F_TIMETZ_LT: u32 = 1354;
pub const F_TIMETZ_LE: u32 = 1355;
pub const F_TIMETZ_GE: u32 = 1356;
pub const F_TIMETZ_GT: u32 = 1357;
pub const F_TIMETZ_CMP: u32 = 1358;
pub const F_TIMESTAMPTZ_DATE_TIMETZ: u32 = 1359;
pub const F_HOSTMASK: u32 = 1362;
pub const F_TEXTREGEXEQ_SUPPORT: u32 = 1364;
pub const F_MAKEACLITEM: u32 = 1365;
pub const F_CHARACTER_LENGTH_BPCHAR: u32 = 1367;
pub const F_POWER_FLOAT8_FLOAT8: u32 = 1368;
pub const F_CHARACTER_LENGTH_TEXT: u32 = 1369;
pub const F_INTERVAL_TIME: u32 = 1370;
pub const F_PG_LOCK_STATUS: u32 = 1371;
pub const F_CHAR_LENGTH_BPCHAR: u32 = 1372;
pub const F_ISFINITE_DATE: u32 = 1373;
pub const F_OCTET_LENGTH_TEXT: u32 = 1374;
pub const F_OCTET_LENGTH_BPCHAR: u32 = 1375;
pub const F_FACTORIAL: u32 = 1376;
pub const F_TIME_LARGER: u32 = 1377;
pub const F_TIME_SMALLER: u32 = 1378;
pub const F_TIMETZ_LARGER: u32 = 1379;
pub const F_TIMETZ_SMALLER: u32 = 1380;
pub const F_CHAR_LENGTH_TEXT: u32 = 1381;
pub const F_DATE_PART_TEXT_DATE: u32 = 1384;
pub const F_DATE_PART_TEXT_TIME: u32 = 1385;
pub const F_AGE_TIMESTAMPTZ: u32 = 1386;
pub const F_PG_GET_CONSTRAINTDEF_OID: Oid = Oid(1387);
pub const F_TIMETZ_TIMESTAMPTZ: u32 = 1388;
pub const F_ISFINITE_TIMESTAMPTZ: u32 = 1389;
pub const F_ISFINITE_INTERVAL: u32 = 1390;
pub const F_PG_STAT_GET_BACKEND_START: u32 = 1391;
pub const F_PG_STAT_GET_BACKEND_CLIENT_ADDR: u32 = 1392;
pub const F_PG_STAT_GET_BACKEND_CLIENT_PORT: u32 = 1393;
pub const F_ABS_FLOAT4: u32 = 1394;
pub const F_ABS_FLOAT8: u32 = 1395;
pub const F_ABS_INT8: u32 = 1396;
pub const F_ABS_INT4: u32 = 1397;
pub const F_ABS_INT2: u32 = 1398;
pub const F_NAME_VARCHAR: u32 = 1400;
pub const F_VARCHAR_NAME: u32 = 1401;
pub const F_CURRENT_SCHEMA: u32 = 1402;
pub const F_CURRENT_SCHEMAS: u32 = 1403;
pub const F_OVERLAY_TEXT_TEXT_INT4_INT4: u32 = 1404;
pub const F_OVERLAY_TEXT_TEXT_INT4: u32 = 1405;
pub const F_ISVERTICAL_POINT_POINT: u32 = 1406;
pub const F_ISHORIZONTAL_POINT_POINT: u32 = 1407;
pub const F_ISPARALLEL_LSEG_LSEG: u32 = 1408;
pub const F_ISPERP_LSEG_LSEG: u32 = 1409;
pub const F_ISVERTICAL_LSEG: u32 = 1410;
pub const F_ISHORIZONTAL_LSEG: u32 = 1411;
pub const F_ISPARALLEL_LINE_LINE: u32 = 1412;
pub const F_ISPERP_LINE_LINE: u32 = 1413;
pub const F_ISVERTICAL_LINE: u32 = 1414;
pub const F_ISHORIZONTAL_LINE: u32 = 1415;
pub const F_POINT_CIRCLE: u32 = 1416;
pub const F_TIME_INTERVAL: u32 = 1419;
pub const F_BOX_POINT_POINT: u32 = 1421;
pub const F_BOX_ADD: u32 = 1422;
pub const F_BOX_SUB: u32 = 1423;
pub const F_BOX_MUL: u32 = 1424;
pub const F_BOX_DIV: u32 = 1425;
pub const F_PATH_CONTAIN_PT: u32 = 1426;
pub const F_CIDR_OUT: u32 = 1427;
pub const F_POLY_CONTAIN_PT: u32 = 1428;
pub const F_PT_CONTAINED_POLY: u32 = 1429;
pub const F_ISCLOSED: u32 = 1430;
pub const F_ISOPEN: u32 = 1431;
pub const F_PATH_NPOINTS: u32 = 1432;
pub const F_PCLOSE: u32 = 1433;
pub const F_POPEN: u32 = 1434;
pub const F_PATH_ADD: u32 = 1435;
pub const F_PATH_ADD_PT: u32 = 1436;
pub const F_PATH_SUB_PT: u32 = 1437;
pub const F_PATH_MUL_PT: u32 = 1438;
pub const F_PATH_DIV_PT: u32 = 1439;
pub const F_POINT_FLOAT8_FLOAT8: u32 = 1440;
pub const F_POINT_ADD: u32 = 1441;
pub const F_POINT_SUB: u32 = 1442;
pub const F_POINT_MUL: u32 = 1443;
pub const F_POINT_DIV: u32 = 1444;
pub const F_POLY_NPOINTS: u32 = 1445;
pub const F_BOX_POLYGON: u32 = 1446;
pub const F_PATH: u32 = 1447;
pub const F_POLYGON_BOX: u32 = 1448;
pub const F_POLYGON_PATH: u32 = 1449;
pub const F_CIRCLE_IN: u32 = 1450;
pub const F_CIRCLE_OUT: u32 = 1451;
pub const F_CIRCLE_SAME: u32 = 1452;
pub const F_CIRCLE_CONTAIN: u32 = 1453;
pub const F_CIRCLE_LEFT: u32 = 1454;
pub const F_CIRCLE_OVERLEFT: u32 = 1455;
pub const F_CIRCLE_OVERRIGHT: u32 = 1456;
pub const F_CIRCLE_RIGHT: u32 = 1457;
pub const F_CIRCLE_CONTAINED: u32 = 1458;
pub const F_CIRCLE_OVERLAP: u32 = 1459;
pub const F_CIRCLE_BELOW: u32 = 1460;
pub const F_CIRCLE_ABOVE: u32 = 1461;
pub const F_CIRCLE_EQ: u32 = 1462;
pub const F_CIRCLE_NE: u32 = 1463;
pub const F_CIRCLE_LT: u32 = 1464;
pub const F_CIRCLE_GT: u32 = 1465;
pub const F_CIRCLE_LE: u32 = 1466;
pub const F_CIRCLE_GE: u32 = 1467;
pub const F_AREA_CIRCLE: u32 = 1468;
pub const F_DIAMETER: u32 = 1469;
pub const F_RADIUS: u32 = 1470;
pub const F_CIRCLE_DISTANCE: u32 = 1471;
pub const F_CIRCLE_CENTER: u32 = 1472;
pub const F_CIRCLE_POINT_FLOAT8: u32 = 1473;
pub const F_CIRCLE_POLYGON: u32 = 1474;
pub const F_POLYGON_INT4_CIRCLE: u32 = 1475;
pub const F_DIST_PC: u32 = 1476;
pub const F_CIRCLE_CONTAIN_PT: u32 = 1477;
pub const F_PT_CONTAINED_CIRCLE: u32 = 1478;
pub const F_CIRCLE_BOX: u32 = 1479;
pub const F_BOX_CIRCLE: u32 = 1480;
pub const F_LOG10_NUMERIC: u32 = 1481;
pub const F_LSEG_NE: u32 = 1482;
pub const F_LSEG_LT: u32 = 1483;
pub const F_LSEG_LE: u32 = 1484;
pub const F_LSEG_GT: u32 = 1485;
pub const F_LSEG_GE: u32 = 1486;
pub const F_LSEG_LENGTH: u32 = 1487;
pub const F_CLOSE_LS: u32 = 1488;
pub const F_CLOSE_LSEG: u32 = 1489;
pub const F_LINE_IN: u32 = 1490;
pub const F_LINE_OUT: u32 = 1491;
pub const F_LINE_EQ: u32 = 1492;
pub const F_LINE: u32 = 1493;
pub const F_LINE_INTERPT: u32 = 1494;
pub const F_LINE_INTERSECT: u32 = 1495;
pub const F_LINE_PARALLEL: u32 = 1496;
pub const F_LINE_PERP: u32 = 1497;
pub const F_LINE_VERTICAL: u32 = 1498;
pub const F_LINE_HORIZONTAL: u32 = 1499;
pub const F_LENGTH_LSEG: u32 = 1530;
pub const F_LENGTH_PATH: u32 = 1531;
pub const F_POINT_LSEG: u32 = 1532;
pub const F_POINT_BOX: u32 = 1534;
pub const F_POINT_POLYGON: u32 = 1540;
pub const F_LSEG_BOX: u32 = 1541;
pub const F_CENTER_BOX: u32 = 1542;
pub const F_CENTER_CIRCLE: u32 = 1543;
pub const F_POLYGON_CIRCLE: u32 = 1544;
pub const F_NPOINTS_PATH: u32 = 1545;
pub const F_NPOINTS_POLYGON: u32 = 1556;
pub const F_BIT_IN: u32 = 1564;
pub const F_BIT_OUT: u32 = 1565;
pub const F_LIKE_TEXT_TEXT: u32 = 1569;
pub const F_NOTLIKE_TEXT_TEXT: u32 = 1570;
pub const F_LIKE_NAME_TEXT: u32 = 1571;
pub const F_NOTLIKE_NAME_TEXT: u32 = 1572;
pub const F_PG_GET_RULEDEF_OID: Oid = Oid(1573);
pub const F_NEXTVAL: u32 = 1574;
pub const F_CURRVAL: u32 = 1575;
pub const F_SETVAL_REGCLASS_INT8: u32 = 1576;
pub const F_VARBIT_IN: u32 = 1579;
pub const F_VARBIT_OUT: u32 = 1580;
pub const F_BITEQ: u32 = 1581;
pub const F_BITNE: u32 = 1582;
pub const F_BITGE: u32 = 1592;
pub const F_BITGT: u32 = 1593;
pub const F_BITLE: u32 = 1594;
pub const F_BITLT: u32 = 1595;
pub const F_BITCMP: u32 = 1596;
pub const F_PG_ENCODING_TO_CHAR: u32 = 1597;
pub const F_RANDOM_: u32 = 1598;
pub const F_SETSEED: u32 = 1599;
pub const F_ASIN: u32 = 1600;
pub const F_ACOS: u32 = 1601;
pub const F_ATAN: u32 = 1602;
pub const F_ATAN2: u32 = 1603;
pub const F_SIN: u32 = 1604;
pub const F_COS: u32 = 1605;
pub const F_TAN: u32 = 1606;
pub const F_COT: u32 = 1607;
pub const F_DEGREES: u32 = 1608;
pub const F_RADIANS: u32 = 1609;
pub const F_PI: u32 = 1610;
pub const F_INTERVAL_MUL: u32 = 1618;
pub const F_PG_TYPEOF: u32 = 1619;
pub const F_ASCII: u32 = 1620;
pub const F_CHR: u32 = 1621;
pub const F_REPEAT: u32 = 1622;
pub const F_SIMILAR_ESCAPE: u32 = 1623;
pub const F_MUL_D_INTERVAL: u32 = 1624;
pub const F_BPCHARLIKE: u32 = 1631;
pub const F_BPCHARNLIKE: u32 = 1632;
pub const F_TEXTICLIKE: u32 = 1633;
pub const F_TEXTICNLIKE: u32 = 1634;
pub const F_NAMEICLIKE: u32 = 1635;
pub const F_NAMEICNLIKE: u32 = 1636;
pub const F_LIKE_ESCAPE_TEXT_TEXT: u32 = 1637;
pub const F_OIDGT: u32 = 1638;
pub const F_OIDGE: u32 = 1639;
pub const F_PG_GET_VIEWDEF_TEXT: u32 = 1640;
pub const F_PG_GET_VIEWDEF_OID: Oid = Oid(1641);
pub const F_PG_GET_USERBYID: u32 = 1642;
pub const F_PG_GET_INDEXDEF_OID: Oid = Oid(1643);
pub const F_RI_FKEY_CHECK_INS: u32 = 1644;
pub const F_RI_FKEY_CHECK_UPD: u32 = 1645;
pub const F_RI_FKEY_CASCADE_DEL: u32 = 1646;
pub const F_RI_FKEY_CASCADE_UPD: u32 = 1647;
pub const F_RI_FKEY_RESTRICT_DEL: u32 = 1648;
pub const F_RI_FKEY_RESTRICT_UPD: u32 = 1649;
pub const F_RI_FKEY_SETNULL_DEL: u32 = 1650;
pub const F_RI_FKEY_SETNULL_UPD: u32 = 1651;
pub const F_RI_FKEY_SETDEFAULT_DEL: u32 = 1652;
pub const F_RI_FKEY_SETDEFAULT_UPD: u32 = 1653;
pub const F_RI_FKEY_NOACTION_DEL: u32 = 1654;
pub const F_RI_FKEY_NOACTION_UPD: u32 = 1655;
pub const F_BPCHARICREGEXEQ: u32 = 1656;
pub const F_BPCHARICREGEXNE: u32 = 1657;
pub const F_BPCHARREGEXEQ: u32 = 1658;
pub const F_BPCHARREGEXNE: u32 = 1659;
pub const F_BPCHARICLIKE: u32 = 1660;
pub const F_BPCHARICNLIKE: u32 = 1661;
pub const F_PG_GET_TRIGGERDEF_OID: Oid = Oid(1662);
pub const F_PG_GET_SERIAL_SEQUENCE: u32 = 1665;
pub const F_VARBITEQ: u32 = 1666;
pub const F_VARBITNE: u32 = 1667;
pub const F_VARBITGE: u32 = 1668;
pub const F_VARBITGT: u32 = 1669;
pub const F_VARBITLE: u32 = 1670;
pub const F_VARBITLT: u32 = 1671;
pub const F_VARBITCMP: u32 = 1672;
pub const F_BITAND: u32 = 1673;
pub const F_BITOR: u32 = 1674;
pub const F_BITXOR: u32 = 1675;
pub const F_BITNOT: u32 = 1676;
pub const F_BITSHIFTLEFT: u32 = 1677;
pub const F_BITSHIFTRIGHT: u32 = 1678;
pub const F_BITCAT: u32 = 1679;
pub const F_SUBSTRING_BIT_INT4_INT4: u32 = 1680;
pub const F_LENGTH_BIT: u32 = 1681;
pub const F_OCTET_LENGTH_BIT: u32 = 1682;
pub const F_BIT_INT4_INT4: u32 = 1683;
pub const F_INT4_BIT: u32 = 1684;
pub const F_BIT_BIT_INT4_BOOL: u32 = 1685;
pub const F_PG_GET_KEYWORDS: u32 = 1686;
pub const F_VARBIT: u32 = 1687;
pub const F_TIME_HASH: u32 = 1688;
pub const F_ACLEXPLODE: u32 = 1689;
pub const F_TIME_MI_TIME: u32 = 1690;
pub const F_BOOLLE: u32 = 1691;
pub const F_BOOLGE: u32 = 1692;
pub const F_BTBOOLCMP: u32 = 1693;
pub const F_TIMETZ_HASH: u32 = 1696;
pub const F_INTERVAL_HASH: u32 = 1697;
pub const F_POSITION_BIT_BIT: u32 = 1698;
pub const F_SUBSTRING_BIT_INT4: u32 = 1699;
pub const F_NUMERIC_IN: u32 = 1701;
pub const F_NUMERIC_OUT: u32 = 1702;
pub const F_NUMERIC_NUMERIC_INT4: u32 = 1703;
pub const F_NUMERIC_ABS: u32 = 1704;
pub const F_ABS_NUMERIC: u32 = 1705;
pub const F_SIGN_NUMERIC: u32 = 1706;
pub const F_ROUND_NUMERIC_INT4: u32 = 1707;
pub const F_ROUND_NUMERIC: u32 = 1708;
pub const F_TRUNC_NUMERIC_INT4: u32 = 1709;
pub const F_TRUNC_NUMERIC: u32 = 1710;
pub const F_CEIL_NUMERIC: u32 = 1711;
pub const F_FLOOR_NUMERIC: u32 = 1712;
pub const F_LENGTH_BYTEA_NAME: u32 = 1713;
pub const F_CONVERT_FROM: u32 = 1714;
pub const F_CIDR: u32 = 1715;
pub const F_PG_GET_EXPR_PG_NODE_TREE_OID: Oid = Oid(1716);
pub const F_CONVERT_TO: u32 = 1717;
pub const F_NUMERIC_EQ: u32 = 1718;
pub const F_NUMERIC_NE: u32 = 1719;
pub const F_NUMERIC_GT: u32 = 1720;
pub const F_NUMERIC_GE: u32 = 1721;
pub const F_NUMERIC_LT: u32 = 1722;
pub const F_NUMERIC_LE: u32 = 1723;
pub const F_NUMERIC_ADD: u32 = 1724;
pub const F_NUMERIC_SUB: u32 = 1725;
pub const F_NUMERIC_MUL: u32 = 1726;
pub const F_NUMERIC_DIV: u32 = 1727;
pub const F_MOD_NUMERIC_NUMERIC: u32 = 1728;
pub const F_NUMERIC_MOD: u32 = 1729;
pub const F_SQRT_NUMERIC: u32 = 1730;
pub const F_NUMERIC_SQRT: u32 = 1731;
pub const F_EXP_NUMERIC: u32 = 1732;
pub const F_NUMERIC_EXP: u32 = 1733;
pub const F_LN_NUMERIC: u32 = 1734;
pub const F_NUMERIC_LN: u32 = 1735;
pub const F_LOG_NUMERIC_NUMERIC: u32 = 1736;
pub const F_NUMERIC_LOG: u32 = 1737;
pub const F_POW_NUMERIC_NUMERIC: u32 = 1738;
pub const F_NUMERIC_POWER: u32 = 1739;
pub const F_NUMERIC_INT4: u32 = 1740;
pub const F_LOG_NUMERIC: u32 = 1741;
pub const F_NUMERIC_FLOAT4: u32 = 1742;
pub const F_NUMERIC_FLOAT8: u32 = 1743;
pub const F_INT4_NUMERIC: u32 = 1744;
pub const F_FLOAT4_NUMERIC: u32 = 1745;
pub const F_FLOAT8_NUMERIC: u32 = 1746;
pub const F_TIME_PL_INTERVAL: u32 = 1747;
pub const F_TIME_MI_INTERVAL: u32 = 1748;
pub const F_TIMETZ_PL_INTERVAL: u32 = 1749;
pub const F_TIMETZ_MI_INTERVAL: u32 = 1750;
pub const F_NUMERIC_INC: u32 = 1764;
pub const F_SETVAL_REGCLASS_INT8_BOOL: u32 = 1765;
pub const F_NUMERIC_SMALLER: u32 = 1766;
pub const F_NUMERIC_LARGER: u32 = 1767;
pub const F_TO_CHAR_INTERVAL_TEXT: u32 = 1768;
pub const F_NUMERIC_CMP: u32 = 1769;
pub const F_TO_CHAR_TIMESTAMPTZ_TEXT: u32 = 1770;
pub const F_NUMERIC_UMINUS: u32 = 1771;
pub const F_TO_CHAR_NUMERIC_TEXT: u32 = 1772;
pub const F_TO_CHAR_INT4_TEXT: u32 = 1773;
pub const F_TO_CHAR_INT8_TEXT: u32 = 1774;
pub const F_TO_CHAR_FLOAT4_TEXT: u32 = 1775;
pub const F_TO_CHAR_FLOAT8_TEXT: u32 = 1776;
pub const F_TO_NUMBER: u32 = 1777;
pub const F_TO_TIMESTAMP_TEXT_TEXT: u32 = 1778;
pub const F_INT8_NUMERIC: u32 = 1779;
pub const F_TO_DATE: u32 = 1780;
pub const F_NUMERIC_INT8: u32 = 1781;
pub const F_NUMERIC_INT2: u32 = 1782;
pub const F_INT2_NUMERIC: u32 = 1783;
pub const F_OIDIN: u32 = 1798;
pub const F_OIDOUT: u32 = 1799;
pub const F_BIT_LENGTH_BYTEA: u32 = 1810;
pub const F_BIT_LENGTH_TEXT: u32 = 1811;
pub const F_BIT_LENGTH_BIT: u32 = 1812;
pub const F_CONVERT: u32 = 1813;
pub const F_ICLIKESEL: u32 = 1814;
pub const F_ICNLIKESEL: u32 = 1815;
pub const F_ICLIKEJOINSEL: u32 = 1816;
pub const F_ICNLIKEJOINSEL: u32 = 1817;
pub const F_REGEXEQSEL: u32 = 1818;
pub const F_LIKESEL: u32 = 1819;
pub const F_ICREGEXEQSEL: u32 = 1820;
pub const F_REGEXNESEL: u32 = 1821;
pub const F_NLIKESEL: u32 = 1822;
pub const F_ICREGEXNESEL: u32 = 1823;
pub const F_REGEXEQJOINSEL: u32 = 1824;
pub const F_LIKEJOINSEL: u32 = 1825;
pub const F_ICREGEXEQJOINSEL: u32 = 1826;
pub const F_REGEXNEJOINSEL: u32 = 1827;
pub const F_NLIKEJOINSEL: u32 = 1828;
pub const F_ICREGEXNEJOINSEL: u32 = 1829;
pub const F_FLOAT8_AVG: u32 = 1830;
pub const F_FLOAT8_VAR_SAMP: u32 = 1831;
pub const F_FLOAT8_STDDEV_SAMP: u32 = 1832;
pub const F_NUMERIC_ACCUM: u32 = 1833;
pub const F_INT2_ACCUM: u32 = 1834;
pub const F_INT4_ACCUM: u32 = 1835;
pub const F_INT8_ACCUM: u32 = 1836;
pub const F_NUMERIC_AVG: u32 = 1837;
pub const F_NUMERIC_VAR_SAMP: u32 = 1838;
pub const F_NUMERIC_STDDEV_SAMP: u32 = 1839;
pub const F_INT2_SUM: u32 = 1840;
pub const F_INT4_SUM: u32 = 1841;
pub const F_INT8_SUM: u32 = 1842;
pub const F_INTERVAL_AVG_ACCUM: u32 = 1843;
pub const F_INTERVAL_AVG: u32 = 1844;
pub const F_TO_ASCII_TEXT: u32 = 1845;
pub const F_TO_ASCII_TEXT_INT4: u32 = 1846;
pub const F_TO_ASCII_TEXT_NAME: u32 = 1847;
pub const F_INTERVAL_PL_TIME: u32 = 1848;
pub const F_INT28EQ: u32 = 1850;
pub const F_INT28NE: u32 = 1851;
pub const F_INT28LT: u32 = 1852;
pub const F_INT28GT: u32 = 1853;
pub const F_INT28LE: u32 = 1854;
pub const F_INT28GE: u32 = 1855;
pub const F_INT82EQ: u32 = 1856;
pub const F_INT82NE: u32 = 1857;
pub const F_INT82LT: u32 = 1858;
pub const F_INT82GT: u32 = 1859;
pub const F_INT82LE: u32 = 1860;
pub const F_INT82GE: u32 = 1861;
pub const F_INT2AND: u32 = 1892;
pub const F_INT2OR: u32 = 1893;
pub const F_INT2XOR: u32 = 1894;
pub const F_INT2NOT: u32 = 1895;
pub const F_INT2SHL: u32 = 1896;
pub const F_INT2SHR: u32 = 1897;
pub const F_INT4AND: u32 = 1898;
pub const F_INT4OR: u32 = 1899;
pub const F_INT4XOR: u32 = 1900;
pub const F_INT4NOT: u32 = 1901;
pub const F_INT4SHL: u32 = 1902;
pub const F_INT4SHR: u32 = 1903;
pub const F_INT8AND: u32 = 1904;
pub const F_INT8OR: u32 = 1905;
pub const F_INT8XOR: u32 = 1906;
pub const F_INT8NOT: u32 = 1907;
pub const F_INT8SHL: u32 = 1908;
pub const F_INT8SHR: u32 = 1909;
pub const F_INT8UP: u32 = 1910;
pub const F_INT2UP: u32 = 1911;
pub const F_INT4UP: u32 = 1912;
pub const F_FLOAT4UP: u32 = 1913;
pub const F_FLOAT8UP: u32 = 1914;
pub const F_NUMERIC_UPLUS: u32 = 1915;
pub const F_HAS_TABLE_PRIVILEGE_NAME_TEXT_TEXT: u32 = 1922;
pub const F_HAS_TABLE_PRIVILEGE_NAME_OID_TEXT: u32 = 1923;
pub const F_HAS_TABLE_PRIVILEGE_OID_TEXT_TEXT: u32 = 1924;
pub const F_HAS_TABLE_PRIVILEGE_OID_OID_TEXT: u32 = 1925;
pub const F_HAS_TABLE_PRIVILEGE_TEXT_TEXT: u32 = 1926;
pub const F_HAS_TABLE_PRIVILEGE_OID_TEXT: u32 = 1927;
pub const F_PG_STAT_GET_NUMSCANS: u32 = 1928;
pub const F_PG_STAT_GET_TUPLES_RETURNED: u32 = 1929;
pub const F_PG_STAT_GET_TUPLES_FETCHED: u32 = 1930;
pub const F_PG_STAT_GET_TUPLES_INSERTED: u32 = 1931;
pub const F_PG_STAT_GET_TUPLES_UPDATED: u32 = 1932;
pub const F_PG_STAT_GET_TUPLES_DELETED: u32 = 1933;
pub const F_PG_STAT_GET_BLOCKS_FETCHED: u32 = 1934;
pub const F_PG_STAT_GET_BLOCKS_HIT: u32 = 1935;
pub const F_PG_STAT_GET_BACKEND_IDSET: u32 = 1936;
pub const F_PG_STAT_GET_BACKEND_PID: u32 = 1937;
pub const F_PG_STAT_GET_BACKEND_DBID: u32 = 1938;
pub const F_PG_STAT_GET_BACKEND_USERID: u32 = 1939;
pub const F_PG_STAT_GET_BACKEND_ACTIVITY: u32 = 1940;
pub const F_PG_STAT_GET_DB_NUMBACKENDS: u32 = 1941;
pub const F_PG_STAT_GET_DB_XACT_COMMIT: u32 = 1942;
pub const F_PG_STAT_GET_DB_XACT_ROLLBACK: u32 = 1943;
pub const F_PG_STAT_GET_DB_BLOCKS_FETCHED: u32 = 1944;
pub const F_PG_STAT_GET_DB_BLOCKS_HIT: u32 = 1945;
pub const F_ENCODE: u32 = 1946;
pub const F_DECODE: u32 = 1947;
pub const F_BYTEAEQ: u32 = 1948;
pub const F_BYTEALT: u32 = 1949;
pub const F_BYTEALE: u32 = 1950;
pub const F_BYTEAGT: u32 = 1951;
pub const F_BYTEAGE: u32 = 1952;
pub const F_BYTEANE: u32 = 1953;
pub const F_BYTEACMP: u32 = 1954;
pub const F_TIMESTAMP_TIMESTAMP_INT4: u32 = 1961;
pub const F_INT2_AVG_ACCUM: u32 = 1962;
pub const F_INT4_AVG_ACCUM: u32 = 1963;
pub const F_INT8_AVG: u32 = 1964;
pub const F_OIDLARGER: u32 = 1965;
pub const F_OIDSMALLER: u32 = 1966;
pub const F_TIMESTAMPTZ_TIMESTAMPTZ_INT4: u32 = 1967;
pub const F_TIME_TIME_INT4: u32 = 1968;
pub const F_TIMETZ_TIMETZ_INT4: u32 = 1969;
pub const F_PG_STAT_GET_TUPLES_HOT_UPDATED: u32 = 1972;
pub const F_DIV: u32 = 1973;
pub const F_NUMERIC_DIV_TRUNC: u32 = 1980;
pub const F_SIMILAR_TO_ESCAPE_TEXT_TEXT: u32 = 1986;
pub const F_SIMILAR_TO_ESCAPE_TEXT: u32 = 1987;
pub const F_SHOBJ_DESCRIPTION: u32 = 1993;
pub const F_TEXTANYCAT: u32 = 2003;
pub const F_ANYTEXTCAT: u32 = 2004;
pub const F_BYTEALIKE: u32 = 2005;
pub const F_BYTEANLIKE: u32 = 2006;
pub const F_LIKE_BYTEA_BYTEA: u32 = 2007;
pub const F_NOTLIKE_BYTEA_BYTEA: u32 = 2008;
pub const F_LIKE_ESCAPE_BYTEA_BYTEA: u32 = 2009;
pub const F_LENGTH_BYTEA: u32 = 2010;
pub const F_BYTEACAT: u32 = 2011;
pub const F_SUBSTRING_BYTEA_INT4_INT4: u32 = 2012;
pub const F_SUBSTRING_BYTEA_INT4: u32 = 2013;
pub const F_POSITION_BYTEA_BYTEA: u32 = 2014;
pub const F_BTRIM_BYTEA_BYTEA: u32 = 2015;
pub const F_TIME_TIMESTAMPTZ: u32 = 2019;
pub const F_DATE_TRUNC_TEXT_TIMESTAMP: u32 = 2020;
pub const F_DATE_PART_TEXT_TIMESTAMP: u32 = 2021;
pub const F_PG_STAT_GET_ACTIVITY: u32 = 2022;
pub const F_JSONB_PATH_QUERY_FIRST_TZ: u32 = 2023;
pub const F_TIMESTAMP_DATE: u32 = 2024;
pub const F_TIMESTAMP_DATE_TIME: u32 = 2025;
pub const F_PG_BACKEND_PID: u32 = 2026;
pub const F_TIMESTAMP_TIMESTAMPTZ: u32 = 2027;
pub const F_TIMESTAMPTZ_TIMESTAMP: u32 = 2028;
pub const F_DATE_TIMESTAMP: u32 = 2029;
pub const F_JSONB_PATH_MATCH_TZ: u32 = 2030;
pub const F_TIMESTAMP_MI: u32 = 2031;
pub const F_TIMESTAMP_PL_INTERVAL: u32 = 2032;
pub const F_TIMESTAMP_MI_INTERVAL: u32 = 2033;
pub const F_PG_CONF_LOAD_TIME: u32 = 2034;
pub const F_TIMESTAMP_SMALLER: u32 = 2035;
pub const F_TIMESTAMP_LARGER: u32 = 2036;
pub const F_TIMEZONE_TEXT_TIMETZ: u32 = 2037;
pub const F_TIMEZONE_INTERVAL_TIMETZ: u32 = 2038;
pub const F_TIMESTAMP_HASH: u32 = 2039;
pub const F_OVERLAPS_TIMESTAMP_TIMESTAMP_TIMESTAMP_TIMESTAMP: u32 = 2041;
pub const F_OVERLAPS_TIMESTAMP_INTERVAL_TIMESTAMP_INTERVAL: u32 = 2042;
pub const F_OVERLAPS_TIMESTAMP_TIMESTAMP_TIMESTAMP_INTERVAL: u32 = 2043;
pub const F_OVERLAPS_TIMESTAMP_INTERVAL_TIMESTAMP_TIMESTAMP: u32 = 2044;
pub const F_TIMESTAMP_CMP: u32 = 2045;
pub const F_TIME_TIMETZ: u32 = 2046;
pub const F_TIMETZ_TIME: u32 = 2047;
pub const F_ISFINITE_TIMESTAMP: u32 = 2048;
pub const F_TO_CHAR_TIMESTAMP_TEXT: u32 = 2049;
pub const F_MAX_ANYARRAY: u32 = 2050;
pub const F_MIN_ANYARRAY: u32 = 2051;
pub const F_TIMESTAMP_EQ: u32 = 2052;
pub const F_TIMESTAMP_NE: u32 = 2053;
pub const F_TIMESTAMP_LT: u32 = 2054;
pub const F_TIMESTAMP_LE: u32 = 2055;
pub const F_TIMESTAMP_GE: u32 = 2056;
pub const F_TIMESTAMP_GT: u32 = 2057;
pub const F_AGE_TIMESTAMP_TIMESTAMP: u32 = 2058;
pub const F_AGE_TIMESTAMP: u32 = 2059;
pub const F_TIMEZONE_TEXT_TIMESTAMP: u32 = 2069;
pub const F_TIMEZONE_INTERVAL_TIMESTAMP: u32 = 2070;
pub const F_DATE_PL_INTERVAL: u32 = 2071;
pub const F_DATE_MI_INTERVAL: u32 = 2072;
pub const F_SUBSTRING_TEXT_TEXT: u32 = 2073;
pub const F_SUBSTRING_TEXT_TEXT_TEXT: u32 = 2074;
pub const F_BIT_INT8_INT4: u32 = 2075;
pub const F_INT8_BIT: u32 = 2076;
pub const F_CURRENT_SETTING_TEXT: u32 = 2077;
pub const F_SET_CONFIG: u32 = 2078;
pub const F_PG_TABLE_IS_VISIBLE: u32 = 2079;
pub const F_PG_TYPE_IS_VISIBLE: u32 = 2080;
pub const F_PG_FUNCTION_IS_VISIBLE: u32 = 2081;
pub const F_PG_OPERATOR_IS_VISIBLE: u32 = 2082;
pub const F_PG_OPCLASS_IS_VISIBLE: u32 = 2083;
pub const F_PG_SHOW_ALL_SETTINGS: u32 = 2084;
pub const F_SUBSTR_BYTEA_INT4_INT4: u32 = 2085;
pub const F_SUBSTR_BYTEA_INT4: u32 = 2086;
pub const F_REPLACE: u32 = 2087;
pub const F_SPLIT_PART: u32 = 2088;
pub const F_TO_HEX_INT4: u32 = 2089;
pub const F_TO_HEX_INT8: u32 = 2090;
pub const F_ARRAY_LOWER: u32 = 2091;
pub const F_ARRAY_UPPER: u32 = 2092;
pub const F_PG_CONVERSION_IS_VISIBLE: u32 = 2093;
pub const F_PG_STAT_GET_BACKEND_ACTIVITY_START: u32 = 2094;
pub const F_PG_TERMINATE_BACKEND: u32 = 2096;
pub const F_PG_GET_FUNCTIONDEF: u32 = 2098;
pub const F_AVG_INT8: u32 = 2100;
pub const F_AVG_INT4: u32 = 2101;
pub const F_AVG_INT2: u32 = 2102;
pub const F_AVG_NUMERIC: u32 = 2103;
pub const F_AVG_FLOAT4: u32 = 2104;
pub const F_AVG_FLOAT8: u32 = 2105;
pub const F_AVG_INTERVAL: u32 = 2106;
pub const F_SUM_INT8: u32 = 2107;
pub const F_SUM_INT4: u32 = 2108;
pub const F_SUM_INT2: u32 = 2109;
pub const F_SUM_FLOAT4: u32 = 2110;
pub const F_SUM_FLOAT8: u32 = 2111;
pub const F_SUM_MONEY: u32 = 2112;
pub const F_SUM_INTERVAL: u32 = 2113;
pub const F_SUM_NUMERIC: u32 = 2114;
pub const F_MAX_INT8: u32 = 2115;
pub const F_MAX_INT4: u32 = 2116;
pub const F_MAX_INT2: u32 = 2117;
pub const F_MAX_OID: Oid = Oid(2118);
pub const F_MAX_FLOAT4: u32 = 2119;
pub const F_MAX_FLOAT8: u32 = 2120;
pub const F_PG_COLUMN_COMPRESSION: u32 = 2121;
pub const F_MAX_DATE: u32 = 2122;
pub const F_MAX_TIME: u32 = 2123;
pub const F_MAX_TIMETZ: u32 = 2124;
pub const F_MAX_MONEY: u32 = 2125;
pub const F_MAX_TIMESTAMP: u32 = 2126;
pub const F_MAX_TIMESTAMPTZ: u32 = 2127;
pub const F_MAX_INTERVAL: u32 = 2128;
pub const F_MAX_TEXT: u32 = 2129;
pub const F_MAX_NUMERIC: u32 = 2130;
pub const F_MIN_INT8: u32 = 2131;
pub const F_MIN_INT4: u32 = 2132;
pub const F_MIN_INT2: u32 = 2133;
pub const F_MIN_OID: Oid = Oid(2134);
pub const F_MIN_FLOAT4: u32 = 2135;
pub const F_MIN_FLOAT8: u32 = 2136;
pub const F_PG_STAT_FORCE_NEXT_FLUSH: u32 = 2137;
pub const F_MIN_DATE: u32 = 2138;
pub const F_MIN_TIME: u32 = 2139;
pub const F_MIN_TIMETZ: u32 = 2140;
pub const F_MIN_MONEY: u32 = 2141;
pub const F_MIN_TIMESTAMP: u32 = 2142;
pub const F_MIN_TIMESTAMPTZ: u32 = 2143;
pub const F_MIN_INTERVAL: u32 = 2144;
pub const F_MIN_TEXT: u32 = 2145;
pub const F_MIN_NUMERIC: u32 = 2146;
pub const F_COUNT_ANY: u32 = 2147;
pub const F_VARIANCE_INT8: u32 = 2148;
pub const F_VARIANCE_INT4: u32 = 2149;
pub const F_VARIANCE_INT2: u32 = 2150;
pub const F_VARIANCE_FLOAT4: u32 = 2151;
pub const F_VARIANCE_FLOAT8: u32 = 2152;
pub const F_VARIANCE_NUMERIC: u32 = 2153;
pub const F_STDDEV_INT8: u32 = 2154;
pub const F_STDDEV_INT4: u32 = 2155;
pub const F_STDDEV_INT2: u32 = 2156;
pub const F_STDDEV_FLOAT4: u32 = 2157;
pub const F_STDDEV_FLOAT8: u32 = 2158;
pub const F_STDDEV_NUMERIC: u32 = 2159;
pub const F_TEXT_PATTERN_LT: u32 = 2160;
pub const F_TEXT_PATTERN_LE: u32 = 2161;
pub const F_PG_GET_FUNCTION_ARGUMENTS: u32 = 2162;
pub const F_TEXT_PATTERN_GE: u32 = 2163;
pub const F_TEXT_PATTERN_GT: u32 = 2164;
pub const F_PG_GET_FUNCTION_RESULT: u32 = 2165;
pub const F_BTTEXT_PATTERN_CMP: u32 = 2166;
pub const F_CEILING_NUMERIC: u32 = 2167;
pub const F_PG_DATABASE_SIZE_NAME: u32 = 2168;
pub const F_POWER_NUMERIC_NUMERIC: u32 = 2169;
pub const F_WIDTH_BUCKET_NUMERIC_NUMERIC_NUMERIC_INT4: u32 = 2170;
pub const F_PG_CANCEL_BACKEND: u32 = 2171;
pub const F_PG_BACKUP_START: u32 = 2172;
pub const F_BPCHAR_PATTERN_LT: u32 = 2174;
pub const F_BPCHAR_PATTERN_LE: u32 = 2175;
pub const F_ARRAY_LENGTH: u32 = 2176;
pub const F_BPCHAR_PATTERN_GE: u32 = 2177;
pub const F_BPCHAR_PATTERN_GT: u32 = 2178;
pub const F_GIST_POINT_CONSISTENT: u32 = 2179;
pub const F_BTBPCHAR_PATTERN_CMP: u32 = 2180;
pub const F_HAS_SEQUENCE_PRIVILEGE_NAME_TEXT_TEXT: u32 = 2181;
pub const F_HAS_SEQUENCE_PRIVILEGE_NAME_OID_TEXT: u32 = 2182;
pub const F_HAS_SEQUENCE_PRIVILEGE_OID_TEXT_TEXT: u32 = 2183;
pub const F_HAS_SEQUENCE_PRIVILEGE_OID_OID_TEXT: u32 = 2184;
pub const F_HAS_SEQUENCE_PRIVILEGE_TEXT_TEXT: u32 = 2185;
pub const F_HAS_SEQUENCE_PRIVILEGE_OID_TEXT: u32 = 2186;
pub const F_BTINT48CMP: u32 = 2188;
pub const F_BTINT84CMP: u32 = 2189;
pub const F_BTINT24CMP: u32 = 2190;
pub const F_BTINT42CMP: u32 = 2191;
pub const F_BTINT28CMP: u32 = 2192;
pub const F_BTINT82CMP: u32 = 2193;
pub const F_BTFLOAT48CMP: u32 = 2194;
pub const F_BTFLOAT84CMP: u32 = 2195;
pub const F_INET_CLIENT_ADDR: u32 = 2196;
pub const F_INET_CLIENT_PORT: u32 = 2197;
pub const F_INET_SERVER_ADDR: u32 = 2198;
pub const F_INET_SERVER_PORT: u32 = 2199;
pub const F_REGPROCEDUREIN: u32 = 2212;
pub const F_REGPROCEDUREOUT: u32 = 2213;
pub const F_REGOPERIN: u32 = 2214;
pub const F_REGOPEROUT: u32 = 2215;
pub const F_REGOPERATORIN: u32 = 2216;
pub const F_REGOPERATOROUT: u32 = 2217;
pub const F_REGCLASSIN: u32 = 2218;
pub const F_REGCLASSOUT: u32 = 2219;
pub const F_REGTYPEIN: u32 = 2220;
pub const F_REGTYPEOUT: u32 = 2221;
pub const F_PG_STAT_CLEAR_SNAPSHOT: u32 = 2230;
pub const F_PG_GET_FUNCTION_IDENTITY_ARGUMENTS: u32 = 2232;
pub const F_HASHTID: u32 = 2233;
pub const F_HASHTIDEXTENDED: u32 = 2234;
pub const F_BIT_AND_INT2: u32 = 2236;
pub const F_BIT_OR_INT2: u32 = 2237;
pub const F_BIT_AND_INT4: u32 = 2238;
pub const F_BIT_OR_INT4: u32 = 2239;
pub const F_BIT_AND_INT8: u32 = 2240;
pub const F_BIT_OR_INT8: u32 = 2241;
pub const F_BIT_AND_BIT: u32 = 2242;
pub const F_BIT_OR_BIT: u32 = 2243;
pub const F_MAX_BPCHAR: u32 = 2244;
pub const F_MIN_BPCHAR: u32 = 2245;
pub const F_FMGR_INTERNAL_VALIDATOR: u32 = 2246;
pub const F_FMGR_C_VALIDATOR: u32 = 2247;
pub const F_FMGR_SQL_VALIDATOR: u32 = 2248;
pub const F_HAS_DATABASE_PRIVILEGE_NAME_TEXT_TEXT: u32 = 2250;
pub const F_HAS_DATABASE_PRIVILEGE_NAME_OID_TEXT: u32 = 2251;
pub const F_HAS_DATABASE_PRIVILEGE_OID_TEXT_TEXT: u32 = 2252;
pub const F_HAS_DATABASE_PRIVILEGE_OID_OID_TEXT: u32 = 2253;
pub const F_HAS_DATABASE_PRIVILEGE_TEXT_TEXT: u32 = 2254;
pub const F_HAS_DATABASE_PRIVILEGE_OID_TEXT: u32 = 2255;
pub const F_HAS_FUNCTION_PRIVILEGE_NAME_TEXT_TEXT: u32 = 2256;
pub const F_HAS_FUNCTION_PRIVILEGE_NAME_OID_TEXT: u32 = 2257;
pub const F_HAS_FUNCTION_PRIVILEGE_OID_TEXT_TEXT: u32 = 2258;
pub const F_HAS_FUNCTION_PRIVILEGE_OID_OID_TEXT: u32 = 2259;
pub const F_HAS_FUNCTION_PRIVILEGE_TEXT_TEXT: u32 = 2260;
pub const F_HAS_FUNCTION_PRIVILEGE_OID_TEXT: u32 = 2261;
pub const F_HAS_LANGUAGE_PRIVILEGE_NAME_TEXT_TEXT: u32 = 2262;
pub const F_HAS_LANGUAGE_PRIVILEGE_NAME_OID_TEXT: u32 = 2263;
pub const F_HAS_LANGUAGE_PRIVILEGE_OID_TEXT_TEXT: u32 = 2264;
pub const F_HAS_LANGUAGE_PRIVILEGE_OID_OID_TEXT: u32 = 2265;
pub const F_HAS_LANGUAGE_PRIVILEGE_TEXT_TEXT: u32 = 2266;
pub const F_HAS_LANGUAGE_PRIVILEGE_OID_TEXT: u32 = 2267;
pub const F_HAS_SCHEMA_PRIVILEGE_NAME_TEXT_TEXT: u32 = 2268;
pub const F_HAS_SCHEMA_PRIVILEGE_NAME_OID_TEXT: u32 = 2269;
pub const F_HAS_SCHEMA_PRIVILEGE_OID_TEXT_TEXT: u32 = 2270;
pub const F_HAS_SCHEMA_PRIVILEGE_OID_OID_TEXT: u32 = 2271;
pub const F_HAS_SCHEMA_PRIVILEGE_TEXT_TEXT: u32 = 2272;
pub const F_HAS_SCHEMA_PRIVILEGE_OID_TEXT: u32 = 2273;
pub const F_PG_STAT_RESET: u32 = 2274;
pub const F_PG_GET_BACKEND_MEMORY_CONTEXTS: u32 = 2282;
pub const F_REGEXP_REPLACE_TEXT_TEXT_TEXT: u32 = 2284;
pub const F_REGEXP_REPLACE_TEXT_TEXT_TEXT_TEXT: u32 = 2285;
pub const F_PG_TOTAL_RELATION_SIZE: u32 = 2286;
pub const F_PG_SIZE_PRETTY_INT8: u32 = 2288;
pub const F_PG_OPTIONS_TO_TABLE: u32 = 2289;
pub const F_RECORD_IN: u32 = 2290;
pub const F_RECORD_OUT: u32 = 2291;
pub const F_CSTRING_IN: u32 = 2292;
pub const F_CSTRING_OUT: u32 = 2293;
pub const F_ANY_IN: u32 = 2294;
pub const F_ANY_OUT: u32 = 2295;
pub const F_ANYARRAY_IN: u32 = 2296;
pub const F_ANYARRAY_OUT: u32 = 2297;
pub const F_VOID_IN: u32 = 2298;
pub const F_VOID_OUT: u32 = 2299;
pub const F_TRIGGER_IN: u32 = 2300;
pub const F_TRIGGER_OUT: u32 = 2301;
pub const F_LANGUAGE_HANDLER_IN: u32 = 2302;
pub const F_LANGUAGE_HANDLER_OUT: u32 = 2303;
pub const F_INTERNAL_IN: u32 = 2304;
pub const F_INTERNAL_OUT: u32 = 2305;
pub const F_PG_STAT_GET_SLRU: u32 = 2306;
pub const F_PG_STAT_RESET_SLRU: u32 = 2307;
pub const F_CEIL_FLOAT8: u32 = 2308;
pub const F_FLOOR_FLOAT8: u32 = 2309;
pub const F_SIGN_FLOAT8: u32 = 2310;
pub const F_MD5_TEXT: u32 = 2311;
pub const F_ANYELEMENT_IN: u32 = 2312;
pub const F_ANYELEMENT_OUT: u32 = 2313;
pub const F_POSTGRESQL_FDW_VALIDATOR: u32 = 2316;
pub const F_PG_ENCODING_MAX_LENGTH: u32 = 2319;
pub const F_CEILING_FLOAT8: u32 = 2320;
pub const F_MD5_BYTEA: u32 = 2321;
pub const F_PG_TABLESPACE_SIZE_OID: Oid = Oid(2322);
pub const F_PG_TABLESPACE_SIZE_NAME: u32 = 2323;
pub const F_PG_DATABASE_SIZE_OID: Oid = Oid(2324);
pub const F_PG_RELATION_SIZE_REGCLASS: u32 = 2325;
pub const F_UNNEST_ANYARRAY: u32 = 2331;
pub const F_PG_RELATION_SIZE_REGCLASS_TEXT: u32 = 2332;
pub const F_ARRAY_AGG_TRANSFN: u32 = 2333;
pub const F_ARRAY_AGG_FINALFN: u32 = 2334;
pub const F_ARRAY_AGG_ANYNONARRAY: u32 = 2335;
pub const F_DATE_LT_TIMESTAMP: u32 = 2338;
pub const F_DATE_LE_TIMESTAMP: u32 = 2339;
pub const F_DATE_EQ_TIMESTAMP: u32 = 2340;
pub const F_DATE_GT_TIMESTAMP: u32 = 2341;
pub const F_DATE_GE_TIMESTAMP: u32 = 2342;
pub const F_DATE_NE_TIMESTAMP: u32 = 2343;
pub const F_DATE_CMP_TIMESTAMP: u32 = 2344;
pub const F_DATE_LT_TIMESTAMPTZ: u32 = 2351;
pub const F_DATE_LE_TIMESTAMPTZ: u32 = 2352;
pub const F_DATE_EQ_TIMESTAMPTZ: u32 = 2353;
pub const F_DATE_GT_TIMESTAMPTZ: u32 = 2354;
pub const F_DATE_GE_TIMESTAMPTZ: u32 = 2355;
pub const F_DATE_NE_TIMESTAMPTZ: u32 = 2356;
pub const F_DATE_CMP_TIMESTAMPTZ: u32 = 2357;
pub const F_TIMESTAMP_LT_DATE: u32 = 2364;
pub const F_TIMESTAMP_LE_DATE: u32 = 2365;
pub const F_TIMESTAMP_EQ_DATE: u32 = 2366;
pub const F_TIMESTAMP_GT_DATE: u32 = 2367;
pub const F_TIMESTAMP_GE_DATE: u32 = 2368;
pub const F_TIMESTAMP_NE_DATE: u32 = 2369;
pub const F_TIMESTAMP_CMP_DATE: u32 = 2370;
pub const F_TIMESTAMPTZ_LT_DATE: u32 = 2377;
pub const F_TIMESTAMPTZ_LE_DATE: u32 = 2378;
pub const F_TIMESTAMPTZ_EQ_DATE: u32 = 2379;
pub const F_TIMESTAMPTZ_GT_DATE: u32 = 2380;
pub const F_TIMESTAMPTZ_GE_DATE: u32 = 2381;
pub const F_TIMESTAMPTZ_NE_DATE: u32 = 2382;
pub const F_TIMESTAMPTZ_CMP_DATE: u32 = 2383;
pub const F_HAS_TABLESPACE_PRIVILEGE_NAME_TEXT_TEXT: u32 = 2390;
pub const F_HAS_TABLESPACE_PRIVILEGE_NAME_OID_TEXT: u32 = 2391;
pub const F_HAS_TABLESPACE_PRIVILEGE_OID_TEXT_TEXT: u32 = 2392;
pub const F_HAS_TABLESPACE_PRIVILEGE_OID_OID_TEXT: u32 = 2393;
pub const F_HAS_TABLESPACE_PRIVILEGE_TEXT_TEXT: u32 = 2394;
pub const F_HAS_TABLESPACE_PRIVILEGE_OID_TEXT: u32 = 2395;
pub const F_SHELL_IN: u32 = 2398;
pub const F_SHELL_OUT: u32 = 2399;
pub const F_ARRAY_RECV: u32 = 2400;
pub const F_ARRAY_SEND: u32 = 2401;
pub const F_RECORD_RECV: u32 = 2402;
pub const F_RECORD_SEND: u32 = 2403;
pub const F_INT2RECV: u32 = 2404;
pub const F_INT2SEND: u32 = 2405;
pub const F_INT4RECV: u32 = 2406;
pub const F_INT4SEND: u32 = 2407;
pub const F_INT8RECV: u32 = 2408;
pub const F_INT8SEND: u32 = 2409;
pub const F_INT2VECTORRECV: u32 = 2410;
pub const F_INT2VECTORSEND: u32 = 2411;
pub const F_BYTEARECV: u32 = 2412;
pub const F_BYTEASEND: u32 = 2413;
pub const F_TEXTRECV: u32 = 2414;
pub const F_TEXTSEND: u32 = 2415;
pub const F_UNKNOWNRECV: u32 = 2416;
pub const F_UNKNOWNSEND: u32 = 2417;
pub const F_OIDRECV: u32 = 2418;
pub const F_OIDSEND: u32 = 2419;
pub const F_OIDVECTORRECV: u32 = 2420;
pub const F_OIDVECTORSEND: u32 = 2421;
pub const F_NAMERECV: u32 = 2422;
pub const F_NAMESEND: u32 = 2423;
pub const F_FLOAT4RECV: u32 = 2424;
pub const F_FLOAT4SEND: u32 = 2425;
pub const F_FLOAT8RECV: u32 = 2426;
pub const F_FLOAT8SEND: u32 = 2427;
pub const F_POINT_RECV: u32 = 2428;
pub const F_POINT_SEND: u32 = 2429;
pub const F_BPCHARRECV: u32 = 2430;
pub const F_BPCHARSEND: u32 = 2431;
pub const F_VARCHARRECV: u32 = 2432;
pub const F_VARCHARSEND: u32 = 2433;
pub const F_CHARRECV: u32 = 2434;
pub const F_CHARSEND: u32 = 2435;
pub const F_BOOLRECV: u32 = 2436;
pub const F_BOOLSEND: u32 = 2437;
pub const F_TIDRECV: u32 = 2438;
pub const F_TIDSEND: u32 = 2439;
pub const F_XIDRECV: u32 = 2440;
pub const F_XIDSEND: u32 = 2441;
pub const F_CIDRECV: u32 = 2442;
pub const F_CIDSEND: u32 = 2443;
pub const F_REGPROCRECV: u32 = 2444;
pub const F_REGPROCSEND: u32 = 2445;
pub const F_REGPROCEDURERECV: u32 = 2446;
pub const F_REGPROCEDURESEND: u32 = 2447;
pub const F_REGOPERRECV: u32 = 2448;
pub const F_REGOPERSEND: u32 = 2449;
pub const F_REGOPERATORRECV: u32 = 2450;
pub const F_REGOPERATORSEND: u32 = 2451;
pub const F_REGCLASSRECV: u32 = 2452;
pub const F_REGCLASSSEND: u32 = 2453;
pub const F_REGTYPERECV: u32 = 2454;
pub const F_REGTYPESEND: u32 = 2455;
pub const F_BIT_RECV: u32 = 2456;
pub const F_BIT_SEND: u32 = 2457;
pub const F_VARBIT_RECV: u32 = 2458;
pub const F_VARBIT_SEND: u32 = 2459;
pub const F_NUMERIC_RECV: u32 = 2460;
pub const F_NUMERIC_SEND: u32 = 2461;
pub const F_SINH: u32 = 2462;
pub const F_COSH: u32 = 2463;
pub const F_TANH: u32 = 2464;
pub const F_ASINH: u32 = 2465;
pub const F_ACOSH: u32 = 2466;
pub const F_ATANH: u32 = 2467;
pub const F_DATE_RECV: u32 = 2468;
pub const F_DATE_SEND: u32 = 2469;
pub const F_TIME_RECV: u32 = 2470;
pub const F_TIME_SEND: u32 = 2471;
pub const F_TIMETZ_RECV: u32 = 2472;
pub const F_TIMETZ_SEND: u32 = 2473;
pub const F_TIMESTAMP_RECV: u32 = 2474;
pub const F_TIMESTAMP_SEND: u32 = 2475;
pub const F_TIMESTAMPTZ_RECV: u32 = 2476;
pub const F_TIMESTAMPTZ_SEND: u32 = 2477;
pub const F_INTERVAL_RECV: u32 = 2478;
pub const F_INTERVAL_SEND: u32 = 2479;
pub const F_LSEG_RECV: u32 = 2480;
pub const F_LSEG_SEND: u32 = 2481;
pub const F_PATH_RECV: u32 = 2482;
pub const F_PATH_SEND: u32 = 2483;
pub const F_BOX_RECV: u32 = 2484;
pub const F_BOX_SEND: u32 = 2485;
pub const F_POLY_RECV: u32 = 2486;
pub const F_POLY_SEND: u32 = 2487;
pub const F_LINE_RECV: u32 = 2488;
pub const F_LINE_SEND: u32 = 2489;
pub const F_CIRCLE_RECV: u32 = 2490;
pub const F_CIRCLE_SEND: u32 = 2491;
pub const F_CASH_RECV: u32 = 2492;
pub const F_CASH_SEND: u32 = 2493;
pub const F_MACADDR_RECV: u32 = 2494;
pub const F_MACADDR_SEND: u32 = 2495;
pub const F_INET_RECV: u32 = 2496;
pub const F_INET_SEND: u32 = 2497;
pub const F_CIDR_RECV: u32 = 2498;
pub const F_CIDR_SEND: u32 = 2499;
pub const F_CSTRING_RECV: u32 = 2500;
pub const F_CSTRING_SEND: u32 = 2501;
pub const F_ANYARRAY_RECV: u32 = 2502;
pub const F_ANYARRAY_SEND: u32 = 2503;
pub const F_PG_GET_RULEDEF_OID_BOOL: u32 = 2504;
pub const F_PG_GET_VIEWDEF_TEXT_BOOL: u32 = 2505;
pub const F_PG_GET_VIEWDEF_OID_BOOL: u32 = 2506;
pub const F_PG_GET_INDEXDEF_OID_INT4_BOOL: u32 = 2507;
pub const F_PG_GET_CONSTRAINTDEF_OID_BOOL: u32 = 2508;
pub const F_PG_GET_EXPR_PG_NODE_TREE_OID_BOOL: u32 = 2509;
pub const F_PG_PREPARED_STATEMENT: u32 = 2510;
pub const F_PG_CURSOR: u32 = 2511;
pub const F_FLOAT8_VAR_POP: u32 = 2512;
pub const F_FLOAT8_STDDEV_POP: u32 = 2513;
pub const F_NUMERIC_VAR_POP: u32 = 2514;
pub const F_BOOLAND_STATEFUNC: u32 = 2515;
pub const F_BOOLOR_STATEFUNC: u32 = 2516;
pub const F_BOOL_AND: u32 = 2517;
pub const F_BOOL_OR: u32 = 2518;
pub const F_EVERY: u32 = 2519;
pub const F_TIMESTAMP_LT_TIMESTAMPTZ: u32 = 2520;
pub const F_TIMESTAMP_LE_TIMESTAMPTZ: u32 = 2521;
pub const F_TIMESTAMP_EQ_TIMESTAMPTZ: u32 = 2522;
pub const F_TIMESTAMP_GT_TIMESTAMPTZ: u32 = 2523;
pub const F_TIMESTAMP_GE_TIMESTAMPTZ: u32 = 2524;
pub const F_TIMESTAMP_NE_TIMESTAMPTZ: u32 = 2525;
pub const F_TIMESTAMP_CMP_TIMESTAMPTZ: u32 = 2526;
pub const F_TIMESTAMPTZ_LT_TIMESTAMP: u32 = 2527;
pub const F_TIMESTAMPTZ_LE_TIMESTAMP: u32 = 2528;
pub const F_TIMESTAMPTZ_EQ_TIMESTAMP: u32 = 2529;
pub const F_TIMESTAMPTZ_GT_TIMESTAMP: u32 = 2530;
pub const F_TIMESTAMPTZ_GE_TIMESTAMP: u32 = 2531;
pub const F_TIMESTAMPTZ_NE_TIMESTAMP: u32 = 2532;
pub const F_TIMESTAMPTZ_CMP_TIMESTAMP: u32 = 2533;
pub const F_INTERVAL_PL_DATE: u32 = 2546;
pub const F_INTERVAL_PL_TIMETZ: u32 = 2547;
pub const F_INTERVAL_PL_TIMESTAMP: u32 = 2548;
pub const F_INTERVAL_PL_TIMESTAMPTZ: u32 = 2549;
pub const F_INTEGER_PL_DATE: u32 = 2550;
pub const F_PG_TABLESPACE_DATABASES: u32 = 2556;
pub const F_BOOL_INT4: u32 = 2557;
pub const F_INT4_BOOL: u32 = 2558;
pub const F_LASTVAL: u32 = 2559;
pub const F_PG_POSTMASTER_START_TIME: u32 = 2560;
pub const F_PG_BLOCKING_PIDS: u32 = 2561;
pub const F_BOX_BELOW: u32 = 2562;
pub const F_BOX_OVERBELOW: u32 = 2563;
pub const F_BOX_OVERABOVE: u32 = 2564;
pub const F_BOX_ABOVE: u32 = 2565;
pub const F_POLY_BELOW: u32 = 2566;
pub const F_POLY_OVERBELOW: u32 = 2567;
pub const F_POLY_OVERABOVE: u32 = 2568;
pub const F_POLY_ABOVE: u32 = 2569;
pub const F_GIST_BOX_CONSISTENT: u32 = 2578;
pub const F_FLOAT8_JSONB: u32 = 2580;
pub const F_GIST_BOX_PENALTY: u32 = 2581;
pub const F_GIST_BOX_PICKSPLIT: u32 = 2582;
pub const F_GIST_BOX_UNION: u32 = 2583;
pub const F_GIST_BOX_SAME: u32 = 2584;
pub const F_GIST_POLY_CONSISTENT: u32 = 2585;
pub const F_GIST_POLY_COMPRESS: u32 = 2586;
pub const F_CIRCLE_OVERBELOW: u32 = 2587;
pub const F_CIRCLE_OVERABOVE: u32 = 2588;
pub const F_GIST_CIRCLE_CONSISTENT: u32 = 2591;
pub const F_GIST_CIRCLE_COMPRESS: u32 = 2592;
pub const F_NUMERIC_STDDEV_POP: u32 = 2596;
pub const F_DOMAIN_IN: u32 = 2597;
pub const F_DOMAIN_RECV: u32 = 2598;
pub const F_PG_TIMEZONE_ABBREVS: u32 = 2599;
pub const F_XMLEXISTS: u32 = 2614;
pub const F_PG_RELOAD_CONF: u32 = 2621;
pub const F_PG_ROTATE_LOGFILE: u32 = 2622;
pub const F_PG_STAT_FILE_TEXT: u32 = 2623;
pub const F_PG_READ_FILE_TEXT_INT8_INT8: u32 = 2624;
pub const F_PG_LS_DIR_TEXT: u32 = 2625;
pub const F_PG_SLEEP: u32 = 2626;
pub const F_INETNOT: u32 = 2627;
pub const F_INETAND: u32 = 2628;
pub const F_INETOR: u32 = 2629;
pub const F_INETPL: u32 = 2630;
pub const F_INT8PL_INET: u32 = 2631;
pub const F_INETMI_INT8: u32 = 2632;
pub const F_INETMI: u32 = 2633;
pub const F_VAR_SAMP_INT8: u32 = 2641;
pub const F_VAR_SAMP_INT4: u32 = 2642;
pub const F_VAR_SAMP_INT2: u32 = 2643;
pub const F_VAR_SAMP_FLOAT4: u32 = 2644;
pub const F_VAR_SAMP_FLOAT8: u32 = 2645;
pub const F_VAR_SAMP_NUMERIC: u32 = 2646;
pub const F_TRANSACTION_TIMESTAMP: u32 = 2647;
pub const F_STATEMENT_TIMESTAMP: u32 = 2648;
pub const F_CLOCK_TIMESTAMP: u32 = 2649;
pub const F_GIN_CMP_PREFIX: u32 = 2700;
pub const F_PG_HAS_ROLE_NAME_NAME_TEXT: u32 = 2705;
pub const F_PG_HAS_ROLE_NAME_OID_TEXT: u32 = 2706;
pub const F_PG_HAS_ROLE_OID_NAME_TEXT: u32 = 2707;
pub const F_PG_HAS_ROLE_OID_OID_TEXT: u32 = 2708;
pub const F_PG_HAS_ROLE_NAME_TEXT: u32 = 2709;
pub const F_PG_HAS_ROLE_OID_TEXT: u32 = 2710;
pub const F_JUSTIFY_INTERVAL: u32 = 2711;
pub const F_STDDEV_SAMP_INT8: u32 = 2712;
pub const F_STDDEV_SAMP_INT4: u32 = 2713;
pub const F_STDDEV_SAMP_INT2: u32 = 2714;
pub const F_STDDEV_SAMP_FLOAT4: u32 = 2715;
pub const F_STDDEV_SAMP_FLOAT8: u32 = 2716;
pub const F_STDDEV_SAMP_NUMERIC: u32 = 2717;
pub const F_VAR_POP_INT8: u32 = 2718;
pub const F_VAR_POP_INT4: u32 = 2719;
pub const F_VAR_POP_INT2: u32 = 2720;
pub const F_VAR_POP_FLOAT4: u32 = 2721;
pub const F_VAR_POP_FLOAT8: u32 = 2722;
pub const F_VAR_POP_NUMERIC: u32 = 2723;
pub const F_STDDEV_POP_INT8: u32 = 2724;
pub const F_STDDEV_POP_INT4: u32 = 2725;
pub const F_STDDEV_POP_INT2: u32 = 2726;
pub const F_STDDEV_POP_FLOAT4: u32 = 2727;
pub const F_STDDEV_POP_FLOAT8: u32 = 2728;
pub const F_STDDEV_POP_NUMERIC: u32 = 2729;
pub const F_PG_GET_TRIGGERDEF_OID_BOOL: u32 = 2730;
pub const F_ASIND: u32 = 2731;
pub const F_ACOSD: u32 = 2732;
pub const F_ATAND: u32 = 2733;
pub const F_ATAN2D: u32 = 2734;
pub const F_SIND: u32 = 2735;
pub const F_COSD: u32 = 2736;
pub const F_TAND: u32 = 2737;
pub const F_COTD: u32 = 2738;
pub const F_PG_BACKUP_STOP: u32 = 2739;
pub const F_NUMERIC_AVG_SERIALIZE: u32 = 2740;
pub const F_NUMERIC_AVG_DESERIALIZE: u32 = 2741;
pub const F_GINARRAYEXTRACT_ANYARRAY_INTERNAL_INTERNAL: u32 = 2743;
pub const F_GINARRAYCONSISTENT: u32 = 2744;
pub const F_INT8_AVG_ACCUM: u32 = 2746;
pub const F_ARRAYOVERLAP: u32 = 2747;
pub const F_ARRAYCONTAINS: u32 = 2748;
pub const F_ARRAYCONTAINED: u32 = 2749;
pub const F_PG_STAT_GET_DB_TUPLES_RETURNED: u32 = 2758;
pub const F_PG_STAT_GET_DB_TUPLES_FETCHED: u32 = 2759;
pub const F_PG_STAT_GET_DB_TUPLES_INSERTED: u32 = 2760;
pub const F_PG_STAT_GET_DB_TUPLES_UPDATED: u32 = 2761;
pub const F_PG_STAT_GET_DB_TUPLES_DELETED: u32 = 2762;
pub const F_REGEXP_MATCHES_TEXT_TEXT: u32 = 2763;
pub const F_REGEXP_MATCHES_TEXT_TEXT_TEXT: u32 = 2764;
pub const F_REGEXP_SPLIT_TO_TABLE_TEXT_TEXT: u32 = 2765;
pub const F_REGEXP_SPLIT_TO_TABLE_TEXT_TEXT_TEXT: u32 = 2766;
pub const F_REGEXP_SPLIT_TO_ARRAY_TEXT_TEXT: u32 = 2767;
pub const F_REGEXP_SPLIT_TO_ARRAY_TEXT_TEXT_TEXT: u32 = 2768;
pub const F_PG_STAT_GET_CHECKPOINTER_NUM_TIMED: u32 = 2769;
pub const F_PG_STAT_GET_CHECKPOINTER_NUM_REQUESTED: u32 = 2770;
pub const F_PG_STAT_GET_CHECKPOINTER_BUFFERS_WRITTEN: u32 = 2771;
pub const F_PG_STAT_GET_BGWRITER_BUF_WRITTEN_CLEAN: u32 = 2772;
pub const F_PG_STAT_GET_BGWRITER_MAXWRITTEN_CLEAN: u32 = 2773;
pub const F_GINQUERYARRAYEXTRACT: u32 = 2774;
pub const F_ANYNONARRAY_IN: u32 = 2777;
pub const F_ANYNONARRAY_OUT: u32 = 2778;
pub const F_PG_STAT_GET_LAST_VACUUM_TIME: u32 = 2781;
pub const F_PG_STAT_GET_LAST_AUTOVACUUM_TIME: u32 = 2782;
pub const F_PG_STAT_GET_LAST_ANALYZE_TIME: u32 = 2783;
pub const F_PG_STAT_GET_LAST_AUTOANALYZE_TIME: u32 = 2784;
pub const F_INT8_AVG_COMBINE: u32 = 2785;
pub const F_INT8_AVG_SERIALIZE: u32 = 2786;
pub const F_INT8_AVG_DESERIALIZE: u32 = 2787;
pub const F_PG_STAT_GET_BACKEND_WAIT_EVENT_TYPE: u32 = 2788;
pub const F_TIDGT: u32 = 2790;
pub const F_TIDLT: u32 = 2791;
pub const F_TIDGE: u32 = 2792;
pub const F_TIDLE: u32 = 2793;
pub const F_BTTIDCMP: u32 = 2794;
pub const F_TIDLARGER: u32 = 2795;
pub const F_TIDSMALLER: u32 = 2796;
pub const F_MAX_TID: u32 = 2797;
pub const F_MIN_TID: u32 = 2798;
pub const F_COUNT_: u32 = 2803;
pub const F_INT8INC_ANY: u32 = 2804;
pub const F_INT8INC_FLOAT8_FLOAT8: u32 = 2805;
pub const F_FLOAT8_REGR_ACCUM: u32 = 2806;
pub const F_FLOAT8_REGR_SXX: u32 = 2807;
pub const F_FLOAT8_REGR_SYY: u32 = 2808;
pub const F_FLOAT8_REGR_SXY: u32 = 2809;
pub const F_FLOAT8_REGR_AVGX: u32 = 2810;
pub const F_FLOAT8_REGR_AVGY: u32 = 2811;
pub const F_FLOAT8_REGR_R2: u32 = 2812;
pub const F_FLOAT8_REGR_SLOPE: u32 = 2813;
pub const F_FLOAT8_REGR_INTERCEPT: u32 = 2814;
pub const F_FLOAT8_COVAR_POP: u32 = 2815;
pub const F_FLOAT8_COVAR_SAMP: u32 = 2816;
pub const F_FLOAT8_CORR: u32 = 2817;
pub const F_REGR_COUNT: u32 = 2818;
pub const F_REGR_SXX: u32 = 2819;
pub const F_REGR_SYY: u32 = 2820;
pub const F_REGR_SXY: u32 = 2821;
pub const F_REGR_AVGX: u32 = 2822;
pub const F_REGR_AVGY: u32 = 2823;
pub const F_REGR_R2: u32 = 2824;
pub const F_REGR_SLOPE: u32 = 2825;
pub const F_REGR_INTERCEPT: u32 = 2826;
pub const F_COVAR_POP: u32 = 2827;
pub const F_COVAR_SAMP: u32 = 2828;
pub const F_CORR: u32 = 2829;
pub const F_PG_STAT_GET_DB_BLK_READ_TIME: u32 = 2844;
pub const F_PG_STAT_GET_DB_BLK_WRITE_TIME: u32 = 2845;
pub const F_PG_SWITCH_WAL: u32 = 2848;
pub const F_PG_CURRENT_WAL_LSN: u32 = 2849;
pub const F_PG_WALFILE_NAME_OFFSET: u32 = 2850;
pub const F_PG_WALFILE_NAME: u32 = 2851;
pub const F_PG_CURRENT_WAL_INSERT_LSN: u32 = 2852;
pub const F_PG_STAT_GET_BACKEND_WAIT_EVENT: u32 = 2853;
pub const F_PG_MY_TEMP_SCHEMA: u32 = 2854;
pub const F_PG_IS_OTHER_TEMP_SCHEMA: u32 = 2855;
pub const F_PG_TIMEZONE_NAMES: u32 = 2856;
pub const F_PG_STAT_GET_BACKEND_XACT_START: u32 = 2857;
pub const F_NUMERIC_AVG_ACCUM: u32 = 2858;
pub const F_PG_STAT_GET_BUF_ALLOC: u32 = 2859;
pub const F_PG_STAT_GET_LIVE_TUPLES: u32 = 2878;
pub const F_PG_STAT_GET_DEAD_TUPLES: u32 = 2879;
pub const F_PG_ADVISORY_LOCK_INT8: u32 = 2880;
pub const F_PG_ADVISORY_LOCK_SHARED_INT8: u32 = 2881;
pub const F_PG_TRY_ADVISORY_LOCK_INT8: u32 = 2882;
pub const F_PG_TRY_ADVISORY_LOCK_SHARED_INT8: u32 = 2883;
pub const F_PG_ADVISORY_UNLOCK_INT8: u32 = 2884;
pub const F_PG_ADVISORY_UNLOCK_SHARED_INT8: u32 = 2885;
pub const F_PG_ADVISORY_LOCK_INT4_INT4: u32 = 2886;
pub const F_PG_ADVISORY_LOCK_SHARED_INT4_INT4: u32 = 2887;
pub const F_PG_TRY_ADVISORY_LOCK_INT4_INT4: u32 = 2888;
pub const F_PG_TRY_ADVISORY_LOCK_SHARED_INT4_INT4: u32 = 2889;
pub const F_PG_ADVISORY_UNLOCK_INT4_INT4: u32 = 2890;
pub const F_PG_ADVISORY_UNLOCK_SHARED_INT4_INT4: u32 = 2891;
pub const F_PG_ADVISORY_UNLOCK_ALL: u32 = 2892;
pub const F_XML_IN: u32 = 2893;
pub const F_XML_OUT: u32 = 2894;
pub const F_XMLCOMMENT: u32 = 2895;
pub const F_XML: u32 = 2896;
pub const F_XMLVALIDATE: u32 = 2897;
pub const F_XML_RECV: u32 = 2898;
pub const F_XML_SEND: u32 = 2899;
pub const F_XMLCONCAT2: u32 = 2900;
pub const F_XMLAGG: u32 = 2901;
pub const F_VARBITTYPMODIN: u32 = 2902;
pub const F_INTERVALTYPMODIN: u32 = 2903;
pub const F_INTERVALTYPMODOUT: u32 = 2904;
pub const F_TIMESTAMPTYPMODIN: u32 = 2905;
pub const F_TIMESTAMPTYPMODOUT: u32 = 2906;
pub const F_TIMESTAMPTZTYPMODIN: u32 = 2907;
pub const F_TIMESTAMPTZTYPMODOUT: u32 = 2908;
pub const F_TIMETYPMODIN: u32 = 2909;
pub const F_TIMETYPMODOUT: u32 = 2910;
pub const F_TIMETZTYPMODIN: u32 = 2911;
pub const F_TIMETZTYPMODOUT: u32 = 2912;
pub const F_BPCHARTYPMODIN: u32 = 2913;
pub const F_BPCHARTYPMODOUT: u32 = 2914;
pub const F_VARCHARTYPMODIN: u32 = 2915;
pub const F_VARCHARTYPMODOUT: u32 = 2916;
pub const F_NUMERICTYPMODIN: u32 = 2917;
pub const F_NUMERICTYPMODOUT: u32 = 2918;
pub const F_BITTYPMODIN: u32 = 2919;
pub const F_BITTYPMODOUT: u32 = 2920;
pub const F_VARBITTYPMODOUT: u32 = 2921;
pub const F_TEXT_XML: u32 = 2922;
pub const F_TABLE_TO_XML: u32 = 2923;
pub const F_QUERY_TO_XML: u32 = 2924;
pub const F_CURSOR_TO_XML: u32 = 2925;
pub const F_TABLE_TO_XMLSCHEMA: u32 = 2926;
pub const F_QUERY_TO_XMLSCHEMA: u32 = 2927;
pub const F_CURSOR_TO_XMLSCHEMA: u32 = 2928;
pub const F_TABLE_TO_XML_AND_XMLSCHEMA: u32 = 2929;
pub const F_QUERY_TO_XML_AND_XMLSCHEMA: u32 = 2930;
pub const F_XPATH_TEXT_XML__TEXT: u32 = 2931;
pub const F_XPATH_TEXT_XML: u32 = 2932;
pub const F_SCHEMA_TO_XML: u32 = 2933;
pub const F_SCHEMA_TO_XMLSCHEMA: u32 = 2934;
pub const F_SCHEMA_TO_XML_AND_XMLSCHEMA: u32 = 2935;
pub const F_DATABASE_TO_XML: u32 = 2936;
pub const F_DATABASE_TO_XMLSCHEMA: u32 = 2937;
pub const F_DATABASE_TO_XML_AND_XMLSCHEMA: u32 = 2938;
pub const F_TXID_SNAPSHOT_IN: u32 = 2939;
pub const F_TXID_SNAPSHOT_OUT: u32 = 2940;
pub const F_TXID_SNAPSHOT_RECV: u32 = 2941;
pub const F_TXID_SNAPSHOT_SEND: u32 = 2942;
pub const F_TXID_CURRENT: u32 = 2943;
pub const F_TXID_CURRENT_SNAPSHOT: u32 = 2944;
pub const F_TXID_SNAPSHOT_XMIN: u32 = 2945;
pub const F_TXID_SNAPSHOT_XMAX: u32 = 2946;
pub const F_TXID_SNAPSHOT_XIP: u32 = 2947;
pub const F_TXID_VISIBLE_IN_SNAPSHOT: u32 = 2948;
pub const F_UUID_IN: u32 = 2952;
pub const F_UUID_OUT: u32 = 2953;
pub const F_UUID_LT: u32 = 2954;
pub const F_UUID_LE: u32 = 2955;
pub const F_UUID_EQ: u32 = 2956;
pub const F_UUID_GE: u32 = 2957;
pub const F_UUID_GT: u32 = 2958;
pub const F_UUID_NE: u32 = 2959;
pub const F_UUID_CMP: u32 = 2960;
pub const F_UUID_RECV: u32 = 2961;
pub const F_UUID_SEND: u32 = 2962;
pub const F_UUID_HASH: u32 = 2963;
pub const F_TEXT_BOOL: u32 = 2971;
pub const F_PG_STAT_GET_FUNCTION_CALLS: u32 = 2978;
pub const F_PG_STAT_GET_FUNCTION_TOTAL_TIME: u32 = 2979;
pub const F_PG_STAT_GET_FUNCTION_SELF_TIME: u32 = 2980;
pub const F_RECORD_EQ: u32 = 2981;
pub const F_RECORD_NE: u32 = 2982;
pub const F_RECORD_LT: u32 = 2983;
pub const F_RECORD_GT: u32 = 2984;
pub const F_RECORD_LE: u32 = 2985;
pub const F_RECORD_GE: u32 = 2986;
pub const F_BTRECORDCMP: u32 = 2987;
pub const F_PG_TABLE_SIZE: u32 = 2997;
pub const F_PG_INDEXES_SIZE: u32 = 2998;
pub const F_PG_RELATION_FILENODE: u32 = 2999;
pub const F_HAS_FOREIGN_DATA_WRAPPER_PRIVILEGE_NAME_TEXT_TEXT: u32 = 3000;
pub const F_HAS_FOREIGN_DATA_WRAPPER_PRIVILEGE_NAME_OID_TEXT: u32 = 3001;
pub const F_HAS_FOREIGN_DATA_WRAPPER_PRIVILEGE_OID_TEXT_TEXT: u32 = 3002;
pub const F_HAS_FOREIGN_DATA_WRAPPER_PRIVILEGE_OID_OID_TEXT: u32 = 3003;
pub const F_HAS_FOREIGN_DATA_WRAPPER_PRIVILEGE_TEXT_TEXT: u32 = 3004;
pub const F_HAS_FOREIGN_DATA_WRAPPER_PRIVILEGE_OID_TEXT: u32 = 3005;
pub const F_HAS_SERVER_PRIVILEGE_NAME_TEXT_TEXT: u32 = 3006;
pub const F_HAS_SERVER_PRIVILEGE_NAME_OID_TEXT: u32 = 3007;
pub const F_HAS_SERVER_PRIVILEGE_OID_TEXT_TEXT: u32 = 3008;
pub const F_HAS_SERVER_PRIVILEGE_OID_OID_TEXT: u32 = 3009;
pub const F_HAS_SERVER_PRIVILEGE_TEXT_TEXT: u32 = 3010;
pub const F_HAS_SERVER_PRIVILEGE_OID_TEXT: u32 = 3011;
pub const F_HAS_COLUMN_PRIVILEGE_NAME_TEXT_TEXT_TEXT: u32 = 3012;
pub const F_HAS_COLUMN_PRIVILEGE_NAME_TEXT_INT2_TEXT: u32 = 3013;
pub const F_HAS_COLUMN_PRIVILEGE_NAME_OID_TEXT_TEXT: u32 = 3014;
pub const F_HAS_COLUMN_PRIVILEGE_NAME_OID_INT2_TEXT: u32 = 3015;
pub const F_HAS_COLUMN_PRIVILEGE_OID_TEXT_TEXT_TEXT: u32 = 3016;
pub const F_HAS_COLUMN_PRIVILEGE_OID_TEXT_INT2_TEXT: u32 = 3017;
pub const F_HAS_COLUMN_PRIVILEGE_OID_OID_TEXT_TEXT: u32 = 3018;
pub const F_HAS_COLUMN_PRIVILEGE_OID_OID_INT2_TEXT: u32 = 3019;
pub const F_HAS_COLUMN_PRIVILEGE_TEXT_TEXT_TEXT: u32 = 3020;
pub const F_HAS_COLUMN_PRIVILEGE_TEXT_INT2_TEXT: u32 = 3021;
pub const F_HAS_COLUMN_PRIVILEGE_OID_TEXT_TEXT: u32 = 3022;
pub const F_HAS_COLUMN_PRIVILEGE_OID_INT2_TEXT: u32 = 3023;
pub const F_HAS_ANY_COLUMN_PRIVILEGE_NAME_TEXT_TEXT: u32 = 3024;
pub const F_HAS_ANY_COLUMN_PRIVILEGE_NAME_OID_TEXT: u32 = 3025;
pub const F_HAS_ANY_COLUMN_PRIVILEGE_OID_TEXT_TEXT: u32 = 3026;
pub const F_HAS_ANY_COLUMN_PRIVILEGE_OID_OID_TEXT: u32 = 3027;
pub const F_HAS_ANY_COLUMN_PRIVILEGE_TEXT_TEXT: u32 = 3028;
pub const F_HAS_ANY_COLUMN_PRIVILEGE_OID_TEXT: u32 = 3029;
pub const F_OVERLAY_BIT_BIT_INT4_INT4: u32 = 3030;
pub const F_OVERLAY_BIT_BIT_INT4: u32 = 3031;
pub const F_GET_BIT_BIT_INT4: u32 = 3032;
pub const F_SET_BIT_BIT_INT4_INT4: u32 = 3033;
pub const F_PG_RELATION_FILEPATH: u32 = 3034;
pub const F_PG_LISTENING_CHANNELS: u32 = 3035;
pub const F_PG_NOTIFY: u32 = 3036;
pub const F_PG_STAT_GET_XACT_NUMSCANS: u32 = 3037;
pub const F_PG_STAT_GET_XACT_TUPLES_RETURNED: u32 = 3038;
pub const F_PG_STAT_GET_XACT_TUPLES_FETCHED: u32 = 3039;
pub const F_PG_STAT_GET_XACT_TUPLES_INSERTED: u32 = 3040;
pub const F_PG_STAT_GET_XACT_TUPLES_UPDATED: u32 = 3041;
pub const F_PG_STAT_GET_XACT_TUPLES_DELETED: u32 = 3042;
pub const F_PG_STAT_GET_XACT_TUPLES_HOT_UPDATED: u32 = 3043;
pub const F_PG_STAT_GET_XACT_BLOCKS_FETCHED: u32 = 3044;
pub const F_PG_STAT_GET_XACT_BLOCKS_HIT: u32 = 3045;
pub const F_PG_STAT_GET_XACT_FUNCTION_CALLS: u32 = 3046;
pub const F_PG_STAT_GET_XACT_FUNCTION_TOTAL_TIME: u32 = 3047;
pub const F_PG_STAT_GET_XACT_FUNCTION_SELF_TIME: u32 = 3048;
pub const F_XPATH_EXISTS_TEXT_XML__TEXT: u32 = 3049;
pub const F_XPATH_EXISTS_TEXT_XML: u32 = 3050;
pub const F_XML_IS_WELL_FORMED: u32 = 3051;
pub const F_XML_IS_WELL_FORMED_DOCUMENT: u32 = 3052;
pub const F_XML_IS_WELL_FORMED_CONTENT: u32 = 3053;
pub const F_PG_STAT_GET_VACUUM_COUNT: u32 = 3054;
pub const F_PG_STAT_GET_AUTOVACUUM_COUNT: u32 = 3055;
pub const F_PG_STAT_GET_ANALYZE_COUNT: u32 = 3056;
pub const F_PG_STAT_GET_AUTOANALYZE_COUNT: u32 = 3057;
pub const F_CONCAT: u32 = 3058;
pub const F_CONCAT_WS: u32 = 3059;
pub const F_LEFT: u32 = 3060;
pub const F_RIGHT: u32 = 3061;
pub const F_REVERSE: u32 = 3062;
pub const F_GIST_POINT_DISTANCE: u32 = 3064;
pub const F_PG_STAT_GET_DB_CONFLICT_TABLESPACE: u32 = 3065;
pub const F_PG_STAT_GET_DB_CONFLICT_LOCK: u32 = 3066;
pub const F_PG_STAT_GET_DB_CONFLICT_SNAPSHOT: u32 = 3067;
pub const F_PG_STAT_GET_DB_CONFLICT_BUFFERPIN: u32 = 3068;
pub const F_PG_STAT_GET_DB_CONFLICT_STARTUP_DEADLOCK: u32 = 3069;
pub const F_PG_STAT_GET_DB_CONFLICT_ALL: u32 = 3070;
pub const F_PG_WAL_REPLAY_PAUSE: u32 = 3071;
pub const F_PG_WAL_REPLAY_RESUME: u32 = 3072;
pub const F_PG_IS_WAL_REPLAY_PAUSED: u32 = 3073;
pub const F_PG_STAT_GET_DB_STAT_RESET_TIME: u32 = 3074;
pub const F_PG_STAT_GET_BGWRITER_STAT_RESET_TIME: u32 = 3075;
pub const F_GINARRAYEXTRACT_ANYARRAY_INTERNAL: u32 = 3076;
pub const F_GIN_EXTRACT_TSVECTOR_TSVECTOR_INTERNAL: u32 = 3077;
pub const F_PG_SEQUENCE_PARAMETERS: u32 = 3078;
pub const F_PG_AVAILABLE_EXTENSIONS: u32 = 3082;
pub const F_PG_AVAILABLE_EXTENSION_VERSIONS: u32 = 3083;
pub const F_PG_EXTENSION_UPDATE_PATHS: u32 = 3084;
pub const F_PG_EXTENSION_CONFIG_DUMP: u32 = 3086;
pub const F_GIN_EXTRACT_TSQUERY_TSQUERY_INTERNAL_INT2_INTERNAL_INTERNAL: u32 = 3087;
pub const F_GIN_TSQUERY_CONSISTENT_INTERNAL_INT2_TSQUERY_INT4_INTERNAL_INTERNAL: u32 = 3088;
pub const F_PG_ADVISORY_XACT_LOCK_INT8: u32 = 3089;
pub const F_PG_ADVISORY_XACT_LOCK_SHARED_INT8: u32 = 3090;
pub const F_PG_TRY_ADVISORY_XACT_LOCK_INT8: u32 = 3091;
pub const F_PG_TRY_ADVISORY_XACT_LOCK_SHARED_INT8: u32 = 3092;
pub const F_PG_ADVISORY_XACT_LOCK_INT4_INT4: u32 = 3093;
pub const F_PG_ADVISORY_XACT_LOCK_SHARED_INT4_INT4: u32 = 3094;
pub const F_PG_TRY_ADVISORY_XACT_LOCK_INT4_INT4: u32 = 3095;
pub const F_PG_TRY_ADVISORY_XACT_LOCK_SHARED_INT4_INT4: u32 = 3096;
pub const F_VARCHAR_SUPPORT: u32 = 3097;
pub const F_PG_CREATE_RESTORE_POINT: u32 = 3098;
pub const F_PG_STAT_GET_WAL_SENDERS: u32 = 3099;
pub const F_ROW_NUMBER: u32 = 3100;
pub const F_RANK_: u32 = 3101;
pub const F_DENSE_RANK_: u32 = 3102;
pub const F_PERCENT_RANK_: u32 = 3103;
pub const F_CUME_DIST_: u32 = 3104;
pub const F_NTILE: u32 = 3105;
pub const F_LAG_ANYELEMENT: u32 = 3106;
pub const F_LAG_ANYELEMENT_INT4: u32 = 3107;
pub const F_LAG_ANYCOMPATIBLE_INT4_ANYCOMPATIBLE: u32 = 3108;
pub const F_LEAD_ANYELEMENT: u32 = 3109;
pub const F_LEAD_ANYELEMENT_INT4: u32 = 3110;
pub const F_LEAD_ANYCOMPATIBLE_INT4_ANYCOMPATIBLE: u32 = 3111;
pub const F_FIRST_VALUE: u32 = 3112;
pub const F_LAST_VALUE: u32 = 3113;
pub const F_NTH_VALUE: u32 = 3114;
pub const F_FDW_HANDLER_IN: u32 = 3116;
pub const F_FDW_HANDLER_OUT: u32 = 3117;
pub const F_VOID_RECV: u32 = 3120;
pub const F_VOID_SEND: u32 = 3121;
pub const F_BTINT2SORTSUPPORT: u32 = 3129;
pub const F_BTINT4SORTSUPPORT: u32 = 3130;
pub const F_BTINT8SORTSUPPORT: u32 = 3131;
pub const F_BTFLOAT4SORTSUPPORT: u32 = 3132;
pub const F_BTFLOAT8SORTSUPPORT: u32 = 3133;
pub const F_BTOIDSORTSUPPORT: u32 = 3134;
pub const F_BTNAMESORTSUPPORT: u32 = 3135;
pub const F_DATE_SORTSUPPORT: u32 = 3136;
pub const F_TIMESTAMP_SORTSUPPORT: u32 = 3137;
pub const F_HAS_TYPE_PRIVILEGE_NAME_TEXT_TEXT: u32 = 3138;
pub const F_HAS_TYPE_PRIVILEGE_NAME_OID_TEXT: u32 = 3139;
pub const F_HAS_TYPE_PRIVILEGE_OID_TEXT_TEXT: u32 = 3140;
pub const F_HAS_TYPE_PRIVILEGE_OID_OID_TEXT: u32 = 3141;
pub const F_HAS_TYPE_PRIVILEGE_TEXT_TEXT: u32 = 3142;
pub const F_HAS_TYPE_PRIVILEGE_OID_TEXT: u32 = 3143;
pub const F_MACADDR_NOT: u32 = 3144;
pub const F_MACADDR_AND: u32 = 3145;
pub const F_MACADDR_OR: u32 = 3146;
pub const F_PG_STAT_GET_DB_TEMP_FILES: u32 = 3150;
pub const F_PG_STAT_GET_DB_TEMP_BYTES: u32 = 3151;
pub const F_PG_STAT_GET_DB_DEADLOCKS: u32 = 3152;
pub const F_ARRAY_TO_JSON_ANYARRAY: u32 = 3153;
pub const F_ARRAY_TO_JSON_ANYARRAY_BOOL: u32 = 3154;
pub const F_ROW_TO_JSON_RECORD: u32 = 3155;
pub const F_ROW_TO_JSON_RECORD_BOOL: u32 = 3156;
pub const F_NUMERIC_SUPPORT: u32 = 3157;
pub const F_VARBIT_SUPPORT: u32 = 3158;
pub const F_PG_GET_VIEWDEF_OID_INT4: u32 = 3159;
pub const F_PG_STAT_GET_CHECKPOINTER_WRITE_TIME: u32 = 3160;
pub const F_PG_STAT_GET_CHECKPOINTER_SYNC_TIME: u32 = 3161;
pub const F_PG_COLLATION_FOR: u32 = 3162;
pub const F_PG_TRIGGER_DEPTH: u32 = 3163;
pub const F_PG_WAL_LSN_DIFF: u32 = 3165;
pub const F_PG_SIZE_PRETTY_NUMERIC: u32 = 3166;
pub const F_ARRAY_REMOVE: u32 = 3167;
pub const F_ARRAY_REPLACE: u32 = 3168;
pub const F_RANGESEL: u32 = 3169;
pub const F_LO_LSEEK64: u32 = 3170;
pub const F_LO_TELL64: u32 = 3171;
pub const F_LO_TRUNCATE64: u32 = 3172;
pub const F_JSON_AGG_TRANSFN: u32 = 3173;
pub const F_JSON_AGG_FINALFN: u32 = 3174;
pub const F_JSON_AGG: u32 = 3175;
pub const F_TO_JSON: u32 = 3176;
pub const F_PG_STAT_GET_MOD_SINCE_ANALYZE: u32 = 3177;
pub const F_NUMERIC_SUM: u32 = 3178;
pub const F_CARDINALITY: u32 = 3179;
pub const F_JSON_OBJECT_AGG_TRANSFN: u32 = 3180;
pub const F_RECORD_IMAGE_EQ: u32 = 3181;
pub const F_RECORD_IMAGE_NE: u32 = 3182;
pub const F_RECORD_IMAGE_LT: u32 = 3183;
pub const F_RECORD_IMAGE_GT: u32 = 3184;
pub const F_RECORD_IMAGE_LE: u32 = 3185;
pub const F_RECORD_IMAGE_GE: u32 = 3186;
pub const F_BTRECORDIMAGECMP: u32 = 3187;
pub const F_PG_STAT_GET_ARCHIVER: u32 = 3195;
pub const F_JSON_OBJECT_AGG_FINALFN: u32 = 3196;
pub const F_JSON_OBJECT_AGG: u32 = 3197;
pub const F_JSON_BUILD_ARRAY_ANY: u32 = 3198;
pub const F_JSON_BUILD_ARRAY_: u32 = 3199;
pub const F_JSON_BUILD_OBJECT_ANY: u32 = 3200;
pub const F_JSON_BUILD_OBJECT_: u32 = 3201;
pub const F_JSON_OBJECT__TEXT: u32 = 3202;
pub const F_JSON_OBJECT__TEXT__TEXT: u32 = 3203;
pub const F_JSON_TO_RECORD: u32 = 3204;
pub const F_JSON_TO_RECORDSET: u32 = 3205;
pub const F_JSONB_ARRAY_LENGTH: u32 = 3207;
pub const F_JSONB_EACH: u32 = 3208;
pub const F_JSONB_POPULATE_RECORD: u32 = 3209;
pub const F_JSONB_TYPEOF: u32 = 3210;
pub const F_JSONB_OBJECT_FIELD_TEXT: u32 = 3214;
pub const F_JSONB_ARRAY_ELEMENT: u32 = 3215;
pub const F_JSONB_ARRAY_ELEMENT_TEXT: u32 = 3216;
pub const F_JSONB_EXTRACT_PATH: u32 = 3217;
pub const F_WIDTH_BUCKET_ANYCOMPATIBLE_ANYCOMPATIBLEARRAY: u32 = 3218;
pub const F_JSONB_ARRAY_ELEMENTS: u32 = 3219;
pub const F_PG_LSN_IN: u32 = 3229;
pub const F_PG_LSN_OUT: u32 = 3230;
pub const F_PG_LSN_LT: u32 = 3231;
pub const F_PG_LSN_LE: u32 = 3232;
pub const F_PG_LSN_EQ: u32 = 3233;
pub const F_PG_LSN_GE: u32 = 3234;
pub const F_PG_LSN_GT: u32 = 3235;
pub const F_PG_LSN_NE: u32 = 3236;
pub const F_PG_LSN_MI: u32 = 3237;
pub const F_PG_LSN_RECV: u32 = 3238;
pub const F_PG_LSN_SEND: u32 = 3239;
pub const F_PG_LSN_CMP: u32 = 3251;
pub const F_PG_LSN_HASH: u32 = 3252;
pub const F_BTTEXTSORTSUPPORT: u32 = 3255;
pub const F_GENERATE_SERIES_NUMERIC_NUMERIC_NUMERIC: u32 = 3259;
pub const F_GENERATE_SERIES_NUMERIC_NUMERIC: u32 = 3260;
pub const F_JSON_STRIP_NULLS: u32 = 3261;
pub const F_JSONB_STRIP_NULLS: u32 = 3262;
pub const F_JSONB_OBJECT__TEXT: u32 = 3263;
pub const F_JSONB_OBJECT__TEXT__TEXT: u32 = 3264;
pub const F_JSONB_AGG_TRANSFN: u32 = 3265;
pub const F_JSONB_AGG_FINALFN: u32 = 3266;
pub const F_JSONB_AGG: u32 = 3267;
pub const F_JSONB_OBJECT_AGG_TRANSFN: u32 = 3268;
pub const F_JSONB_OBJECT_AGG_FINALFN: u32 = 3269;
pub const F_JSONB_OBJECT_AGG: u32 = 3270;
pub const F_JSONB_BUILD_ARRAY_ANY: u32 = 3271;
pub const F_JSONB_BUILD_ARRAY_: u32 = 3272;
pub const F_JSONB_BUILD_OBJECT_ANY: u32 = 3273;
pub const F_JSONB_BUILD_OBJECT_: u32 = 3274;
pub const F_DIST_PPOLY: u32 = 3275;
pub const F_ARRAY_POSITION_ANYCOMPATIBLEARRAY_ANYCOMPATIBLE: u32 = 3277;
pub const F_ARRAY_POSITION_ANYCOMPATIBLEARRAY_ANYCOMPATIBLE_INT4: u32 = 3278;
pub const F_ARRAY_POSITIONS: u32 = 3279;
pub const F_GIST_CIRCLE_DISTANCE: u32 = 3280;
pub const F_SCALE: u32 = 3281;
pub const F_GIST_POINT_FETCH: u32 = 3282;
pub const F_NUMERIC_SORTSUPPORT: u32 = 3283;
pub const F_GIST_POLY_DISTANCE: u32 = 3288;
pub const F_DIST_CPOINT: u32 = 3290;
pub const F_DIST_POLYP: u32 = 3292;
pub const F_PG_READ_FILE_TEXT_INT8_INT8_BOOL: u32 = 3293;
pub const F_CURRENT_SETTING_TEXT_BOOL: u32 = 3294;
pub const F_PG_READ_BINARY_FILE_TEXT_INT8_INT8_BOOL: u32 = 3295;
pub const F_PG_NOTIFICATION_QUEUE_USAGE: u32 = 3296;
pub const F_PG_LS_DIR_TEXT_BOOL_BOOL: u32 = 3297;
pub const F_ROW_SECURITY_ACTIVE_OID: Oid = Oid(3298);
pub const F_ROW_SECURITY_ACTIVE_TEXT: u32 = 3299;
pub const F_UUID_SORTSUPPORT: u32 = 3300;
pub const F_JSONB_CONCAT: u32 = 3301;
pub const F_JSONB_DELETE_JSONB_TEXT: u32 = 3302;
pub const F_JSONB_DELETE_JSONB_INT4: u32 = 3303;
pub const F_JSONB_DELETE_PATH: u32 = 3304;
pub const F_JSONB_SET: u32 = 3305;
pub const F_JSONB_PRETTY: u32 = 3306;
pub const F_PG_STAT_FILE_TEXT_BOOL: u32 = 3307;
pub const F_XIDNEQ: u32 = 3308;
pub const F_XIDNEQINT4: u32 = 3309;
pub const F_TSM_HANDLER_IN: u32 = 3311;
pub const F_TSM_HANDLER_OUT: u32 = 3312;
pub const F_BERNOULLI: u32 = 3313;
pub const F_SYSTEM: u32 = 3314;
pub const F_PG_STAT_GET_WAL_RECEIVER: u32 = 3317;
pub const F_PG_STAT_GET_PROGRESS_INFO: u32 = 3318;
pub const F_TS_FILTER: u32 = 3319;
pub const F_SETWEIGHT_TSVECTOR_CHAR__TEXT: u32 = 3320;
pub const F_TS_DELETE_TSVECTOR_TEXT: u32 = 3321;
pub const F_UNNEST_TSVECTOR: u32 = 3322;
pub const F_TS_DELETE_TSVECTOR__TEXT: u32 = 3323;
pub const F_INT4_AVG_COMBINE: u32 = 3324;
pub const F_INTERVAL_AVG_COMBINE: u32 = 3325;
pub const F_TSVECTOR_TO_ARRAY: u32 = 3326;
pub const F_ARRAY_TO_TSVECTOR: u32 = 3327;
pub const F_BPCHAR_SORTSUPPORT: u32 = 3328;
pub const F_PG_SHOW_ALL_FILE_SETTINGS: u32 = 3329;
pub const F_PG_CURRENT_WAL_FLUSH_LSN: u32 = 3330;
pub const F_BYTEA_SORTSUPPORT: u32 = 3331;
pub const F_BTTEXT_PATTERN_SORTSUPPORT: u32 = 3332;
pub const F_BTBPCHAR_PATTERN_SORTSUPPORT: u32 = 3333;
pub const F_PG_SIZE_BYTES: u32 = 3334;
pub const F_NUMERIC_SERIALIZE: u32 = 3335;
pub const F_NUMERIC_DESERIALIZE: u32 = 3336;
pub const F_NUMERIC_AVG_COMBINE: u32 = 3337;
pub const F_NUMERIC_POLY_COMBINE: u32 = 3338;
pub const F_NUMERIC_POLY_SERIALIZE: u32 = 3339;
pub const F_NUMERIC_POLY_DESERIALIZE: u32 = 3340;
pub const F_NUMERIC_COMBINE: u32 = 3341;
pub const F_FLOAT8_REGR_COMBINE: u32 = 3342;
pub const F_JSONB_DELETE_JSONB__TEXT: u32 = 3343;
pub const F_CASH_MUL_INT8: u32 = 3344;
pub const F_CASH_DIV_INT8: u32 = 3345;
pub const F_TXID_CURRENT_IF_ASSIGNED: u32 = 3348;
pub const F_PG_GET_PARTKEYDEF: u32 = 3352;
pub const F_PG_LS_LOGDIR: u32 = 3353;
pub const F_PG_LS_WALDIR: u32 = 3354;
pub const F_PG_NDISTINCT_IN: u32 = 3355;
pub const F_PG_NDISTINCT_OUT: u32 = 3356;
pub const F_PG_NDISTINCT_RECV: u32 = 3357;
pub const F_PG_NDISTINCT_SEND: u32 = 3358;
pub const F_MACADDR_SORTSUPPORT: u32 = 3359;
pub const F_TXID_STATUS: u32 = 3360;
pub const F_PG_SAFE_SNAPSHOT_BLOCKING_PIDS: u32 = 3376;
pub const F_PG_ISOLATION_TEST_SESSION_IS_BLOCKED: u32 = 3378;
pub const F_PG_IDENTIFY_OBJECT_AS_ADDRESS: u32 = 3382;
pub const F_BRIN_MINMAX_OPCINFO: u32 = 3383;
pub const F_BRIN_MINMAX_ADD_VALUE: u32 = 3384;
pub const F_BRIN_MINMAX_CONSISTENT: u32 = 3385;
pub const F_BRIN_MINMAX_UNION: u32 = 3386;
pub const F_INT8_AVG_ACCUM_INV: u32 = 3387;
pub const F_NUMERIC_POLY_SUM: u32 = 3388;
pub const F_NUMERIC_POLY_AVG: u32 = 3389;
pub const F_NUMERIC_POLY_VAR_POP: u32 = 3390;
pub const F_NUMERIC_POLY_VAR_SAMP: u32 = 3391;
pub const F_NUMERIC_POLY_STDDEV_POP: u32 = 3392;
pub const F_NUMERIC_POLY_STDDEV_SAMP: u32 = 3393;
pub const F_REGEXP_MATCH_TEXT_TEXT: u32 = 3396;
pub const F_REGEXP_MATCH_TEXT_TEXT_TEXT: u32 = 3397;
pub const F_INT8_MUL_CASH: u32 = 3399;
pub const F_PG_CONFIG: u32 = 3400;
pub const F_PG_HBA_FILE_RULES: u32 = 3401;
pub const F_PG_STATISTICS_OBJ_IS_VISIBLE: u32 = 3403;
pub const F_PG_DEPENDENCIES_IN: u32 = 3404;
pub const F_PG_DEPENDENCIES_OUT: u32 = 3405;
pub const F_PG_DEPENDENCIES_RECV: u32 = 3406;
pub const F_PG_DEPENDENCIES_SEND: u32 = 3407;
pub const F_PG_GET_PARTITION_CONSTRAINTDEF: u32 = 3408;
pub const F_TIME_HASH_EXTENDED: u32 = 3409;
pub const F_TIMETZ_HASH_EXTENDED: u32 = 3410;
pub const F_TIMESTAMP_HASH_EXTENDED: u32 = 3411;
pub const F_UUID_HASH_EXTENDED: u32 = 3412;
pub const F_PG_LSN_HASH_EXTENDED: u32 = 3413;
pub const F_HASHENUMEXTENDED: u32 = 3414;
pub const F_PG_GET_STATISTICSOBJDEF: u32 = 3415;
pub const F_JSONB_HASH_EXTENDED: u32 = 3416;
pub const F_HASH_RANGE_EXTENDED: u32 = 3417;
pub const F_INTERVAL_HASH_EXTENDED: u32 = 3418;
pub const F_SHA224: u32 = 3419;
pub const F_SHA256: u32 = 3420;
pub const F_SHA384: u32 = 3421;
pub const F_SHA512: u32 = 3422;
pub const F_PG_PARTITION_TREE: u32 = 3423;
pub const F_PG_PARTITION_ROOT: u32 = 3424;
pub const F_PG_PARTITION_ANCESTORS: u32 = 3425;
pub const F_PG_STAT_GET_DB_CHECKSUM_FAILURES: u32 = 3426;
pub const F_PG_MCV_LIST_ITEMS: u32 = 3427;
pub const F_PG_STAT_GET_DB_CHECKSUM_LAST_FAILURE: u32 = 3428;
pub const F_GEN_RANDOM_UUID: u32 = 3432;
pub const F_GTSVECTOR_OPTIONS: u32 = 3434;
pub const F_GIST_POINT_SORTSUPPORT: u32 = 3435;
pub const F_PG_PROMOTE: u32 = 3436;
pub const F_PREFIXSEL: u32 = 3437;
pub const F_PREFIXJOINSEL: u32 = 3438;
pub const F_PG_CONTROL_SYSTEM: u32 = 3441;
pub const F_PG_CONTROL_CHECKPOINT: u32 = 3442;
pub const F_PG_CONTROL_RECOVERY: u32 = 3443;
pub const F_PG_CONTROL_INIT: u32 = 3444;
pub const F_PG_IMPORT_SYSTEM_COLLATIONS: u32 = 3445;
pub const F_MACADDR8_RECV: u32 = 3446;
pub const F_MACADDR8_SEND: u32 = 3447;
pub const F_PG_COLLATION_ACTUAL_VERSION: u32 = 3448;
pub const F_NUMERIC_JSONB: u32 = 3449;
pub const F_INT2_JSONB: u32 = 3450;
pub const F_INT4_JSONB: u32 = 3451;
pub const F_INT8_JSONB: u32 = 3452;
pub const F_FLOAT4_JSONB: u32 = 3453;
pub const F_PG_FILENODE_RELATION: u32 = 3454;
pub const F_LO_FROM_BYTEA: u32 = 3457;
pub const F_LO_GET_OID: Oid = Oid(3458);
pub const F_LO_GET_OID_INT8_INT4: u32 = 3459;
pub const F_LO_PUT: u32 = 3460;
pub const F_MAKE_TIMESTAMP: u32 = 3461;
pub const F_MAKE_TIMESTAMPTZ_INT4_INT4_INT4_INT4_INT4_FLOAT8: u32 = 3462;
pub const F_MAKE_TIMESTAMPTZ_INT4_INT4_INT4_INT4_INT4_FLOAT8_TEXT: u32 = 3463;
pub const F_MAKE_INTERVAL: u32 = 3464;
pub const F_JSONB_ARRAY_ELEMENTS_TEXT: u32 = 3465;
pub const F_SPG_RANGE_QUAD_CONFIG: u32 = 3469;
pub const F_SPG_RANGE_QUAD_CHOOSE: u32 = 3470;
pub const F_SPG_RANGE_QUAD_PICKSPLIT: u32 = 3471;
pub const F_SPG_RANGE_QUAD_INNER_CONSISTENT: u32 = 3472;
pub const F_SPG_RANGE_QUAD_LEAF_CONSISTENT: u32 = 3473;
pub const F_JSONB_POPULATE_RECORDSET: u32 = 3475;
pub const F_TO_REGOPERATOR: u32 = 3476;
pub const F_JSONB_OBJECT_FIELD: u32 = 3478;
pub const F_TO_REGPROCEDURE: u32 = 3479;
pub const F_GIN_COMPARE_JSONB: u32 = 3480;
pub const F_GIN_EXTRACT_JSONB: u32 = 3482;
pub const F_GIN_EXTRACT_JSONB_QUERY: u32 = 3483;
pub const F_GIN_CONSISTENT_JSONB: u32 = 3484;
pub const F_GIN_EXTRACT_JSONB_PATH: u32 = 3485;
pub const F_GIN_EXTRACT_JSONB_QUERY_PATH: u32 = 3486;
pub const F_GIN_CONSISTENT_JSONB_PATH: u32 = 3487;
pub const F_GIN_TRICONSISTENT_JSONB: u32 = 3488;
pub const F_GIN_TRICONSISTENT_JSONB_PATH: u32 = 3489;
pub const F_JSONB_TO_RECORD: u32 = 3490;
pub const F_JSONB_TO_RECORDSET: u32 = 3491;
pub const F_TO_REGOPER: u32 = 3492;
pub const F_TO_REGTYPE: u32 = 3493;
pub const F_TO_REGPROC: u32 = 3494;
pub const F_TO_REGCLASS: u32 = 3495;
pub const F_BOOL_ACCUM: u32 = 3496;
pub const F_BOOL_ACCUM_INV: u32 = 3497;
pub const F_BOOL_ALLTRUE: u32 = 3498;
pub const F_BOOL_ANYTRUE: u32 = 3499;
pub const F_ANYENUM_IN: u32 = 3504;
pub const F_ANYENUM_OUT: u32 = 3505;
pub const F_ENUM_IN: u32 = 3506;
pub const F_ENUM_OUT: u32 = 3507;
pub const F_ENUM_EQ: u32 = 3508;
pub const F_ENUM_NE: u32 = 3509;
pub const F_ENUM_LT: u32 = 3510;
pub const F_ENUM_GT: u32 = 3511;
pub const F_ENUM_LE: u32 = 3512;
pub const F_ENUM_GE: u32 = 3513;
pub const F_ENUM_CMP: u32 = 3514;
pub const F_HASHENUM: u32 = 3515;
pub const F_ENUM_SMALLER: u32 = 3524;
pub const F_ENUM_LARGER: u32 = 3525;
pub const F_MAX_ANYENUM: u32 = 3526;
pub const F_MIN_ANYENUM: u32 = 3527;
pub const F_ENUM_FIRST: u32 = 3528;
pub const F_ENUM_LAST: u32 = 3529;
pub const F_ENUM_RANGE_ANYENUM_ANYENUM: u32 = 3530;
pub const F_ENUM_RANGE_ANYENUM: u32 = 3531;
pub const F_ENUM_RECV: u32 = 3532;
pub const F_ENUM_SEND: u32 = 3533;
pub const F_STRING_AGG_TRANSFN: u32 = 3535;
pub const F_STRING_AGG_FINALFN: u32 = 3536;
pub const F_PG_DESCRIBE_OBJECT: u32 = 3537;
pub const F_STRING_AGG_TEXT_TEXT: u32 = 3538;
pub const F_FORMAT_TEXT_ANY: u32 = 3539;
pub const F_FORMAT_TEXT: u32 = 3540;
pub const F_BYTEA_STRING_AGG_TRANSFN: u32 = 3543;
pub const F_BYTEA_STRING_AGG_FINALFN: u32 = 3544;
pub const F_STRING_AGG_BYTEA_BYTEA: u32 = 3545;
pub const F_INT8DEC: u32 = 3546;
pub const F_INT8DEC_ANY: u32 = 3547;
pub const F_NUMERIC_ACCUM_INV: u32 = 3548;
pub const F_INTERVAL_AVG_ACCUM_INV: u32 = 3549;
pub const F_NETWORK_OVERLAP: u32 = 3551;
pub const F_INET_GIST_CONSISTENT: u32 = 3553;
pub const F_INET_GIST_UNION: u32 = 3554;
pub const F_INET_GIST_COMPRESS: u32 = 3555;
pub const F_BOOL_JSONB: u32 = 3556;
pub const F_INET_GIST_PENALTY: u32 = 3557;
pub const F_INET_GIST_PICKSPLIT: u32 = 3558;
pub const F_INET_GIST_SAME: u32 = 3559;
pub const F_NETWORKSEL: u32 = 3560;
pub const F_NETWORKJOINSEL: u32 = 3561;
pub const F_NETWORK_LARGER: u32 = 3562;
pub const F_NETWORK_SMALLER: u32 = 3563;
pub const F_MAX_INET: u32 = 3564;
pub const F_MIN_INET: u32 = 3565;
pub const F_PG_EVENT_TRIGGER_DROPPED_OBJECTS: u32 = 3566;
pub const F_INT2_ACCUM_INV: u32 = 3567;
pub const F_INT4_ACCUM_INV: u32 = 3568;
pub const F_INT8_ACCUM_INV: u32 = 3569;
pub const F_INT2_AVG_ACCUM_INV: u32 = 3570;
pub const F_INT4_AVG_ACCUM_INV: u32 = 3571;
pub const F_INT2INT4_SUM: u32 = 3572;
pub const F_INET_GIST_FETCH: u32 = 3573;
pub const F_PG_LOGICAL_EMIT_MESSAGE_BOOL_TEXT_TEXT_BOOL: u32 = 3577;
pub const F_PG_LOGICAL_EMIT_MESSAGE_BOOL_TEXT_BYTEA_BOOL: u32 = 3578;
pub const F_JSONB_INSERT: u32 = 3579;
pub const F_PG_XACT_COMMIT_TIMESTAMP: u32 = 3581;
pub const F_BINARY_UPGRADE_SET_NEXT_PG_TYPE_OID: Oid = Oid(3582);
pub const F_PG_LAST_COMMITTED_XACT: u32 = 3583;
pub const F_BINARY_UPGRADE_SET_NEXT_ARRAY_PG_TYPE_OID: Oid = Oid(3584);
pub const F_BINARY_UPGRADE_SET_NEXT_HEAP_PG_CLASS_OID: Oid = Oid(3586);
pub const F_BINARY_UPGRADE_SET_NEXT_INDEX_PG_CLASS_OID: Oid = Oid(3587);
pub const F_BINARY_UPGRADE_SET_NEXT_TOAST_PG_CLASS_OID: Oid = Oid(3588);
pub const F_BINARY_UPGRADE_SET_NEXT_PG_ENUM_OID: Oid = Oid(3589);
pub const F_BINARY_UPGRADE_SET_NEXT_PG_AUTHID_OID: Oid = Oid(3590);
pub const F_BINARY_UPGRADE_CREATE_EMPTY_EXTENSION: u32 = 3591;
pub const F_EVENT_TRIGGER_IN: u32 = 3594;
pub const F_EVENT_TRIGGER_OUT: u32 = 3595;
pub const F_TSVECTORIN: u32 = 3610;
pub const F_TSVECTOROUT: u32 = 3611;
pub const F_TSQUERYIN: u32 = 3612;
pub const F_TSQUERYOUT: u32 = 3613;
pub const F_TSVECTOR_LT: u32 = 3616;
pub const F_TSVECTOR_LE: u32 = 3617;
pub const F_TSVECTOR_EQ: u32 = 3618;
pub const F_TSVECTOR_NE: u32 = 3619;
pub const F_TSVECTOR_GE: u32 = 3620;
pub const F_TSVECTOR_GT: u32 = 3621;
pub const F_TSVECTOR_CMP: u32 = 3622;
pub const F_STRIP: u32 = 3623;
pub const F_SETWEIGHT_TSVECTOR_CHAR: u32 = 3624;
pub const F_TSVECTOR_CONCAT: u32 = 3625;
pub const F_TS_MATCH_VQ: u32 = 3634;
pub const F_TS_MATCH_QV: u32 = 3635;
pub const F_TSVECTORSEND: u32 = 3638;
pub const F_TSVECTORRECV: u32 = 3639;
pub const F_TSQUERYSEND: u32 = 3640;
pub const F_TSQUERYRECV: u32 = 3641;
pub const F_GTSVECTORIN: u32 = 3646;
pub const F_GTSVECTOROUT: u32 = 3647;
pub const F_GTSVECTOR_COMPRESS: u32 = 3648;
pub const F_GTSVECTOR_DECOMPRESS: u32 = 3649;
pub const F_GTSVECTOR_PICKSPLIT: u32 = 3650;
pub const F_GTSVECTOR_UNION: u32 = 3651;
pub const F_GTSVECTOR_SAME: u32 = 3652;
pub const F_GTSVECTOR_PENALTY: u32 = 3653;
pub const F_GTSVECTOR_CONSISTENT_INTERNAL_TSVECTOR_INT2_OID_INTERNAL: u32 = 3654;
pub const F_GIN_EXTRACT_TSVECTOR_TSVECTOR_INTERNAL_INTERNAL: u32 = 3656;
pub const F_GIN_EXTRACT_TSQUERY_TSVECTOR_INTERNAL_INT2_INTERNAL_INTERNAL_INTERNAL_INTERNAL: u32 =
    3657;
pub const F_GIN_TSQUERY_CONSISTENT_INTERNAL_INT2_TSVECTOR_INT4_INTERNAL_INTERNAL_INTERNAL_INTERNAL : u32 = 3658 ;
pub const F_TSQUERY_LT: u32 = 3662;
pub const F_TSQUERY_LE: u32 = 3663;
pub const F_TSQUERY_EQ: u32 = 3664;
pub const F_TSQUERY_NE: u32 = 3665;
pub const F_TSQUERY_GE: u32 = 3666;
pub const F_TSQUERY_GT: u32 = 3667;
pub const F_TSQUERY_CMP: u32 = 3668;
pub const F_TSQUERY_AND: u32 = 3669;
pub const F_TSQUERY_OR: u32 = 3670;
pub const F_TSQUERY_NOT: u32 = 3671;
pub const F_NUMNODE: u32 = 3672;
pub const F_QUERYTREE: u32 = 3673;
pub const F_TS_REWRITE_TSQUERY_TSQUERY_TSQUERY: u32 = 3684;
pub const F_TS_REWRITE_TSQUERY_TEXT: u32 = 3685;
pub const F_TSMATCHSEL: u32 = 3686;
pub const F_TSMATCHJOINSEL: u32 = 3687;
pub const F_TS_TYPANALYZE: u32 = 3688;
pub const F_TS_STAT_TEXT: u32 = 3689;
pub const F_TS_STAT_TEXT_TEXT: u32 = 3690;
pub const F_TSQ_MCONTAINS: u32 = 3691;
pub const F_TSQ_MCONTAINED: u32 = 3692;
pub const F_GTSQUERY_COMPRESS: u32 = 3695;
pub const F_STARTS_WITH: u32 = 3696;
pub const F_GTSQUERY_PICKSPLIT: u32 = 3697;
pub const F_GTSQUERY_UNION: u32 = 3698;
pub const F_GTSQUERY_SAME: u32 = 3699;
pub const F_GTSQUERY_PENALTY: u32 = 3700;
pub const F_GTSQUERY_CONSISTENT_INTERNAL_TSQUERY_INT2_OID_INTERNAL: u32 = 3701;
pub const F_TS_RANK__FLOAT4_TSVECTOR_TSQUERY_INT4: u32 = 3703;
pub const F_TS_RANK__FLOAT4_TSVECTOR_TSQUERY: u32 = 3704;
pub const F_TS_RANK_TSVECTOR_TSQUERY_INT4: u32 = 3705;
pub const F_TS_RANK_TSVECTOR_TSQUERY: u32 = 3706;
pub const F_TS_RANK_CD__FLOAT4_TSVECTOR_TSQUERY_INT4: u32 = 3707;
pub const F_TS_RANK_CD__FLOAT4_TSVECTOR_TSQUERY: u32 = 3708;
pub const F_TS_RANK_CD_TSVECTOR_TSQUERY_INT4: u32 = 3709;
pub const F_TS_RANK_CD_TSVECTOR_TSQUERY: u32 = 3710;
pub const F_LENGTH_TSVECTOR: u32 = 3711;
pub const F_TS_TOKEN_TYPE_OID: Oid = Oid(3713);
pub const F_TS_TOKEN_TYPE_TEXT: u32 = 3714;
pub const F_TS_PARSE_OID_TEXT: u32 = 3715;
pub const F_TS_PARSE_TEXT_TEXT: u32 = 3716;
pub const F_PRSD_START: u32 = 3717;
pub const F_PRSD_NEXTTOKEN: u32 = 3718;
pub const F_PRSD_END: u32 = 3719;
pub const F_PRSD_HEADLINE: u32 = 3720;
pub const F_PRSD_LEXTYPE: u32 = 3721;
pub const F_TS_LEXIZE: u32 = 3723;
pub const F_GIN_CMP_TSLEXEME: u32 = 3724;
pub const F_DSIMPLE_INIT: u32 = 3725;
pub const F_DSIMPLE_LEXIZE: u32 = 3726;
pub const F_DSYNONYM_INIT: u32 = 3728;
pub const F_DSYNONYM_LEXIZE: u32 = 3729;
pub const F_DISPELL_INIT: u32 = 3731;
pub const F_DISPELL_LEXIZE: u32 = 3732;
pub const F_REGCONFIGIN: u32 = 3736;
pub const F_REGCONFIGOUT: u32 = 3737;
pub const F_REGCONFIGRECV: u32 = 3738;
pub const F_REGCONFIGSEND: u32 = 3739;
pub const F_THESAURUS_INIT: u32 = 3740;
pub const F_THESAURUS_LEXIZE: u32 = 3741;
pub const F_TS_HEADLINE_REGCONFIG_TEXT_TSQUERY_TEXT: u32 = 3743;
pub const F_TS_HEADLINE_REGCONFIG_TEXT_TSQUERY: u32 = 3744;
pub const F_TO_TSVECTOR_REGCONFIG_TEXT: u32 = 3745;
pub const F_TO_TSQUERY_REGCONFIG_TEXT: u32 = 3746;
pub const F_PLAINTO_TSQUERY_REGCONFIG_TEXT: u32 = 3747;
pub const F_TO_TSVECTOR_TEXT: u32 = 3749;
pub const F_TO_TSQUERY_TEXT: u32 = 3750;
pub const F_PLAINTO_TSQUERY_TEXT: u32 = 3751;
pub const F_TSVECTOR_UPDATE_TRIGGER: u32 = 3752;
pub const F_TSVECTOR_UPDATE_TRIGGER_COLUMN: u32 = 3753;
pub const F_TS_HEADLINE_TEXT_TSQUERY_TEXT: u32 = 3754;
pub const F_TS_HEADLINE_TEXT_TSQUERY: u32 = 3755;
pub const F_PG_TS_PARSER_IS_VISIBLE: u32 = 3756;
pub const F_PG_TS_DICT_IS_VISIBLE: u32 = 3757;
pub const F_PG_TS_CONFIG_IS_VISIBLE: u32 = 3758;
pub const F_GET_CURRENT_TS_CONFIG: u32 = 3759;
pub const F_TS_MATCH_TT: u32 = 3760;
pub const F_TS_MATCH_TQ: u32 = 3761;
pub const F_PG_TS_TEMPLATE_IS_VISIBLE: u32 = 3768;
pub const F_REGDICTIONARYIN: u32 = 3771;
pub const F_REGDICTIONARYOUT: u32 = 3772;
pub const F_REGDICTIONARYRECV: u32 = 3773;
pub const F_REGDICTIONARYSEND: u32 = 3774;
pub const F_PG_STAT_RESET_SHARED: u32 = 3775;
pub const F_PG_STAT_RESET_SINGLE_TABLE_COUNTERS: u32 = 3776;
pub const F_PG_STAT_RESET_SINGLE_FUNCTION_COUNTERS: u32 = 3777;
pub const F_PG_TABLESPACE_LOCATION: u32 = 3778;
pub const F_PG_CREATE_PHYSICAL_REPLICATION_SLOT: u32 = 3779;
pub const F_PG_DROP_REPLICATION_SLOT: u32 = 3780;
pub const F_PG_GET_REPLICATION_SLOTS: u32 = 3781;
pub const F_PG_LOGICAL_SLOT_GET_CHANGES: u32 = 3782;
pub const F_PG_LOGICAL_SLOT_GET_BINARY_CHANGES: u32 = 3783;
pub const F_PG_LOGICAL_SLOT_PEEK_CHANGES: u32 = 3784;
pub const F_PG_LOGICAL_SLOT_PEEK_BINARY_CHANGES: u32 = 3785;
pub const F_PG_CREATE_LOGICAL_REPLICATION_SLOT: u32 = 3786;
pub const F_TO_JSONB: u32 = 3787;
pub const F_PG_STAT_GET_SNAPSHOT_TIMESTAMP: u32 = 3788;
pub const F_GIN_CLEAN_PENDING_LIST: u32 = 3789;
pub const F_GTSVECTOR_CONSISTENT_INTERNAL_GTSVECTOR_INT4_OID_INTERNAL: u32 = 3790;
pub const F_GIN_EXTRACT_TSQUERY_TSQUERY_INTERNAL_INT2_INTERNAL_INTERNAL_INTERNAL_INTERNAL: u32 =
    3791;
pub const F_GIN_TSQUERY_CONSISTENT_INTERNAL_INT2_TSQUERY_INT4_INTERNAL_INTERNAL_INTERNAL_INTERNAL : u32 = 3792 ;
pub const F_GTSQUERY_CONSISTENT_INTERNAL_INTERNAL_INT4_OID_INTERNAL: u32 = 3793;
pub const F_INET_SPG_CONFIG: u32 = 3795;
pub const F_INET_SPG_CHOOSE: u32 = 3796;
pub const F_INET_SPG_PICKSPLIT: u32 = 3797;
pub const F_INET_SPG_INNER_CONSISTENT: u32 = 3798;
pub const F_INET_SPG_LEAF_CONSISTENT: u32 = 3799;
pub const F_PG_CURRENT_LOGFILE_: u32 = 3800;
pub const F_PG_CURRENT_LOGFILE_TEXT: u32 = 3801;
pub const F_JSONB_SEND: u32 = 3803;
pub const F_JSONB_OUT: u32 = 3804;
pub const F_JSONB_RECV: u32 = 3805;
pub const F_JSONB_IN: u32 = 3806;
pub const F_PG_GET_FUNCTION_ARG_DEFAULT: u32 = 3808;
pub const F_PG_EXPORT_SNAPSHOT: u32 = 3809;
pub const F_PG_IS_IN_RECOVERY: u32 = 3810;
pub const F_MONEY_INT4: u32 = 3811;
pub const F_MONEY_INT8: u32 = 3812;
pub const F_XMLTEXT: u32 = 3813;
pub const F_PG_COLLATION_IS_VISIBLE: u32 = 3815;
pub const F_ARRAY_TYPANALYZE: u32 = 3816;
pub const F_ARRAYCONTSEL: u32 = 3817;
pub const F_ARRAYCONTJOINSEL: u32 = 3818;
pub const F_PG_GET_MULTIXACT_MEMBERS: u32 = 3819;
pub const F_PG_LAST_WAL_RECEIVE_LSN: u32 = 3820;
pub const F_PG_LAST_WAL_REPLAY_LSN: u32 = 3821;
pub const F_CASH_DIV_CASH: u32 = 3822;
pub const F_NUMERIC_MONEY: u32 = 3823;
pub const F_MONEY_NUMERIC: u32 = 3824;
pub const F_PG_READ_FILE_TEXT: u32 = 3826;
pub const F_PG_READ_BINARY_FILE_TEXT_INT8_INT8: u32 = 3827;
pub const F_PG_READ_BINARY_FILE_TEXT: u32 = 3828;
pub const F_PG_OPFAMILY_IS_VISIBLE: u32 = 3829;
pub const F_PG_LAST_XACT_REPLAY_TIMESTAMP: u32 = 3830;
pub const F_ANYRANGE_IN: u32 = 3832;
pub const F_ANYRANGE_OUT: u32 = 3833;
pub const F_RANGE_IN: u32 = 3834;
pub const F_RANGE_OUT: u32 = 3835;
pub const F_RANGE_RECV: u32 = 3836;
pub const F_RANGE_SEND: u32 = 3837;
pub const F_PG_IDENTIFY_OBJECT: u32 = 3839;
pub const F_INT4RANGE_INT4_INT4: u32 = 3840;
pub const F_INT4RANGE_INT4_INT4_TEXT: u32 = 3841;
pub const F_PG_RELATION_IS_UPDATABLE: u32 = 3842;
pub const F_PG_COLUMN_IS_UPDATABLE: u32 = 3843;
pub const F_NUMRANGE_NUMERIC_NUMERIC: u32 = 3844;
pub const F_NUMRANGE_NUMERIC_NUMERIC_TEXT: u32 = 3845;
pub const F_MAKE_DATE: u32 = 3846;
pub const F_MAKE_TIME: u32 = 3847;
pub const F_LOWER_ANYRANGE: u32 = 3848;
pub const F_UPPER_ANYRANGE: u32 = 3849;
pub const F_ISEMPTY_ANYRANGE: u32 = 3850;
pub const F_LOWER_INC_ANYRANGE: u32 = 3851;
pub const F_UPPER_INC_ANYRANGE: u32 = 3852;
pub const F_LOWER_INF_ANYRANGE: u32 = 3853;
pub const F_UPPER_INF_ANYRANGE: u32 = 3854;
pub const F_RANGE_EQ: u32 = 3855;
pub const F_RANGE_NE: u32 = 3856;
pub const F_RANGE_OVERLAPS: u32 = 3857;
pub const F_RANGE_CONTAINS_ELEM: u32 = 3858;
pub const F_RANGE_CONTAINS: u32 = 3859;
pub const F_ELEM_CONTAINED_BY_RANGE: u32 = 3860;
pub const F_RANGE_CONTAINED_BY: u32 = 3861;
pub const F_RANGE_ADJACENT: u32 = 3862;
pub const F_RANGE_BEFORE: u32 = 3863;
pub const F_RANGE_AFTER: u32 = 3864;
pub const F_RANGE_OVERLEFT: u32 = 3865;
pub const F_RANGE_OVERRIGHT: u32 = 3866;
pub const F_RANGE_UNION: u32 = 3867;
pub const F_RANGE_INTERSECT: u32 = 3868;
pub const F_RANGE_MINUS: u32 = 3869;
pub const F_RANGE_CMP: u32 = 3870;
pub const F_RANGE_LT: u32 = 3871;
pub const F_RANGE_LE: u32 = 3872;
pub const F_RANGE_GE: u32 = 3873;
pub const F_RANGE_GT: u32 = 3874;
pub const F_RANGE_GIST_CONSISTENT: u32 = 3875;
pub const F_RANGE_GIST_UNION: u32 = 3876;
pub const F_PG_REPLICATION_SLOT_ADVANCE: u32 = 3878;
pub const F_RANGE_GIST_PENALTY: u32 = 3879;
pub const F_RANGE_GIST_PICKSPLIT: u32 = 3880;
pub const F_RANGE_GIST_SAME: u32 = 3881;
pub const F_HASH_RANGE: u32 = 3902;
pub const F_INT4RANGE_CANONICAL: u32 = 3914;
pub const F_DATERANGE_CANONICAL: u32 = 3915;
pub const F_RANGE_TYPANALYZE: u32 = 3916;
pub const F_TIMESTAMP_SUPPORT: u32 = 3917;
pub const F_INTERVAL_SUPPORT: u32 = 3918;
pub const F_GINARRAYTRICONSISTENT: u32 = 3920;
pub const F_GIN_TSQUERY_TRICONSISTENT: u32 = 3921;
pub const F_INT4RANGE_SUBDIFF: u32 = 3922;
pub const F_INT8RANGE_SUBDIFF: u32 = 3923;
pub const F_NUMRANGE_SUBDIFF: u32 = 3924;
pub const F_DATERANGE_SUBDIFF: u32 = 3925;
pub const F_INT8RANGE_CANONICAL: u32 = 3928;
pub const F_TSRANGE_SUBDIFF: u32 = 3929;
pub const F_TSTZRANGE_SUBDIFF: u32 = 3930;
pub const F_JSONB_OBJECT_KEYS: u32 = 3931;
pub const F_JSONB_EACH_TEXT: u32 = 3932;
pub const F_TSRANGE_TIMESTAMP_TIMESTAMP: u32 = 3933;
pub const F_TSRANGE_TIMESTAMP_TIMESTAMP_TEXT: u32 = 3934;
pub const F_PG_SLEEP_FOR: u32 = 3935;
pub const F_PG_SLEEP_UNTIL: u32 = 3936;
pub const F_TSTZRANGE_TIMESTAMPTZ_TIMESTAMPTZ: u32 = 3937;
pub const F_TSTZRANGE_TIMESTAMPTZ_TIMESTAMPTZ_TEXT: u32 = 3938;
pub const F_MXID_AGE: u32 = 3939;
pub const F_JSONB_EXTRACT_PATH_TEXT: u32 = 3940;
pub const F_DATERANGE_DATE_DATE: u32 = 3941;
pub const F_DATERANGE_DATE_DATE_TEXT: u32 = 3942;
pub const F_ACLDEFAULT: u32 = 3943;
pub const F_TIME_SUPPORT: u32 = 3944;
pub const F_INT8RANGE_INT8_INT8: u32 = 3945;
pub const F_INT8RANGE_INT8_INT8_TEXT: u32 = 3946;
pub const F_JSON_OBJECT_FIELD: u32 = 3947;
pub const F_JSON_OBJECT_FIELD_TEXT: u32 = 3948;
pub const F_JSON_ARRAY_ELEMENT: u32 = 3949;
pub const F_JSON_ARRAY_ELEMENT_TEXT: u32 = 3950;
pub const F_JSON_EXTRACT_PATH: u32 = 3951;
pub const F_BRIN_SUMMARIZE_NEW_VALUES: u32 = 3952;
pub const F_JSON_EXTRACT_PATH_TEXT: u32 = 3953;
pub const F_PG_GET_OBJECT_ADDRESS: u32 = 3954;
pub const F_JSON_ARRAY_ELEMENTS: u32 = 3955;
pub const F_JSON_ARRAY_LENGTH: u32 = 3956;
pub const F_JSON_OBJECT_KEYS: u32 = 3957;
pub const F_JSON_EACH: u32 = 3958;
pub const F_JSON_EACH_TEXT: u32 = 3959;
pub const F_JSON_POPULATE_RECORD: u32 = 3960;
pub const F_JSON_POPULATE_RECORDSET: u32 = 3961;
pub const F_JSON_TYPEOF: u32 = 3968;
pub const F_JSON_ARRAY_ELEMENTS_TEXT: u32 = 3969;
pub const F_ORDERED_SET_TRANSITION: u32 = 3970;
pub const F_ORDERED_SET_TRANSITION_MULTI: u32 = 3971;
pub const F_PERCENTILE_DISC_FLOAT8_ANYELEMENT: u32 = 3972;
pub const F_PERCENTILE_DISC_FINAL: u32 = 3973;
pub const F_PERCENTILE_CONT_FLOAT8_FLOAT8: u32 = 3974;
pub const F_PERCENTILE_CONT_FLOAT8_FINAL: u32 = 3975;
pub const F_PERCENTILE_CONT_FLOAT8_INTERVAL: u32 = 3976;
pub const F_PERCENTILE_CONT_INTERVAL_FINAL: u32 = 3977;
pub const F_PERCENTILE_DISC__FLOAT8_ANYELEMENT: u32 = 3978;
pub const F_PERCENTILE_DISC_MULTI_FINAL: u32 = 3979;
pub const F_PERCENTILE_CONT__FLOAT8_FLOAT8: u32 = 3980;
pub const F_PERCENTILE_CONT_FLOAT8_MULTI_FINAL: u32 = 3981;
pub const F_PERCENTILE_CONT__FLOAT8_INTERVAL: u32 = 3982;
pub const F_PERCENTILE_CONT_INTERVAL_MULTI_FINAL: u32 = 3983;
pub const F_MODE: u32 = 3984;
pub const F_MODE_FINAL: u32 = 3985;
pub const F_RANK_ANY: u32 = 3986;
pub const F_RANK_FINAL: u32 = 3987;
pub const F_PERCENT_RANK_ANY: u32 = 3988;
pub const F_PERCENT_RANK_FINAL: u32 = 3989;
pub const F_CUME_DIST_ANY: u32 = 3990;
pub const F_CUME_DIST_FINAL: u32 = 3991;
pub const F_DENSE_RANK_ANY: u32 = 3992;
pub const F_DENSE_RANK_FINAL: u32 = 3993;
pub const F_GENERATE_SERIES_INT4_SUPPORT: u32 = 3994;
pub const F_GENERATE_SERIES_INT8_SUPPORT: u32 = 3995;
pub const F_ARRAY_UNNEST_SUPPORT: u32 = 3996;
pub const F_GIST_BOX_DISTANCE: u32 = 3998;
pub const F_BRIN_SUMMARIZE_RANGE: u32 = 3999;
pub const F_JSONPATH_IN: u32 = 4001;
pub const F_JSONPATH_RECV: u32 = 4002;
pub const F_JSONPATH_OUT: u32 = 4003;
pub const F_JSONPATH_SEND: u32 = 4004;
pub const F_JSONB_PATH_EXISTS: u32 = 4005;
pub const F_JSONB_PATH_QUERY: u32 = 4006;
pub const F_JSONB_PATH_QUERY_ARRAY: u32 = 4007;
pub const F_JSONB_PATH_QUERY_FIRST: u32 = 4008;
pub const F_JSONB_PATH_MATCH: u32 = 4009;
pub const F_JSONB_PATH_EXISTS_OPR: u32 = 4010;
pub const F_JSONB_PATH_MATCH_OPR: u32 = 4011;
pub const F_BRIN_DESUMMARIZE_RANGE: u32 = 4014;
pub const F_SPG_QUAD_CONFIG: u32 = 4018;
pub const F_SPG_QUAD_CHOOSE: u32 = 4019;
pub const F_SPG_QUAD_PICKSPLIT: u32 = 4020;
pub const F_SPG_QUAD_INNER_CONSISTENT: u32 = 4021;
pub const F_SPG_QUAD_LEAF_CONSISTENT: u32 = 4022;
pub const F_SPG_KD_CONFIG: u32 = 4023;
pub const F_SPG_KD_CHOOSE: u32 = 4024;
pub const F_SPG_KD_PICKSPLIT: u32 = 4025;
pub const F_SPG_KD_INNER_CONSISTENT: u32 = 4026;
pub const F_SPG_TEXT_CONFIG: u32 = 4027;
pub const F_SPG_TEXT_CHOOSE: u32 = 4028;
pub const F_SPG_TEXT_PICKSPLIT: u32 = 4029;
pub const F_SPG_TEXT_INNER_CONSISTENT: u32 = 4030;
pub const F_SPG_TEXT_LEAF_CONSISTENT: u32 = 4031;
pub const F_PG_SEQUENCE_LAST_VALUE: u32 = 4032;
pub const F_JSONB_NE: u32 = 4038;
pub const F_JSONB_LT: u32 = 4039;
pub const F_JSONB_GT: u32 = 4040;
pub const F_JSONB_LE: u32 = 4041;
pub const F_JSONB_GE: u32 = 4042;
pub const F_JSONB_EQ: u32 = 4043;
pub const F_JSONB_CMP: u32 = 4044;
pub const F_JSONB_HASH: u32 = 4045;
pub const F_JSONB_CONTAINS: u32 = 4046;
pub const F_JSONB_EXISTS: u32 = 4047;
pub const F_JSONB_EXISTS_ANY: u32 = 4048;
pub const F_JSONB_EXISTS_ALL: u32 = 4049;
pub const F_JSONB_CONTAINED: u32 = 4050;
pub const F_ARRAY_AGG_ARRAY_TRANSFN: u32 = 4051;
pub const F_ARRAY_AGG_ARRAY_FINALFN: u32 = 4052;
pub const F_ARRAY_AGG_ANYARRAY: u32 = 4053;
pub const F_RANGE_MERGE_ANYRANGE_ANYRANGE: u32 = 4057;
pub const F_INET_MERGE: u32 = 4063;
pub const F_BOUND_BOX: u32 = 4067;
pub const F_INET_SAME_FAMILY: u32 = 4071;
pub const F_BINARY_UPGRADE_SET_RECORD_INIT_PRIVS: u32 = 4083;
pub const F_REGNAMESPACEIN: u32 = 4084;
pub const F_REGNAMESPACEOUT: u32 = 4085;
pub const F_TO_REGNAMESPACE: u32 = 4086;
pub const F_REGNAMESPACERECV: u32 = 4087;
pub const F_REGNAMESPACESEND: u32 = 4088;
pub const F_BOX_POINT: u32 = 4091;
pub const F_REGROLEOUT: u32 = 4092;
pub const F_TO_REGROLE: u32 = 4093;
pub const F_REGROLERECV: u32 = 4094;
pub const F_REGROLESEND: u32 = 4095;
pub const F_REGROLEIN: u32 = 4098;
pub const F_BINARY_UPGRADE_SET_MISSING_VALUE: u32 = 4101;
pub const F_BRIN_INCLUSION_OPCINFO: u32 = 4105;
pub const F_BRIN_INCLUSION_ADD_VALUE: u32 = 4106;
pub const F_BRIN_INCLUSION_CONSISTENT: u32 = 4107;
pub const F_BRIN_INCLUSION_UNION: u32 = 4108;
pub const F_MACADDR8_IN: u32 = 4110;
pub const F_MACADDR8_OUT: u32 = 4111;
pub const F_TRUNC_MACADDR8: u32 = 4112;
pub const F_MACADDR8_EQ: u32 = 4113;
pub const F_MACADDR8_LT: u32 = 4114;
pub const F_MACADDR8_LE: u32 = 4115;
pub const F_MACADDR8_GT: u32 = 4116;
pub const F_MACADDR8_GE: u32 = 4117;
pub const F_MACADDR8_NE: u32 = 4118;
pub const F_MACADDR8_CMP: u32 = 4119;
pub const F_MACADDR8_NOT: u32 = 4120;
pub const F_MACADDR8_AND: u32 = 4121;
pub const F_MACADDR8_OR: u32 = 4122;
pub const F_MACADDR8: u32 = 4123;
pub const F_MACADDR: u32 = 4124;
pub const F_MACADDR8_SET7BIT: u32 = 4125;
pub const F_IN_RANGE_INT8_INT8_INT8_BOOL_BOOL: u32 = 4126;
pub const F_IN_RANGE_INT4_INT4_INT8_BOOL_BOOL: u32 = 4127;
pub const F_IN_RANGE_INT4_INT4_INT4_BOOL_BOOL: u32 = 4128;
pub const F_IN_RANGE_INT4_INT4_INT2_BOOL_BOOL: u32 = 4129;
pub const F_IN_RANGE_INT2_INT2_INT8_BOOL_BOOL: u32 = 4130;
pub const F_IN_RANGE_INT2_INT2_INT4_BOOL_BOOL: u32 = 4131;
pub const F_IN_RANGE_INT2_INT2_INT2_BOOL_BOOL: u32 = 4132;
pub const F_IN_RANGE_DATE_DATE_INTERVAL_BOOL_BOOL: u32 = 4133;
pub const F_IN_RANGE_TIMESTAMP_TIMESTAMP_INTERVAL_BOOL_BOOL: u32 = 4134;
pub const F_IN_RANGE_TIMESTAMPTZ_TIMESTAMPTZ_INTERVAL_BOOL_BOOL: u32 = 4135;
pub const F_IN_RANGE_INTERVAL_INTERVAL_INTERVAL_BOOL_BOOL: u32 = 4136;
pub const F_IN_RANGE_TIME_TIME_INTERVAL_BOOL_BOOL: u32 = 4137;
pub const F_IN_RANGE_TIMETZ_TIMETZ_INTERVAL_BOOL_BOOL: u32 = 4138;
pub const F_IN_RANGE_FLOAT8_FLOAT8_FLOAT8_BOOL_BOOL: u32 = 4139;
pub const F_IN_RANGE_FLOAT4_FLOAT4_FLOAT8_BOOL_BOOL: u32 = 4140;
pub const F_IN_RANGE_NUMERIC_NUMERIC_NUMERIC_BOOL_BOOL: u32 = 4141;
pub const F_PG_LSN_LARGER: u32 = 4187;
pub const F_PG_LSN_SMALLER: u32 = 4188;
pub const F_MAX_PG_LSN: u32 = 4189;
pub const F_MIN_PG_LSN: u32 = 4190;
pub const F_REGCOLLATIONIN: u32 = 4193;
pub const F_REGCOLLATIONOUT: u32 = 4194;
pub const F_TO_REGCOLLATION: u32 = 4195;
pub const F_REGCOLLATIONRECV: u32 = 4196;
pub const F_REGCOLLATIONSEND: u32 = 4197;
pub const F_TS_HEADLINE_REGCONFIG_JSONB_TSQUERY_TEXT: u32 = 4201;
pub const F_TS_HEADLINE_REGCONFIG_JSONB_TSQUERY: u32 = 4202;
pub const F_TS_HEADLINE_JSONB_TSQUERY_TEXT: u32 = 4203;
pub const F_TS_HEADLINE_JSONB_TSQUERY: u32 = 4204;
pub const F_TS_HEADLINE_REGCONFIG_JSON_TSQUERY_TEXT: u32 = 4205;
pub const F_TS_HEADLINE_REGCONFIG_JSON_TSQUERY: u32 = 4206;
pub const F_TS_HEADLINE_JSON_TSQUERY_TEXT: u32 = 4207;
pub const F_TS_HEADLINE_JSON_TSQUERY: u32 = 4208;
pub const F_TO_TSVECTOR_JSONB: u32 = 4209;
pub const F_TO_TSVECTOR_JSON: u32 = 4210;
pub const F_TO_TSVECTOR_REGCONFIG_JSONB: u32 = 4211;
pub const F_TO_TSVECTOR_REGCONFIG_JSON: u32 = 4212;
pub const F_JSONB_TO_TSVECTOR_JSONB_JSONB: u32 = 4213;
pub const F_JSONB_TO_TSVECTOR_REGCONFIG_JSONB_JSONB: u32 = 4214;
pub const F_JSON_TO_TSVECTOR_JSON_JSONB: u32 = 4215;
pub const F_JSON_TO_TSVECTOR_REGCONFIG_JSON_JSONB: u32 = 4216;
pub const F_PG_COPY_PHYSICAL_REPLICATION_SLOT_NAME_NAME_BOOL: u32 = 4220;
pub const F_PG_COPY_PHYSICAL_REPLICATION_SLOT_NAME_NAME: u32 = 4221;
pub const F_PG_COPY_LOGICAL_REPLICATION_SLOT_NAME_NAME_BOOL_NAME: u32 = 4222;
pub const F_PG_COPY_LOGICAL_REPLICATION_SLOT_NAME_NAME_BOOL: u32 = 4223;
pub const F_PG_COPY_LOGICAL_REPLICATION_SLOT_NAME_NAME: u32 = 4224;
pub const F_ANYCOMPATIBLEMULTIRANGE_IN: u32 = 4226;
pub const F_ANYCOMPATIBLEMULTIRANGE_OUT: u32 = 4227;
pub const F_RANGE_MERGE_ANYMULTIRANGE: u32 = 4228;
pub const F_ANYMULTIRANGE_IN: u32 = 4229;
pub const F_ANYMULTIRANGE_OUT: u32 = 4230;
pub const F_MULTIRANGE_IN: u32 = 4231;
pub const F_MULTIRANGE_OUT: u32 = 4232;
pub const F_MULTIRANGE_RECV: u32 = 4233;
pub const F_MULTIRANGE_SEND: u32 = 4234;
pub const F_LOWER_ANYMULTIRANGE: u32 = 4235;
pub const F_UPPER_ANYMULTIRANGE: u32 = 4236;
pub const F_ISEMPTY_ANYMULTIRANGE: u32 = 4237;
pub const F_LOWER_INC_ANYMULTIRANGE: u32 = 4238;
pub const F_UPPER_INC_ANYMULTIRANGE: u32 = 4239;
pub const F_LOWER_INF_ANYMULTIRANGE: u32 = 4240;
pub const F_UPPER_INF_ANYMULTIRANGE: u32 = 4241;
pub const F_MULTIRANGE_TYPANALYZE: u32 = 4242;
pub const F_MULTIRANGESEL: u32 = 4243;
pub const F_MULTIRANGE_EQ: u32 = 4244;
pub const F_MULTIRANGE_NE: u32 = 4245;
pub const F_RANGE_OVERLAPS_MULTIRANGE: u32 = 4246;
pub const F_MULTIRANGE_OVERLAPS_RANGE: u32 = 4247;
pub const F_MULTIRANGE_OVERLAPS_MULTIRANGE: u32 = 4248;
pub const F_MULTIRANGE_CONTAINS_ELEM: u32 = 4249;
pub const F_MULTIRANGE_CONTAINS_RANGE: u32 = 4250;
pub const F_MULTIRANGE_CONTAINS_MULTIRANGE: u32 = 4251;
pub const F_ELEM_CONTAINED_BY_MULTIRANGE: u32 = 4252;
pub const F_RANGE_CONTAINED_BY_MULTIRANGE: u32 = 4253;
pub const F_MULTIRANGE_CONTAINED_BY_MULTIRANGE: u32 = 4254;
pub const F_RANGE_ADJACENT_MULTIRANGE: u32 = 4255;
pub const F_MULTIRANGE_ADJACENT_MULTIRANGE: u32 = 4256;
pub const F_MULTIRANGE_ADJACENT_RANGE: u32 = 4257;
pub const F_RANGE_BEFORE_MULTIRANGE: u32 = 4258;
pub const F_MULTIRANGE_BEFORE_RANGE: u32 = 4259;
pub const F_MULTIRANGE_BEFORE_MULTIRANGE: u32 = 4260;
pub const F_RANGE_AFTER_MULTIRANGE: u32 = 4261;
pub const F_MULTIRANGE_AFTER_RANGE: u32 = 4262;
pub const F_MULTIRANGE_AFTER_MULTIRANGE: u32 = 4263;
pub const F_RANGE_OVERLEFT_MULTIRANGE: u32 = 4264;
pub const F_MULTIRANGE_OVERLEFT_RANGE: u32 = 4265;
pub const F_MULTIRANGE_OVERLEFT_MULTIRANGE: u32 = 4266;
pub const F_RANGE_OVERRIGHT_MULTIRANGE: u32 = 4267;
pub const F_MULTIRANGE_OVERRIGHT_RANGE: u32 = 4268;
pub const F_MULTIRANGE_OVERRIGHT_MULTIRANGE: u32 = 4269;
pub const F_MULTIRANGE_UNION: u32 = 4270;
pub const F_MULTIRANGE_MINUS: u32 = 4271;
pub const F_MULTIRANGE_INTERSECT: u32 = 4272;
pub const F_MULTIRANGE_CMP: u32 = 4273;
pub const F_MULTIRANGE_LT: u32 = 4274;
pub const F_MULTIRANGE_LE: u32 = 4275;
pub const F_MULTIRANGE_GE: u32 = 4276;
pub const F_MULTIRANGE_GT: u32 = 4277;
pub const F_HASH_MULTIRANGE: u32 = 4278;
pub const F_HASH_MULTIRANGE_EXTENDED: u32 = 4279;
pub const F_INT4MULTIRANGE_: u32 = 4280;
pub const F_INT4MULTIRANGE_INT4RANGE: u32 = 4281;
pub const F_INT4MULTIRANGE__INT4RANGE: u32 = 4282;
pub const F_NUMMULTIRANGE_: u32 = 4283;
pub const F_NUMMULTIRANGE_NUMRANGE: u32 = 4284;
pub const F_NUMMULTIRANGE__NUMRANGE: u32 = 4285;
pub const F_TSMULTIRANGE_: u32 = 4286;
pub const F_TSMULTIRANGE_TSRANGE: u32 = 4287;
pub const F_TSMULTIRANGE__TSRANGE: u32 = 4288;
pub const F_TSTZMULTIRANGE_: u32 = 4289;
pub const F_TSTZMULTIRANGE_TSTZRANGE: u32 = 4290;
pub const F_TSTZMULTIRANGE__TSTZRANGE: u32 = 4291;
pub const F_DATEMULTIRANGE_: u32 = 4292;
pub const F_DATEMULTIRANGE_DATERANGE: u32 = 4293;
pub const F_DATEMULTIRANGE__DATERANGE: u32 = 4294;
pub const F_INT8MULTIRANGE_: u32 = 4295;
pub const F_INT8MULTIRANGE_INT8RANGE: u32 = 4296;
pub const F_INT8MULTIRANGE__INT8RANGE: u32 = 4297;
pub const F_MULTIRANGE: u32 = 4298;
pub const F_RANGE_AGG_TRANSFN: u32 = 4299;
pub const F_RANGE_AGG_FINALFN: u32 = 4300;
pub const F_RANGE_AGG_ANYRANGE: u32 = 4301;
pub const F_KOI8R_TO_MIC: u32 = 4302;
pub const F_MIC_TO_KOI8R: u32 = 4303;
pub const F_ISO_TO_MIC: u32 = 4304;
pub const F_MIC_TO_ISO: u32 = 4305;
pub const F_WIN1251_TO_MIC: u32 = 4306;
pub const F_MIC_TO_WIN1251: u32 = 4307;
pub const F_WIN866_TO_MIC: u32 = 4308;
pub const F_MIC_TO_WIN866: u32 = 4309;
pub const F_KOI8R_TO_WIN1251: u32 = 4310;
pub const F_WIN1251_TO_KOI8R: u32 = 4311;
pub const F_KOI8R_TO_WIN866: u32 = 4312;
pub const F_WIN866_TO_KOI8R: u32 = 4313;
pub const F_WIN866_TO_WIN1251: u32 = 4314;
pub const F_WIN1251_TO_WIN866: u32 = 4315;
pub const F_ISO_TO_KOI8R: u32 = 4316;
pub const F_KOI8R_TO_ISO: u32 = 4317;
pub const F_ISO_TO_WIN1251: u32 = 4318;
pub const F_WIN1251_TO_ISO: u32 = 4319;
pub const F_ISO_TO_WIN866: u32 = 4320;
pub const F_WIN866_TO_ISO: u32 = 4321;
pub const F_EUC_CN_TO_MIC: u32 = 4322;
pub const F_MIC_TO_EUC_CN: u32 = 4323;
pub const F_EUC_JP_TO_SJIS: u32 = 4324;
pub const F_SJIS_TO_EUC_JP: u32 = 4325;
pub const F_EUC_JP_TO_MIC: u32 = 4326;
pub const F_SJIS_TO_MIC: u32 = 4327;
pub const F_MIC_TO_EUC_JP: u32 = 4328;
pub const F_MIC_TO_SJIS: u32 = 4329;
pub const F_EUC_KR_TO_MIC: u32 = 4330;
pub const F_MIC_TO_EUC_KR: u32 = 4331;
pub const F_EUC_TW_TO_BIG5: u32 = 4332;
pub const F_BIG5_TO_EUC_TW: u32 = 4333;
pub const F_EUC_TW_TO_MIC: u32 = 4334;
pub const F_BIG5_TO_MIC: u32 = 4335;
pub const F_MIC_TO_EUC_TW: u32 = 4336;
pub const F_MIC_TO_BIG5: u32 = 4337;
pub const F_LATIN2_TO_MIC: u32 = 4338;
pub const F_MIC_TO_LATIN2: u32 = 4339;
pub const F_WIN1250_TO_MIC: u32 = 4340;
pub const F_MIC_TO_WIN1250: u32 = 4341;
pub const F_LATIN2_TO_WIN1250: u32 = 4342;
pub const F_WIN1250_TO_LATIN2: u32 = 4343;
pub const F_LATIN1_TO_MIC: u32 = 4344;
pub const F_MIC_TO_LATIN1: u32 = 4345;
pub const F_LATIN3_TO_MIC: u32 = 4346;
pub const F_MIC_TO_LATIN3: u32 = 4347;
pub const F_LATIN4_TO_MIC: u32 = 4348;
pub const F_MIC_TO_LATIN4: u32 = 4349;
pub const F_NORMALIZE: u32 = 4350;
pub const F_IS_NORMALIZED: u32 = 4351;
pub const F_BIG5_TO_UTF8: u32 = 4352;
pub const F_UTF8_TO_BIG5: u32 = 4353;
pub const F_UTF8_TO_KOI8R: u32 = 4354;
pub const F_KOI8R_TO_UTF8: u32 = 4355;
pub const F_UTF8_TO_KOI8U: u32 = 4356;
pub const F_KOI8U_TO_UTF8: u32 = 4357;
pub const F_UTF8_TO_WIN: u32 = 4358;
pub const F_WIN_TO_UTF8: u32 = 4359;
pub const F_EUC_CN_TO_UTF8: u32 = 4360;
pub const F_UTF8_TO_EUC_CN: u32 = 4361;
pub const F_EUC_JP_TO_UTF8: u32 = 4362;
pub const F_UTF8_TO_EUC_JP: u32 = 4363;
pub const F_EUC_KR_TO_UTF8: u32 = 4364;
pub const F_UTF8_TO_EUC_KR: u32 = 4365;
pub const F_EUC_TW_TO_UTF8: u32 = 4366;
pub const F_UTF8_TO_EUC_TW: u32 = 4367;
pub const F_GB18030_TO_UTF8: u32 = 4368;
pub const F_UTF8_TO_GB18030: u32 = 4369;
pub const F_GBK_TO_UTF8: u32 = 4370;
pub const F_UTF8_TO_GBK: u32 = 4371;
pub const F_UTF8_TO_ISO8859: u32 = 4372;
pub const F_ISO8859_TO_UTF8: u32 = 4373;
pub const F_ISO8859_1_TO_UTF8: u32 = 4374;
pub const F_UTF8_TO_ISO8859_1: u32 = 4375;
pub const F_JOHAB_TO_UTF8: u32 = 4376;
pub const F_UTF8_TO_JOHAB: u32 = 4377;
pub const F_SJIS_TO_UTF8: u32 = 4378;
pub const F_UTF8_TO_SJIS: u32 = 4379;
pub const F_UHC_TO_UTF8: u32 = 4380;
pub const F_UTF8_TO_UHC: u32 = 4381;
pub const F_EUC_JIS_2004_TO_UTF8: u32 = 4382;
pub const F_UTF8_TO_EUC_JIS_2004: u32 = 4383;
pub const F_SHIFT_JIS_2004_TO_UTF8: u32 = 4384;
pub const F_UTF8_TO_SHIFT_JIS_2004: u32 = 4385;
pub const F_EUC_JIS_2004_TO_SHIFT_JIS_2004: u32 = 4386;
pub const F_SHIFT_JIS_2004_TO_EUC_JIS_2004: u32 = 4387;
pub const F_MULTIRANGE_INTERSECT_AGG_TRANSFN: u32 = 4388;
pub const F_RANGE_INTERSECT_AGG_ANYMULTIRANGE: u32 = 4389;
pub const F_BINARY_UPGRADE_SET_NEXT_MULTIRANGE_PG_TYPE_OID: Oid = Oid(4390);
pub const F_BINARY_UPGRADE_SET_NEXT_MULTIRANGE_ARRAY_PG_TYPE_OID: Oid = Oid(4391);
pub const F_RANGE_INTERSECT_AGG_TRANSFN: u32 = 4401;
pub const F_RANGE_INTERSECT_AGG_ANYRANGE: u32 = 4450;
pub const F_RANGE_CONTAINS_MULTIRANGE: u32 = 4541;
pub const F_MULTIRANGE_CONTAINED_BY_RANGE: u32 = 4542;
pub const F_PG_LOG_BACKEND_MEMORY_CONTEXTS: u32 = 4543;
pub const F_BINARY_UPGRADE_SET_NEXT_HEAP_RELFILENODE: u32 = 4545;
pub const F_BINARY_UPGRADE_SET_NEXT_INDEX_RELFILENODE: u32 = 4546;
pub const F_BINARY_UPGRADE_SET_NEXT_TOAST_RELFILENODE: u32 = 4547;
pub const F_BINARY_UPGRADE_SET_NEXT_PG_TABLESPACE_OID: Oid = Oid(4548);
pub const F_UNICODE_VERSION: u32 = 4549;
pub const F_PG_EVENT_TRIGGER_TABLE_REWRITE_OID: Oid = Oid(4566);
pub const F_PG_EVENT_TRIGGER_TABLE_REWRITE_REASON: u32 = 4567;
pub const F_PG_EVENT_TRIGGER_DDL_COMMANDS: u32 = 4568;
pub const F_BRIN_BLOOM_OPCINFO: u32 = 4591;
pub const F_BRIN_BLOOM_ADD_VALUE: u32 = 4592;
pub const F_BRIN_BLOOM_CONSISTENT: u32 = 4593;
pub const F_BRIN_BLOOM_UNION: u32 = 4594;
pub const F_BRIN_BLOOM_OPTIONS: u32 = 4595;
pub const F_BRIN_BLOOM_SUMMARY_IN: u32 = 4596;
pub const F_BRIN_BLOOM_SUMMARY_OUT: u32 = 4597;
pub const F_BRIN_BLOOM_SUMMARY_RECV: u32 = 4598;
pub const F_BRIN_BLOOM_SUMMARY_SEND: u32 = 4599;
pub const F_BRIN_MINMAX_MULTI_OPCINFO: u32 = 4616;
pub const F_BRIN_MINMAX_MULTI_ADD_VALUE: u32 = 4617;
pub const F_BRIN_MINMAX_MULTI_CONSISTENT: u32 = 4618;
pub const F_BRIN_MINMAX_MULTI_UNION: u32 = 4619;
pub const F_BRIN_MINMAX_MULTI_OPTIONS: u32 = 4620;
pub const F_BRIN_MINMAX_MULTI_DISTANCE_INT2: u32 = 4621;
pub const F_BRIN_MINMAX_MULTI_DISTANCE_INT4: u32 = 4622;
pub const F_BRIN_MINMAX_MULTI_DISTANCE_INT8: u32 = 4623;
pub const F_BRIN_MINMAX_MULTI_DISTANCE_FLOAT4: u32 = 4624;
pub const F_BRIN_MINMAX_MULTI_DISTANCE_FLOAT8: u32 = 4625;
pub const F_BRIN_MINMAX_MULTI_DISTANCE_NUMERIC: u32 = 4626;
pub const F_BRIN_MINMAX_MULTI_DISTANCE_TID: u32 = 4627;
pub const F_BRIN_MINMAX_MULTI_DISTANCE_UUID: u32 = 4628;
pub const F_BRIN_MINMAX_MULTI_DISTANCE_DATE: u32 = 4629;
pub const F_BRIN_MINMAX_MULTI_DISTANCE_TIME: u32 = 4630;
pub const F_BRIN_MINMAX_MULTI_DISTANCE_INTERVAL: u32 = 4631;
pub const F_BRIN_MINMAX_MULTI_DISTANCE_TIMETZ: u32 = 4632;
pub const F_BRIN_MINMAX_MULTI_DISTANCE_PG_LSN: u32 = 4633;
pub const F_BRIN_MINMAX_MULTI_DISTANCE_MACADDR: u32 = 4634;
pub const F_BRIN_MINMAX_MULTI_DISTANCE_MACADDR8: u32 = 4635;
pub const F_BRIN_MINMAX_MULTI_DISTANCE_INET: u32 = 4636;
pub const F_BRIN_MINMAX_MULTI_DISTANCE_TIMESTAMP: u32 = 4637;
pub const F_BRIN_MINMAX_MULTI_SUMMARY_IN: u32 = 4638;
pub const F_BRIN_MINMAX_MULTI_SUMMARY_OUT: u32 = 4639;
pub const F_BRIN_MINMAX_MULTI_SUMMARY_RECV: u32 = 4640;
pub const F_BRIN_MINMAX_MULTI_SUMMARY_SEND: u32 = 4641;
pub const F_PHRASETO_TSQUERY_TEXT: u32 = 5001;
pub const F_TSQUERY_PHRASE_TSQUERY_TSQUERY: u32 = 5003;
pub const F_TSQUERY_PHRASE_TSQUERY_TSQUERY_INT4: u32 = 5004;
pub const F_PHRASETO_TSQUERY_REGCONFIG_TEXT: u32 = 5006;
pub const F_WEBSEARCH_TO_TSQUERY_REGCONFIG_TEXT: u32 = 5007;
pub const F_WEBSEARCH_TO_TSQUERY_TEXT: u32 = 5009;
pub const F_SPG_BBOX_QUAD_CONFIG: u32 = 5010;
pub const F_SPG_POLY_QUAD_COMPRESS: u32 = 5011;
pub const F_SPG_BOX_QUAD_CONFIG: u32 = 5012;
pub const F_SPG_BOX_QUAD_CHOOSE: u32 = 5013;
pub const F_SPG_BOX_QUAD_PICKSPLIT: u32 = 5014;
pub const F_SPG_BOX_QUAD_INNER_CONSISTENT: u32 = 5015;
pub const F_SPG_BOX_QUAD_LEAF_CONSISTENT: u32 = 5016;
pub const F_PG_MCV_LIST_IN: u32 = 5018;
pub const F_PG_MCV_LIST_OUT: u32 = 5019;
pub const F_PG_MCV_LIST_RECV: u32 = 5020;
pub const F_PG_MCV_LIST_SEND: u32 = 5021;
pub const F_PG_LSN_PLI: u32 = 5022;
pub const F_NUMERIC_PL_PG_LSN: u32 = 5023;
pub const F_PG_LSN_MII: u32 = 5024;
pub const F_SATISFIES_HASH_PARTITION: u32 = 5028;
pub const F_PG_LS_TMPDIR_: u32 = 5029;
pub const F_PG_LS_TMPDIR_OID: Oid = Oid(5030);
pub const F_PG_LS_ARCHIVE_STATUSDIR: u32 = 5031;
pub const F_NETWORK_SORTSUPPORT: u32 = 5033;
pub const F_XID8LT: u32 = 5034;
pub const F_XID8GT: u32 = 5035;
pub const F_XID8LE: u32 = 5036;
pub const F_XID8GE: u32 = 5037;
pub const F_MATCHINGSEL: u32 = 5040;
pub const F_MATCHINGJOINSEL: u32 = 5041;
pub const F_MIN_SCALE: u32 = 5042;
pub const F_TRIM_SCALE: u32 = 5043;
pub const F_GCD_INT4_INT4: u32 = 5044;
pub const F_GCD_INT8_INT8: u32 = 5045;
pub const F_LCM_INT4_INT4: u32 = 5046;
pub const F_LCM_INT8_INT8: u32 = 5047;
pub const F_GCD_NUMERIC_NUMERIC: u32 = 5048;
pub const F_LCM_NUMERIC_NUMERIC: u32 = 5049;
pub const F_BTVARSTREQUALIMAGE: u32 = 5050;
pub const F_BTEQUALIMAGE: u32 = 5051;
pub const F_PG_GET_SHMEM_ALLOCATIONS: u32 = 5052;
pub const F_PG_STAT_GET_INS_SINCE_VACUUM: u32 = 5053;
pub const F_JSONB_SET_LAX: u32 = 5054;
pub const F_PG_SNAPSHOT_IN: u32 = 5055;
pub const F_PG_SNAPSHOT_OUT: u32 = 5056;
pub const F_PG_SNAPSHOT_RECV: u32 = 5057;
pub const F_PG_SNAPSHOT_SEND: u32 = 5058;
pub const F_PG_CURRENT_XACT_ID: u32 = 5059;
pub const F_PG_CURRENT_XACT_ID_IF_ASSIGNED: u32 = 5060;
pub const F_PG_CURRENT_SNAPSHOT: u32 = 5061;
pub const F_PG_SNAPSHOT_XMIN: u32 = 5062;
pub const F_PG_SNAPSHOT_XMAX: u32 = 5063;
pub const F_PG_SNAPSHOT_XIP: u32 = 5064;
pub const F_PG_VISIBLE_IN_SNAPSHOT: u32 = 5065;
pub const F_PG_XACT_STATUS: u32 = 5066;
pub const F_XID8IN: u32 = 5070;
pub const F_XID: u32 = 5071;
pub const F_XID8OUT: u32 = 5081;
pub const F_XID8RECV: u32 = 5082;
pub const F_XID8SEND: u32 = 5083;
pub const F_XID8EQ: u32 = 5084;
pub const F_XID8NE: u32 = 5085;
pub const F_ANYCOMPATIBLE_IN: u32 = 5086;
pub const F_ANYCOMPATIBLE_OUT: u32 = 5087;
pub const F_ANYCOMPATIBLEARRAY_IN: u32 = 5088;
pub const F_ANYCOMPATIBLEARRAY_OUT: u32 = 5089;
pub const F_ANYCOMPATIBLEARRAY_RECV: u32 = 5090;
pub const F_ANYCOMPATIBLEARRAY_SEND: u32 = 5091;
pub const F_ANYCOMPATIBLENONARRAY_IN: u32 = 5092;
pub const F_ANYCOMPATIBLENONARRAY_OUT: u32 = 5093;
pub const F_ANYCOMPATIBLERANGE_IN: u32 = 5094;
pub const F_ANYCOMPATIBLERANGE_OUT: u32 = 5095;
pub const F_XID8CMP: u32 = 5096;
pub const F_XID8_LARGER: u32 = 5097;
pub const F_XID8_SMALLER: u32 = 5098;
pub const F_MAX_XID8: u32 = 5099;
pub const F_MIN_XID8: u32 = 5100;
pub const F_PG_REPLICATION_ORIGIN_CREATE: u32 = 6003;
pub const F_PG_REPLICATION_ORIGIN_DROP: u32 = 6004;
pub const F_PG_REPLICATION_ORIGIN_OID: Oid = Oid(6005);
pub const F_PG_REPLICATION_ORIGIN_SESSION_SETUP: u32 = 6006;
pub const F_PG_REPLICATION_ORIGIN_SESSION_RESET: u32 = 6007;
pub const F_PG_REPLICATION_ORIGIN_SESSION_IS_SETUP: u32 = 6008;
pub const F_PG_REPLICATION_ORIGIN_SESSION_PROGRESS: u32 = 6009;
pub const F_PG_REPLICATION_ORIGIN_XACT_SETUP: u32 = 6010;
pub const F_PG_REPLICATION_ORIGIN_XACT_RESET: u32 = 6011;
pub const F_PG_REPLICATION_ORIGIN_ADVANCE: u32 = 6012;
pub const F_PG_REPLICATION_ORIGIN_PROGRESS: u32 = 6013;
pub const F_PG_SHOW_REPLICATION_ORIGIN_STATUS: u32 = 6014;
pub const F_JSONB_SUBSCRIPT_HANDLER: u32 = 6098;
pub const F_ICU_UNICODE_VERSION: u32 = 6099;
pub const F_PG_LSN: u32 = 6103;
pub const F_UNICODE_ASSIGNED: u32 = 6105;
pub const F_PG_STAT_GET_BACKEND_SUBXACT: u32 = 6107;
pub const F_PG_STAT_GET_SUBSCRIPTION: u32 = 6118;
pub const F_PG_GET_PUBLICATION_TABLES: u32 = 6119;
pub const F_PG_GET_REPLICA_IDENTITY_INDEX: u32 = 6120;
pub const F_PG_RELATION_IS_PUBLISHABLE: u32 = 6121;
pub const F_MULTIRANGE_GIST_CONSISTENT: u32 = 6154;
pub const F_MULTIRANGE_GIST_COMPRESS: u32 = 6156;
pub const F_PG_GET_CATALOG_FOREIGN_KEYS: u32 = 6159;
pub const F_STRING_TO_TABLE_TEXT_TEXT: u32 = 6160;
pub const F_STRING_TO_TABLE_TEXT_TEXT_TEXT: u32 = 6161;
pub const F_BIT_COUNT_BIT: u32 = 6162;
pub const F_BIT_COUNT_BYTEA: u32 = 6163;
pub const F_BIT_XOR_INT2: u32 = 6164;
pub const F_BIT_XOR_INT4: u32 = 6165;
pub const F_BIT_XOR_INT8: u32 = 6166;
pub const F_BIT_XOR_BIT: u32 = 6167;
pub const F_PG_XACT_COMMIT_TIMESTAMP_ORIGIN: u32 = 6168;
pub const F_PG_STAT_GET_REPLICATION_SLOT: u32 = 6169;
pub const F_PG_STAT_RESET_REPLICATION_SLOT: u32 = 6170;
pub const F_TRIM_ARRAY: u32 = 6172;
pub const F_PG_GET_STATISTICSOBJDEF_EXPRESSIONS: u32 = 6173;
pub const F_PG_GET_STATISTICSOBJDEF_COLUMNS: u32 = 6174;
pub const F_DATE_BIN_INTERVAL_TIMESTAMP_TIMESTAMP: u32 = 6177;
pub const F_DATE_BIN_INTERVAL_TIMESTAMPTZ_TIMESTAMPTZ: u32 = 6178;
pub const F_ARRAY_SUBSCRIPT_HANDLER: u32 = 6179;
pub const F_RAW_ARRAY_SUBSCRIPT_HANDLER: u32 = 6180;
pub const F_TS_DEBUG_REGCONFIG_TEXT: u32 = 6183;
pub const F_TS_DEBUG_TEXT: u32 = 6184;
pub const F_PG_STAT_GET_DB_SESSION_TIME: u32 = 6185;
pub const F_PG_STAT_GET_DB_ACTIVE_TIME: u32 = 6186;
pub const F_PG_STAT_GET_DB_IDLE_IN_TRANSACTION_TIME: u32 = 6187;
pub const F_PG_STAT_GET_DB_SESSIONS: u32 = 6188;
pub const F_PG_STAT_GET_DB_SESSIONS_ABANDONED: u32 = 6189;
pub const F_PG_STAT_GET_DB_SESSIONS_FATAL: u32 = 6190;
pub const F_PG_STAT_GET_DB_SESSIONS_KILLED: u32 = 6191;
pub const F_HASH_RECORD: u32 = 6192;
pub const F_HASH_RECORD_EXTENDED: u32 = 6193;
pub const F_LTRIM_BYTEA_BYTEA: u32 = 6195;
pub const F_RTRIM_BYTEA_BYTEA: u32 = 6196;
pub const F_PG_GET_FUNCTION_SQLBODY: u32 = 6197;
pub const F_UNISTR: u32 = 6198;
pub const F_EXTRACT_TEXT_DATE: u32 = 6199;
pub const F_EXTRACT_TEXT_TIME: u32 = 6200;
pub const F_EXTRACT_TEXT_TIMETZ: u32 = 6201;
pub const F_EXTRACT_TEXT_TIMESTAMP: u32 = 6202;
pub const F_EXTRACT_TEXT_TIMESTAMPTZ: u32 = 6203;
pub const F_EXTRACT_TEXT_INTERVAL: u32 = 6204;
pub const F_HAS_PARAMETER_PRIVILEGE_NAME_TEXT_TEXT: u32 = 6205;
pub const F_HAS_PARAMETER_PRIVILEGE_OID_TEXT_TEXT: u32 = 6206;
pub const F_HAS_PARAMETER_PRIVILEGE_TEXT_TEXT: u32 = 6207;
pub const F_PG_READ_FILE_TEXT_BOOL: u32 = 6208;
pub const F_PG_READ_BINARY_FILE_TEXT_BOOL: u32 = 6209;
pub const F_PG_INPUT_IS_VALID: u32 = 6210;
pub const F_PG_INPUT_ERROR_INFO: u32 = 6211;
pub const F_RANDOM_NORMAL: u32 = 6212;
pub const F_PG_SPLIT_WALFILE_NAME: u32 = 6213;
pub const F_PG_STAT_GET_IO: u32 = 6214;
pub const F_ARRAY_SHUFFLE: u32 = 6215;
pub const F_ARRAY_SAMPLE: u32 = 6216;
pub const F_PG_STAT_GET_TUPLES_NEWPAGE_UPDATED: u32 = 6217;
pub const F_PG_STAT_GET_XACT_TUPLES_NEWPAGE_UPDATED: u32 = 6218;
pub const F_ERF: u32 = 6219;
pub const F_ERFC: u32 = 6220;
pub const F_DATE_ADD_TIMESTAMPTZ_INTERVAL: u32 = 6221;
pub const F_DATE_ADD_TIMESTAMPTZ_INTERVAL_TEXT: u32 = 6222;
pub const F_DATE_SUBTRACT_TIMESTAMPTZ_INTERVAL: u32 = 6223;
pub const F_PG_GET_WAL_RESOURCE_MANAGERS: u32 = 6224;
pub const F_MULTIRANGE_AGG_TRANSFN: u32 = 6225;
pub const F_MULTIRANGE_AGG_FINALFN: u32 = 6226;
pub const F_RANGE_AGG_ANYMULTIRANGE: u32 = 6227;
pub const F_PG_STAT_HAVE_STATS: u32 = 6230;
pub const F_PG_STAT_GET_SUBSCRIPTION_STATS: u32 = 6231;
pub const F_PG_STAT_RESET_SUBSCRIPTION_STATS: u32 = 6232;
pub const F_WINDOW_ROW_NUMBER_SUPPORT: u32 = 6233;
pub const F_WINDOW_RANK_SUPPORT: u32 = 6234;
pub const F_WINDOW_DENSE_RANK_SUPPORT: u32 = 6235;
pub const F_INT8INC_SUPPORT: u32 = 6236;
pub const F_PG_SETTINGS_GET_FLAGS: u32 = 6240;
pub const F_PG_STOP_MAKING_PINNED_OBJECTS: u32 = 6241;
pub const F_TEXT_STARTS_WITH_SUPPORT: u32 = 6242;
pub const F_PG_STAT_GET_RECOVERY_PREFETCH: u32 = 6248;
pub const F_PG_DATABASE_COLLATION_ACTUAL_VERSION: u32 = 6249;
pub const F_PG_IDENT_FILE_MAPPINGS: u32 = 6250;
pub const F_REGEXP_REPLACE_TEXT_TEXT_TEXT_INT4_INT4_TEXT: u32 = 6251;
pub const F_REGEXP_REPLACE_TEXT_TEXT_TEXT_INT4_INT4: u32 = 6252;
pub const F_REGEXP_REPLACE_TEXT_TEXT_TEXT_INT4: u32 = 6253;
pub const F_REGEXP_COUNT_TEXT_TEXT: u32 = 6254;
pub const F_REGEXP_COUNT_TEXT_TEXT_INT4: u32 = 6255;
pub const F_REGEXP_COUNT_TEXT_TEXT_INT4_TEXT: u32 = 6256;
pub const F_REGEXP_INSTR_TEXT_TEXT: u32 = 6257;
pub const F_REGEXP_INSTR_TEXT_TEXT_INT4: u32 = 6258;
pub const F_REGEXP_INSTR_TEXT_TEXT_INT4_INT4: u32 = 6259;
pub const F_REGEXP_INSTR_TEXT_TEXT_INT4_INT4_INT4: u32 = 6260;
pub const F_REGEXP_INSTR_TEXT_TEXT_INT4_INT4_INT4_TEXT: u32 = 6261;
pub const F_REGEXP_INSTR_TEXT_TEXT_INT4_INT4_INT4_TEXT_INT4: u32 = 6262;
pub const F_REGEXP_LIKE_TEXT_TEXT: u32 = 6263;
pub const F_REGEXP_LIKE_TEXT_TEXT_TEXT: u32 = 6264;
pub const F_REGEXP_SUBSTR_TEXT_TEXT: u32 = 6265;
pub const F_REGEXP_SUBSTR_TEXT_TEXT_INT4: u32 = 6266;
pub const F_REGEXP_SUBSTR_TEXT_TEXT_INT4_INT4: u32 = 6267;
pub const F_REGEXP_SUBSTR_TEXT_TEXT_INT4_INT4_TEXT: u32 = 6268;
pub const F_REGEXP_SUBSTR_TEXT_TEXT_INT4_INT4_TEXT_INT4: u32 = 6269;
pub const F_PG_LS_LOGICALSNAPDIR: u32 = 6270;
pub const F_PG_LS_LOGICALMAPDIR: u32 = 6271;
pub const F_PG_LS_REPLSLOTDIR: u32 = 6272;
pub const F_DATE_SUBTRACT_TIMESTAMPTZ_INTERVAL_TEXT: u32 = 6273;
pub const F_GENERATE_SERIES_TIMESTAMPTZ_TIMESTAMPTZ_INTERVAL_TEXT: u32 = 6274;
pub const F_JSON_AGG_STRICT_TRANSFN: u32 = 6275;
pub const F_JSON_AGG_STRICT: u32 = 6276;
pub const F_JSON_OBJECT_AGG_STRICT_TRANSFN: u32 = 6277;
pub const F_JSON_OBJECT_AGG_UNIQUE_TRANSFN: u32 = 6278;
pub const F_JSON_OBJECT_AGG_UNIQUE_STRICT_TRANSFN: u32 = 6279;
pub const F_JSON_OBJECT_AGG_STRICT: u32 = 6280;
pub const F_JSON_OBJECT_AGG_UNIQUE: u32 = 6281;
pub const F_JSON_OBJECT_AGG_UNIQUE_STRICT: u32 = 6282;
pub const F_JSONB_AGG_STRICT_TRANSFN: u32 = 6283;
pub const F_JSONB_AGG_STRICT: u32 = 6284;
pub const F_JSONB_OBJECT_AGG_STRICT_TRANSFN: u32 = 6285;
pub const F_JSONB_OBJECT_AGG_UNIQUE_TRANSFN: u32 = 6286;
pub const F_JSONB_OBJECT_AGG_UNIQUE_STRICT_TRANSFN: u32 = 6287;
pub const F_JSONB_OBJECT_AGG_STRICT: u32 = 6288;
pub const F_JSONB_OBJECT_AGG_UNIQUE: u32 = 6289;
pub const F_JSONB_OBJECT_AGG_UNIQUE_STRICT: u32 = 6290;
pub const F_ANY_VALUE: u32 = 6291;
pub const F_ANY_VALUE_TRANSFN: u32 = 6292;
pub const F_ARRAY_AGG_COMBINE: u32 = 6293;
pub const F_ARRAY_AGG_SERIALIZE: u32 = 6294;
pub const F_ARRAY_AGG_DESERIALIZE: u32 = 6295;
pub const F_ARRAY_AGG_ARRAY_COMBINE: u32 = 6296;
pub const F_ARRAY_AGG_ARRAY_SERIALIZE: u32 = 6297;
pub const F_ARRAY_AGG_ARRAY_DESERIALIZE: u32 = 6298;
pub const F_STRING_AGG_COMBINE: u32 = 6299;
pub const F_STRING_AGG_SERIALIZE: u32 = 6300;
pub const F_STRING_AGG_DESERIALIZE: u32 = 6301;
pub const F_PG_LOG_STANDBY_SNAPSHOT: u32 = 6305;
pub const F_WINDOW_PERCENT_RANK_SUPPORT: u32 = 6306;
pub const F_WINDOW_CUME_DIST_SUPPORT: u32 = 6307;
pub const F_WINDOW_NTILE_SUPPORT: u32 = 6308;
pub const F_PG_STAT_GET_DB_CONFLICT_LOGICALSLOT: u32 = 6309;
pub const F_PG_STAT_GET_LASTSCAN: u32 = 6310;
pub const F_SYSTEM_USER: u32 = 6311;
pub const F_BINARY_UPGRADE_LOGICAL_SLOT_HAS_CAUGHT_UP: u32 = 6312;
pub const F_PG_STAT_GET_CHECKPOINTER_STAT_RESET_TIME: u32 = 6314;
pub const F_PG_BASETYPE: u32 = 6315;
pub const F_PG_COLUMN_TOAST_CHUNK_ID: u32 = 6316;
pub const F_TO_REGTYPEMOD: u32 = 6317;
pub const F_PG_GET_WAIT_EVENTS: u32 = 6318;
pub const F_BINARY_UPGRADE_ADD_SUB_REL_STATE: u32 = 6319;
pub const F_BINARY_UPGRADE_REPLORIGIN_ADVANCE: u32 = 6320;
pub const F_PG_AVAILABLE_WAL_SUMMARIES: u32 = 6321;
pub const F_PG_WAL_SUMMARY_CONTENTS: u32 = 6322;
pub const F_PG_GET_WAL_SUMMARIZER_STATE: u32 = 6323;
pub const F_INTERVAL_AVG_SERIALIZE: u32 = 6324;
pub const F_INTERVAL_AVG_DESERIALIZE: u32 = 6325;
pub const F_INTERVAL_SUM: u32 = 6326;
pub const F_PG_STAT_GET_CHECKPOINTER_RESTARTPOINTS_TIMED: u32 = 6327;
pub const F_PG_STAT_GET_CHECKPOINTER_RESTARTPOINTS_REQUESTED: u32 = 6328;
pub const F_PG_STAT_GET_CHECKPOINTER_RESTARTPOINTS_PERFORMED: u32 = 6329;
pub const F_TO_BIN_INT4: u32 = 6330;
pub const F_TO_BIN_INT8: u32 = 6331;
pub const F_TO_OCT_INT4: u32 = 6332;
pub const F_TO_OCT_INT8: u32 = 6333;
pub const F_TIMEZONE_TIMESTAMPTZ: u32 = 6334;
pub const F_TIMEZONE_TIMESTAMP: u32 = 6335;
pub const F_TIMEZONE_TIMETZ: u32 = 6336;
pub const F_JSONB_POPULATE_RECORD_VALID: u32 = 6338;
pub const F_RANDOM_INT4_INT4: u32 = 6339;
pub const F_RANDOM_INT8_INT8: u32 = 6340;
pub const F_RANDOM_NUMERIC_NUMERIC: u32 = 6341;
pub const F_UUID_EXTRACT_TIMESTAMP: u32 = 6342;
pub const F_UUID_EXTRACT_VERSION: u32 = 6343;
pub const F_PG_SYNC_REPLICATION_SLOTS: u32 = 6344;
pub const F_RANGE_CONTAINS_ELEM_SUPPORT: u32 = 6345;
pub const F_ELEM_CONTAINED_BY_RANGE_SUPPORT: u32 = 6346;
pub const NUMERIC_MAX_PRECISION: u32 = 1000;
pub const NUMERIC_MIN_SCALE: i32 = -1000;
pub const NUMERIC_MAX_SCALE: u32 = 1000;
pub const NUMERIC_MAX_DISPLAY_SCALE: u32 = 1000;
pub const NUMERIC_MIN_DISPLAY_SCALE: u32 = 0;
pub const NUMERIC_MAX_RESULT_SCALE: u32 = 2000;
pub const NUMERIC_MIN_SIG_DIGITS: u32 = 16;
pub const JsonbContainsStrategyNumber: u32 = 7;
pub const JsonbExistsStrategyNumber: u32 = 9;
pub const JsonbExistsAnyStrategyNumber: u32 = 10;
pub const JsonbExistsAllStrategyNumber: u32 = 11;
pub const JsonbJsonpathExistsStrategyNumber: u32 = 15;
pub const JsonbJsonpathPredicateStrategyNumber: u32 = 16;
pub const JGINFLAG_KEY: u32 = 1;
pub const JGINFLAG_NULL: u32 = 2;
pub const JGINFLAG_BOOL: u32 = 3;
pub const JGINFLAG_NUM: u32 = 4;
pub const JGINFLAG_STR: u32 = 5;
pub const JGINFLAG_HASHED: u32 = 16;
pub const JGIN_MAXLENGTH: u32 = 125;
pub const JENTRY_OFFLENMASK: u32 = 268435455;
pub const JENTRY_TYPEMASK: u32 = 1879048192;
pub const JENTRY_HAS_OFF: u32 = 2147483648;
pub const JENTRY_ISSTRING: u32 = 0;
pub const JENTRY_ISNUMERIC: u32 = 268435456;
pub const JENTRY_ISBOOL_FALSE: u32 = 536870912;
pub const JENTRY_ISBOOL_TRUE: u32 = 805306368;
pub const JENTRY_ISNULL: u32 = 1073741824;
pub const JENTRY_ISCONTAINER: u32 = 1342177280;
pub const JB_OFFSET_STRIDE: u32 = 32;
pub const JB_CMASK: u32 = 268435455;
pub const JB_FSCALAR: u32 = 268435456;
pub const JB_FOBJECT: u32 = 536870912;
pub const JB_FARRAY: u32 = 1073741824;
pub const ATTSTATSSLOT_VALUES: u32 = 1;
pub const ATTSTATSSLOT_NUMBERS: u32 = 2;
pub const FORMAT_PROC_INVALID_AS_NULL: u32 = 1;
pub const FORMAT_PROC_FORCE_QUALIFY: u32 = 2;
pub const FORMAT_OPERATOR_INVALID_AS_NULL: u32 = 1;
pub const FORMAT_OPERATOR_FORCE_QUALIFY: u32 = 2;
pub const RULE_INDEXDEF_PRETTY: u32 = 1;
pub const RULE_INDEXDEF_KEYS_ONLY: u32 = 2;
pub const DEFAULT_EQ_SEL: f64 = 0.005;
pub const DEFAULT_INEQ_SEL: f64 = 0.3333333333333333;
pub const DEFAULT_RANGE_INEQ_SEL: f64 = 0.005;
pub const DEFAULT_MULTIRANGE_INEQ_SEL: f64 = 0.005;
pub const DEFAULT_MATCH_SEL: f64 = 0.005;
pub const DEFAULT_MATCHING_SEL: f64 = 0.01;
pub const DEFAULT_NUM_DISTINCT: u32 = 200;
pub const DEFAULT_UNK_SEL: f64 = 0.005;
pub const DEFAULT_NOT_UNK_SEL: f64 = 0.995;
pub const SELFLAG_USED_DEFAULT: u32 = 1;
pub const CATCACHE_MAXKEYS: u32 = 4;
pub const CT_MAGIC: u32 = 1462113538;
pub const CL_MAGIC: u32 = 1383485699;
pub const RANGE_EMPTY_LITERAL: &::core::ffi::CStr = c"empty";
pub const RANGE_EMPTY: u32 = 1;
pub const RANGE_LB_INC: u32 = 2;
pub const RANGE_UB_INC: u32 = 4;
pub const RANGE_LB_INF: u32 = 8;
pub const RANGE_UB_INF: u32 = 16;
pub const RANGE_LB_NULL: u32 = 32;
pub const RANGE_UB_NULL: u32 = 64;
pub const RANGE_CONTAIN_EMPTY: u32 = 128;
pub const RANGESTRAT_BEFORE: u32 = 1;
pub const RANGESTRAT_OVERLEFT: u32 = 2;
pub const RANGESTRAT_OVERLAPS: u32 = 3;
pub const RANGESTRAT_OVERRIGHT: u32 = 4;
pub const RANGESTRAT_AFTER: u32 = 5;
pub const RANGESTRAT_ADJACENT: u32 = 6;
pub const RANGESTRAT_CONTAINS: u32 = 7;
pub const RANGESTRAT_CONTAINED_BY: u32 = 8;
pub const RANGESTRAT_CONTAINS_ELEM: u32 = 16;
pub const RANGESTRAT_EQ: u32 = 18;
pub type pg_int64 = ::core::ffi::c_long;
pub type va_list = __builtin_va_list;
pub type __uid_t = ::core::ffi::c_uint;
pub type __gid_t = ::core::ffi::c_uint;
pub type __ino_t = ::core::ffi::c_ulong;
pub type __mode_t = ::core::ffi::c_uint;
pub type __off_t = ::core::ffi::c_long;
pub type __off64_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
pub type __socklen_t = ::core::ffi::c_uint;
pub type __sig_atomic_t = ::core::ffi::c_int;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::core::ffi::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::core::ffi::c_int,
    pub _IO_read_ptr: *mut ::core::ffi::c_char,
    pub _IO_read_end: *mut ::core::ffi::c_char,
    pub _IO_read_base: *mut ::core::ffi::c_char,
    pub _IO_write_base: *mut ::core::ffi::c_char,
    pub _IO_write_ptr: *mut ::core::ffi::c_char,
    pub _IO_write_end: *mut ::core::ffi::c_char,
    pub _IO_buf_base: *mut ::core::ffi::c_char,
    pub _IO_buf_end: *mut ::core::ffi::c_char,
    pub _IO_save_base: *mut ::core::ffi::c_char,
    pub _IO_backup_base: *mut ::core::ffi::c_char,
    pub _IO_save_end: *mut ::core::ffi::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::core::ffi::c_int,
    pub _flags2: ::core::ffi::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::core::ffi::c_ushort,
    pub _vtable_offset: ::core::ffi::c_schar,
    pub _shortbuf: [::core::ffi::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::core::ffi::c_void,
    pub __pad5: usize,
    pub _mode: ::core::ffi::c_int,
    pub _unused2: [::core::ffi::c_char; 20usize],
}
impl Default for _IO_FILE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type off_t = __off_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::core::ffi::c_ulong; 16usize],
}
pub type pg_funcptr_t = ::core::option::Option<unsafe extern "C-unwind" fn()>;
pub type Pointer = *mut ::core::ffi::c_char;
pub type int8 = ::core::ffi::c_schar;
pub type int16 = ::core::ffi::c_short;
pub type int32 = ::core::ffi::c_int;
pub type uint8 = ::core::ffi::c_uchar;
pub type uint16 = ::core::ffi::c_ushort;
pub type uint32 = ::core::ffi::c_uint;
pub type bits8 = uint8;
pub type bits16 = uint16;
pub type bits32 = uint32;
pub type int64 = ::core::ffi::c_long;
pub type uint64 = ::core::ffi::c_ulong;
pub type int128 = i128;
pub type uint128 = u128;
pub type Size = usize;
pub type Index = ::core::ffi::c_uint;
pub type Offset = ::core::ffi::c_int;
pub type float4 = f32;
pub type float8 = f64;
pub type regproc = Oid;
pub type RegProcedure = regproc;
pub type LocalTransactionId = uint32;
pub type SubTransactionId = uint32;
pub type MultiXactOffset = uint32;
pub type CommandId = uint32;
#[repr(C)]
#[derive(Debug, Default)]
pub struct varlena {
    pub vl_len_: [::core::ffi::c_char; 4usize],
    pub vl_dat: __IncompleteArrayField<::core::ffi::c_char>,
}
pub type bytea = varlena;
pub type text = varlena;
pub type BpChar = varlena;
pub type VarChar = varlena;
#[repr(C)]
#[derive(Debug)]
pub struct int2vector {
    pub vl_len_: int32,
    pub ndim: ::core::ffi::c_int,
    pub dataoffset: int32,
    pub elemtype: Oid,
    pub dim1: ::core::ffi::c_int,
    pub lbound1: ::core::ffi::c_int,
    pub values: __IncompleteArrayField<int16>,
}
impl Default for int2vector {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct oidvector {
    pub vl_len_: int32,
    pub ndim: ::core::ffi::c_int,
    pub dataoffset: int32,
    pub elemtype: Oid,
    pub dim1: ::core::ffi::c_int,
    pub lbound1: ::core::ffi::c_int,
    pub values: __IncompleteArrayField<Oid>,
}
impl Default for oidvector {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nameData {
    pub data: [::core::ffi::c_char; 64usize],
}
impl Default for nameData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NameData = nameData;
pub type Name = *mut NameData;
#[repr(C)]
#[derive(Copy, Clone)]
pub union PGAlignedBlock {
    pub data: [::core::ffi::c_char; 8192usize],
    pub force_align_d: f64,
    pub force_align_i64: int64,
}
impl Default for PGAlignedBlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(4096))]
#[derive(Copy, Clone)]
pub union PGIOAlignedBlock {
    pub data: [::core::ffi::c_char; 8192usize],
    pub force_align_d: f64,
    pub force_align_i64: int64,
}
impl Default for PGIOAlignedBlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(4096))]
#[derive(Copy, Clone)]
pub union PGAlignedXLogBlock {
    pub data: [::core::ffi::c_char; 8192usize],
    pub force_align_d: f64,
    pub force_align_i64: int64,
}
impl Default for PGAlignedXLogBlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pgsocket = ::core::ffi::c_int;
pub type qsort_arg_comparator = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        a: *const ::core::ffi::c_void,
        b: *const ::core::ffi::c_void,
        arg: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
pub type pqsigfunc =
    ::core::option::Option<unsafe extern "C-unwind" fn(postgres_signal_arg: ::core::ffi::c_int)>;
pub type __jmp_buf = [::core::ffi::c_long; 8usize];
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::core::ffi::c_int,
    pub __saved_mask: __sigset_t,
}
pub type sigjmp_buf = [__jmp_buf_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StringInfoData {
    pub data: *mut ::core::ffi::c_char,
    pub len: ::core::ffi::c_int,
    pub maxlen: ::core::ffi::c_int,
    pub cursor: ::core::ffi::c_int,
}
impl Default for StringInfoData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type StringInfo = *mut StringInfoData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ErrorContextCallback {
    pub previous: *mut ErrorContextCallback,
    pub callback:
        ::core::option::Option<unsafe extern "C-unwind" fn(arg: *mut ::core::ffi::c_void)>,
    pub arg: *mut ::core::ffi::c_void,
}
impl Default for ErrorContextCallback {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ErrorData {
    pub elevel: ::core::ffi::c_int,
    pub output_to_server: bool,
    pub output_to_client: bool,
    pub hide_stmt: bool,
    pub hide_ctx: bool,
    pub filename: *const ::core::ffi::c_char,
    pub lineno: ::core::ffi::c_int,
    pub funcname: *const ::core::ffi::c_char,
    pub domain: *const ::core::ffi::c_char,
    pub context_domain: *const ::core::ffi::c_char,
    pub sqlerrcode: ::core::ffi::c_int,
    pub message: *mut ::core::ffi::c_char,
    pub detail: *mut ::core::ffi::c_char,
    pub detail_log: *mut ::core::ffi::c_char,
    pub hint: *mut ::core::ffi::c_char,
    pub context: *mut ::core::ffi::c_char,
    pub backtrace: *mut ::core::ffi::c_char,
    pub message_id: *const ::core::ffi::c_char,
    pub schema_name: *mut ::core::ffi::c_char,
    pub table_name: *mut ::core::ffi::c_char,
    pub column_name: *mut ::core::ffi::c_char,
    pub datatype_name: *mut ::core::ffi::c_char,
    pub constraint_name: *mut ::core::ffi::c_char,
    pub cursorpos: ::core::ffi::c_int,
    pub internalpos: ::core::ffi::c_int,
    pub internalquery: *mut ::core::ffi::c_char,
    pub saved_errno: ::core::ffi::c_int,
    pub assoc_context: *mut MemoryContextData,
}
impl Default for ErrorData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type emit_log_hook_type =
    ::core::option::Option<unsafe extern "C-unwind" fn(edata: *mut ErrorData)>;
pub mod PGErrorVerbosity {
    pub type Type = ::core::ffi::c_uint;
    pub const PGERROR_TERSE: Type = 0;
    pub const PGERROR_DEFAULT: Type = 1;
    pub const PGERROR_VERBOSE: Type = 2;
}
pub type MemoryContext = *mut MemoryContextData;
pub type MemoryContextCallbackFunction =
    ::core::option::Option<unsafe extern "C-unwind" fn(arg: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryContextCallback {
    pub func: MemoryContextCallbackFunction,
    pub arg: *mut ::core::ffi::c_void,
    pub next: *mut MemoryContextCallback,
}
impl Default for MemoryContextCallback {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NullableDatum {
    pub value: Datum,
    pub isnull: bool,
}
impl Default for NullableDatum {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type AttrNumber = int16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_attribute {
    pub attrelid: Oid,
    pub attname: NameData,
    pub atttypid: Oid,
    pub attlen: int16,
    pub attnum: int16,
    pub attcacheoff: int32,
    pub atttypmod: int32,
    pub attndims: int16,
    pub attbyval: bool,
    pub attalign: ::core::ffi::c_char,
    pub attstorage: ::core::ffi::c_char,
    pub attcompression: ::core::ffi::c_char,
    pub attnotnull: bool,
    pub atthasdef: bool,
    pub atthasmissing: bool,
    pub attidentity: ::core::ffi::c_char,
    pub attgenerated: ::core::ffi::c_char,
    pub attisdropped: bool,
    pub attislocal: bool,
    pub attinhcount: int16,
    pub attcollation: Oid,
}
impl Default for FormData_pg_attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_attribute = *mut FormData_pg_attribute;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormExtraData_pg_attribute {
    pub attstattarget: NullableDatum,
    pub attoptions: NullableDatum,
}
impl Default for FormExtraData_pg_attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum NodeTag {
    T_Invalid = 0,
    T_List = 1,
    T_Alias = 2,
    T_RangeVar = 3,
    T_TableFunc = 4,
    T_IntoClause = 5,
    T_Var = 6,
    T_Const = 7,
    T_Param = 8,
    T_Aggref = 9,
    T_GroupingFunc = 10,
    T_WindowFunc = 11,
    T_WindowFuncRunCondition = 12,
    T_MergeSupportFunc = 13,
    T_SubscriptingRef = 14,
    T_FuncExpr = 15,
    T_NamedArgExpr = 16,
    T_OpExpr = 17,
    T_DistinctExpr = 18,
    T_NullIfExpr = 19,
    T_ScalarArrayOpExpr = 20,
    T_BoolExpr = 21,
    T_SubLink = 22,
    T_SubPlan = 23,
    T_AlternativeSubPlan = 24,
    T_FieldSelect = 25,
    T_FieldStore = 26,
    T_RelabelType = 27,
    T_CoerceViaIO = 28,
    T_ArrayCoerceExpr = 29,
    T_ConvertRowtypeExpr = 30,
    T_CollateExpr = 31,
    T_CaseExpr = 32,
    T_CaseWhen = 33,
    T_CaseTestExpr = 34,
    T_ArrayExpr = 35,
    T_RowExpr = 36,
    T_RowCompareExpr = 37,
    T_CoalesceExpr = 38,
    T_MinMaxExpr = 39,
    T_SQLValueFunction = 40,
    T_XmlExpr = 41,
    T_JsonFormat = 42,
    T_JsonReturning = 43,
    T_JsonValueExpr = 44,
    T_JsonConstructorExpr = 45,
    T_JsonIsPredicate = 46,
    T_JsonBehavior = 47,
    T_JsonExpr = 48,
    T_JsonTablePath = 49,
    T_JsonTablePathScan = 50,
    T_JsonTableSiblingJoin = 51,
    T_NullTest = 52,
    T_BooleanTest = 53,
    T_MergeAction = 54,
    T_CoerceToDomain = 55,
    T_CoerceToDomainValue = 56,
    T_SetToDefault = 57,
    T_CurrentOfExpr = 58,
    T_NextValueExpr = 59,
    T_InferenceElem = 60,
    T_TargetEntry = 61,
    T_RangeTblRef = 62,
    T_JoinExpr = 63,
    T_FromExpr = 64,
    T_OnConflictExpr = 65,
    T_Query = 66,
    T_TypeName = 67,
    T_ColumnRef = 68,
    T_ParamRef = 69,
    T_A_Expr = 70,
    T_A_Const = 71,
    T_TypeCast = 72,
    T_CollateClause = 73,
    T_RoleSpec = 74,
    T_FuncCall = 75,
    T_A_Star = 76,
    T_A_Indices = 77,
    T_A_Indirection = 78,
    T_A_ArrayExpr = 79,
    T_ResTarget = 80,
    T_MultiAssignRef = 81,
    T_SortBy = 82,
    T_WindowDef = 83,
    T_RangeSubselect = 84,
    T_RangeFunction = 85,
    T_RangeTableFunc = 86,
    T_RangeTableFuncCol = 87,
    T_RangeTableSample = 88,
    T_ColumnDef = 89,
    T_TableLikeClause = 90,
    T_IndexElem = 91,
    T_DefElem = 92,
    T_LockingClause = 93,
    T_XmlSerialize = 94,
    T_PartitionElem = 95,
    T_PartitionSpec = 96,
    T_PartitionBoundSpec = 97,
    T_PartitionRangeDatum = 98,
    T_SinglePartitionSpec = 99,
    T_PartitionCmd = 100,
    T_RangeTblEntry = 101,
    T_RTEPermissionInfo = 102,
    T_RangeTblFunction = 103,
    T_TableSampleClause = 104,
    T_WithCheckOption = 105,
    T_SortGroupClause = 106,
    T_GroupingSet = 107,
    T_WindowClause = 108,
    T_RowMarkClause = 109,
    T_WithClause = 110,
    T_InferClause = 111,
    T_OnConflictClause = 112,
    T_CTESearchClause = 113,
    T_CTECycleClause = 114,
    T_CommonTableExpr = 115,
    T_MergeWhenClause = 116,
    T_TriggerTransition = 117,
    T_JsonOutput = 118,
    T_JsonArgument = 119,
    T_JsonFuncExpr = 120,
    T_JsonTablePathSpec = 121,
    T_JsonTable = 122,
    T_JsonTableColumn = 123,
    T_JsonKeyValue = 124,
    T_JsonParseExpr = 125,
    T_JsonScalarExpr = 126,
    T_JsonSerializeExpr = 127,
    T_JsonObjectConstructor = 128,
    T_JsonArrayConstructor = 129,
    T_JsonArrayQueryConstructor = 130,
    T_JsonAggConstructor = 131,
    T_JsonObjectAgg = 132,
    T_JsonArrayAgg = 133,
    T_RawStmt = 134,
    T_InsertStmt = 135,
    T_DeleteStmt = 136,
    T_UpdateStmt = 137,
    T_MergeStmt = 138,
    T_SelectStmt = 139,
    T_SetOperationStmt = 140,
    T_ReturnStmt = 141,
    T_PLAssignStmt = 142,
    T_CreateSchemaStmt = 143,
    T_AlterTableStmt = 144,
    T_ReplicaIdentityStmt = 145,
    T_AlterTableCmd = 146,
    T_AlterCollationStmt = 147,
    T_AlterDomainStmt = 148,
    T_GrantStmt = 149,
    T_ObjectWithArgs = 150,
    T_AccessPriv = 151,
    T_GrantRoleStmt = 152,
    T_AlterDefaultPrivilegesStmt = 153,
    T_CopyStmt = 154,
    T_VariableSetStmt = 155,
    T_VariableShowStmt = 156,
    T_CreateStmt = 157,
    T_Constraint = 158,
    T_CreateTableSpaceStmt = 159,
    T_DropTableSpaceStmt = 160,
    T_AlterTableSpaceOptionsStmt = 161,
    T_AlterTableMoveAllStmt = 162,
    T_CreateExtensionStmt = 163,
    T_AlterExtensionStmt = 164,
    T_AlterExtensionContentsStmt = 165,
    T_CreateFdwStmt = 166,
    T_AlterFdwStmt = 167,
    T_CreateForeignServerStmt = 168,
    T_AlterForeignServerStmt = 169,
    T_CreateForeignTableStmt = 170,
    T_CreateUserMappingStmt = 171,
    T_AlterUserMappingStmt = 172,
    T_DropUserMappingStmt = 173,
    T_ImportForeignSchemaStmt = 174,
    T_CreatePolicyStmt = 175,
    T_AlterPolicyStmt = 176,
    T_CreateAmStmt = 177,
    T_CreateTrigStmt = 178,
    T_CreateEventTrigStmt = 179,
    T_AlterEventTrigStmt = 180,
    T_CreatePLangStmt = 181,
    T_CreateRoleStmt = 182,
    T_AlterRoleStmt = 183,
    T_AlterRoleSetStmt = 184,
    T_DropRoleStmt = 185,
    T_CreateSeqStmt = 186,
    T_AlterSeqStmt = 187,
    T_DefineStmt = 188,
    T_CreateDomainStmt = 189,
    T_CreateOpClassStmt = 190,
    T_CreateOpClassItem = 191,
    T_CreateOpFamilyStmt = 192,
    T_AlterOpFamilyStmt = 193,
    T_DropStmt = 194,
    T_TruncateStmt = 195,
    T_CommentStmt = 196,
    T_SecLabelStmt = 197,
    T_DeclareCursorStmt = 198,
    T_ClosePortalStmt = 199,
    T_FetchStmt = 200,
    T_IndexStmt = 201,
    T_CreateStatsStmt = 202,
    T_StatsElem = 203,
    T_AlterStatsStmt = 204,
    T_CreateFunctionStmt = 205,
    T_FunctionParameter = 206,
    T_AlterFunctionStmt = 207,
    T_DoStmt = 208,
    T_InlineCodeBlock = 209,
    T_CallStmt = 210,
    T_CallContext = 211,
    T_RenameStmt = 212,
    T_AlterObjectDependsStmt = 213,
    T_AlterObjectSchemaStmt = 214,
    T_AlterOwnerStmt = 215,
    T_AlterOperatorStmt = 216,
    T_AlterTypeStmt = 217,
    T_RuleStmt = 218,
    T_NotifyStmt = 219,
    T_ListenStmt = 220,
    T_UnlistenStmt = 221,
    T_TransactionStmt = 222,
    T_CompositeTypeStmt = 223,
    T_CreateEnumStmt = 224,
    T_CreateRangeStmt = 225,
    T_AlterEnumStmt = 226,
    T_ViewStmt = 227,
    T_LoadStmt = 228,
    T_CreatedbStmt = 229,
    T_AlterDatabaseStmt = 230,
    T_AlterDatabaseRefreshCollStmt = 231,
    T_AlterDatabaseSetStmt = 232,
    T_DropdbStmt = 233,
    T_AlterSystemStmt = 234,
    T_ClusterStmt = 235,
    T_VacuumStmt = 236,
    T_VacuumRelation = 237,
    T_ExplainStmt = 238,
    T_CreateTableAsStmt = 239,
    T_RefreshMatViewStmt = 240,
    T_CheckPointStmt = 241,
    T_DiscardStmt = 242,
    T_LockStmt = 243,
    T_ConstraintsSetStmt = 244,
    T_ReindexStmt = 245,
    T_CreateConversionStmt = 246,
    T_CreateCastStmt = 247,
    T_CreateTransformStmt = 248,
    T_PrepareStmt = 249,
    T_ExecuteStmt = 250,
    T_DeallocateStmt = 251,
    T_DropOwnedStmt = 252,
    T_ReassignOwnedStmt = 253,
    T_AlterTSDictionaryStmt = 254,
    T_AlterTSConfigurationStmt = 255,
    T_PublicationTable = 256,
    T_PublicationObjSpec = 257,
    T_CreatePublicationStmt = 258,
    T_AlterPublicationStmt = 259,
    T_CreateSubscriptionStmt = 260,
    T_AlterSubscriptionStmt = 261,
    T_DropSubscriptionStmt = 262,
    T_PlannerGlobal = 263,
    T_PlannerInfo = 264,
    T_RelOptInfo = 265,
    T_IndexOptInfo = 266,
    T_ForeignKeyOptInfo = 267,
    T_StatisticExtInfo = 268,
    T_JoinDomain = 269,
    T_EquivalenceClass = 270,
    T_EquivalenceMember = 271,
    T_PathKey = 272,
    T_GroupByOrdering = 273,
    T_PathTarget = 274,
    T_ParamPathInfo = 275,
    T_Path = 276,
    T_IndexPath = 277,
    T_IndexClause = 278,
    T_BitmapHeapPath = 279,
    T_BitmapAndPath = 280,
    T_BitmapOrPath = 281,
    T_TidPath = 282,
    T_TidRangePath = 283,
    T_SubqueryScanPath = 284,
    T_ForeignPath = 285,
    T_CustomPath = 286,
    T_AppendPath = 287,
    T_MergeAppendPath = 288,
    T_GroupResultPath = 289,
    T_MaterialPath = 290,
    T_MemoizePath = 291,
    T_UniquePath = 292,
    T_GatherPath = 293,
    T_GatherMergePath = 294,
    T_NestPath = 295,
    T_MergePath = 296,
    T_HashPath = 297,
    T_ProjectionPath = 298,
    T_ProjectSetPath = 299,
    T_SortPath = 300,
    T_IncrementalSortPath = 301,
    T_GroupPath = 302,
    T_UpperUniquePath = 303,
    T_AggPath = 304,
    T_GroupingSetData = 305,
    T_RollupData = 306,
    T_GroupingSetsPath = 307,
    T_MinMaxAggPath = 308,
    T_WindowAggPath = 309,
    T_SetOpPath = 310,
    T_RecursiveUnionPath = 311,
    T_LockRowsPath = 312,
    T_ModifyTablePath = 313,
    T_LimitPath = 314,
    T_RestrictInfo = 315,
    T_PlaceHolderVar = 316,
    T_SpecialJoinInfo = 317,
    T_OuterJoinClauseInfo = 318,
    T_AppendRelInfo = 319,
    T_RowIdentityVarInfo = 320,
    T_PlaceHolderInfo = 321,
    T_MinMaxAggInfo = 322,
    T_PlannerParamItem = 323,
    T_AggInfo = 324,
    T_AggTransInfo = 325,
    T_PlannedStmt = 326,
    T_Result = 327,
    T_ProjectSet = 328,
    T_ModifyTable = 329,
    T_Append = 330,
    T_MergeAppend = 331,
    T_RecursiveUnion = 332,
    T_BitmapAnd = 333,
    T_BitmapOr = 334,
    T_SeqScan = 335,
    T_SampleScan = 336,
    T_IndexScan = 337,
    T_IndexOnlyScan = 338,
    T_BitmapIndexScan = 339,
    T_BitmapHeapScan = 340,
    T_TidScan = 341,
    T_TidRangeScan = 342,
    T_SubqueryScan = 343,
    T_FunctionScan = 344,
    T_ValuesScan = 345,
    T_TableFuncScan = 346,
    T_CteScan = 347,
    T_NamedTuplestoreScan = 348,
    T_WorkTableScan = 349,
    T_ForeignScan = 350,
    T_CustomScan = 351,
    T_NestLoop = 352,
    T_NestLoopParam = 353,
    T_MergeJoin = 354,
    T_HashJoin = 355,
    T_Material = 356,
    T_Memoize = 357,
    T_Sort = 358,
    T_IncrementalSort = 359,
    T_Group = 360,
    T_Agg = 361,
    T_WindowAgg = 362,
    T_Unique = 363,
    T_Gather = 364,
    T_GatherMerge = 365,
    T_Hash = 366,
    T_SetOp = 367,
    T_LockRows = 368,
    T_Limit = 369,
    T_PlanRowMark = 370,
    T_PartitionPruneInfo = 371,
    T_PartitionedRelPruneInfo = 372,
    T_PartitionPruneStepOp = 373,
    T_PartitionPruneStepCombine = 374,
    T_PlanInvalItem = 375,
    T_ExprState = 376,
    T_IndexInfo = 377,
    T_ExprContext = 378,
    T_ReturnSetInfo = 379,
    T_ProjectionInfo = 380,
    T_JunkFilter = 381,
    T_OnConflictSetState = 382,
    T_MergeActionState = 383,
    T_ResultRelInfo = 384,
    T_EState = 385,
    T_WindowFuncExprState = 386,
    T_SetExprState = 387,
    T_SubPlanState = 388,
    T_DomainConstraintState = 389,
    T_ResultState = 390,
    T_ProjectSetState = 391,
    T_ModifyTableState = 392,
    T_AppendState = 393,
    T_MergeAppendState = 394,
    T_RecursiveUnionState = 395,
    T_BitmapAndState = 396,
    T_BitmapOrState = 397,
    T_ScanState = 398,
    T_SeqScanState = 399,
    T_SampleScanState = 400,
    T_IndexScanState = 401,
    T_IndexOnlyScanState = 402,
    T_BitmapIndexScanState = 403,
    T_BitmapHeapScanState = 404,
    T_TidScanState = 405,
    T_TidRangeScanState = 406,
    T_SubqueryScanState = 407,
    T_FunctionScanState = 408,
    T_ValuesScanState = 409,
    T_TableFuncScanState = 410,
    T_CteScanState = 411,
    T_NamedTuplestoreScanState = 412,
    T_WorkTableScanState = 413,
    T_ForeignScanState = 414,
    T_CustomScanState = 415,
    T_JoinState = 416,
    T_NestLoopState = 417,
    T_MergeJoinState = 418,
    T_HashJoinState = 419,
    T_MaterialState = 420,
    T_MemoizeState = 421,
    T_SortState = 422,
    T_IncrementalSortState = 423,
    T_GroupState = 424,
    T_AggState = 425,
    T_WindowAggState = 426,
    T_UniqueState = 427,
    T_GatherState = 428,
    T_GatherMergeState = 429,
    T_HashState = 430,
    T_SetOpState = 431,
    T_LockRowsState = 432,
    T_LimitState = 433,
    T_IndexAmRoutine = 434,
    T_TableAmRoutine = 435,
    T_TsmRoutine = 436,
    T_EventTriggerData = 437,
    T_TriggerData = 438,
    T_TupleTableSlot = 439,
    T_FdwRoutine = 440,
    T_Bitmapset = 441,
    T_ExtensibleNode = 442,
    T_ErrorSaveContext = 443,
    T_IdentifySystemCmd = 444,
    T_BaseBackupCmd = 445,
    T_CreateReplicationSlotCmd = 446,
    T_DropReplicationSlotCmd = 447,
    T_AlterReplicationSlotCmd = 448,
    T_StartReplicationCmd = 449,
    T_ReadReplicationSlotCmd = 450,
    T_TimeLineHistoryCmd = 451,
    T_UploadManifestCmd = 452,
    T_SupportRequestSimplify = 453,
    T_SupportRequestSelectivity = 454,
    T_SupportRequestCost = 455,
    T_SupportRequestRows = 456,
    T_SupportRequestIndexCondition = 457,
    T_SupportRequestWFuncMonotonic = 458,
    T_SupportRequestOptimizeWindowClause = 459,
    T_Integer = 460,
    T_Float = 461,
    T_Boolean = 462,
    T_String = 463,
    T_BitString = 464,
    T_ForeignKeyCacheInfo = 465,
    T_IntList = 466,
    T_OidList = 467,
    T_XidList = 468,
    T_AllocSetContext = 469,
    T_GenerationContext = 470,
    T_SlabContext = 471,
    T_BumpContext = 472,
    T_TIDBitmap = 473,
    T_WindowObjectData = 474,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Node {
    pub type_: NodeTag,
}
impl Default for Node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ParseLoc = ::core::ffi::c_int;
pub type Selectivity = f64;
pub type Cost = f64;
pub type Cardinality = f64;
pub mod CmdType {
    pub type Type = ::core::ffi::c_uint;
    pub const CMD_UNKNOWN: Type = 0;
    pub const CMD_SELECT: Type = 1;
    pub const CMD_UPDATE: Type = 2;
    pub const CMD_INSERT: Type = 3;
    pub const CMD_DELETE: Type = 4;
    pub const CMD_MERGE: Type = 5;
    pub const CMD_UTILITY: Type = 6;
    pub const CMD_NOTHING: Type = 7;
}
pub mod JoinType {
    pub type Type = ::core::ffi::c_uint;
    pub const JOIN_INNER: Type = 0;
    pub const JOIN_LEFT: Type = 1;
    pub const JOIN_FULL: Type = 2;
    pub const JOIN_RIGHT: Type = 3;
    pub const JOIN_SEMI: Type = 4;
    pub const JOIN_ANTI: Type = 5;
    pub const JOIN_RIGHT_ANTI: Type = 6;
    pub const JOIN_UNIQUE_OUTER: Type = 7;
    pub const JOIN_UNIQUE_INNER: Type = 8;
}
pub mod AggStrategy {
    pub type Type = ::core::ffi::c_uint;
    pub const AGG_PLAIN: Type = 0;
    pub const AGG_SORTED: Type = 1;
    pub const AGG_HASHED: Type = 2;
    pub const AGG_MIXED: Type = 3;
}
pub mod AggSplit {
    pub type Type = ::core::ffi::c_uint;
    pub const AGGSPLIT_SIMPLE: Type = 0;
    pub const AGGSPLIT_INITIAL_SERIAL: Type = 6;
    pub const AGGSPLIT_FINAL_DESERIAL: Type = 9;
}
pub mod SetOpCmd {
    pub type Type = ::core::ffi::c_uint;
    pub const SETOPCMD_INTERSECT: Type = 0;
    pub const SETOPCMD_INTERSECT_ALL: Type = 1;
    pub const SETOPCMD_EXCEPT: Type = 2;
    pub const SETOPCMD_EXCEPT_ALL: Type = 3;
}
pub mod SetOpStrategy {
    pub type Type = ::core::ffi::c_uint;
    pub const SETOP_SORTED: Type = 0;
    pub const SETOP_HASHED: Type = 1;
}
pub mod OnConflictAction {
    pub type Type = ::core::ffi::c_uint;
    pub const ONCONFLICT_NONE: Type = 0;
    pub const ONCONFLICT_NOTHING: Type = 1;
    pub const ONCONFLICT_UPDATE: Type = 2;
}
pub mod LimitOption {
    pub type Type = ::core::ffi::c_uint;
    pub const LIMIT_OPTION_COUNT: Type = 0;
    pub const LIMIT_OPTION_WITH_TIES: Type = 1;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ListCell {
    pub ptr_value: *mut ::core::ffi::c_void,
    pub int_value: ::core::ffi::c_int,
    pub oid_value: Oid,
    pub xid_value: TransactionId,
}
impl Default for ListCell {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct List {
    pub type_: NodeTag,
    pub length: ::core::ffi::c_int,
    pub max_length: ::core::ffi::c_int,
    pub elements: *mut ListCell,
    pub initial_elements: __IncompleteArrayField<ListCell>,
}
impl Default for List {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForEachState {
    pub l: *const List,
    pub i: ::core::ffi::c_int,
}
impl Default for ForEachState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForBothState {
    pub l1: *const List,
    pub l2: *const List,
    pub i: ::core::ffi::c_int,
}
impl Default for ForBothState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForBothCellState {
    pub l1: *const List,
    pub l2: *const List,
    pub i1: ::core::ffi::c_int,
    pub i2: ::core::ffi::c_int,
}
impl Default for ForBothCellState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForThreeState {
    pub l1: *const List,
    pub l2: *const List,
    pub l3: *const List,
    pub i: ::core::ffi::c_int,
}
impl Default for ForThreeState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForFourState {
    pub l1: *const List,
    pub l2: *const List,
    pub l3: *const List,
    pub l4: *const List,
    pub i: ::core::ffi::c_int,
}
impl Default for ForFourState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForFiveState {
    pub l1: *const List,
    pub l2: *const List,
    pub l3: *const List,
    pub l4: *const List,
    pub l5: *const List,
    pub i: ::core::ffi::c_int,
}
impl Default for ForFiveState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type list_sort_comparator = ::core::option::Option<
    unsafe extern "C-unwind" fn(a: *const ListCell, b: *const ListCell) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AttrDefault {
    pub adnum: AttrNumber,
    pub adbin: *mut ::core::ffi::c_char,
}
impl Default for AttrDefault {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConstrCheck {
    pub ccname: *mut ::core::ffi::c_char,
    pub ccbin: *mut ::core::ffi::c_char,
    pub ccvalid: bool,
    pub ccnoinherit: bool,
}
impl Default for ConstrCheck {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TupleConstr {
    pub defval: *mut AttrDefault,
    pub check: *mut ConstrCheck,
    pub missing: *mut AttrMissing,
    pub num_defval: uint16,
    pub num_check: uint16,
    pub has_not_null: bool,
    pub has_generated_stored: bool,
}
impl Default for TupleConstr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct TupleDescData {
    pub natts: ::core::ffi::c_int,
    pub tdtypeid: Oid,
    pub tdtypmod: int32,
    pub tdrefcount: ::core::ffi::c_int,
    pub constr: *mut TupleConstr,
    pub attrs: __IncompleteArrayField<FormData_pg_attribute>,
}
impl Default for TupleDescData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TupleDesc = *mut TupleDescData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AttrMap {
    pub attnums: *mut AttrNumber,
    pub maplen: ::core::ffi::c_int,
}
impl Default for AttrMap {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type BlockNumber = uint32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BlockIdData {
    pub bi_hi: uint16,
    pub bi_lo: uint16,
}
pub type BlockId = *mut BlockIdData;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct ItemIdData {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl ItemIdData {
    #[inline]
    pub fn lp_off(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_lp_off(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lp_off_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                15u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lp_off_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                15u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lp_flags(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_lp_flags(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lp_flags_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lp_flags_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lp_len(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_lp_len(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lp_len_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                15u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lp_len_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                15u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        lp_off: ::core::ffi::c_uint,
        lp_flags: ::core::ffi::c_uint,
        lp_len: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 15u8, {
            let lp_off: u32 = unsafe { ::core::mem::transmute(lp_off) };
            lp_off as u64
        });
        __bindgen_bitfield_unit.set(15usize, 2u8, {
            let lp_flags: u32 = unsafe { ::core::mem::transmute(lp_flags) };
            lp_flags as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let lp_len: u32 = unsafe { ::core::mem::transmute(lp_len) };
            lp_len as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ItemId = *mut ItemIdData;
pub type ItemOffset = uint16;
pub type ItemLength = uint16;
pub type OffsetNumber = uint16;
#[repr(C, packed(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct ItemPointerData {
    pub ip_blkid: BlockIdData,
    pub ip_posid: OffsetNumber,
}
pub type ItemPointer = *mut ItemPointerData;
pub type HeapTupleHeader = *mut HeapTupleHeaderData;
pub type MinimalTuple = *mut MinimalTupleData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeapTupleData {
    pub t_len: uint32,
    pub t_self: ItemPointerData,
    pub t_tableOid: Oid,
    pub t_data: HeapTupleHeader,
}
impl Default for HeapTupleData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type HeapTuple = *mut HeapTupleData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::core::ffi::c_void,
    pub iov_len: usize,
}
impl Default for iovec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type XLogRecPtr = uint64;
pub type XLogSegNo = uint64;
pub type TimeLineID = uint32;
pub type RepOriginId = uint16;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FullTransactionId {
    pub value: uint64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TransamVariablesData {
    pub nextOid: Oid,
    pub oidCount: uint32,
    pub nextXid: FullTransactionId,
    pub oldestXid: TransactionId,
    pub xidVacLimit: TransactionId,
    pub xidWarnLimit: TransactionId,
    pub xidStopLimit: TransactionId,
    pub xidWrapLimit: TransactionId,
    pub oldestXidDB: Oid,
    pub oldestCommitTsXid: TransactionId,
    pub newestCommitTsXid: TransactionId,
    pub latestCompletedXid: FullTransactionId,
    pub xactCompletionCount: uint64,
    pub oldestClogXid: TransactionId,
}
impl Default for TransamVariablesData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Item = Pointer;
pub type Page = Pointer;
pub type LocationIndex = uint16;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PageXLogRecPtr {
    pub xlogid: uint32,
    pub xrecoff: uint32,
}
#[repr(C)]
#[derive(Debug)]
pub struct PageHeaderData {
    pub pd_lsn: PageXLogRecPtr,
    pub pd_checksum: uint16,
    pub pd_flags: uint16,
    pub pd_lower: LocationIndex,
    pub pd_upper: LocationIndex,
    pub pd_special: LocationIndex,
    pub pd_pagesize_version: uint16,
    pub pd_prune_xid: TransactionId,
    pub pd_linp: __IncompleteArrayField<ItemIdData>,
}
impl Default for PageHeaderData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PageHeader = *mut PageHeaderData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct varatt_external {
    pub va_rawsize: int32,
    pub va_extinfo: uint32,
    pub va_valueid: Oid,
    pub va_toastrelid: Oid,
}
impl Default for varatt_external {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct varatt_indirect {
    pub pointer: *mut varlena,
}
impl Default for varatt_indirect {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct varatt_expanded {
    pub eohptr: *mut ExpandedObjectHeader,
}
impl Default for varatt_expanded {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod vartag_external {
    pub type Type = ::core::ffi::c_uint;
    pub const VARTAG_INDIRECT: Type = 1;
    pub const VARTAG_EXPANDED_RO: Type = 2;
    pub const VARTAG_EXPANDED_RW: Type = 3;
    pub const VARTAG_ONDISK: Type = 18;
}
#[repr(C)]
pub union varattrib_4b {
    pub va_4byte: ::core::mem::ManuallyDrop<varattrib_4b__bindgen_ty_1>,
    pub va_compressed: ::core::mem::ManuallyDrop<varattrib_4b__bindgen_ty_2>,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct varattrib_4b__bindgen_ty_1 {
    pub va_header: uint32,
    pub va_data: __IncompleteArrayField<::core::ffi::c_char>,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct varattrib_4b__bindgen_ty_2 {
    pub va_header: uint32,
    pub va_tcinfo: uint32,
    pub va_data: __IncompleteArrayField<::core::ffi::c_char>,
}
impl Default for varattrib_4b {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct varattrib_1b {
    pub va_header: uint8,
    pub va_data: __IncompleteArrayField<::core::ffi::c_char>,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct varattrib_1b_e {
    pub va_header: uint8,
    pub va_tag: uint8,
    pub va_data: __IncompleteArrayField<::core::ffi::c_char>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HeapTupleFields {
    pub t_xmin: TransactionId,
    pub t_xmax: TransactionId,
    pub t_field3: HeapTupleFields__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union HeapTupleFields__bindgen_ty_1 {
    pub t_cid: CommandId,
    pub t_xvac: TransactionId,
}
impl Default for HeapTupleFields__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for HeapTupleFields {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DatumTupleFields {
    pub datum_len_: int32,
    pub datum_typmod: int32,
    pub datum_typeid: Oid,
}
impl Default for DatumTupleFields {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct HeapTupleHeaderData {
    pub t_choice: HeapTupleHeaderData__bindgen_ty_1,
    pub t_ctid: ItemPointerData,
    pub t_infomask2: uint16,
    pub t_infomask: uint16,
    pub t_hoff: uint8,
    pub t_bits: __IncompleteArrayField<bits8>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union HeapTupleHeaderData__bindgen_ty_1 {
    pub t_heap: HeapTupleFields,
    pub t_datum: DatumTupleFields,
}
impl Default for HeapTupleHeaderData__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for HeapTupleHeaderData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct MinimalTupleData {
    pub t_len: uint32,
    pub mt_padding: [::core::ffi::c_char; 6usize],
    pub t_infomask2: uint16,
    pub t_infomask: uint16,
    pub t_hoff: uint8,
    pub t_bits: __IncompleteArrayField<bits8>,
}
pub type Buffer = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BufferAccessStrategyData {
    _unused: [u8; 0],
}
pub type BufferAccessStrategy = *mut BufferAccessStrategyData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TupleTableSlot {
    pub type_: NodeTag,
    pub tts_flags: uint16,
    pub tts_nvalid: AttrNumber,
    pub tts_ops: *const TupleTableSlotOps,
    pub tts_tupleDescriptor: TupleDesc,
    pub tts_values: *mut Datum,
    pub tts_isnull: *mut bool,
    pub tts_mcxt: MemoryContext,
    pub tts_tid: ItemPointerData,
    pub tts_tableOid: Oid,
}
impl Default for TupleTableSlot {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TupleTableSlotOps {
    pub base_slot_size: usize,
    pub init: ::core::option::Option<unsafe extern "C-unwind" fn(slot: *mut TupleTableSlot)>,
    pub release: ::core::option::Option<unsafe extern "C-unwind" fn(slot: *mut TupleTableSlot)>,
    pub clear: ::core::option::Option<unsafe extern "C-unwind" fn(slot: *mut TupleTableSlot)>,
    pub getsomeattrs: ::core::option::Option<
        unsafe extern "C-unwind" fn(slot: *mut TupleTableSlot, natts: ::core::ffi::c_int),
    >,
    pub getsysattr: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            slot: *mut TupleTableSlot,
            attnum: ::core::ffi::c_int,
            isnull: *mut bool,
        ) -> Datum,
    >,
    pub is_current_xact_tuple:
        ::core::option::Option<unsafe extern "C-unwind" fn(slot: *mut TupleTableSlot) -> bool>,
    pub materialize: ::core::option::Option<unsafe extern "C-unwind" fn(slot: *mut TupleTableSlot)>,
    pub copyslot: ::core::option::Option<
        unsafe extern "C-unwind" fn(dstslot: *mut TupleTableSlot, srcslot: *mut TupleTableSlot),
    >,
    pub get_heap_tuple:
        ::core::option::Option<unsafe extern "C-unwind" fn(slot: *mut TupleTableSlot) -> HeapTuple>,
    pub get_minimal_tuple: ::core::option::Option<
        unsafe extern "C-unwind" fn(slot: *mut TupleTableSlot) -> MinimalTuple,
    >,
    pub copy_heap_tuple:
        ::core::option::Option<unsafe extern "C-unwind" fn(slot: *mut TupleTableSlot) -> HeapTuple>,
    pub copy_minimal_tuple: ::core::option::Option<
        unsafe extern "C-unwind" fn(slot: *mut TupleTableSlot) -> MinimalTuple,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VirtualTupleTableSlot {
    pub base: TupleTableSlot,
    pub data: *mut ::core::ffi::c_char,
}
impl Default for VirtualTupleTableSlot {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeapTupleTableSlot {
    pub base: TupleTableSlot,
    pub tuple: HeapTuple,
    pub off: uint32,
    pub tupdata: HeapTupleData,
}
impl Default for HeapTupleTableSlot {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BufferHeapTupleTableSlot {
    pub base: HeapTupleTableSlot,
    pub buffer: Buffer,
}
impl Default for BufferHeapTupleTableSlot {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MinimalTupleTableSlot {
    pub base: TupleTableSlot,
    pub tuple: HeapTuple,
    pub mintuple: MinimalTuple,
    pub minhdr: HeapTupleData,
    pub off: uint32,
}
impl Default for MinimalTupleTableSlot {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type bitmapword = uint64;
pub type signedbitmapword = int64;
#[repr(C)]
#[derive(Debug)]
pub struct Bitmapset {
    pub type_: NodeTag,
    pub nwords: ::core::ffi::c_int,
    pub words: __IncompleteArrayField<bitmapword>,
}
impl Default for Bitmapset {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod BMS_Comparison {
    pub type Type = ::core::ffi::c_uint;
    pub const BMS_EQUAL: Type = 0;
    pub const BMS_SUBSET1: Type = 1;
    pub const BMS_SUBSET2: Type = 2;
    pub const BMS_DIFFERENT: Type = 3;
}
pub mod BMS_Membership {
    pub type Type = ::core::ffi::c_uint;
    pub const BMS_EMPTY_SET: Type = 0;
    pub const BMS_SINGLETON: Type = 1;
    pub const BMS_MULTIPLE: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TupleConversionMap {
    pub indesc: TupleDesc,
    pub outdesc: TupleDesc,
    pub attrMap: *mut AttrMap,
    pub invalues: *mut Datum,
    pub inisnull: *mut bool,
    pub outvalues: *mut Datum,
    pub outisnull: *mut bool,
}
impl Default for TupleConversionMap {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct instr_time {
    pub ticks: int64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BufferUsage {
    pub shared_blks_hit: int64,
    pub shared_blks_read: int64,
    pub shared_blks_dirtied: int64,
    pub shared_blks_written: int64,
    pub local_blks_hit: int64,
    pub local_blks_read: int64,
    pub local_blks_dirtied: int64,
    pub local_blks_written: int64,
    pub temp_blks_read: int64,
    pub temp_blks_written: int64,
    pub shared_blk_read_time: instr_time,
    pub shared_blk_write_time: instr_time,
    pub local_blk_read_time: instr_time,
    pub local_blk_write_time: instr_time,
    pub temp_blk_read_time: instr_time,
    pub temp_blk_write_time: instr_time,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WalUsage {
    pub wal_records: int64,
    pub wal_fpi: int64,
    pub wal_bytes: uint64,
}
pub mod InstrumentOption {
    pub type Type = ::core::ffi::c_uint;
    pub const INSTRUMENT_TIMER: Type = 1;
    pub const INSTRUMENT_BUFFERS: Type = 2;
    pub const INSTRUMENT_ROWS: Type = 4;
    pub const INSTRUMENT_WAL: Type = 8;
    pub const INSTRUMENT_ALL: Type = 2147483647;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Instrumentation {
    pub need_timer: bool,
    pub need_bufusage: bool,
    pub need_walusage: bool,
    pub async_mode: bool,
    pub running: bool,
    pub starttime: instr_time,
    pub counter: instr_time,
    pub firsttuple: f64,
    pub tuplecount: f64,
    pub bufusage_start: BufferUsage,
    pub walusage_start: WalUsage,
    pub startup: f64,
    pub total: f64,
    pub ntuples: f64,
    pub ntuples2: f64,
    pub nloops: f64,
    pub nfiltered1: f64,
    pub nfiltered2: f64,
    pub bufusage: BufferUsage,
    pub walusage: WalUsage,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct WorkerInstrumentation {
    pub num_workers: ::core::ffi::c_int,
    pub instrument: __IncompleteArrayField<Instrumentation>,
}
pub type fmNodePtr = *mut Node;
pub type fmAggrefPtr = *mut Aggref;
pub type fmExprContextCallbackFunction =
    ::core::option::Option<unsafe extern "C-unwind" fn(arg: Datum)>;
pub type fmStringInfo = *mut StringInfoData;
pub type FunctionCallInfo = *mut FunctionCallInfoBaseData;
pub type PGFunction =
    ::core::option::Option<unsafe extern "C-unwind" fn(fcinfo: FunctionCallInfo) -> Datum>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FmgrInfo {
    pub fn_addr: PGFunction,
    pub fn_oid: Oid,
    pub fn_nargs: ::core::ffi::c_short,
    pub fn_strict: bool,
    pub fn_retset: bool,
    pub fn_stats: ::core::ffi::c_uchar,
    pub fn_extra: *mut ::core::ffi::c_void,
    pub fn_mcxt: MemoryContext,
    pub fn_expr: fmNodePtr,
}
impl Default for FmgrInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct FunctionCallInfoBaseData {
    pub flinfo: *mut FmgrInfo,
    pub context: fmNodePtr,
    pub resultinfo: fmNodePtr,
    pub fncollation: Oid,
    pub isnull: bool,
    pub nargs: ::core::ffi::c_short,
    pub args: __IncompleteArrayField<NullableDatum>,
}
impl Default for FunctionCallInfoBaseData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Pg_finfo_record {
    pub api_version: ::core::ffi::c_int,
}
pub type PGFInfoFunction =
    ::core::option::Option<unsafe extern "C-unwind" fn() -> *const Pg_finfo_record>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Pg_magic_struct {
    pub len: ::core::ffi::c_int,
    pub version: ::core::ffi::c_int,
    pub funcmaxargs: ::core::ffi::c_int,
    pub indexmaxkeys: ::core::ffi::c_int,
    pub namedatalen: ::core::ffi::c_int,
    pub float8byval: ::core::ffi::c_int,
    pub abi_extra: [::core::ffi::c_char; 32usize],
}
pub type PGModuleMagicFunction =
    ::core::option::Option<unsafe extern "C-unwind" fn() -> *const Pg_magic_struct>;
pub mod FmgrHookEventType {
    pub type Type = ::core::ffi::c_uint;
    pub const FHET_START: Type = 0;
    pub const FHET_END: Type = 1;
    pub const FHET_ABORT: Type = 2;
}
pub type needs_fmgr_hook_type =
    ::core::option::Option<unsafe extern "C-unwind" fn(fn_oid: Oid) -> bool>;
pub type fmgr_hook_type = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        event: FmgrHookEventType::Type,
        flinfo: *mut FmgrInfo,
        arg: *mut Datum,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dlist_node {
    pub prev: *mut dlist_node,
    pub next: *mut dlist_node,
}
impl Default for dlist_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dlist_head {
    pub head: dlist_node,
}
impl Default for dlist_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dlist_iter {
    pub cur: *mut dlist_node,
    pub end: *mut dlist_node,
}
impl Default for dlist_iter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dlist_mutable_iter {
    pub cur: *mut dlist_node,
    pub next: *mut dlist_node,
    pub end: *mut dlist_node,
}
impl Default for dlist_mutable_iter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dclist_head {
    pub dlist: dlist_head,
    pub count: uint32,
}
impl Default for dclist_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slist_node {
    pub next: *mut slist_node,
}
impl Default for slist_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slist_head {
    pub head: slist_node,
}
impl Default for slist_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slist_iter {
    pub cur: *mut slist_node,
}
impl Default for slist_iter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slist_mutable_iter {
    pub cur: *mut slist_node,
    pub next: *mut slist_node,
    pub prev: *mut slist_node,
}
impl Default for slist_mutable_iter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pairingheap_node {
    pub first_child: *mut pairingheap_node,
    pub next_sibling: *mut pairingheap_node,
    pub prev_or_parent: *mut pairingheap_node,
}
impl Default for pairingheap_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pairingheap_comparator = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        a: *const pairingheap_node,
        b: *const pairingheap_node,
        arg: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pairingheap {
    pub ph_compare: pairingheap_comparator,
    pub ph_arg: *mut ::core::ffi::c_void,
    pub ph_root: *mut pairingheap_node,
}
impl Default for pairingheap {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ErrorSaveContext {
    pub type_: NodeTag,
    pub error_occurred: bool,
    pub details_wanted: bool,
    pub error_data: *mut ErrorData,
}
impl Default for ErrorSaveContext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParamExternData {
    pub value: Datum,
    pub isnull: bool,
    pub pflags: uint16,
    pub ptype: Oid,
}
impl Default for ParamExternData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ParamListInfo = *mut ParamListInfoData;
pub type ParamFetchHook = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        params: ParamListInfo,
        paramid: ::core::ffi::c_int,
        speculative: bool,
        workspace: *mut ParamExternData,
    ) -> *mut ParamExternData,
>;
pub type ParamCompileHook = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        params: ParamListInfo,
        param: *mut Param,
        state: *mut ExprState,
        resv: *mut Datum,
        resnull: *mut bool,
    ),
>;
pub type ParserSetupHook = ::core::option::Option<
    unsafe extern "C-unwind" fn(pstate: *mut ParseState, arg: *mut ::core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug)]
pub struct ParamListInfoData {
    pub paramFetch: ParamFetchHook,
    pub paramFetchArg: *mut ::core::ffi::c_void,
    pub paramCompile: ParamCompileHook,
    pub paramCompileArg: *mut ::core::ffi::c_void,
    pub parserSetup: ParserSetupHook,
    pub parserSetupArg: *mut ::core::ffi::c_void,
    pub paramValuesStr: *mut ::core::ffi::c_char,
    pub numParams: ::core::ffi::c_int,
    pub params: __IncompleteArrayField<ParamExternData>,
}
impl Default for ParamListInfoData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParamExecData {
    pub execPlan: *mut ::core::ffi::c_void,
    pub value: Datum,
    pub isnull: bool,
}
impl Default for ParamExecData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParamsErrorCbData {
    pub portalName: *const ::core::ffi::c_char,
    pub params: ParamListInfo,
}
impl Default for ParamsErrorCbData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod ScanDirection {
    pub type Type = ::core::ffi::c_int;
    pub const BackwardScanDirection: Type = -1;
    pub const NoMovementScanDirection: Type = 0;
    pub const ForwardScanDirection: Type = 1;
}
pub type StrategyNumber = uint16;
pub type RelFileNumber = Oid;
pub mod ForkNumber {
    pub type Type = ::core::ffi::c_int;
    pub const InvalidForkNumber: Type = -1;
    pub const MAIN_FORKNUM: Type = 0;
    pub const FSM_FORKNUM: Type = 1;
    pub const VISIBILITYMAP_FORKNUM: Type = 2;
    pub const INIT_FORKNUM: Type = 3;
}
pub mod LockClauseStrength {
    pub type Type = ::core::ffi::c_uint;
    pub const LCS_NONE: Type = 0;
    pub const LCS_FORKEYSHARE: Type = 1;
    pub const LCS_FORSHARE: Type = 2;
    pub const LCS_FORNOKEYUPDATE: Type = 3;
    pub const LCS_FORUPDATE: Type = 4;
}
pub mod LockWaitPolicy {
    pub type Type = ::core::ffi::c_uint;
    pub const LockWaitBlock: Type = 0;
    pub const LockWaitSkip: Type = 1;
    pub const LockWaitError: Type = 2;
}
pub mod LockTupleMode {
    pub type Type = ::core::ffi::c_uint;
    pub const LockTupleKeyShare: Type = 0;
    pub const LockTupleShare: Type = 1;
    pub const LockTupleNoKeyExclusive: Type = 2;
    pub const LockTupleExclusive: Type = 3;
}
pub mod OverridingKind {
    pub type Type = ::core::ffi::c_uint;
    pub const OVERRIDING_NOT_SET: Type = 0;
    pub const OVERRIDING_USER_VALUE: Type = 1;
    pub const OVERRIDING_SYSTEM_VALUE: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Alias {
    pub type_: NodeTag,
    pub aliasname: *mut ::core::ffi::c_char,
    pub colnames: *mut List,
}
impl Default for Alias {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod OnCommitAction {
    pub type Type = ::core::ffi::c_uint;
    pub const ONCOMMIT_NOOP: Type = 0;
    pub const ONCOMMIT_PRESERVE_ROWS: Type = 1;
    pub const ONCOMMIT_DELETE_ROWS: Type = 2;
    pub const ONCOMMIT_DROP: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeVar {
    pub type_: NodeTag,
    pub catalogname: *mut ::core::ffi::c_char,
    pub schemaname: *mut ::core::ffi::c_char,
    pub relname: *mut ::core::ffi::c_char,
    pub inh: bool,
    pub relpersistence: ::core::ffi::c_char,
    pub alias: *mut Alias,
    pub location: ParseLoc,
}
impl Default for RangeVar {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod TableFuncType {
    pub type Type = ::core::ffi::c_uint;
    pub const TFT_XMLTABLE: Type = 0;
    pub const TFT_JSON_TABLE: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TableFunc {
    pub type_: NodeTag,
    pub functype: TableFuncType::Type,
    pub ns_uris: *mut List,
    pub ns_names: *mut List,
    pub docexpr: *mut Node,
    pub rowexpr: *mut Node,
    pub colnames: *mut List,
    pub coltypes: *mut List,
    pub coltypmods: *mut List,
    pub colcollations: *mut List,
    pub colexprs: *mut List,
    pub coldefexprs: *mut List,
    pub colvalexprs: *mut List,
    pub passingvalexprs: *mut List,
    pub notnulls: *mut Bitmapset,
    pub plan: *mut Node,
    pub ordinalitycol: ::core::ffi::c_int,
    pub location: ParseLoc,
}
impl Default for TableFunc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IntoClause {
    pub type_: NodeTag,
    pub rel: *mut RangeVar,
    pub colNames: *mut List,
    pub accessMethod: *mut ::core::ffi::c_char,
    pub options: *mut List,
    pub onCommit: OnCommitAction::Type,
    pub tableSpaceName: *mut ::core::ffi::c_char,
    pub viewQuery: *mut Node,
    pub skipData: bool,
}
impl Default for IntoClause {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Expr {
    pub type_: NodeTag,
}
impl Default for Expr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Var {
    pub xpr: Expr,
    pub varno: ::core::ffi::c_int,
    pub varattno: AttrNumber,
    pub vartype: Oid,
    pub vartypmod: int32,
    pub varcollid: Oid,
    pub varnullingrels: *mut Bitmapset,
    pub varlevelsup: Index,
    pub varnosyn: Index,
    pub varattnosyn: AttrNumber,
    pub location: ParseLoc,
}
impl Default for Var {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Const {
    pub xpr: Expr,
    pub consttype: Oid,
    pub consttypmod: int32,
    pub constcollid: Oid,
    pub constlen: ::core::ffi::c_int,
    pub constvalue: Datum,
    pub constisnull: bool,
    pub constbyval: bool,
    pub location: ParseLoc,
}
impl Default for Const {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod ParamKind {
    pub type Type = ::core::ffi::c_uint;
    pub const PARAM_EXTERN: Type = 0;
    pub const PARAM_EXEC: Type = 1;
    pub const PARAM_SUBLINK: Type = 2;
    pub const PARAM_MULTIEXPR: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Param {
    pub xpr: Expr,
    pub paramkind: ParamKind::Type,
    pub paramid: ::core::ffi::c_int,
    pub paramtype: Oid,
    pub paramtypmod: int32,
    pub paramcollid: Oid,
    pub location: ParseLoc,
}
impl Default for Param {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Aggref {
    pub xpr: Expr,
    pub aggfnoid: Oid,
    pub aggtype: Oid,
    pub aggcollid: Oid,
    pub inputcollid: Oid,
    pub aggtranstype: Oid,
    pub aggargtypes: *mut List,
    pub aggdirectargs: *mut List,
    pub args: *mut List,
    pub aggorder: *mut List,
    pub aggdistinct: *mut List,
    pub aggfilter: *mut Expr,
    pub aggstar: bool,
    pub aggvariadic: bool,
    pub aggkind: ::core::ffi::c_char,
    pub aggpresorted: bool,
    pub agglevelsup: Index,
    pub aggsplit: AggSplit::Type,
    pub aggno: ::core::ffi::c_int,
    pub aggtransno: ::core::ffi::c_int,
    pub location: ParseLoc,
}
impl Default for Aggref {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupingFunc {
    pub xpr: Expr,
    pub args: *mut List,
    pub refs: *mut List,
    pub cols: *mut List,
    pub agglevelsup: Index,
    pub location: ParseLoc,
}
impl Default for GroupingFunc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowFunc {
    pub xpr: Expr,
    pub winfnoid: Oid,
    pub wintype: Oid,
    pub wincollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub aggfilter: *mut Expr,
    pub runCondition: *mut List,
    pub winref: Index,
    pub winstar: bool,
    pub winagg: bool,
    pub location: ParseLoc,
}
impl Default for WindowFunc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowFuncRunCondition {
    pub xpr: Expr,
    pub opno: Oid,
    pub inputcollid: Oid,
    pub wfunc_left: bool,
    pub arg: *mut Expr,
}
impl Default for WindowFuncRunCondition {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeSupportFunc {
    pub xpr: Expr,
    pub msftype: Oid,
    pub msfcollid: Oid,
    pub location: ParseLoc,
}
impl Default for MergeSupportFunc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubscriptingRef {
    pub xpr: Expr,
    pub refcontainertype: Oid,
    pub refelemtype: Oid,
    pub refrestype: Oid,
    pub reftypmod: int32,
    pub refcollid: Oid,
    pub refupperindexpr: *mut List,
    pub reflowerindexpr: *mut List,
    pub refexpr: *mut Expr,
    pub refassgnexpr: *mut Expr,
}
impl Default for SubscriptingRef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod CoercionContext {
    pub type Type = ::core::ffi::c_uint;
    pub const COERCION_IMPLICIT: Type = 0;
    pub const COERCION_ASSIGNMENT: Type = 1;
    pub const COERCION_PLPGSQL: Type = 2;
    pub const COERCION_EXPLICIT: Type = 3;
}
pub mod CoercionForm {
    pub type Type = ::core::ffi::c_uint;
    pub const COERCE_EXPLICIT_CALL: Type = 0;
    pub const COERCE_EXPLICIT_CAST: Type = 1;
    pub const COERCE_IMPLICIT_CAST: Type = 2;
    pub const COERCE_SQL_SYNTAX: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuncExpr {
    pub xpr: Expr,
    pub funcid: Oid,
    pub funcresulttype: Oid,
    pub funcretset: bool,
    pub funcvariadic: bool,
    pub funcformat: CoercionForm::Type,
    pub funccollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub location: ParseLoc,
}
impl Default for FuncExpr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NamedArgExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub name: *mut ::core::ffi::c_char,
    pub argnumber: ::core::ffi::c_int,
    pub location: ParseLoc,
}
impl Default for NamedArgExpr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpExpr {
    pub xpr: Expr,
    pub opno: Oid,
    pub opfuncid: Oid,
    pub opresulttype: Oid,
    pub opretset: bool,
    pub opcollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub location: ParseLoc,
}
impl Default for OpExpr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type DistinctExpr = OpExpr;
pub type NullIfExpr = OpExpr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScalarArrayOpExpr {
    pub xpr: Expr,
    pub opno: Oid,
    pub opfuncid: Oid,
    pub hashfuncid: Oid,
    pub negfuncid: Oid,
    pub useOr: bool,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub location: ParseLoc,
}
impl Default for ScalarArrayOpExpr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod BoolExprType {
    pub type Type = ::core::ffi::c_uint;
    pub const AND_EXPR: Type = 0;
    pub const OR_EXPR: Type = 1;
    pub const NOT_EXPR: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BoolExpr {
    pub xpr: Expr,
    pub boolop: BoolExprType::Type,
    pub args: *mut List,
    pub location: ParseLoc,
}
impl Default for BoolExpr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod SubLinkType {
    pub type Type = ::core::ffi::c_uint;
    pub const EXISTS_SUBLINK: Type = 0;
    pub const ALL_SUBLINK: Type = 1;
    pub const ANY_SUBLINK: Type = 2;
    pub const ROWCOMPARE_SUBLINK: Type = 3;
    pub const EXPR_SUBLINK: Type = 4;
    pub const MULTIEXPR_SUBLINK: Type = 5;
    pub const ARRAY_SUBLINK: Type = 6;
    pub const CTE_SUBLINK: Type = 7;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubLink {
    pub xpr: Expr,
    pub subLinkType: SubLinkType::Type,
    pub subLinkId: ::core::ffi::c_int,
    pub testexpr: *mut Node,
    pub operName: *mut List,
    pub subselect: *mut Node,
    pub location: ParseLoc,
}
impl Default for SubLink {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubPlan {
    pub xpr: Expr,
    pub subLinkType: SubLinkType::Type,
    pub testexpr: *mut Node,
    pub paramIds: *mut List,
    pub plan_id: ::core::ffi::c_int,
    pub plan_name: *mut ::core::ffi::c_char,
    pub firstColType: Oid,
    pub firstColTypmod: int32,
    pub firstColCollation: Oid,
    pub useHashTable: bool,
    pub unknownEqFalse: bool,
    pub parallel_safe: bool,
    pub setParam: *mut List,
    pub parParam: *mut List,
    pub args: *mut List,
    pub startup_cost: Cost,
    pub per_call_cost: Cost,
}
impl Default for SubPlan {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlternativeSubPlan {
    pub xpr: Expr,
    pub subplans: *mut List,
}
impl Default for AlternativeSubPlan {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FieldSelect {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub fieldnum: AttrNumber,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
}
impl Default for FieldSelect {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FieldStore {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub newvals: *mut List,
    pub fieldnums: *mut List,
    pub resulttype: Oid,
}
impl Default for FieldStore {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RelabelType {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub relabelformat: CoercionForm::Type,
    pub location: ParseLoc,
}
impl Default for RelabelType {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CoerceViaIO {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub resultcollid: Oid,
    pub coerceformat: CoercionForm::Type,
    pub location: ParseLoc,
}
impl Default for CoerceViaIO {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayCoerceExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub elemexpr: *mut Expr,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub coerceformat: CoercionForm::Type,
    pub location: ParseLoc,
}
impl Default for ArrayCoerceExpr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConvertRowtypeExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub convertformat: CoercionForm::Type,
    pub location: ParseLoc,
}
impl Default for ConvertRowtypeExpr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollateExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub collOid: Oid,
    pub location: ParseLoc,
}
impl Default for CollateExpr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CaseExpr {
    pub xpr: Expr,
    pub casetype: Oid,
    pub casecollid: Oid,
    pub arg: *mut Expr,
    pub args: *mut List,
    pub defresult: *mut Expr,
    pub location: ParseLoc,
}
impl Default for CaseExpr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CaseWhen {
    pub xpr: Expr,
    pub expr: *mut Expr,
    pub result: *mut Expr,
    pub location: ParseLoc,
}
impl Default for CaseWhen {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CaseTestExpr {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
}
impl Default for CaseTestExpr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayExpr {
    pub xpr: Expr,
    pub array_typeid: Oid,
    pub array_collid: Oid,
    pub element_typeid: Oid,
    pub elements: *mut List,
    pub multidims: bool,
    pub location: ParseLoc,
}
impl Default for ArrayExpr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RowExpr {
    pub xpr: Expr,
    pub args: *mut List,
    pub row_typeid: Oid,
    pub row_format: CoercionForm::Type,
    pub colnames: *mut List,
    pub location: ParseLoc,
}
impl Default for RowExpr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod RowCompareType {
    pub type Type = ::core::ffi::c_uint;
    pub const ROWCOMPARE_LT: Type = 1;
    pub const ROWCOMPARE_LE: Type = 2;
    pub const ROWCOMPARE_EQ: Type = 3;
    pub const ROWCOMPARE_GE: Type = 4;
    pub const ROWCOMPARE_GT: Type = 5;
    pub const ROWCOMPARE_NE: Type = 6;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RowCompareExpr {
    pub xpr: Expr,
    pub rctype: RowCompareType::Type,
    pub opnos: *mut List,
    pub opfamilies: *mut List,
    pub inputcollids: *mut List,
    pub largs: *mut List,
    pub rargs: *mut List,
}
impl Default for RowCompareExpr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CoalesceExpr {
    pub xpr: Expr,
    pub coalescetype: Oid,
    pub coalescecollid: Oid,
    pub args: *mut List,
    pub location: ParseLoc,
}
impl Default for CoalesceExpr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod MinMaxOp {
    pub type Type = ::core::ffi::c_uint;
    pub const IS_GREATEST: Type = 0;
    pub const IS_LEAST: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MinMaxExpr {
    pub xpr: Expr,
    pub minmaxtype: Oid,
    pub minmaxcollid: Oid,
    pub inputcollid: Oid,
    pub op: MinMaxOp::Type,
    pub args: *mut List,
    pub location: ParseLoc,
}
impl Default for MinMaxExpr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod SQLValueFunctionOp {
    pub type Type = ::core::ffi::c_uint;
    pub const SVFOP_CURRENT_DATE: Type = 0;
    pub const SVFOP_CURRENT_TIME: Type = 1;
    pub const SVFOP_CURRENT_TIME_N: Type = 2;
    pub const SVFOP_CURRENT_TIMESTAMP: Type = 3;
    pub const SVFOP_CURRENT_TIMESTAMP_N: Type = 4;
    pub const SVFOP_LOCALTIME: Type = 5;
    pub const SVFOP_LOCALTIME_N: Type = 6;
    pub const SVFOP_LOCALTIMESTAMP: Type = 7;
    pub const SVFOP_LOCALTIMESTAMP_N: Type = 8;
    pub const SVFOP_CURRENT_ROLE: Type = 9;
    pub const SVFOP_CURRENT_USER: Type = 10;
    pub const SVFOP_USER: Type = 11;
    pub const SVFOP_SESSION_USER: Type = 12;
    pub const SVFOP_CURRENT_CATALOG: Type = 13;
    pub const SVFOP_CURRENT_SCHEMA: Type = 14;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SQLValueFunction {
    pub xpr: Expr,
    pub op: SQLValueFunctionOp::Type,
    pub type_: Oid,
    pub typmod: int32,
    pub location: ParseLoc,
}
impl Default for SQLValueFunction {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod XmlExprOp {
    pub type Type = ::core::ffi::c_uint;
    pub const IS_XMLCONCAT: Type = 0;
    pub const IS_XMLELEMENT: Type = 1;
    pub const IS_XMLFOREST: Type = 2;
    pub const IS_XMLPARSE: Type = 3;
    pub const IS_XMLPI: Type = 4;
    pub const IS_XMLROOT: Type = 5;
    pub const IS_XMLSERIALIZE: Type = 6;
    pub const IS_DOCUMENT: Type = 7;
}
pub mod XmlOptionType {
    pub type Type = ::core::ffi::c_uint;
    pub const XMLOPTION_DOCUMENT: Type = 0;
    pub const XMLOPTION_CONTENT: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XmlExpr {
    pub xpr: Expr,
    pub op: XmlExprOp::Type,
    pub name: *mut ::core::ffi::c_char,
    pub named_args: *mut List,
    pub arg_names: *mut List,
    pub args: *mut List,
    pub xmloption: XmlOptionType::Type,
    pub indent: bool,
    pub type_: Oid,
    pub typmod: int32,
    pub location: ParseLoc,
}
impl Default for XmlExpr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod JsonEncoding {
    pub type Type = ::core::ffi::c_uint;
    pub const JS_ENC_DEFAULT: Type = 0;
    pub const JS_ENC_UTF8: Type = 1;
    pub const JS_ENC_UTF16: Type = 2;
    pub const JS_ENC_UTF32: Type = 3;
}
pub mod JsonFormatType {
    pub type Type = ::core::ffi::c_uint;
    pub const JS_FORMAT_DEFAULT: Type = 0;
    pub const JS_FORMAT_JSON: Type = 1;
    pub const JS_FORMAT_JSONB: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonFormat {
    pub type_: NodeTag,
    pub format_type: JsonFormatType::Type,
    pub encoding: JsonEncoding::Type,
    pub location: ParseLoc,
}
impl Default for JsonFormat {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonReturning {
    pub type_: NodeTag,
    pub format: *mut JsonFormat,
    pub typid: Oid,
    pub typmod: int32,
}
impl Default for JsonReturning {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonValueExpr {
    pub type_: NodeTag,
    pub raw_expr: *mut Expr,
    pub formatted_expr: *mut Expr,
    pub format: *mut JsonFormat,
}
impl Default for JsonValueExpr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod JsonConstructorType {
    pub type Type = ::core::ffi::c_uint;
    pub const JSCTOR_JSON_OBJECT: Type = 1;
    pub const JSCTOR_JSON_ARRAY: Type = 2;
    pub const JSCTOR_JSON_OBJECTAGG: Type = 3;
    pub const JSCTOR_JSON_ARRAYAGG: Type = 4;
    pub const JSCTOR_JSON_PARSE: Type = 5;
    pub const JSCTOR_JSON_SCALAR: Type = 6;
    pub const JSCTOR_JSON_SERIALIZE: Type = 7;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonConstructorExpr {
    pub xpr: Expr,
    pub type_: JsonConstructorType::Type,
    pub args: *mut List,
    pub func: *mut Expr,
    pub coercion: *mut Expr,
    pub returning: *mut JsonReturning,
    pub absent_on_null: bool,
    pub unique: bool,
    pub location: ParseLoc,
}
impl Default for JsonConstructorExpr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod JsonValueType {
    pub type Type = ::core::ffi::c_uint;
    pub const JS_TYPE_ANY: Type = 0;
    pub const JS_TYPE_OBJECT: Type = 1;
    pub const JS_TYPE_ARRAY: Type = 2;
    pub const JS_TYPE_SCALAR: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonIsPredicate {
    pub type_: NodeTag,
    pub expr: *mut Node,
    pub format: *mut JsonFormat,
    pub item_type: JsonValueType::Type,
    pub unique_keys: bool,
    pub location: ParseLoc,
}
impl Default for JsonIsPredicate {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod JsonWrapper {
    pub type Type = ::core::ffi::c_uint;
    pub const JSW_UNSPEC: Type = 0;
    pub const JSW_NONE: Type = 1;
    pub const JSW_CONDITIONAL: Type = 2;
    pub const JSW_UNCONDITIONAL: Type = 3;
}
pub mod JsonBehaviorType {
    pub type Type = ::core::ffi::c_uint;
    pub const JSON_BEHAVIOR_NULL: Type = 0;
    pub const JSON_BEHAVIOR_ERROR: Type = 1;
    pub const JSON_BEHAVIOR_EMPTY: Type = 2;
    pub const JSON_BEHAVIOR_TRUE: Type = 3;
    pub const JSON_BEHAVIOR_FALSE: Type = 4;
    pub const JSON_BEHAVIOR_UNKNOWN: Type = 5;
    pub const JSON_BEHAVIOR_EMPTY_ARRAY: Type = 6;
    pub const JSON_BEHAVIOR_EMPTY_OBJECT: Type = 7;
    pub const JSON_BEHAVIOR_DEFAULT: Type = 8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonBehavior {
    pub type_: NodeTag,
    pub btype: JsonBehaviorType::Type,
    pub expr: *mut Node,
    pub coerce: bool,
    pub location: ParseLoc,
}
impl Default for JsonBehavior {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod JsonExprOp {
    pub type Type = ::core::ffi::c_uint;
    pub const JSON_EXISTS_OP: Type = 0;
    pub const JSON_QUERY_OP: Type = 1;
    pub const JSON_VALUE_OP: Type = 2;
    pub const JSON_TABLE_OP: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonExpr {
    pub xpr: Expr,
    pub op: JsonExprOp::Type,
    pub column_name: *mut ::core::ffi::c_char,
    pub formatted_expr: *mut Node,
    pub format: *mut JsonFormat,
    pub path_spec: *mut Node,
    pub returning: *mut JsonReturning,
    pub passing_names: *mut List,
    pub passing_values: *mut List,
    pub on_empty: *mut JsonBehavior,
    pub on_error: *mut JsonBehavior,
    pub use_io_coercion: bool,
    pub use_json_coercion: bool,
    pub wrapper: JsonWrapper::Type,
    pub omit_quotes: bool,
    pub collation: Oid,
    pub location: ParseLoc,
}
impl Default for JsonExpr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonTablePath {
    pub type_: NodeTag,
    pub value: *mut Const,
    pub name: *mut ::core::ffi::c_char,
}
impl Default for JsonTablePath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonTablePlan {
    pub type_: NodeTag,
}
impl Default for JsonTablePlan {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonTablePathScan {
    pub plan: JsonTablePlan,
    pub path: *mut JsonTablePath,
    pub errorOnError: bool,
    pub child: *mut JsonTablePlan,
    pub colMin: ::core::ffi::c_int,
    pub colMax: ::core::ffi::c_int,
}
impl Default for JsonTablePathScan {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonTableSiblingJoin {
    pub plan: JsonTablePlan,
    pub lplan: *mut JsonTablePlan,
    pub rplan: *mut JsonTablePlan,
}
impl Default for JsonTableSiblingJoin {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod NullTestType {
    pub type Type = ::core::ffi::c_uint;
    pub const IS_NULL: Type = 0;
    pub const IS_NOT_NULL: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NullTest {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub nulltesttype: NullTestType::Type,
    pub argisrow: bool,
    pub location: ParseLoc,
}
impl Default for NullTest {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod BoolTestType {
    pub type Type = ::core::ffi::c_uint;
    pub const IS_TRUE: Type = 0;
    pub const IS_NOT_TRUE: Type = 1;
    pub const IS_FALSE: Type = 2;
    pub const IS_NOT_FALSE: Type = 3;
    pub const IS_UNKNOWN: Type = 4;
    pub const IS_NOT_UNKNOWN: Type = 5;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BooleanTest {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub booltesttype: BoolTestType::Type,
    pub location: ParseLoc,
}
impl Default for BooleanTest {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod MergeMatchKind {
    pub type Type = ::core::ffi::c_uint;
    pub const MERGE_WHEN_MATCHED: Type = 0;
    pub const MERGE_WHEN_NOT_MATCHED_BY_SOURCE: Type = 1;
    pub const MERGE_WHEN_NOT_MATCHED_BY_TARGET: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeAction {
    pub type_: NodeTag,
    pub matchKind: MergeMatchKind::Type,
    pub commandType: CmdType::Type,
    pub override_: OverridingKind::Type,
    pub qual: *mut Node,
    pub targetList: *mut List,
    pub updateColnos: *mut List,
}
impl Default for MergeAction {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CoerceToDomain {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub coercionformat: CoercionForm::Type,
    pub location: ParseLoc,
}
impl Default for CoerceToDomain {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CoerceToDomainValue {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
    pub location: ParseLoc,
}
impl Default for CoerceToDomainValue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SetToDefault {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
    pub location: ParseLoc,
}
impl Default for SetToDefault {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CurrentOfExpr {
    pub xpr: Expr,
    pub cvarno: Index,
    pub cursor_name: *mut ::core::ffi::c_char,
    pub cursor_param: ::core::ffi::c_int,
}
impl Default for CurrentOfExpr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NextValueExpr {
    pub xpr: Expr,
    pub seqid: Oid,
    pub typeId: Oid,
}
impl Default for NextValueExpr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InferenceElem {
    pub xpr: Expr,
    pub expr: *mut Node,
    pub infercollid: Oid,
    pub inferopclass: Oid,
}
impl Default for InferenceElem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TargetEntry {
    pub xpr: Expr,
    pub expr: *mut Expr,
    pub resno: AttrNumber,
    pub resname: *mut ::core::ffi::c_char,
    pub ressortgroupref: Index,
    pub resorigtbl: Oid,
    pub resorigcol: AttrNumber,
    pub resjunk: bool,
}
impl Default for TargetEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeTblRef {
    pub type_: NodeTag,
    pub rtindex: ::core::ffi::c_int,
}
impl Default for RangeTblRef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JoinExpr {
    pub type_: NodeTag,
    pub jointype: JoinType::Type,
    pub isNatural: bool,
    pub larg: *mut Node,
    pub rarg: *mut Node,
    pub usingClause: *mut List,
    pub join_using_alias: *mut Alias,
    pub quals: *mut Node,
    pub alias: *mut Alias,
    pub rtindex: ::core::ffi::c_int,
}
impl Default for JoinExpr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FromExpr {
    pub type_: NodeTag,
    pub fromlist: *mut List,
    pub quals: *mut Node,
}
impl Default for FromExpr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OnConflictExpr {
    pub type_: NodeTag,
    pub action: OnConflictAction::Type,
    pub arbiterElems: *mut List,
    pub arbiterWhere: *mut Node,
    pub constraint: Oid,
    pub onConflictSet: *mut List,
    pub onConflictWhere: *mut Node,
    pub exclRelIndex: ::core::ffi::c_int,
    pub exclRelTlist: *mut List,
}
impl Default for OnConflictExpr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlannedStmt {
    pub type_: NodeTag,
    pub commandType: CmdType::Type,
    pub queryId: uint64,
    pub hasReturning: bool,
    pub hasModifyingCTE: bool,
    pub canSetTag: bool,
    pub transientPlan: bool,
    pub dependsOnRole: bool,
    pub parallelModeNeeded: bool,
    pub jitFlags: ::core::ffi::c_int,
    pub planTree: *mut Plan,
    pub rtable: *mut List,
    pub permInfos: *mut List,
    pub resultRelations: *mut List,
    pub appendRelations: *mut List,
    pub subplans: *mut List,
    pub rewindPlanIDs: *mut Bitmapset,
    pub rowMarks: *mut List,
    pub relationOids: *mut List,
    pub invalItems: *mut List,
    pub paramExecTypes: *mut List,
    pub utilityStmt: *mut Node,
    pub stmt_location: ParseLoc,
    pub stmt_len: ParseLoc,
}
impl Default for PlannedStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Plan {
    pub type_: NodeTag,
    pub startup_cost: Cost,
    pub total_cost: Cost,
    pub plan_rows: Cardinality,
    pub plan_width: ::core::ffi::c_int,
    pub parallel_aware: bool,
    pub parallel_safe: bool,
    pub async_capable: bool,
    pub plan_node_id: ::core::ffi::c_int,
    pub targetlist: *mut List,
    pub qual: *mut List,
    pub lefttree: *mut Plan,
    pub righttree: *mut Plan,
    pub initPlan: *mut List,
    pub extParam: *mut Bitmapset,
    pub allParam: *mut Bitmapset,
}
impl Default for Plan {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Result {
    pub plan: Plan,
    pub resconstantqual: *mut Node,
}
impl Default for Result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProjectSet {
    pub plan: Plan,
}
impl Default for ProjectSet {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ModifyTable {
    pub plan: Plan,
    pub operation: CmdType::Type,
    pub canSetTag: bool,
    pub nominalRelation: Index,
    pub rootRelation: Index,
    pub partColsUpdated: bool,
    pub resultRelations: *mut List,
    pub updateColnosLists: *mut List,
    pub withCheckOptionLists: *mut List,
    pub returningLists: *mut List,
    pub fdwPrivLists: *mut List,
    pub fdwDirectModifyPlans: *mut Bitmapset,
    pub rowMarks: *mut List,
    pub epqParam: ::core::ffi::c_int,
    pub onConflictAction: OnConflictAction::Type,
    pub arbiterIndexes: *mut List,
    pub onConflictSet: *mut List,
    pub onConflictCols: *mut List,
    pub onConflictWhere: *mut Node,
    pub exclRelRTI: Index,
    pub exclRelTlist: *mut List,
    pub mergeActionLists: *mut List,
    pub mergeJoinConditions: *mut List,
}
impl Default for ModifyTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Append {
    pub plan: Plan,
    pub apprelids: *mut Bitmapset,
    pub appendplans: *mut List,
    pub nasyncplans: ::core::ffi::c_int,
    pub first_partial_plan: ::core::ffi::c_int,
    pub part_prune_info: *mut PartitionPruneInfo,
}
impl Default for Append {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeAppend {
    pub plan: Plan,
    pub apprelids: *mut Bitmapset,
    pub mergeplans: *mut List,
    pub numCols: ::core::ffi::c_int,
    pub sortColIdx: *mut AttrNumber,
    pub sortOperators: *mut Oid,
    pub collations: *mut Oid,
    pub nullsFirst: *mut bool,
    pub part_prune_info: *mut PartitionPruneInfo,
}
impl Default for MergeAppend {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecursiveUnion {
    pub plan: Plan,
    pub wtParam: ::core::ffi::c_int,
    pub numCols: ::core::ffi::c_int,
    pub dupColIdx: *mut AttrNumber,
    pub dupOperators: *mut Oid,
    pub dupCollations: *mut Oid,
    pub numGroups: ::core::ffi::c_long,
}
impl Default for RecursiveUnion {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapAnd {
    pub plan: Plan,
    pub bitmapplans: *mut List,
}
impl Default for BitmapAnd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapOr {
    pub plan: Plan,
    pub isshared: bool,
    pub bitmapplans: *mut List,
}
impl Default for BitmapOr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Scan {
    pub plan: Plan,
    pub scanrelid: Index,
}
impl Default for Scan {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SeqScan {
    pub scan: Scan,
}
impl Default for SeqScan {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SampleScan {
    pub scan: Scan,
    pub tablesample: *mut TableSampleClause,
}
impl Default for SampleScan {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexScan {
    pub scan: Scan,
    pub indexid: Oid,
    pub indexqual: *mut List,
    pub indexqualorig: *mut List,
    pub indexorderby: *mut List,
    pub indexorderbyorig: *mut List,
    pub indexorderbyops: *mut List,
    pub indexorderdir: ScanDirection::Type,
}
impl Default for IndexScan {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexOnlyScan {
    pub scan: Scan,
    pub indexid: Oid,
    pub indexqual: *mut List,
    pub recheckqual: *mut List,
    pub indexorderby: *mut List,
    pub indextlist: *mut List,
    pub indexorderdir: ScanDirection::Type,
}
impl Default for IndexOnlyScan {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapIndexScan {
    pub scan: Scan,
    pub indexid: Oid,
    pub isshared: bool,
    pub indexqual: *mut List,
    pub indexqualorig: *mut List,
}
impl Default for BitmapIndexScan {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapHeapScan {
    pub scan: Scan,
    pub bitmapqualorig: *mut List,
}
impl Default for BitmapHeapScan {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TidScan {
    pub scan: Scan,
    pub tidquals: *mut List,
}
impl Default for TidScan {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TidRangeScan {
    pub scan: Scan,
    pub tidrangequals: *mut List,
}
impl Default for TidRangeScan {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod SubqueryScanStatus {
    pub type Type = ::core::ffi::c_uint;
    pub const SUBQUERY_SCAN_UNKNOWN: Type = 0;
    pub const SUBQUERY_SCAN_TRIVIAL: Type = 1;
    pub const SUBQUERY_SCAN_NONTRIVIAL: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubqueryScan {
    pub scan: Scan,
    pub subplan: *mut Plan,
    pub scanstatus: SubqueryScanStatus::Type,
}
impl Default for SubqueryScan {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FunctionScan {
    pub scan: Scan,
    pub functions: *mut List,
    pub funcordinality: bool,
}
impl Default for FunctionScan {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ValuesScan {
    pub scan: Scan,
    pub values_lists: *mut List,
}
impl Default for ValuesScan {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TableFuncScan {
    pub scan: Scan,
    pub tablefunc: *mut TableFunc,
}
impl Default for TableFuncScan {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CteScan {
    pub scan: Scan,
    pub ctePlanId: ::core::ffi::c_int,
    pub cteParam: ::core::ffi::c_int,
}
impl Default for CteScan {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NamedTuplestoreScan {
    pub scan: Scan,
    pub enrname: *mut ::core::ffi::c_char,
}
impl Default for NamedTuplestoreScan {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WorkTableScan {
    pub scan: Scan,
    pub wtParam: ::core::ffi::c_int,
}
impl Default for WorkTableScan {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForeignScan {
    pub scan: Scan,
    pub operation: CmdType::Type,
    pub resultRelation: Index,
    pub checkAsUser: Oid,
    pub fs_server: Oid,
    pub fdw_exprs: *mut List,
    pub fdw_private: *mut List,
    pub fdw_scan_tlist: *mut List,
    pub fdw_recheck_quals: *mut List,
    pub fs_relids: *mut Bitmapset,
    pub fs_base_relids: *mut Bitmapset,
    pub fsSystemCol: bool,
}
impl Default for ForeignScan {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomScan {
    pub scan: Scan,
    pub flags: uint32,
    pub custom_plans: *mut List,
    pub custom_exprs: *mut List,
    pub custom_private: *mut List,
    pub custom_scan_tlist: *mut List,
    pub custom_relids: *mut Bitmapset,
    pub methods: *const CustomScanMethods,
}
impl Default for CustomScan {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Join {
    pub plan: Plan,
    pub jointype: JoinType::Type,
    pub inner_unique: bool,
    pub joinqual: *mut List,
}
impl Default for Join {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NestLoop {
    pub join: Join,
    pub nestParams: *mut List,
}
impl Default for NestLoop {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NestLoopParam {
    pub type_: NodeTag,
    pub paramno: ::core::ffi::c_int,
    pub paramval: *mut Var,
}
impl Default for NestLoopParam {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeJoin {
    pub join: Join,
    pub skip_mark_restore: bool,
    pub mergeclauses: *mut List,
    pub mergeFamilies: *mut Oid,
    pub mergeCollations: *mut Oid,
    pub mergeStrategies: *mut ::core::ffi::c_int,
    pub mergeNullsFirst: *mut bool,
}
impl Default for MergeJoin {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashJoin {
    pub join: Join,
    pub hashclauses: *mut List,
    pub hashoperators: *mut List,
    pub hashcollations: *mut List,
    pub hashkeys: *mut List,
}
impl Default for HashJoin {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Material {
    pub plan: Plan,
}
impl Default for Material {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Memoize {
    pub plan: Plan,
    pub numKeys: ::core::ffi::c_int,
    pub hashOperators: *mut Oid,
    pub collations: *mut Oid,
    pub param_exprs: *mut List,
    pub singlerow: bool,
    pub binary_mode: bool,
    pub est_entries: uint32,
    pub keyparamids: *mut Bitmapset,
}
impl Default for Memoize {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sort {
    pub plan: Plan,
    pub numCols: ::core::ffi::c_int,
    pub sortColIdx: *mut AttrNumber,
    pub sortOperators: *mut Oid,
    pub collations: *mut Oid,
    pub nullsFirst: *mut bool,
}
impl Default for Sort {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IncrementalSort {
    pub sort: Sort,
    pub nPresortedCols: ::core::ffi::c_int,
}
impl Default for IncrementalSort {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Group {
    pub plan: Plan,
    pub numCols: ::core::ffi::c_int,
    pub grpColIdx: *mut AttrNumber,
    pub grpOperators: *mut Oid,
    pub grpCollations: *mut Oid,
}
impl Default for Group {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Agg {
    pub plan: Plan,
    pub aggstrategy: AggStrategy::Type,
    pub aggsplit: AggSplit::Type,
    pub numCols: ::core::ffi::c_int,
    pub grpColIdx: *mut AttrNumber,
    pub grpOperators: *mut Oid,
    pub grpCollations: *mut Oid,
    pub numGroups: ::core::ffi::c_long,
    pub transitionSpace: uint64,
    pub aggParams: *mut Bitmapset,
    pub groupingSets: *mut List,
    pub chain: *mut List,
}
impl Default for Agg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowAgg {
    pub plan: Plan,
    pub winref: Index,
    pub partNumCols: ::core::ffi::c_int,
    pub partColIdx: *mut AttrNumber,
    pub partOperators: *mut Oid,
    pub partCollations: *mut Oid,
    pub ordNumCols: ::core::ffi::c_int,
    pub ordColIdx: *mut AttrNumber,
    pub ordOperators: *mut Oid,
    pub ordCollations: *mut Oid,
    pub frameOptions: ::core::ffi::c_int,
    pub startOffset: *mut Node,
    pub endOffset: *mut Node,
    pub runCondition: *mut List,
    pub runConditionOrig: *mut List,
    pub startInRangeFunc: Oid,
    pub endInRangeFunc: Oid,
    pub inRangeColl: Oid,
    pub inRangeAsc: bool,
    pub inRangeNullsFirst: bool,
    pub topWindow: bool,
}
impl Default for WindowAgg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Unique {
    pub plan: Plan,
    pub numCols: ::core::ffi::c_int,
    pub uniqColIdx: *mut AttrNumber,
    pub uniqOperators: *mut Oid,
    pub uniqCollations: *mut Oid,
}
impl Default for Unique {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Gather {
    pub plan: Plan,
    pub num_workers: ::core::ffi::c_int,
    pub rescan_param: ::core::ffi::c_int,
    pub single_copy: bool,
    pub invisible: bool,
    pub initParam: *mut Bitmapset,
}
impl Default for Gather {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GatherMerge {
    pub plan: Plan,
    pub num_workers: ::core::ffi::c_int,
    pub rescan_param: ::core::ffi::c_int,
    pub numCols: ::core::ffi::c_int,
    pub sortColIdx: *mut AttrNumber,
    pub sortOperators: *mut Oid,
    pub collations: *mut Oid,
    pub nullsFirst: *mut bool,
    pub initParam: *mut Bitmapset,
}
impl Default for GatherMerge {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Hash {
    pub plan: Plan,
    pub hashkeys: *mut List,
    pub skewTable: Oid,
    pub skewColumn: AttrNumber,
    pub skewInherit: bool,
    pub rows_total: Cardinality,
}
impl Default for Hash {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SetOp {
    pub plan: Plan,
    pub cmd: SetOpCmd::Type,
    pub strategy: SetOpStrategy::Type,
    pub numCols: ::core::ffi::c_int,
    pub dupColIdx: *mut AttrNumber,
    pub dupOperators: *mut Oid,
    pub dupCollations: *mut Oid,
    pub flagColIdx: AttrNumber,
    pub firstFlag: ::core::ffi::c_int,
    pub numGroups: ::core::ffi::c_long,
}
impl Default for SetOp {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LockRows {
    pub plan: Plan,
    pub rowMarks: *mut List,
    pub epqParam: ::core::ffi::c_int,
}
impl Default for LockRows {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Limit {
    pub plan: Plan,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
    pub limitOption: LimitOption::Type,
    pub uniqNumCols: ::core::ffi::c_int,
    pub uniqColIdx: *mut AttrNumber,
    pub uniqOperators: *mut Oid,
    pub uniqCollations: *mut Oid,
}
impl Default for Limit {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod RowMarkType {
    pub type Type = ::core::ffi::c_uint;
    pub const ROW_MARK_EXCLUSIVE: Type = 0;
    pub const ROW_MARK_NOKEYEXCLUSIVE: Type = 1;
    pub const ROW_MARK_SHARE: Type = 2;
    pub const ROW_MARK_KEYSHARE: Type = 3;
    pub const ROW_MARK_REFERENCE: Type = 4;
    pub const ROW_MARK_COPY: Type = 5;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlanRowMark {
    pub type_: NodeTag,
    pub rti: Index,
    pub prti: Index,
    pub rowmarkId: Index,
    pub markType: RowMarkType::Type,
    pub allMarkTypes: ::core::ffi::c_int,
    pub strength: LockClauseStrength::Type,
    pub waitPolicy: LockWaitPolicy::Type,
    pub isParent: bool,
}
impl Default for PlanRowMark {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionPruneInfo {
    pub type_: NodeTag,
    pub prune_infos: *mut List,
    pub other_subplans: *mut Bitmapset,
}
impl Default for PartitionPruneInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionedRelPruneInfo {
    pub type_: NodeTag,
    pub rtindex: Index,
    pub present_parts: *mut Bitmapset,
    pub nparts: ::core::ffi::c_int,
    pub subplan_map: *mut ::core::ffi::c_int,
    pub subpart_map: *mut ::core::ffi::c_int,
    pub relid_map: *mut Oid,
    pub initial_pruning_steps: *mut List,
    pub exec_pruning_steps: *mut List,
    pub execparamids: *mut Bitmapset,
}
impl Default for PartitionedRelPruneInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionPruneStep {
    pub type_: NodeTag,
    pub step_id: ::core::ffi::c_int,
}
impl Default for PartitionPruneStep {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionPruneStepOp {
    pub step: PartitionPruneStep,
    pub opstrategy: StrategyNumber,
    pub exprs: *mut List,
    pub cmpfns: *mut List,
    pub nullkeys: *mut Bitmapset,
}
impl Default for PartitionPruneStepOp {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod PartitionPruneCombineOp {
    pub type Type = ::core::ffi::c_uint;
    pub const PARTPRUNE_COMBINE_UNION: Type = 0;
    pub const PARTPRUNE_COMBINE_INTERSECT: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionPruneStepCombine {
    pub step: PartitionPruneStep,
    pub combineOp: PartitionPruneCombineOp::Type,
    pub source_stepids: *mut List,
}
impl Default for PartitionPruneStepCombine {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlanInvalItem {
    pub type_: NodeTag,
    pub cacheId: ::core::ffi::c_int,
    pub hashValue: uint32,
}
impl Default for PlanInvalItem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod MonotonicFunction {
    pub type Type = ::core::ffi::c_uint;
    pub const MONOTONICFUNC_NONE: Type = 0;
    pub const MONOTONICFUNC_INCREASING: Type = 1;
    pub const MONOTONICFUNC_DECREASING: Type = 2;
    pub const MONOTONICFUNC_BOTH: Type = 3;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pg_atomic_flag {
    pub value: ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pg_atomic_uint32 {
    pub value: uint32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pg_atomic_uint64 {
    pub value: uint64,
}
pub type dsm_handle = uint32;
pub mod dsm_op {
    pub type Type = ::core::ffi::c_uint;
    pub const DSM_OP_CREATE: Type = 0;
    pub const DSM_OP_ATTACH: Type = 1;
    pub const DSM_OP_DETACH: Type = 2;
    pub const DSM_OP_DESTROY: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsm_segment {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PGShmemHeader {
    _unused: [u8; 0],
}
pub type on_dsm_detach_callback =
    ::core::option::Option<unsafe extern "C-unwind" fn(arg1: *mut dsm_segment, arg: Datum)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_area {
    _unused: [u8; 0],
}
pub type dsa_pointer = uint64;
pub type dsa_pointer_atomic = pg_atomic_uint64;
pub type dsa_handle = dsm_handle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TIDBitmap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TBMIterator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TBMSharedIterator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct TBMIterateResult {
    pub blockno: BlockNumber,
    pub ntuples: ::core::ffi::c_int,
    pub recheck: bool,
    pub offsets: __IncompleteArrayField<OffsetNumber>,
}
pub type PartitionBoundInfo = *mut PartitionBoundInfoData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionKeyData {
    _unused: [u8; 0],
}
pub type PartitionKey = *mut PartitionKeyData;
pub type PartitionDesc = *mut PartitionDescData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionDirectoryData {
    _unused: [u8; 0],
}
pub type PartitionDirectory = *mut PartitionDirectoryData;
pub type ProcNumber = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct proclist_node {
    pub next: ProcNumber,
    pub prev: ProcNumber,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct proclist_head {
    pub head: ProcNumber,
    pub tail: ProcNumber,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct proclist_mutable_iter {
    pub cur: ProcNumber,
    pub next: ProcNumber,
}
pub type slock_t = ::core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SpinDelayStatus {
    pub spins: ::core::ffi::c_int,
    pub delays: ::core::ffi::c_int,
    pub cur_delay: ::core::ffi::c_int,
    pub file: *const ::core::ffi::c_char,
    pub line: ::core::ffi::c_int,
    pub func: *const ::core::ffi::c_char,
}
impl Default for SpinDelayStatus {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ConditionVariable {
    pub mutex: slock_t,
    pub wakeup: proclist_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ConditionVariableMinimallyPadded {
    pub cv: ConditionVariable,
    pub pad: [::core::ffi::c_char; 16usize],
}
impl Default for ConditionVariableMinimallyPadded {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type HashValueFunc = ::core::option::Option<
    unsafe extern "C-unwind" fn(key: *const ::core::ffi::c_void, keysize: Size) -> uint32,
>;
pub type HashCompareFunc = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        key1: *const ::core::ffi::c_void,
        key2: *const ::core::ffi::c_void,
        keysize: Size,
    ) -> ::core::ffi::c_int,
>;
pub type HashCopyFunc = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        dest: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        keysize: Size,
    ) -> *mut ::core::ffi::c_void,
>;
pub type HashAllocFunc =
    ::core::option::Option<unsafe extern "C-unwind" fn(request: Size) -> *mut ::core::ffi::c_void>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HASHELEMENT {
    pub link: *mut HASHELEMENT,
    pub hashvalue: uint32,
}
impl Default for HASHELEMENT {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HASHHDR {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTAB {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HASHCTL {
    pub num_partitions: ::core::ffi::c_long,
    pub ssize: ::core::ffi::c_long,
    pub dsize: ::core::ffi::c_long,
    pub max_dsize: ::core::ffi::c_long,
    pub keysize: Size,
    pub entrysize: Size,
    pub hash: HashValueFunc,
    pub match_: HashCompareFunc,
    pub keycopy: HashCopyFunc,
    pub alloc: HashAllocFunc,
    pub hcxt: MemoryContext,
    pub hctl: *mut HASHHDR,
}
impl Default for HASHCTL {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod HASHACTION {
    pub type Type = ::core::ffi::c_uint;
    pub const HASH_FIND: Type = 0;
    pub const HASH_ENTER: Type = 1;
    pub const HASH_REMOVE: Type = 2;
    pub const HASH_ENTER_NULL: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HASH_SEQ_STATUS {
    pub hashp: *mut HTAB,
    pub curBucket: uint32,
    pub curEntry: *mut HASHELEMENT,
}
impl Default for HASH_SEQ_STATUS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod EphemeralNameRelationType {
    pub type Type = ::core::ffi::c_uint;
    pub const ENR_NAMED_TUPLESTORE: Type = 0;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EphemeralNamedRelationMetadataData {
    pub name: *mut ::core::ffi::c_char,
    pub reliddesc: Oid,
    pub tupdesc: TupleDesc,
    pub enrtype: EphemeralNameRelationType::Type,
    pub enrtuples: f64,
}
impl Default for EphemeralNamedRelationMetadataData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type EphemeralNamedRelationMetadata = *mut EphemeralNamedRelationMetadataData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EphemeralNamedRelationData {
    pub md: EphemeralNamedRelationMetadataData,
    pub reldata: *mut ::core::ffi::c_void,
}
impl Default for EphemeralNamedRelationData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type EphemeralNamedRelation = *mut EphemeralNamedRelationData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueryEnvironment {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Trigger {
    pub tgoid: Oid,
    pub tgname: *mut ::core::ffi::c_char,
    pub tgfoid: Oid,
    pub tgtype: int16,
    pub tgenabled: ::core::ffi::c_char,
    pub tgisinternal: bool,
    pub tgisclone: bool,
    pub tgconstrrelid: Oid,
    pub tgconstrindid: Oid,
    pub tgconstraint: Oid,
    pub tgdeferrable: bool,
    pub tginitdeferred: bool,
    pub tgnargs: int16,
    pub tgnattr: int16,
    pub tgattr: *mut int16,
    pub tgargs: *mut *mut ::core::ffi::c_char,
    pub tgqual: *mut ::core::ffi::c_char,
    pub tgoldtable: *mut ::core::ffi::c_char,
    pub tgnewtable: *mut ::core::ffi::c_char,
}
impl Default for Trigger {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TriggerDesc {
    pub triggers: *mut Trigger,
    pub numtriggers: ::core::ffi::c_int,
    pub trig_insert_before_row: bool,
    pub trig_insert_after_row: bool,
    pub trig_insert_instead_row: bool,
    pub trig_insert_before_statement: bool,
    pub trig_insert_after_statement: bool,
    pub trig_update_before_row: bool,
    pub trig_update_after_row: bool,
    pub trig_update_instead_row: bool,
    pub trig_update_before_statement: bool,
    pub trig_update_after_statement: bool,
    pub trig_delete_before_row: bool,
    pub trig_delete_after_row: bool,
    pub trig_delete_instead_row: bool,
    pub trig_delete_before_statement: bool,
    pub trig_delete_after_statement: bool,
    pub trig_truncate_before_statement: bool,
    pub trig_truncate_after_statement: bool,
    pub trig_insert_new_table: bool,
    pub trig_update_old_table: bool,
    pub trig_update_new_table: bool,
    pub trig_delete_old_table: bool,
}
impl Default for TriggerDesc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type socklen_t = __socklen_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dirent {
    pub d_ino: __ino_t,
    pub d_off: __off_t,
    pub d_reclen: ::core::ffi::c_ushort,
    pub d_type: ::core::ffi::c_uchar,
    pub d_name: [::core::ffi::c_char; 256usize],
}
impl Default for dirent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dirstream {
    _unused: [u8; 0],
}
pub type DIR = __dirstream;
pub type File = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FileSet {
    pub creator_pid: pid_t,
    pub number: uint32,
    pub ntablespaces: ::core::ffi::c_int,
    pub tablespaces: [Oid; 8usize],
}
impl Default for FileSet {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SharedFileSet {
    pub fs: FileSet,
    pub mutex: slock_t,
    pub refcnt: ::core::ffi::c_int,
}
impl Default for SharedFileSet {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SharedTuplestore {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SharedTuplestoreAccessor {
    _unused: [u8; 0],
}
pub type Timestamp = int64;
pub type TimestampTz = int64;
pub type TimeOffset = int64;
pub type fsec_t = int32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Interval {
    pub time: TimeOffset,
    pub day: int32,
    pub month: int32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pg_itm {
    pub tm_usec: ::core::ffi::c_int,
    pub tm_sec: ::core::ffi::c_int,
    pub tm_min: ::core::ffi::c_int,
    pub tm_hour: int64,
    pub tm_mday: ::core::ffi::c_int,
    pub tm_mon: ::core::ffi::c_int,
    pub tm_year: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pg_itm_in {
    pub tm_usec: int64,
    pub tm_mday: ::core::ffi::c_int,
    pub tm_mon: ::core::ffi::c_int,
    pub tm_year: ::core::ffi::c_int,
}
pub mod SnapshotType {
    pub type Type = ::core::ffi::c_uint;
    pub const SNAPSHOT_MVCC: Type = 0;
    pub const SNAPSHOT_SELF: Type = 1;
    pub const SNAPSHOT_ANY: Type = 2;
    pub const SNAPSHOT_TOAST: Type = 3;
    pub const SNAPSHOT_DIRTY: Type = 4;
    pub const SNAPSHOT_HISTORIC_MVCC: Type = 5;
    pub const SNAPSHOT_NON_VACUUMABLE: Type = 6;
}
pub type Snapshot = *mut SnapshotData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SnapshotData {
    pub snapshot_type: SnapshotType::Type,
    pub xmin: TransactionId,
    pub xmax: TransactionId,
    pub xip: *mut TransactionId,
    pub xcnt: uint32,
    pub subxip: *mut TransactionId,
    pub subxcnt: int32,
    pub suboverflowed: bool,
    pub takenDuringRecovery: bool,
    pub copied: bool,
    pub curcid: CommandId,
    pub speculativeToken: uint32,
    pub vistest: *mut GlobalVisState,
    pub active_count: uint32,
    pub regd_count: uint32,
    pub ph_node: pairingheap_node,
    pub whenTaken: TimestampTz,
    pub lsn: XLogRecPtr,
    pub snapXactCompletionCount: uint64,
}
impl Default for SnapshotData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Relation = *mut RelationData;
pub type RelationPtr = *mut Relation;
pub mod IndexAttrBitmapKind {
    pub type Type = ::core::ffi::c_uint;
    pub const INDEX_ATTR_BITMAP_KEY: Type = 0;
    pub const INDEX_ATTR_BITMAP_PRIMARY_KEY: Type = 1;
    pub const INDEX_ATTR_BITMAP_IDENTITY_KEY: Type = 2;
    pub const INDEX_ATTR_BITMAP_HOT_BLOCKING: Type = 3;
    pub const INDEX_ATTR_BITMAP_SUMMARIZED: Type = 4;
}
pub type SortSupport = *mut SortSupportData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SortSupportData {
    pub ssup_cxt: MemoryContext,
    pub ssup_collation: Oid,
    pub ssup_reverse: bool,
    pub ssup_nulls_first: bool,
    pub ssup_attno: AttrNumber,
    pub ssup_extra: *mut ::core::ffi::c_void,
    pub comparator: ::core::option::Option<
        unsafe extern "C-unwind" fn(x: Datum, y: Datum, ssup: SortSupport) -> ::core::ffi::c_int,
    >,
    pub abbreviate: bool,
    pub abbrev_converter: ::core::option::Option<
        unsafe extern "C-unwind" fn(original: Datum, ssup: SortSupport) -> Datum,
    >,
    pub abbrev_abort: ::core::option::Option<
        unsafe extern "C-unwind" fn(memtupcount: ::core::ffi::c_int, ssup: SortSupport) -> bool,
    >,
    pub abbrev_full_comparator: ::core::option::Option<
        unsafe extern "C-unwind" fn(x: Datum, y: Datum, ssup: SortSupport) -> ::core::ffi::c_int,
    >,
}
impl Default for SortSupportData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScanKeyData {
    pub sk_flags: ::core::ffi::c_int,
    pub sk_attno: AttrNumber,
    pub sk_strategy: StrategyNumber,
    pub sk_subtype: Oid,
    pub sk_collation: Oid,
    pub sk_func: FmgrInfo,
    pub sk_argument: Datum,
}
impl Default for ScanKeyData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ScanKey = *mut ScanKeyData;
pub type LOCKMASK = ::core::ffi::c_int;
pub type LOCKMODE = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xl_standby_lock {
    pub xid: TransactionId,
    pub dbOid: Oid,
    pub relOid: Oid,
}
impl Default for xl_standby_lock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IndexBuildResult {
    pub heap_tuples: f64,
    pub index_tuples: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexVacuumInfo {
    pub index: Relation,
    pub heaprel: Relation,
    pub analyze_only: bool,
    pub report_progress: bool,
    pub estimated_count: bool,
    pub message_level: ::core::ffi::c_int,
    pub num_heap_tuples: f64,
    pub strategy: BufferAccessStrategy,
}
impl Default for IndexVacuumInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IndexBulkDeleteResult {
    pub num_pages: BlockNumber,
    pub estimated_count: bool,
    pub num_index_tuples: f64,
    pub tuples_removed: f64,
    pub pages_newly_deleted: BlockNumber,
    pub pages_deleted: BlockNumber,
    pub pages_free: BlockNumber,
}
pub type IndexBulkDeleteCallback = ::core::option::Option<
    unsafe extern "C-unwind" fn(itemptr: ItemPointer, state: *mut ::core::ffi::c_void) -> bool,
>;
pub type IndexScanDesc = *mut IndexScanDescData;
pub type SysScanDesc = *mut SysScanDescData;
pub type ParallelIndexScanDesc = *mut ParallelIndexScanDescData;
pub mod IndexUniqueCheck {
    pub type Type = ::core::ffi::c_uint;
    pub const UNIQUE_CHECK_NO: Type = 0;
    pub const UNIQUE_CHECK_YES: Type = 1;
    pub const UNIQUE_CHECK_PARTIAL: Type = 2;
    pub const UNIQUE_CHECK_EXISTING: Type = 3;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IndexOrderByDistance {
    pub value: f64,
    pub isnull: bool,
}
pub mod IndexAMProperty {
    pub type Type = ::core::ffi::c_uint;
    pub const AMPROP_UNKNOWN: Type = 0;
    pub const AMPROP_ASC: Type = 1;
    pub const AMPROP_DESC: Type = 2;
    pub const AMPROP_NULLS_FIRST: Type = 3;
    pub const AMPROP_NULLS_LAST: Type = 4;
    pub const AMPROP_ORDERABLE: Type = 5;
    pub const AMPROP_DISTANCE_ORDERABLE: Type = 6;
    pub const AMPROP_RETURNABLE: Type = 7;
    pub const AMPROP_SEARCH_ARRAY: Type = 8;
    pub const AMPROP_SEARCH_NULLS: Type = 9;
    pub const AMPROP_CLUSTERABLE: Type = 10;
    pub const AMPROP_INDEX_SCAN: Type = 11;
    pub const AMPROP_BITMAP_SCAN: Type = 12;
    pub const AMPROP_BACKWARD_SCAN: Type = 13;
    pub const AMPROP_CAN_ORDER: Type = 14;
    pub const AMPROP_CAN_UNIQUE: Type = 15;
    pub const AMPROP_CAN_MULTI_COL: Type = 16;
    pub const AMPROP_CAN_EXCLUDE: Type = 17;
    pub const AMPROP_CAN_INCLUDE: Type = 18;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpFamilyMember {
    pub is_func: bool,
    pub object: Oid,
    pub number: ::core::ffi::c_int,
    pub lefttype: Oid,
    pub righttype: Oid,
    pub sortfamily: Oid,
    pub ref_is_hard: bool,
    pub ref_is_family: bool,
    pub refobjid: Oid,
}
impl Default for OpFamilyMember {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ambuild_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        heapRelation: Relation,
        indexRelation: Relation,
        indexInfo: *mut IndexInfo,
    ) -> *mut IndexBuildResult,
>;
pub type ambuildempty_function =
    ::core::option::Option<unsafe extern "C-unwind" fn(indexRelation: Relation)>;
pub type aminsert_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        indexRelation: Relation,
        values: *mut Datum,
        isnull: *mut bool,
        heap_tid: ItemPointer,
        heapRelation: Relation,
        checkUnique: IndexUniqueCheck::Type,
        indexUnchanged: bool,
        indexInfo: *mut IndexInfo,
    ) -> bool,
>;
pub type aminsertcleanup_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(indexRelation: Relation, indexInfo: *mut IndexInfo),
>;
pub type ambulkdelete_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        info: *mut IndexVacuumInfo,
        stats: *mut IndexBulkDeleteResult,
        callback: IndexBulkDeleteCallback,
        callback_state: *mut ::core::ffi::c_void,
    ) -> *mut IndexBulkDeleteResult,
>;
pub type amvacuumcleanup_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        info: *mut IndexVacuumInfo,
        stats: *mut IndexBulkDeleteResult,
    ) -> *mut IndexBulkDeleteResult,
>;
pub type amcanreturn_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(indexRelation: Relation, attno: ::core::ffi::c_int) -> bool,
>;
pub type amcostestimate_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        root: *mut PlannerInfo,
        path: *mut IndexPath,
        loop_count: f64,
        indexStartupCost: *mut Cost,
        indexTotalCost: *mut Cost,
        indexSelectivity: *mut Selectivity,
        indexCorrelation: *mut f64,
        indexPages: *mut f64,
    ),
>;
pub type amoptions_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(reloptions: Datum, validate: bool) -> *mut bytea,
>;
pub type amproperty_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        index_oid: Oid,
        attno: ::core::ffi::c_int,
        prop: IndexAMProperty::Type,
        propname: *const ::core::ffi::c_char,
        res: *mut bool,
        isnull: *mut bool,
    ) -> bool,
>;
pub type ambuildphasename_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(phasenum: int64) -> *mut ::core::ffi::c_char,
>;
pub type amvalidate_function =
    ::core::option::Option<unsafe extern "C-unwind" fn(opclassoid: Oid) -> bool>;
pub type amadjustmembers_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        opfamilyoid: Oid,
        opclassoid: Oid,
        operators: *mut List,
        functions: *mut List,
    ),
>;
pub type ambeginscan_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        indexRelation: Relation,
        nkeys: ::core::ffi::c_int,
        norderbys: ::core::ffi::c_int,
    ) -> IndexScanDesc,
>;
pub type amrescan_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        scan: IndexScanDesc,
        keys: ScanKey,
        nkeys: ::core::ffi::c_int,
        orderbys: ScanKey,
        norderbys: ::core::ffi::c_int,
    ),
>;
pub type amgettuple_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(scan: IndexScanDesc, direction: ScanDirection::Type) -> bool,
>;
pub type amgetbitmap_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(scan: IndexScanDesc, tbm: *mut TIDBitmap) -> int64,
>;
pub type amendscan_function =
    ::core::option::Option<unsafe extern "C-unwind" fn(scan: IndexScanDesc)>;
pub type ammarkpos_function =
    ::core::option::Option<unsafe extern "C-unwind" fn(scan: IndexScanDesc)>;
pub type amrestrpos_function =
    ::core::option::Option<unsafe extern "C-unwind" fn(scan: IndexScanDesc)>;
pub type amestimateparallelscan_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(nkeys: ::core::ffi::c_int, norderbys: ::core::ffi::c_int) -> Size,
>;
pub type aminitparallelscan_function =
    ::core::option::Option<unsafe extern "C-unwind" fn(target: *mut ::core::ffi::c_void)>;
pub type amparallelrescan_function =
    ::core::option::Option<unsafe extern "C-unwind" fn(scan: IndexScanDesc)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexAmRoutine {
    pub type_: NodeTag,
    pub amstrategies: uint16,
    pub amsupport: uint16,
    pub amoptsprocnum: uint16,
    pub amcanorder: bool,
    pub amcanorderbyop: bool,
    pub amcanbackward: bool,
    pub amcanunique: bool,
    pub amcanmulticol: bool,
    pub amoptionalkey: bool,
    pub amsearcharray: bool,
    pub amsearchnulls: bool,
    pub amstorage: bool,
    pub amclusterable: bool,
    pub ampredlocks: bool,
    pub amcanparallel: bool,
    pub amcanbuildparallel: bool,
    pub amcaninclude: bool,
    pub amusemaintenanceworkmem: bool,
    pub amsummarizing: bool,
    pub amparallelvacuumoptions: uint8,
    pub amkeytype: Oid,
    pub ambuild: ambuild_function,
    pub ambuildempty: ambuildempty_function,
    pub aminsert: aminsert_function,
    pub aminsertcleanup: aminsertcleanup_function,
    pub ambulkdelete: ambulkdelete_function,
    pub amvacuumcleanup: amvacuumcleanup_function,
    pub amcanreturn: amcanreturn_function,
    pub amcostestimate: amcostestimate_function,
    pub amoptions: amoptions_function,
    pub amproperty: amproperty_function,
    pub ambuildphasename: ambuildphasename_function,
    pub amvalidate: amvalidate_function,
    pub amadjustmembers: amadjustmembers_function,
    pub ambeginscan: ambeginscan_function,
    pub amrescan: amrescan_function,
    pub amgettuple: amgettuple_function,
    pub amgetbitmap: amgetbitmap_function,
    pub amendscan: amendscan_function,
    pub ammarkpos: ammarkpos_function,
    pub amrestrpos: amrestrpos_function,
    pub amestimateparallelscan: amestimateparallelscan_function,
    pub aminitparallelscan: aminitparallelscan_function,
    pub amparallelrescan: amparallelrescan_function,
}
impl Default for IndexAmRoutine {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DomainConstraintCache {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TypeCacheEnumData {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TypeCacheEntry {
    pub type_id: Oid,
    pub type_id_hash: uint32,
    pub typlen: int16,
    pub typbyval: bool,
    pub typalign: ::core::ffi::c_char,
    pub typstorage: ::core::ffi::c_char,
    pub typtype: ::core::ffi::c_char,
    pub typrelid: Oid,
    pub typsubscript: Oid,
    pub typelem: Oid,
    pub typcollation: Oid,
    pub btree_opf: Oid,
    pub btree_opintype: Oid,
    pub hash_opf: Oid,
    pub hash_opintype: Oid,
    pub eq_opr: Oid,
    pub lt_opr: Oid,
    pub gt_opr: Oid,
    pub cmp_proc: Oid,
    pub hash_proc: Oid,
    pub hash_extended_proc: Oid,
    pub eq_opr_finfo: FmgrInfo,
    pub cmp_proc_finfo: FmgrInfo,
    pub hash_proc_finfo: FmgrInfo,
    pub hash_extended_proc_finfo: FmgrInfo,
    pub tupDesc: TupleDesc,
    pub tupDesc_identifier: uint64,
    pub rngelemtype: *mut TypeCacheEntry,
    pub rng_opfamily: Oid,
    pub rng_collation: Oid,
    pub rng_cmp_proc_finfo: FmgrInfo,
    pub rng_canonical_finfo: FmgrInfo,
    pub rng_subdiff_finfo: FmgrInfo,
    pub rngtype: *mut TypeCacheEntry,
    pub domainBaseType: Oid,
    pub domainBaseTypmod: int32,
    pub domainData: *mut DomainConstraintCache,
    pub flags: ::core::ffi::c_int,
    pub enumData: *mut TypeCacheEnumData,
    pub nextDomain: *mut TypeCacheEntry,
}
impl Default for TypeCacheEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DomainConstraintRef {
    pub constraints: *mut List,
    pub refctx: MemoryContext,
    pub tcache: *mut TypeCacheEntry,
    pub need_exprstate: bool,
    pub dcc: *mut DomainConstraintCache,
    pub callback: MemoryContextCallback,
}
impl Default for DomainConstraintRef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SharedRecordTypmodRegistry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct BrinOpcInfo {
    pub oi_nstored: uint16,
    pub oi_regular_nulls: bool,
    pub oi_opaque: *mut ::core::ffi::c_void,
    pub oi_typcache: __IncompleteArrayField<*mut TypeCacheEntry>,
}
impl Default for BrinOpcInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct BrinDesc {
    pub bd_context: MemoryContext,
    pub bd_index: Relation,
    pub bd_tupdesc: TupleDesc,
    pub bd_disktdesc: TupleDesc,
    pub bd_totalstored: ::core::ffi::c_int,
    pub bd_info: __IncompleteArrayField<*mut BrinOpcInfo>,
}
impl Default for BrinDesc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type brin_serialize_callback_type = ::core::option::Option<
    unsafe extern "C-unwind" fn(bdesc: *mut BrinDesc, src: Datum, dst: *mut Datum),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BrinValues {
    pub bv_attno: AttrNumber,
    pub bv_hasnulls: bool,
    pub bv_allnulls: bool,
    pub bv_values: *mut Datum,
    pub bv_mem_value: Datum,
    pub bv_context: MemoryContext,
    pub bv_serialize: brin_serialize_callback_type,
}
impl Default for BrinValues {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct BrinMemTuple {
    pub bt_placeholder: bool,
    pub bt_empty_range: bool,
    pub bt_blkno: BlockNumber,
    pub bt_context: MemoryContext,
    pub bt_values: *mut Datum,
    pub bt_allnulls: *mut bool,
    pub bt_hasnulls: *mut bool,
    pub bt_columns: __IncompleteArrayField<BrinValues>,
}
impl Default for BrinMemTuple {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BrinTuple {
    pub bt_blkno: BlockNumber,
    pub bt_info: uint8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IndexTupleData {
    pub t_tid: ItemPointerData,
    pub t_info: ::core::ffi::c_ushort,
}
pub type IndexTuple = *mut IndexTupleData;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IndexAttributeBitMapData {
    pub bits: [bits8; 4usize],
}
pub type IndexAttributeBitMap = *mut IndexAttributeBitMapData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LogicalTapeSet {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LogicalTape {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TapeShare {
    pub firstblocknumber: int64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Tuplesortstate {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sharedsort {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SortCoordinateData {
    pub isWorker: bool,
    pub nParticipants: ::core::ffi::c_int,
    pub sharedsort: *mut Sharedsort,
}
impl Default for SortCoordinateData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SortCoordinate = *mut SortCoordinateData;
pub mod TuplesortMethod {
    pub type Type = ::core::ffi::c_uint;
    pub const SORT_TYPE_STILL_IN_PROGRESS: Type = 0;
    pub const SORT_TYPE_TOP_N_HEAPSORT: Type = 1;
    pub const SORT_TYPE_QUICKSORT: Type = 2;
    pub const SORT_TYPE_EXTERNAL_SORT: Type = 4;
    pub const SORT_TYPE_EXTERNAL_MERGE: Type = 8;
}
pub mod TuplesortSpaceType {
    pub type Type = ::core::ffi::c_uint;
    pub const SORT_SPACE_TYPE_DISK: Type = 0;
    pub const SORT_SPACE_TYPE_MEMORY: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TuplesortInstrumentation {
    pub sortMethod: TuplesortMethod::Type,
    pub spaceType: TuplesortSpaceType::Type,
    pub spaceUsed: int64,
}
impl Default for TuplesortInstrumentation {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SortTuple {
    pub tuple: *mut ::core::ffi::c_void,
    pub datum1: Datum,
    pub isnull1: bool,
    pub srctape: ::core::ffi::c_int,
}
impl Default for SortTuple {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SortTupleComparator = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        a: *const SortTuple,
        b: *const SortTuple,
        state: *mut Tuplesortstate,
    ) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TuplesortPublic {
    pub comparetup: SortTupleComparator,
    pub comparetup_tiebreak: SortTupleComparator,
    pub removeabbrev: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            state: *mut Tuplesortstate,
            stups: *mut SortTuple,
            count: ::core::ffi::c_int,
        ),
    >,
    pub writetup: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            state: *mut Tuplesortstate,
            tape: *mut LogicalTape,
            stup: *mut SortTuple,
        ),
    >,
    pub readtup: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            state: *mut Tuplesortstate,
            stup: *mut SortTuple,
            tape: *mut LogicalTape,
            len: ::core::ffi::c_uint,
        ),
    >,
    pub freestate: ::core::option::Option<unsafe extern "C-unwind" fn(state: *mut Tuplesortstate)>,
    pub maincontext: MemoryContext,
    pub sortcontext: MemoryContext,
    pub tuplecontext: MemoryContext,
    pub haveDatum1: bool,
    pub nKeys: ::core::ffi::c_int,
    pub sortKeys: SortSupport,
    pub onlyKey: SortSupport,
    pub sortopt: ::core::ffi::c_int,
    pub tuples: bool,
    pub arg: *mut ::core::ffi::c_void,
}
impl Default for TuplesortPublic {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Tuplestorestate {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParallelHashJoinState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CopyMultiInsertBuffer {
    _unused: [u8; 0],
}
pub type ExprStateEvalFunc = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        expression: *mut ExprState,
        econtext: *mut ExprContext,
        isNull: *mut bool,
    ) -> Datum,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprState {
    pub type_: NodeTag,
    pub flags: uint8,
    pub resnull: bool,
    pub resvalue: Datum,
    pub resultslot: *mut TupleTableSlot,
    pub steps: *mut ExprEvalStep,
    pub evalfunc: ExprStateEvalFunc,
    pub expr: *mut Expr,
    pub evalfunc_private: *mut ::core::ffi::c_void,
    pub steps_len: ::core::ffi::c_int,
    pub steps_alloc: ::core::ffi::c_int,
    pub parent: *mut PlanState,
    pub ext_params: ParamListInfo,
    pub innermost_caseval: *mut Datum,
    pub innermost_casenull: *mut bool,
    pub innermost_domainval: *mut Datum,
    pub innermost_domainnull: *mut bool,
    pub escontext: *mut ErrorSaveContext,
}
impl Default for ExprState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexInfo {
    pub type_: NodeTag,
    pub ii_NumIndexAttrs: ::core::ffi::c_int,
    pub ii_NumIndexKeyAttrs: ::core::ffi::c_int,
    pub ii_IndexAttrNumbers: [AttrNumber; 32usize],
    pub ii_Expressions: *mut List,
    pub ii_ExpressionsState: *mut List,
    pub ii_Predicate: *mut List,
    pub ii_PredicateState: *mut ExprState,
    pub ii_ExclusionOps: *mut Oid,
    pub ii_ExclusionProcs: *mut Oid,
    pub ii_ExclusionStrats: *mut uint16,
    pub ii_UniqueOps: *mut Oid,
    pub ii_UniqueProcs: *mut Oid,
    pub ii_UniqueStrats: *mut uint16,
    pub ii_Unique: bool,
    pub ii_NullsNotDistinct: bool,
    pub ii_ReadyForInserts: bool,
    pub ii_CheckedUnchanged: bool,
    pub ii_IndexUnchanged: bool,
    pub ii_Concurrent: bool,
    pub ii_BrokenHotChain: bool,
    pub ii_Summarizing: bool,
    pub ii_ParallelWorkers: ::core::ffi::c_int,
    pub ii_Am: Oid,
    pub ii_AmCache: *mut ::core::ffi::c_void,
    pub ii_Context: MemoryContext,
}
impl Default for IndexInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ExprContextCallbackFunction =
    ::core::option::Option<unsafe extern "C-unwind" fn(arg: Datum)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprContext_CB {
    pub next: *mut ExprContext_CB,
    pub function: ExprContextCallbackFunction,
    pub arg: Datum,
}
impl Default for ExprContext_CB {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprContext {
    pub type_: NodeTag,
    pub ecxt_scantuple: *mut TupleTableSlot,
    pub ecxt_innertuple: *mut TupleTableSlot,
    pub ecxt_outertuple: *mut TupleTableSlot,
    pub ecxt_per_query_memory: MemoryContext,
    pub ecxt_per_tuple_memory: MemoryContext,
    pub ecxt_param_exec_vals: *mut ParamExecData,
    pub ecxt_param_list_info: ParamListInfo,
    pub ecxt_aggvalues: *mut Datum,
    pub ecxt_aggnulls: *mut bool,
    pub caseValue_datum: Datum,
    pub caseValue_isNull: bool,
    pub domainValue_datum: Datum,
    pub domainValue_isNull: bool,
    pub ecxt_estate: *mut EState,
    pub ecxt_callbacks: *mut ExprContext_CB,
}
impl Default for ExprContext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod ExprDoneCond {
    pub type Type = ::core::ffi::c_uint;
    pub const ExprSingleResult: Type = 0;
    pub const ExprMultipleResult: Type = 1;
    pub const ExprEndResult: Type = 2;
}
pub mod SetFunctionReturnMode {
    pub type Type = ::core::ffi::c_uint;
    pub const SFRM_ValuePerCall: Type = 1;
    pub const SFRM_Materialize: Type = 2;
    pub const SFRM_Materialize_Random: Type = 4;
    pub const SFRM_Materialize_Preferred: Type = 8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReturnSetInfo {
    pub type_: NodeTag,
    pub econtext: *mut ExprContext,
    pub expectedDesc: TupleDesc,
    pub allowedModes: ::core::ffi::c_int,
    pub returnMode: SetFunctionReturnMode::Type,
    pub isDone: ExprDoneCond::Type,
    pub setResult: *mut Tuplestorestate,
    pub setDesc: TupleDesc,
}
impl Default for ReturnSetInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProjectionInfo {
    pub type_: NodeTag,
    pub pi_state: ExprState,
    pub pi_exprContext: *mut ExprContext,
}
impl Default for ProjectionInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JunkFilter {
    pub type_: NodeTag,
    pub jf_targetList: *mut List,
    pub jf_cleanTupType: TupleDesc,
    pub jf_cleanMap: *mut AttrNumber,
    pub jf_resultSlot: *mut TupleTableSlot,
}
impl Default for JunkFilter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OnConflictSetState {
    pub type_: NodeTag,
    pub oc_Existing: *mut TupleTableSlot,
    pub oc_ProjSlot: *mut TupleTableSlot,
    pub oc_ProjInfo: *mut ProjectionInfo,
    pub oc_WhereClause: *mut ExprState,
}
impl Default for OnConflictSetState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeActionState {
    pub type_: NodeTag,
    pub mas_action: *mut MergeAction,
    pub mas_proj: *mut ProjectionInfo,
    pub mas_whenqual: *mut ExprState,
}
impl Default for MergeActionState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResultRelInfo {
    pub type_: NodeTag,
    pub ri_RangeTableIndex: Index,
    pub ri_RelationDesc: Relation,
    pub ri_NumIndices: ::core::ffi::c_int,
    pub ri_IndexRelationDescs: RelationPtr,
    pub ri_IndexRelationInfo: *mut *mut IndexInfo,
    pub ri_RowIdAttNo: AttrNumber,
    pub ri_extraUpdatedCols: *mut Bitmapset,
    pub ri_projectNew: *mut ProjectionInfo,
    pub ri_newTupleSlot: *mut TupleTableSlot,
    pub ri_oldTupleSlot: *mut TupleTableSlot,
    pub ri_projectNewInfoValid: bool,
    pub ri_needLockTagTuple: bool,
    pub ri_TrigDesc: *mut TriggerDesc,
    pub ri_TrigFunctions: *mut FmgrInfo,
    pub ri_TrigWhenExprs: *mut *mut ExprState,
    pub ri_TrigInstrument: *mut Instrumentation,
    pub ri_ReturningSlot: *mut TupleTableSlot,
    pub ri_TrigOldSlot: *mut TupleTableSlot,
    pub ri_TrigNewSlot: *mut TupleTableSlot,
    pub ri_FdwRoutine: *mut FdwRoutine,
    pub ri_FdwState: *mut ::core::ffi::c_void,
    pub ri_usesFdwDirectModify: bool,
    pub ri_NumSlots: ::core::ffi::c_int,
    pub ri_NumSlotsInitialized: ::core::ffi::c_int,
    pub ri_BatchSize: ::core::ffi::c_int,
    pub ri_Slots: *mut *mut TupleTableSlot,
    pub ri_PlanSlots: *mut *mut TupleTableSlot,
    pub ri_WithCheckOptions: *mut List,
    pub ri_WithCheckOptionExprs: *mut List,
    pub ri_ConstraintExprs: *mut *mut ExprState,
    pub ri_GeneratedExprsI: *mut *mut ExprState,
    pub ri_GeneratedExprsU: *mut *mut ExprState,
    pub ri_NumGeneratedNeededI: ::core::ffi::c_int,
    pub ri_NumGeneratedNeededU: ::core::ffi::c_int,
    pub ri_returningList: *mut List,
    pub ri_projectReturning: *mut ProjectionInfo,
    pub ri_onConflictArbiterIndexes: *mut List,
    pub ri_onConflict: *mut OnConflictSetState,
    pub ri_MergeActions: [*mut List; 3usize],
    pub ri_MergeJoinCondition: *mut ExprState,
    pub ri_PartitionCheckExpr: *mut ExprState,
    pub ri_ChildToRootMap: *mut TupleConversionMap,
    pub ri_ChildToRootMapValid: bool,
    pub ri_RootToChildMap: *mut TupleConversionMap,
    pub ri_RootToChildMapValid: bool,
    pub ri_RootResultRelInfo: *mut ResultRelInfo,
    pub ri_PartitionTupleSlot: *mut TupleTableSlot,
    pub ri_CopyMultiInsertBuffer: *mut CopyMultiInsertBuffer,
    pub ri_ancestorResultRels: *mut List,
}
impl Default for ResultRelInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AsyncRequest {
    pub requestor: *mut PlanState,
    pub requestee: *mut PlanState,
    pub request_index: ::core::ffi::c_int,
    pub callback_pending: bool,
    pub request_complete: bool,
    pub result: *mut TupleTableSlot,
}
impl Default for AsyncRequest {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EState {
    pub type_: NodeTag,
    pub es_direction: ScanDirection::Type,
    pub es_snapshot: Snapshot,
    pub es_crosscheck_snapshot: Snapshot,
    pub es_range_table: *mut List,
    pub es_range_table_size: Index,
    pub es_relations: *mut Relation,
    pub es_rowmarks: *mut *mut ExecRowMark,
    pub es_rteperminfos: *mut List,
    pub es_plannedstmt: *mut PlannedStmt,
    pub es_sourceText: *const ::core::ffi::c_char,
    pub es_junkFilter: *mut JunkFilter,
    pub es_output_cid: CommandId,
    pub es_result_relations: *mut *mut ResultRelInfo,
    pub es_opened_result_relations: *mut List,
    pub es_partition_directory: PartitionDirectory,
    pub es_tuple_routing_result_relations: *mut List,
    pub es_trig_target_relations: *mut List,
    pub es_param_list_info: ParamListInfo,
    pub es_param_exec_vals: *mut ParamExecData,
    pub es_queryEnv: *mut QueryEnvironment,
    pub es_query_cxt: MemoryContext,
    pub es_tupleTable: *mut List,
    pub es_processed: uint64,
    pub es_total_processed: uint64,
    pub es_top_eflags: ::core::ffi::c_int,
    pub es_instrument: ::core::ffi::c_int,
    pub es_finished: bool,
    pub es_exprcontexts: *mut List,
    pub es_subplanstates: *mut List,
    pub es_auxmodifytables: *mut List,
    pub es_per_tuple_exprcontext: *mut ExprContext,
    pub es_epq_active: *mut EPQState,
    pub es_use_parallel_mode: bool,
    pub es_query_dsa: *mut dsa_area,
    pub es_jit_flags: ::core::ffi::c_int,
    pub es_jit: *mut JitContext,
    pub es_jit_worker_instr: *mut JitInstrumentation,
    pub es_insert_pending_result_relations: *mut List,
    pub es_insert_pending_modifytables: *mut List,
}
impl Default for EState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExecRowMark {
    pub relation: Relation,
    pub relid: Oid,
    pub rti: Index,
    pub prti: Index,
    pub rowmarkId: Index,
    pub markType: RowMarkType::Type,
    pub strength: LockClauseStrength::Type,
    pub waitPolicy: LockWaitPolicy::Type,
    pub ermActive: bool,
    pub curCtid: ItemPointerData,
    pub ermExtra: *mut ::core::ffi::c_void,
}
impl Default for ExecRowMark {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExecAuxRowMark {
    pub rowmark: *mut ExecRowMark,
    pub ctidAttNo: AttrNumber,
    pub toidAttNo: AttrNumber,
    pub wholeAttNo: AttrNumber,
}
impl Default for ExecAuxRowMark {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TupleHashEntry = *mut TupleHashEntryData;
pub type TupleHashTable = *mut TupleHashTableData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TupleHashEntryData {
    pub firstTuple: MinimalTuple,
    pub additional: *mut ::core::ffi::c_void,
    pub status: uint32,
    pub hash: uint32,
}
impl Default for TupleHashEntryData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tuplehash_hash {
    pub size: uint64,
    pub members: uint32,
    pub sizemask: uint32,
    pub grow_threshold: uint32,
    pub data: *mut TupleHashEntryData,
    pub ctx: MemoryContext,
    pub private_data: *mut ::core::ffi::c_void,
}
impl Default for tuplehash_hash {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod tuplehash_status {
    pub type Type = ::core::ffi::c_uint;
    pub const tuplehash_SH_EMPTY: Type = 0;
    pub const tuplehash_SH_IN_USE: Type = 1;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tuplehash_iterator {
    pub cur: uint32,
    pub end: uint32,
    pub done: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TupleHashTableData {
    pub hashtab: *mut tuplehash_hash,
    pub numCols: ::core::ffi::c_int,
    pub keyColIdx: *mut AttrNumber,
    pub tab_hash_funcs: *mut FmgrInfo,
    pub tab_eq_func: *mut ExprState,
    pub tab_collations: *mut Oid,
    pub tablecxt: MemoryContext,
    pub tempcxt: MemoryContext,
    pub entrysize: Size,
    pub tableslot: *mut TupleTableSlot,
    pub inputslot: *mut TupleTableSlot,
    pub in_hash_funcs: *mut FmgrInfo,
    pub cur_eq_func: *mut ExprState,
    pub hash_iv: uint32,
    pub exprcontext: *mut ExprContext,
}
impl Default for TupleHashTableData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TupleHashIterator = tuplehash_iterator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowFuncExprState {
    pub type_: NodeTag,
    pub wfunc: *mut WindowFunc,
    pub args: *mut List,
    pub aggfilter: *mut ExprState,
    pub wfuncno: ::core::ffi::c_int,
}
impl Default for WindowFuncExprState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SetExprState {
    pub type_: NodeTag,
    pub expr: *mut Expr,
    pub args: *mut List,
    pub elidedFuncState: *mut ExprState,
    pub func: FmgrInfo,
    pub funcResultStore: *mut Tuplestorestate,
    pub funcResultSlot: *mut TupleTableSlot,
    pub funcResultDesc: TupleDesc,
    pub funcReturnsTuple: bool,
    pub funcReturnsSet: bool,
    pub setArgsValid: bool,
    pub shutdown_reg: bool,
    pub fcinfo: FunctionCallInfo,
}
impl Default for SetExprState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubPlanState {
    pub type_: NodeTag,
    pub subplan: *mut SubPlan,
    pub planstate: *mut PlanState,
    pub parent: *mut PlanState,
    pub testexpr: *mut ExprState,
    pub args: *mut List,
    pub curTuple: HeapTuple,
    pub curArray: Datum,
    pub descRight: TupleDesc,
    pub projLeft: *mut ProjectionInfo,
    pub projRight: *mut ProjectionInfo,
    pub hashtable: TupleHashTable,
    pub hashnulls: TupleHashTable,
    pub havehashrows: bool,
    pub havenullrows: bool,
    pub hashtablecxt: MemoryContext,
    pub hashtempcxt: MemoryContext,
    pub innerecontext: *mut ExprContext,
    pub numCols: ::core::ffi::c_int,
    pub keyColIdx: *mut AttrNumber,
    pub tab_eq_funcoids: *mut Oid,
    pub tab_collations: *mut Oid,
    pub tab_hash_funcs: *mut FmgrInfo,
    pub tab_eq_funcs: *mut FmgrInfo,
    pub lhs_hash_funcs: *mut FmgrInfo,
    pub cur_eq_funcs: *mut FmgrInfo,
    pub cur_eq_comp: *mut ExprState,
}
impl Default for SubPlanState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod DomainConstraintType {
    pub type Type = ::core::ffi::c_uint;
    pub const DOM_CONSTRAINT_NOTNULL: Type = 0;
    pub const DOM_CONSTRAINT_CHECK: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DomainConstraintState {
    pub type_: NodeTag,
    pub constrainttype: DomainConstraintType::Type,
    pub name: *mut ::core::ffi::c_char,
    pub check_expr: *mut Expr,
    pub check_exprstate: *mut ExprState,
}
impl Default for DomainConstraintState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonExprState {
    pub jsexpr: *mut JsonExpr,
    pub formatted_expr: NullableDatum,
    pub pathspec: NullableDatum,
    pub args: *mut List,
    pub error: NullableDatum,
    pub empty: NullableDatum,
    pub jump_empty: ::core::ffi::c_int,
    pub jump_error: ::core::ffi::c_int,
    pub jump_eval_coercion: ::core::ffi::c_int,
    pub jump_end: ::core::ffi::c_int,
    pub input_fcinfo: FunctionCallInfo,
    pub escontext: ErrorSaveContext,
}
impl Default for JsonExprState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ExecProcNodeMtd = ::core::option::Option<
    unsafe extern "C-unwind" fn(pstate: *mut PlanState) -> *mut TupleTableSlot,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlanState {
    pub type_: NodeTag,
    pub plan: *mut Plan,
    pub state: *mut EState,
    pub ExecProcNode: ExecProcNodeMtd,
    pub ExecProcNodeReal: ExecProcNodeMtd,
    pub instrument: *mut Instrumentation,
    pub worker_instrument: *mut WorkerInstrumentation,
    pub worker_jit_instrument: *mut SharedJitInstrumentation,
    pub qual: *mut ExprState,
    pub lefttree: *mut PlanState,
    pub righttree: *mut PlanState,
    pub initPlan: *mut List,
    pub subPlan: *mut List,
    pub chgParam: *mut Bitmapset,
    pub ps_ResultTupleDesc: TupleDesc,
    pub ps_ResultTupleSlot: *mut TupleTableSlot,
    pub ps_ExprContext: *mut ExprContext,
    pub ps_ProjInfo: *mut ProjectionInfo,
    pub async_capable: bool,
    pub scandesc: TupleDesc,
    pub scanops: *const TupleTableSlotOps,
    pub outerops: *const TupleTableSlotOps,
    pub innerops: *const TupleTableSlotOps,
    pub resultops: *const TupleTableSlotOps,
    pub scanopsfixed: bool,
    pub outeropsfixed: bool,
    pub inneropsfixed: bool,
    pub resultopsfixed: bool,
    pub scanopsset: bool,
    pub outeropsset: bool,
    pub inneropsset: bool,
    pub resultopsset: bool,
}
impl Default for PlanState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EPQState {
    pub parentestate: *mut EState,
    pub epqParam: ::core::ffi::c_int,
    pub resultRelations: *mut List,
    pub tuple_table: *mut List,
    pub relsubs_slot: *mut *mut TupleTableSlot,
    pub plan: *mut Plan,
    pub arowMarks: *mut List,
    pub origslot: *mut TupleTableSlot,
    pub recheckestate: *mut EState,
    pub relsubs_rowmark: *mut *mut ExecAuxRowMark,
    pub relsubs_done: *mut bool,
    pub relsubs_blocked: *mut bool,
    pub recheckplanstate: *mut PlanState,
}
impl Default for EPQState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResultState {
    pub ps: PlanState,
    pub resconstantqual: *mut ExprState,
    pub rs_done: bool,
    pub rs_checkqual: bool,
}
impl Default for ResultState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProjectSetState {
    pub ps: PlanState,
    pub elems: *mut *mut Node,
    pub elemdone: *mut ExprDoneCond::Type,
    pub nelems: ::core::ffi::c_int,
    pub pending_srf_tuples: bool,
    pub argcontext: MemoryContext,
}
impl Default for ProjectSetState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ModifyTableState {
    pub ps: PlanState,
    pub operation: CmdType::Type,
    pub canSetTag: bool,
    pub mt_done: bool,
    pub mt_nrels: ::core::ffi::c_int,
    pub resultRelInfo: *mut ResultRelInfo,
    pub rootResultRelInfo: *mut ResultRelInfo,
    pub mt_epqstate: EPQState,
    pub fireBSTriggers: bool,
    pub mt_resultOidAttno: ::core::ffi::c_int,
    pub mt_lastResultOid: Oid,
    pub mt_lastResultIndex: ::core::ffi::c_int,
    pub mt_resultOidHash: *mut HTAB,
    pub mt_root_tuple_slot: *mut TupleTableSlot,
    pub mt_partition_tuple_routing: *mut PartitionTupleRouting,
    pub mt_transition_capture: *mut TransitionCaptureState,
    pub mt_oc_transition_capture: *mut TransitionCaptureState,
    pub mt_merge_subcommands: ::core::ffi::c_int,
    pub mt_merge_action: *mut MergeActionState,
    pub mt_merge_pending_not_matched: *mut TupleTableSlot,
    pub mt_merge_inserted: f64,
    pub mt_merge_updated: f64,
    pub mt_merge_deleted: f64,
}
impl Default for ModifyTableState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParallelAppendState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionPruneState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AppendState {
    pub ps: PlanState,
    pub appendplans: *mut *mut PlanState,
    pub as_nplans: ::core::ffi::c_int,
    pub as_whichplan: ::core::ffi::c_int,
    pub as_begun: bool,
    pub as_asyncplans: *mut Bitmapset,
    pub as_nasyncplans: ::core::ffi::c_int,
    pub as_asyncrequests: *mut *mut AsyncRequest,
    pub as_asyncresults: *mut *mut TupleTableSlot,
    pub as_nasyncresults: ::core::ffi::c_int,
    pub as_syncdone: bool,
    pub as_nasyncremain: ::core::ffi::c_int,
    pub as_needrequest: *mut Bitmapset,
    pub as_eventset: *mut WaitEventSet,
    pub as_first_partial_plan: ::core::ffi::c_int,
    pub as_pstate: *mut ParallelAppendState,
    pub pstate_len: Size,
    pub as_prune_state: *mut PartitionPruneState,
    pub as_valid_subplans_identified: bool,
    pub as_valid_subplans: *mut Bitmapset,
    pub as_valid_asyncplans: *mut Bitmapset,
    pub choose_next_subplan:
        ::core::option::Option<unsafe extern "C-unwind" fn(arg1: *mut AppendState) -> bool>,
}
impl Default for AppendState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeAppendState {
    pub ps: PlanState,
    pub mergeplans: *mut *mut PlanState,
    pub ms_nplans: ::core::ffi::c_int,
    pub ms_nkeys: ::core::ffi::c_int,
    pub ms_sortkeys: SortSupport,
    pub ms_slots: *mut *mut TupleTableSlot,
    pub ms_heap: *mut binaryheap,
    pub ms_initialized: bool,
    pub ms_prune_state: *mut PartitionPruneState,
    pub ms_valid_subplans: *mut Bitmapset,
}
impl Default for MergeAppendState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecursiveUnionState {
    pub ps: PlanState,
    pub recursing: bool,
    pub intermediate_empty: bool,
    pub working_table: *mut Tuplestorestate,
    pub intermediate_table: *mut Tuplestorestate,
    pub eqfuncoids: *mut Oid,
    pub hashfunctions: *mut FmgrInfo,
    pub tempContext: MemoryContext,
    pub hashtable: TupleHashTable,
    pub tableContext: MemoryContext,
}
impl Default for RecursiveUnionState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapAndState {
    pub ps: PlanState,
    pub bitmapplans: *mut *mut PlanState,
    pub nplans: ::core::ffi::c_int,
}
impl Default for BitmapAndState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapOrState {
    pub ps: PlanState,
    pub bitmapplans: *mut *mut PlanState,
    pub nplans: ::core::ffi::c_int,
}
impl Default for BitmapOrState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScanState {
    pub ps: PlanState,
    pub ss_currentRelation: Relation,
    pub ss_currentScanDesc: *mut TableScanDescData,
    pub ss_ScanTupleSlot: *mut TupleTableSlot,
}
impl Default for ScanState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SeqScanState {
    pub ss: ScanState,
    pub pscan_len: Size,
}
impl Default for SeqScanState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SampleScanState {
    pub ss: ScanState,
    pub args: *mut List,
    pub repeatable: *mut ExprState,
    pub tsmroutine: *mut TsmRoutine,
    pub tsm_state: *mut ::core::ffi::c_void,
    pub use_bulkread: bool,
    pub use_pagemode: bool,
    pub begun: bool,
    pub seed: uint32,
    pub donetuples: int64,
    pub haveblock: bool,
    pub done: bool,
}
impl Default for SampleScanState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexRuntimeKeyInfo {
    pub scan_key: *mut ScanKeyData,
    pub key_expr: *mut ExprState,
    pub key_toastable: bool,
}
impl Default for IndexRuntimeKeyInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexArrayKeyInfo {
    pub scan_key: *mut ScanKeyData,
    pub array_expr: *mut ExprState,
    pub next_elem: ::core::ffi::c_int,
    pub num_elems: ::core::ffi::c_int,
    pub elem_values: *mut Datum,
    pub elem_nulls: *mut bool,
}
impl Default for IndexArrayKeyInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexScanState {
    pub ss: ScanState,
    pub indexqualorig: *mut ExprState,
    pub indexorderbyorig: *mut List,
    pub iss_ScanKeys: *mut ScanKeyData,
    pub iss_NumScanKeys: ::core::ffi::c_int,
    pub iss_OrderByKeys: *mut ScanKeyData,
    pub iss_NumOrderByKeys: ::core::ffi::c_int,
    pub iss_RuntimeKeys: *mut IndexRuntimeKeyInfo,
    pub iss_NumRuntimeKeys: ::core::ffi::c_int,
    pub iss_RuntimeKeysReady: bool,
    pub iss_RuntimeContext: *mut ExprContext,
    pub iss_RelationDesc: Relation,
    pub iss_ScanDesc: *mut IndexScanDescData,
    pub iss_ReorderQueue: *mut pairingheap,
    pub iss_ReachedEnd: bool,
    pub iss_OrderByValues: *mut Datum,
    pub iss_OrderByNulls: *mut bool,
    pub iss_SortSupport: SortSupport,
    pub iss_OrderByTypByVals: *mut bool,
    pub iss_OrderByTypLens: *mut int16,
    pub iss_PscanLen: Size,
}
impl Default for IndexScanState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexOnlyScanState {
    pub ss: ScanState,
    pub recheckqual: *mut ExprState,
    pub ioss_ScanKeys: *mut ScanKeyData,
    pub ioss_NumScanKeys: ::core::ffi::c_int,
    pub ioss_OrderByKeys: *mut ScanKeyData,
    pub ioss_NumOrderByKeys: ::core::ffi::c_int,
    pub ioss_RuntimeKeys: *mut IndexRuntimeKeyInfo,
    pub ioss_NumRuntimeKeys: ::core::ffi::c_int,
    pub ioss_RuntimeKeysReady: bool,
    pub ioss_RuntimeContext: *mut ExprContext,
    pub ioss_RelationDesc: Relation,
    pub ioss_ScanDesc: *mut IndexScanDescData,
    pub ioss_TableSlot: *mut TupleTableSlot,
    pub ioss_VMBuffer: Buffer,
    pub ioss_PscanLen: Size,
    pub ioss_NameCStringAttNums: *mut AttrNumber,
    pub ioss_NameCStringCount: ::core::ffi::c_int,
}
impl Default for IndexOnlyScanState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapIndexScanState {
    pub ss: ScanState,
    pub biss_result: *mut TIDBitmap,
    pub biss_ScanKeys: *mut ScanKeyData,
    pub biss_NumScanKeys: ::core::ffi::c_int,
    pub biss_RuntimeKeys: *mut IndexRuntimeKeyInfo,
    pub biss_NumRuntimeKeys: ::core::ffi::c_int,
    pub biss_ArrayKeys: *mut IndexArrayKeyInfo,
    pub biss_NumArrayKeys: ::core::ffi::c_int,
    pub biss_RuntimeKeysReady: bool,
    pub biss_RuntimeContext: *mut ExprContext,
    pub biss_RelationDesc: Relation,
    pub biss_ScanDesc: *mut IndexScanDescData,
}
impl Default for BitmapIndexScanState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod SharedBitmapState {
    pub type Type = ::core::ffi::c_uint;
    pub const BM_INITIAL: Type = 0;
    pub const BM_INPROGRESS: Type = 1;
    pub const BM_FINISHED: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParallelBitmapHeapState {
    pub tbmiterator: dsa_pointer,
    pub prefetch_iterator: dsa_pointer,
    pub mutex: slock_t,
    pub prefetch_pages: ::core::ffi::c_int,
    pub prefetch_target: ::core::ffi::c_int,
    pub state: SharedBitmapState::Type,
    pub cv: ConditionVariable,
}
impl Default for ParallelBitmapHeapState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapHeapScanState {
    pub ss: ScanState,
    pub bitmapqualorig: *mut ExprState,
    pub tbm: *mut TIDBitmap,
    pub tbmiterator: *mut TBMIterator,
    pub tbmres: *mut TBMIterateResult,
    pub pvmbuffer: Buffer,
    pub exact_pages: ::core::ffi::c_long,
    pub lossy_pages: ::core::ffi::c_long,
    pub prefetch_iterator: *mut TBMIterator,
    pub prefetch_pages: ::core::ffi::c_int,
    pub prefetch_target: ::core::ffi::c_int,
    pub prefetch_maximum: ::core::ffi::c_int,
    pub initialized: bool,
    pub shared_tbmiterator: *mut TBMSharedIterator,
    pub shared_prefetch_iterator: *mut TBMSharedIterator,
    pub pstate: *mut ParallelBitmapHeapState,
}
impl Default for BitmapHeapScanState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TidScanState {
    pub ss: ScanState,
    pub tss_tidexprs: *mut List,
    pub tss_isCurrentOf: bool,
    pub tss_NumTids: ::core::ffi::c_int,
    pub tss_TidPtr: ::core::ffi::c_int,
    pub tss_TidList: *mut ItemPointerData,
}
impl Default for TidScanState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TidRangeScanState {
    pub ss: ScanState,
    pub trss_tidexprs: *mut List,
    pub trss_mintid: ItemPointerData,
    pub trss_maxtid: ItemPointerData,
    pub trss_inScan: bool,
}
impl Default for TidRangeScanState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubqueryScanState {
    pub ss: ScanState,
    pub subplan: *mut PlanState,
}
impl Default for SubqueryScanState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FunctionScanPerFuncState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FunctionScanState {
    pub ss: ScanState,
    pub eflags: ::core::ffi::c_int,
    pub ordinality: bool,
    pub simple: bool,
    pub ordinal: int64,
    pub nfuncs: ::core::ffi::c_int,
    pub funcstates: *mut FunctionScanPerFuncState,
    pub argcontext: MemoryContext,
}
impl Default for FunctionScanState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ValuesScanState {
    pub ss: ScanState,
    pub rowcontext: *mut ExprContext,
    pub exprlists: *mut *mut List,
    pub exprstatelists: *mut *mut List,
    pub array_len: ::core::ffi::c_int,
    pub curr_idx: ::core::ffi::c_int,
}
impl Default for ValuesScanState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TableFuncScanState {
    pub ss: ScanState,
    pub docexpr: *mut ExprState,
    pub rowexpr: *mut ExprState,
    pub colexprs: *mut List,
    pub coldefexprs: *mut List,
    pub colvalexprs: *mut List,
    pub passingvalexprs: *mut List,
    pub ns_names: *mut List,
    pub ns_uris: *mut List,
    pub notnulls: *mut Bitmapset,
    pub opaque: *mut ::core::ffi::c_void,
    pub routine: *mut TableFuncRoutine,
    pub in_functions: *mut FmgrInfo,
    pub typioparams: *mut Oid,
    pub ordinal: int64,
    pub perTableCxt: MemoryContext,
    pub tupstore: *mut Tuplestorestate,
}
impl Default for TableFuncScanState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CteScanState {
    pub ss: ScanState,
    pub eflags: ::core::ffi::c_int,
    pub readptr: ::core::ffi::c_int,
    pub cteplanstate: *mut PlanState,
    pub leader: *mut CteScanState,
    pub cte_table: *mut Tuplestorestate,
    pub eof_cte: bool,
}
impl Default for CteScanState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NamedTuplestoreScanState {
    pub ss: ScanState,
    pub readptr: ::core::ffi::c_int,
    pub tupdesc: TupleDesc,
    pub relation: *mut Tuplestorestate,
}
impl Default for NamedTuplestoreScanState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WorkTableScanState {
    pub ss: ScanState,
    pub rustate: *mut RecursiveUnionState,
}
impl Default for WorkTableScanState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForeignScanState {
    pub ss: ScanState,
    pub fdw_recheck_quals: *mut ExprState,
    pub pscan_len: Size,
    pub resultRelInfo: *mut ResultRelInfo,
    pub fdwroutine: *mut FdwRoutine,
    pub fdw_state: *mut ::core::ffi::c_void,
}
impl Default for ForeignScanState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomScanState {
    pub ss: ScanState,
    pub flags: uint32,
    pub custom_ps: *mut List,
    pub pscan_len: Size,
    pub methods: *const CustomExecMethods,
    pub slotOps: *const TupleTableSlotOps,
}
impl Default for CustomScanState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JoinState {
    pub ps: PlanState,
    pub jointype: JoinType::Type,
    pub single_match: bool,
    pub joinqual: *mut ExprState,
}
impl Default for JoinState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NestLoopState {
    pub js: JoinState,
    pub nl_NeedNewOuter: bool,
    pub nl_MatchedOuter: bool,
    pub nl_NullInnerTupleSlot: *mut TupleTableSlot,
}
impl Default for NestLoopState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeJoinClauseData {
    _unused: [u8; 0],
}
pub type MergeJoinClause = *mut MergeJoinClauseData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeJoinState {
    pub js: JoinState,
    pub mj_NumClauses: ::core::ffi::c_int,
    pub mj_Clauses: MergeJoinClause,
    pub mj_JoinState: ::core::ffi::c_int,
    pub mj_SkipMarkRestore: bool,
    pub mj_ExtraMarks: bool,
    pub mj_ConstFalseJoin: bool,
    pub mj_FillOuter: bool,
    pub mj_FillInner: bool,
    pub mj_MatchedOuter: bool,
    pub mj_MatchedInner: bool,
    pub mj_OuterTupleSlot: *mut TupleTableSlot,
    pub mj_InnerTupleSlot: *mut TupleTableSlot,
    pub mj_MarkedTupleSlot: *mut TupleTableSlot,
    pub mj_NullOuterTupleSlot: *mut TupleTableSlot,
    pub mj_NullInnerTupleSlot: *mut TupleTableSlot,
    pub mj_OuterEContext: *mut ExprContext,
    pub mj_InnerEContext: *mut ExprContext,
}
impl Default for MergeJoinState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashJoinTupleData {
    _unused: [u8; 0],
}
pub type HashJoinTuple = *mut HashJoinTupleData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashJoinTableData {
    _unused: [u8; 0],
}
pub type HashJoinTable = *mut HashJoinTableData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashJoinState {
    pub js: JoinState,
    pub hashclauses: *mut ExprState,
    pub hj_OuterHashKeys: *mut List,
    pub hj_HashOperators: *mut List,
    pub hj_Collations: *mut List,
    pub hj_HashTable: HashJoinTable,
    pub hj_CurHashValue: uint32,
    pub hj_CurBucketNo: ::core::ffi::c_int,
    pub hj_CurSkewBucketNo: ::core::ffi::c_int,
    pub hj_CurTuple: HashJoinTuple,
    pub hj_OuterTupleSlot: *mut TupleTableSlot,
    pub hj_HashTupleSlot: *mut TupleTableSlot,
    pub hj_NullOuterTupleSlot: *mut TupleTableSlot,
    pub hj_NullInnerTupleSlot: *mut TupleTableSlot,
    pub hj_FirstOuterTupleSlot: *mut TupleTableSlot,
    pub hj_JoinState: ::core::ffi::c_int,
    pub hj_MatchedOuter: bool,
    pub hj_OuterNotEmpty: bool,
}
impl Default for HashJoinState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MaterialState {
    pub ss: ScanState,
    pub eflags: ::core::ffi::c_int,
    pub eof_underlying: bool,
    pub tuplestorestate: *mut Tuplestorestate,
}
impl Default for MaterialState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoizeEntry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoizeTuple {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoizeKey {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MemoizeInstrumentation {
    pub cache_hits: uint64,
    pub cache_misses: uint64,
    pub cache_evictions: uint64,
    pub cache_overflows: uint64,
    pub mem_peak: uint64,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct SharedMemoizeInfo {
    pub num_workers: ::core::ffi::c_int,
    pub sinstrument: __IncompleteArrayField<MemoizeInstrumentation>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoizeState {
    pub ss: ScanState,
    pub mstatus: ::core::ffi::c_int,
    pub nkeys: ::core::ffi::c_int,
    pub hashtable: *mut memoize_hash,
    pub hashkeydesc: TupleDesc,
    pub tableslot: *mut TupleTableSlot,
    pub probeslot: *mut TupleTableSlot,
    pub cache_eq_expr: *mut ExprState,
    pub param_exprs: *mut *mut ExprState,
    pub hashfunctions: *mut FmgrInfo,
    pub collations: *mut Oid,
    pub mem_used: uint64,
    pub mem_limit: uint64,
    pub tableContext: MemoryContext,
    pub lru_list: dlist_head,
    pub last_tuple: *mut MemoizeTuple,
    pub entry: *mut MemoizeEntry,
    pub singlerow: bool,
    pub binary_mode: bool,
    pub stats: MemoizeInstrumentation,
    pub shared_info: *mut SharedMemoizeInfo,
    pub keyparamids: *mut Bitmapset,
}
impl Default for MemoizeState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PresortedKeyData {
    pub flinfo: FmgrInfo,
    pub fcinfo: FunctionCallInfo,
    pub attno: OffsetNumber,
}
impl Default for PresortedKeyData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SharedSortInfo {
    pub num_workers: ::core::ffi::c_int,
    pub sinstrument: __IncompleteArrayField<TuplesortInstrumentation>,
}
impl Default for SharedSortInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SortState {
    pub ss: ScanState,
    pub randomAccess: bool,
    pub bounded: bool,
    pub bound: int64,
    pub sort_Done: bool,
    pub bounded_Done: bool,
    pub bound_Done: int64,
    pub tuplesortstate: *mut ::core::ffi::c_void,
    pub am_worker: bool,
    pub datumSort: bool,
    pub shared_info: *mut SharedSortInfo,
}
impl Default for SortState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IncrementalSortGroupInfo {
    pub groupCount: int64,
    pub maxDiskSpaceUsed: int64,
    pub totalDiskSpaceUsed: int64,
    pub maxMemorySpaceUsed: int64,
    pub totalMemorySpaceUsed: int64,
    pub sortMethods: bits32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IncrementalSortInfo {
    pub fullsortGroupInfo: IncrementalSortGroupInfo,
    pub prefixsortGroupInfo: IncrementalSortGroupInfo,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct SharedIncrementalSortInfo {
    pub num_workers: ::core::ffi::c_int,
    pub sinfo: __IncompleteArrayField<IncrementalSortInfo>,
}
pub mod IncrementalSortExecutionStatus {
    pub type Type = ::core::ffi::c_uint;
    pub const INCSORT_LOADFULLSORT: Type = 0;
    pub const INCSORT_LOADPREFIXSORT: Type = 1;
    pub const INCSORT_READFULLSORT: Type = 2;
    pub const INCSORT_READPREFIXSORT: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IncrementalSortState {
    pub ss: ScanState,
    pub bounded: bool,
    pub bound: int64,
    pub outerNodeDone: bool,
    pub bound_Done: int64,
    pub execution_status: IncrementalSortExecutionStatus::Type,
    pub n_fullsort_remaining: int64,
    pub fullsort_state: *mut Tuplesortstate,
    pub prefixsort_state: *mut Tuplesortstate,
    pub presorted_keys: *mut PresortedKeyData,
    pub incsort_info: IncrementalSortInfo,
    pub group_pivot: *mut TupleTableSlot,
    pub transfer_tuple: *mut TupleTableSlot,
    pub am_worker: bool,
    pub shared_info: *mut SharedIncrementalSortInfo,
}
impl Default for IncrementalSortState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupState {
    pub ss: ScanState,
    pub eqfunction: *mut ExprState,
    pub grp_done: bool,
}
impl Default for GroupState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AggregateInstrumentation {
    pub hash_mem_peak: Size,
    pub hash_disk_used: uint64,
    pub hash_batches_used: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct SharedAggInfo {
    pub num_workers: ::core::ffi::c_int,
    pub sinstrument: __IncompleteArrayField<AggregateInstrumentation>,
}
pub type AggStatePerAgg = *mut AggStatePerAggData;
pub type AggStatePerTrans = *mut AggStatePerTransData;
pub type AggStatePerGroup = *mut AggStatePerGroupData;
pub type AggStatePerPhase = *mut AggStatePerPhaseData;
pub type AggStatePerHash = *mut AggStatePerHashData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggState {
    pub ss: ScanState,
    pub aggs: *mut List,
    pub numaggs: ::core::ffi::c_int,
    pub numtrans: ::core::ffi::c_int,
    pub aggstrategy: AggStrategy::Type,
    pub aggsplit: AggSplit::Type,
    pub phase: AggStatePerPhase,
    pub numphases: ::core::ffi::c_int,
    pub current_phase: ::core::ffi::c_int,
    pub peragg: AggStatePerAgg,
    pub pertrans: AggStatePerTrans,
    pub hashcontext: *mut ExprContext,
    pub aggcontexts: *mut *mut ExprContext,
    pub tmpcontext: *mut ExprContext,
    pub curaggcontext: *mut ExprContext,
    pub curperagg: AggStatePerAgg,
    pub curpertrans: AggStatePerTrans,
    pub input_done: bool,
    pub agg_done: bool,
    pub projected_set: ::core::ffi::c_int,
    pub current_set: ::core::ffi::c_int,
    pub grouped_cols: *mut Bitmapset,
    pub all_grouped_cols: *mut List,
    pub colnos_needed: *mut Bitmapset,
    pub max_colno_needed: ::core::ffi::c_int,
    pub all_cols_needed: bool,
    pub maxsets: ::core::ffi::c_int,
    pub phases: AggStatePerPhase,
    pub sort_in: *mut Tuplesortstate,
    pub sort_out: *mut Tuplesortstate,
    pub sort_slot: *mut TupleTableSlot,
    pub pergroups: *mut AggStatePerGroup,
    pub grp_firstTuple: HeapTuple,
    pub table_filled: bool,
    pub num_hashes: ::core::ffi::c_int,
    pub hash_metacxt: MemoryContext,
    pub hash_tapeset: *mut LogicalTapeSet,
    pub hash_spills: *mut HashAggSpill,
    pub hash_spill_rslot: *mut TupleTableSlot,
    pub hash_spill_wslot: *mut TupleTableSlot,
    pub hash_batches: *mut List,
    pub hash_ever_spilled: bool,
    pub hash_spill_mode: bool,
    pub hash_mem_limit: Size,
    pub hash_ngroups_limit: uint64,
    pub hash_planned_partitions: ::core::ffi::c_int,
    pub hashentrysize: f64,
    pub hash_mem_peak: Size,
    pub hash_ngroups_current: uint64,
    pub hash_disk_used: uint64,
    pub hash_batches_used: ::core::ffi::c_int,
    pub perhash: AggStatePerHash,
    pub hash_pergroup: *mut AggStatePerGroup,
    pub all_pergroups: *mut AggStatePerGroup,
    pub shared_info: *mut SharedAggInfo,
}
impl Default for AggState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowStatePerFuncData {
    _unused: [u8; 0],
}
pub type WindowStatePerFunc = *mut WindowStatePerFuncData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowStatePerAggData {
    _unused: [u8; 0],
}
pub type WindowStatePerAgg = *mut WindowStatePerAggData;
pub mod WindowAggStatus {
    pub type Type = ::core::ffi::c_uint;
    pub const WINDOWAGG_DONE: Type = 0;
    pub const WINDOWAGG_RUN: Type = 1;
    pub const WINDOWAGG_PASSTHROUGH: Type = 2;
    pub const WINDOWAGG_PASSTHROUGH_STRICT: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowAggState {
    pub ss: ScanState,
    pub funcs: *mut List,
    pub numfuncs: ::core::ffi::c_int,
    pub numaggs: ::core::ffi::c_int,
    pub perfunc: WindowStatePerFunc,
    pub peragg: WindowStatePerAgg,
    pub partEqfunction: *mut ExprState,
    pub ordEqfunction: *mut ExprState,
    pub buffer: *mut Tuplestorestate,
    pub current_ptr: ::core::ffi::c_int,
    pub framehead_ptr: ::core::ffi::c_int,
    pub frametail_ptr: ::core::ffi::c_int,
    pub grouptail_ptr: ::core::ffi::c_int,
    pub spooled_rows: int64,
    pub currentpos: int64,
    pub frameheadpos: int64,
    pub frametailpos: int64,
    pub agg_winobj: *mut WindowObjectData,
    pub aggregatedbase: int64,
    pub aggregatedupto: int64,
    pub status: WindowAggStatus::Type,
    pub frameOptions: ::core::ffi::c_int,
    pub startOffset: *mut ExprState,
    pub endOffset: *mut ExprState,
    pub startOffsetValue: Datum,
    pub endOffsetValue: Datum,
    pub startInRangeFunc: FmgrInfo,
    pub endInRangeFunc: FmgrInfo,
    pub inRangeColl: Oid,
    pub inRangeAsc: bool,
    pub inRangeNullsFirst: bool,
    pub currentgroup: int64,
    pub frameheadgroup: int64,
    pub frametailgroup: int64,
    pub groupheadpos: int64,
    pub grouptailpos: int64,
    pub partcontext: MemoryContext,
    pub aggcontext: MemoryContext,
    pub curaggcontext: MemoryContext,
    pub tmpcontext: *mut ExprContext,
    pub runcondition: *mut ExprState,
    pub use_pass_through: bool,
    pub top_window: bool,
    pub all_first: bool,
    pub partition_spooled: bool,
    pub more_partitions: bool,
    pub framehead_valid: bool,
    pub frametail_valid: bool,
    pub grouptail_valid: bool,
    pub first_part_slot: *mut TupleTableSlot,
    pub framehead_slot: *mut TupleTableSlot,
    pub frametail_slot: *mut TupleTableSlot,
    pub agg_row_slot: *mut TupleTableSlot,
    pub temp_slot_1: *mut TupleTableSlot,
    pub temp_slot_2: *mut TupleTableSlot,
}
impl Default for WindowAggState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UniqueState {
    pub ps: PlanState,
    pub eqfunction: *mut ExprState,
}
impl Default for UniqueState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GatherState {
    pub ps: PlanState,
    pub initialized: bool,
    pub need_to_scan_locally: bool,
    pub tuples_needed: int64,
    pub funnel_slot: *mut TupleTableSlot,
    pub pei: *mut ParallelExecutorInfo,
    pub nworkers_launched: ::core::ffi::c_int,
    pub nreaders: ::core::ffi::c_int,
    pub nextreader: ::core::ffi::c_int,
    pub reader: *mut *mut TupleQueueReader,
}
impl Default for GatherState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GMReaderTupleBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GatherMergeState {
    pub ps: PlanState,
    pub initialized: bool,
    pub gm_initialized: bool,
    pub need_to_scan_locally: bool,
    pub tuples_needed: int64,
    pub tupDesc: TupleDesc,
    pub gm_nkeys: ::core::ffi::c_int,
    pub gm_sortkeys: SortSupport,
    pub pei: *mut ParallelExecutorInfo,
    pub nworkers_launched: ::core::ffi::c_int,
    pub nreaders: ::core::ffi::c_int,
    pub gm_slots: *mut *mut TupleTableSlot,
    pub reader: *mut *mut TupleQueueReader,
    pub gm_tuple_buffers: *mut GMReaderTupleBuffer,
    pub gm_heap: *mut binaryheap,
}
impl Default for GatherMergeState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HashInstrumentation {
    pub nbuckets: ::core::ffi::c_int,
    pub nbuckets_original: ::core::ffi::c_int,
    pub nbatch: ::core::ffi::c_int,
    pub nbatch_original: ::core::ffi::c_int,
    pub space_peak: Size,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct SharedHashInfo {
    pub num_workers: ::core::ffi::c_int,
    pub hinstrument: __IncompleteArrayField<HashInstrumentation>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashState {
    pub ps: PlanState,
    pub hashtable: HashJoinTable,
    pub hashkeys: *mut List,
    pub shared_info: *mut SharedHashInfo,
    pub hinstrument: *mut HashInstrumentation,
    pub parallel_state: *mut ParallelHashJoinState,
}
impl Default for HashState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SetOpStatePerGroupData {
    _unused: [u8; 0],
}
pub type SetOpStatePerGroup = *mut SetOpStatePerGroupData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SetOpState {
    pub ps: PlanState,
    pub eqfunction: *mut ExprState,
    pub eqfuncoids: *mut Oid,
    pub hashfunctions: *mut FmgrInfo,
    pub setop_done: bool,
    pub numOutput: ::core::ffi::c_long,
    pub pergroup: SetOpStatePerGroup,
    pub grp_firstTuple: HeapTuple,
    pub hashtable: TupleHashTable,
    pub tableContext: MemoryContext,
    pub table_filled: bool,
    pub hashiter: TupleHashIterator,
}
impl Default for SetOpState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LockRowsState {
    pub ps: PlanState,
    pub lr_arowMarks: *mut List,
    pub lr_epqstate: EPQState,
}
impl Default for LockRowsState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod LimitStateCond {
    pub type Type = ::core::ffi::c_uint;
    pub const LIMIT_INITIAL: Type = 0;
    pub const LIMIT_RESCAN: Type = 1;
    pub const LIMIT_EMPTY: Type = 2;
    pub const LIMIT_INWINDOW: Type = 3;
    pub const LIMIT_WINDOWEND_TIES: Type = 4;
    pub const LIMIT_SUBPLANEOF: Type = 5;
    pub const LIMIT_WINDOWEND: Type = 6;
    pub const LIMIT_WINDOWSTART: Type = 7;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LimitState {
    pub ps: PlanState,
    pub limitOffset: *mut ExprState,
    pub limitCount: *mut ExprState,
    pub limitOption: LimitOption::Type,
    pub offset: int64,
    pub count: int64,
    pub noCount: bool,
    pub lstate: LimitStateCond::Type,
    pub position: int64,
    pub subSlot: *mut TupleTableSlot,
    pub eqfunction: *mut ExprState,
    pub last_slot: *mut TupleTableSlot,
}
impl Default for LimitState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod CommandTag {
    pub type Type = ::core::ffi::c_uint;
    pub const CMDTAG_UNKNOWN: Type = 0;
    pub const CMDTAG_ALTER_ACCESS_METHOD: Type = 1;
    pub const CMDTAG_ALTER_AGGREGATE: Type = 2;
    pub const CMDTAG_ALTER_CAST: Type = 3;
    pub const CMDTAG_ALTER_COLLATION: Type = 4;
    pub const CMDTAG_ALTER_CONSTRAINT: Type = 5;
    pub const CMDTAG_ALTER_CONVERSION: Type = 6;
    pub const CMDTAG_ALTER_DATABASE: Type = 7;
    pub const CMDTAG_ALTER_DEFAULT_PRIVILEGES: Type = 8;
    pub const CMDTAG_ALTER_DOMAIN: Type = 9;
    pub const CMDTAG_ALTER_EVENT_TRIGGER: Type = 10;
    pub const CMDTAG_ALTER_EXTENSION: Type = 11;
    pub const CMDTAG_ALTER_FOREIGN_DATA_WRAPPER: Type = 12;
    pub const CMDTAG_ALTER_FOREIGN_TABLE: Type = 13;
    pub const CMDTAG_ALTER_FUNCTION: Type = 14;
    pub const CMDTAG_ALTER_INDEX: Type = 15;
    pub const CMDTAG_ALTER_LANGUAGE: Type = 16;
    pub const CMDTAG_ALTER_LARGE_OBJECT: Type = 17;
    pub const CMDTAG_ALTER_MATERIALIZED_VIEW: Type = 18;
    pub const CMDTAG_ALTER_OPERATOR: Type = 19;
    pub const CMDTAG_ALTER_OPERATOR_CLASS: Type = 20;
    pub const CMDTAG_ALTER_OPERATOR_FAMILY: Type = 21;
    pub const CMDTAG_ALTER_POLICY: Type = 22;
    pub const CMDTAG_ALTER_PROCEDURE: Type = 23;
    pub const CMDTAG_ALTER_PUBLICATION: Type = 24;
    pub const CMDTAG_ALTER_ROLE: Type = 25;
    pub const CMDTAG_ALTER_ROUTINE: Type = 26;
    pub const CMDTAG_ALTER_RULE: Type = 27;
    pub const CMDTAG_ALTER_SCHEMA: Type = 28;
    pub const CMDTAG_ALTER_SEQUENCE: Type = 29;
    pub const CMDTAG_ALTER_SERVER: Type = 30;
    pub const CMDTAG_ALTER_STATISTICS: Type = 31;
    pub const CMDTAG_ALTER_SUBSCRIPTION: Type = 32;
    pub const CMDTAG_ALTER_SYSTEM: Type = 33;
    pub const CMDTAG_ALTER_TABLE: Type = 34;
    pub const CMDTAG_ALTER_TABLESPACE: Type = 35;
    pub const CMDTAG_ALTER_TEXT_SEARCH_CONFIGURATION: Type = 36;
    pub const CMDTAG_ALTER_TEXT_SEARCH_DICTIONARY: Type = 37;
    pub const CMDTAG_ALTER_TEXT_SEARCH_PARSER: Type = 38;
    pub const CMDTAG_ALTER_TEXT_SEARCH_TEMPLATE: Type = 39;
    pub const CMDTAG_ALTER_TRANSFORM: Type = 40;
    pub const CMDTAG_ALTER_TRIGGER: Type = 41;
    pub const CMDTAG_ALTER_TYPE: Type = 42;
    pub const CMDTAG_ALTER_USER_MAPPING: Type = 43;
    pub const CMDTAG_ALTER_VIEW: Type = 44;
    pub const CMDTAG_ANALYZE: Type = 45;
    pub const CMDTAG_BEGIN: Type = 46;
    pub const CMDTAG_CALL: Type = 47;
    pub const CMDTAG_CHECKPOINT: Type = 48;
    pub const CMDTAG_CLOSE: Type = 49;
    pub const CMDTAG_CLOSE_CURSOR: Type = 50;
    pub const CMDTAG_CLOSE_CURSOR_ALL: Type = 51;
    pub const CMDTAG_CLUSTER: Type = 52;
    pub const CMDTAG_COMMENT: Type = 53;
    pub const CMDTAG_COMMIT: Type = 54;
    pub const CMDTAG_COMMIT_PREPARED: Type = 55;
    pub const CMDTAG_COPY: Type = 56;
    pub const CMDTAG_COPY_FROM: Type = 57;
    pub const CMDTAG_CREATE_ACCESS_METHOD: Type = 58;
    pub const CMDTAG_CREATE_AGGREGATE: Type = 59;
    pub const CMDTAG_CREATE_CAST: Type = 60;
    pub const CMDTAG_CREATE_COLLATION: Type = 61;
    pub const CMDTAG_CREATE_CONSTRAINT: Type = 62;
    pub const CMDTAG_CREATE_CONVERSION: Type = 63;
    pub const CMDTAG_CREATE_DATABASE: Type = 64;
    pub const CMDTAG_CREATE_DOMAIN: Type = 65;
    pub const CMDTAG_CREATE_EVENT_TRIGGER: Type = 66;
    pub const CMDTAG_CREATE_EXTENSION: Type = 67;
    pub const CMDTAG_CREATE_FOREIGN_DATA_WRAPPER: Type = 68;
    pub const CMDTAG_CREATE_FOREIGN_TABLE: Type = 69;
    pub const CMDTAG_CREATE_FUNCTION: Type = 70;
    pub const CMDTAG_CREATE_INDEX: Type = 71;
    pub const CMDTAG_CREATE_LANGUAGE: Type = 72;
    pub const CMDTAG_CREATE_MATERIALIZED_VIEW: Type = 73;
    pub const CMDTAG_CREATE_OPERATOR: Type = 74;
    pub const CMDTAG_CREATE_OPERATOR_CLASS: Type = 75;
    pub const CMDTAG_CREATE_OPERATOR_FAMILY: Type = 76;
    pub const CMDTAG_CREATE_POLICY: Type = 77;
    pub const CMDTAG_CREATE_PROCEDURE: Type = 78;
    pub const CMDTAG_CREATE_PUBLICATION: Type = 79;
    pub const CMDTAG_CREATE_ROLE: Type = 80;
    pub const CMDTAG_CREATE_ROUTINE: Type = 81;
    pub const CMDTAG_CREATE_RULE: Type = 82;
    pub const CMDTAG_CREATE_SCHEMA: Type = 83;
    pub const CMDTAG_CREATE_SEQUENCE: Type = 84;
    pub const CMDTAG_CREATE_SERVER: Type = 85;
    pub const CMDTAG_CREATE_STATISTICS: Type = 86;
    pub const CMDTAG_CREATE_SUBSCRIPTION: Type = 87;
    pub const CMDTAG_CREATE_TABLE: Type = 88;
    pub const CMDTAG_CREATE_TABLE_AS: Type = 89;
    pub const CMDTAG_CREATE_TABLESPACE: Type = 90;
    pub const CMDTAG_CREATE_TEXT_SEARCH_CONFIGURATION: Type = 91;
    pub const CMDTAG_CREATE_TEXT_SEARCH_DICTIONARY: Type = 92;
    pub const CMDTAG_CREATE_TEXT_SEARCH_PARSER: Type = 93;
    pub const CMDTAG_CREATE_TEXT_SEARCH_TEMPLATE: Type = 94;
    pub const CMDTAG_CREATE_TRANSFORM: Type = 95;
    pub const CMDTAG_CREATE_TRIGGER: Type = 96;
    pub const CMDTAG_CREATE_TYPE: Type = 97;
    pub const CMDTAG_CREATE_USER_MAPPING: Type = 98;
    pub const CMDTAG_CREATE_VIEW: Type = 99;
    pub const CMDTAG_DEALLOCATE: Type = 100;
    pub const CMDTAG_DEALLOCATE_ALL: Type = 101;
    pub const CMDTAG_DECLARE_CURSOR: Type = 102;
    pub const CMDTAG_DELETE: Type = 103;
    pub const CMDTAG_DISCARD: Type = 104;
    pub const CMDTAG_DISCARD_ALL: Type = 105;
    pub const CMDTAG_DISCARD_PLANS: Type = 106;
    pub const CMDTAG_DISCARD_SEQUENCES: Type = 107;
    pub const CMDTAG_DISCARD_TEMP: Type = 108;
    pub const CMDTAG_DO: Type = 109;
    pub const CMDTAG_DROP_ACCESS_METHOD: Type = 110;
    pub const CMDTAG_DROP_AGGREGATE: Type = 111;
    pub const CMDTAG_DROP_CAST: Type = 112;
    pub const CMDTAG_DROP_COLLATION: Type = 113;
    pub const CMDTAG_DROP_CONSTRAINT: Type = 114;
    pub const CMDTAG_DROP_CONVERSION: Type = 115;
    pub const CMDTAG_DROP_DATABASE: Type = 116;
    pub const CMDTAG_DROP_DOMAIN: Type = 117;
    pub const CMDTAG_DROP_EVENT_TRIGGER: Type = 118;
    pub const CMDTAG_DROP_EXTENSION: Type = 119;
    pub const CMDTAG_DROP_FOREIGN_DATA_WRAPPER: Type = 120;
    pub const CMDTAG_DROP_FOREIGN_TABLE: Type = 121;
    pub const CMDTAG_DROP_FUNCTION: Type = 122;
    pub const CMDTAG_DROP_INDEX: Type = 123;
    pub const CMDTAG_DROP_LANGUAGE: Type = 124;
    pub const CMDTAG_DROP_MATERIALIZED_VIEW: Type = 125;
    pub const CMDTAG_DROP_OPERATOR: Type = 126;
    pub const CMDTAG_DROP_OPERATOR_CLASS: Type = 127;
    pub const CMDTAG_DROP_OPERATOR_FAMILY: Type = 128;
    pub const CMDTAG_DROP_OWNED: Type = 129;
    pub const CMDTAG_DROP_POLICY: Type = 130;
    pub const CMDTAG_DROP_PROCEDURE: Type = 131;
    pub const CMDTAG_DROP_PUBLICATION: Type = 132;
    pub const CMDTAG_DROP_ROLE: Type = 133;
    pub const CMDTAG_DROP_ROUTINE: Type = 134;
    pub const CMDTAG_DROP_RULE: Type = 135;
    pub const CMDTAG_DROP_SCHEMA: Type = 136;
    pub const CMDTAG_DROP_SEQUENCE: Type = 137;
    pub const CMDTAG_DROP_SERVER: Type = 138;
    pub const CMDTAG_DROP_STATISTICS: Type = 139;
    pub const CMDTAG_DROP_SUBSCRIPTION: Type = 140;
    pub const CMDTAG_DROP_TABLE: Type = 141;
    pub const CMDTAG_DROP_TABLESPACE: Type = 142;
    pub const CMDTAG_DROP_TEXT_SEARCH_CONFIGURATION: Type = 143;
    pub const CMDTAG_DROP_TEXT_SEARCH_DICTIONARY: Type = 144;
    pub const CMDTAG_DROP_TEXT_SEARCH_PARSER: Type = 145;
    pub const CMDTAG_DROP_TEXT_SEARCH_TEMPLATE: Type = 146;
    pub const CMDTAG_DROP_TRANSFORM: Type = 147;
    pub const CMDTAG_DROP_TRIGGER: Type = 148;
    pub const CMDTAG_DROP_TYPE: Type = 149;
    pub const CMDTAG_DROP_USER_MAPPING: Type = 150;
    pub const CMDTAG_DROP_VIEW: Type = 151;
    pub const CMDTAG_EXECUTE: Type = 152;
    pub const CMDTAG_EXPLAIN: Type = 153;
    pub const CMDTAG_FETCH: Type = 154;
    pub const CMDTAG_GRANT: Type = 155;
    pub const CMDTAG_GRANT_ROLE: Type = 156;
    pub const CMDTAG_IMPORT_FOREIGN_SCHEMA: Type = 157;
    pub const CMDTAG_INSERT: Type = 158;
    pub const CMDTAG_LISTEN: Type = 159;
    pub const CMDTAG_LOAD: Type = 160;
    pub const CMDTAG_LOCK_TABLE: Type = 161;
    pub const CMDTAG_LOGIN: Type = 162;
    pub const CMDTAG_MERGE: Type = 163;
    pub const CMDTAG_MOVE: Type = 164;
    pub const CMDTAG_NOTIFY: Type = 165;
    pub const CMDTAG_PREPARE: Type = 166;
    pub const CMDTAG_PREPARE_TRANSACTION: Type = 167;
    pub const CMDTAG_REASSIGN_OWNED: Type = 168;
    pub const CMDTAG_REFRESH_MATERIALIZED_VIEW: Type = 169;
    pub const CMDTAG_REINDEX: Type = 170;
    pub const CMDTAG_RELEASE: Type = 171;
    pub const CMDTAG_RESET: Type = 172;
    pub const CMDTAG_REVOKE: Type = 173;
    pub const CMDTAG_REVOKE_ROLE: Type = 174;
    pub const CMDTAG_ROLLBACK: Type = 175;
    pub const CMDTAG_ROLLBACK_PREPARED: Type = 176;
    pub const CMDTAG_SAVEPOINT: Type = 177;
    pub const CMDTAG_SECURITY_LABEL: Type = 178;
    pub const CMDTAG_SELECT: Type = 179;
    pub const CMDTAG_SELECT_FOR_KEY_SHARE: Type = 180;
    pub const CMDTAG_SELECT_FOR_NO_KEY_UPDATE: Type = 181;
    pub const CMDTAG_SELECT_FOR_SHARE: Type = 182;
    pub const CMDTAG_SELECT_FOR_UPDATE: Type = 183;
    pub const CMDTAG_SELECT_INTO: Type = 184;
    pub const CMDTAG_SET: Type = 185;
    pub const CMDTAG_SET_CONSTRAINTS: Type = 186;
    pub const CMDTAG_SHOW: Type = 187;
    pub const CMDTAG_START_TRANSACTION: Type = 188;
    pub const CMDTAG_TRUNCATE_TABLE: Type = 189;
    pub const CMDTAG_UNLISTEN: Type = 190;
    pub const CMDTAG_UPDATE: Type = 191;
    pub const CMDTAG_VACUUM: Type = 192;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueryCompletion {
    pub commandTag: CommandTag::Type,
    pub nprocessed: uint64,
}
impl Default for QueryCompletion {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod CommandDest {
    pub type Type = ::core::ffi::c_uint;
    pub const DestNone: Type = 0;
    pub const DestDebug: Type = 1;
    pub const DestRemote: Type = 2;
    pub const DestRemoteExecute: Type = 3;
    pub const DestRemoteSimple: Type = 4;
    pub const DestSPI: Type = 5;
    pub const DestTuplestore: Type = 6;
    pub const DestIntoRel: Type = 7;
    pub const DestCopyOut: Type = 8;
    pub const DestSQLFunction: Type = 9;
    pub const DestTransientRel: Type = 10;
    pub const DestTupleQueue: Type = 11;
    pub const DestExplainSerialize: Type = 12;
}
pub type DestReceiver = _DestReceiver;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DestReceiver {
    pub receiveSlot: ::core::option::Option<
        unsafe extern "C-unwind" fn(slot: *mut TupleTableSlot, self_: *mut DestReceiver) -> bool,
    >,
    pub rStartup: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            self_: *mut DestReceiver,
            operation: ::core::ffi::c_int,
            typeinfo: TupleDesc,
        ),
    >,
    pub rShutdown: ::core::option::Option<unsafe extern "C-unwind" fn(self_: *mut DestReceiver)>,
    pub rDestroy: ::core::option::Option<unsafe extern "C-unwind" fn(self_: *mut DestReceiver)>,
    pub mydest: CommandDest::Type,
}
impl Default for _DestReceiver {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueryDesc {
    pub operation: CmdType::Type,
    pub plannedstmt: *mut PlannedStmt,
    pub sourceText: *const ::core::ffi::c_char,
    pub snapshot: Snapshot,
    pub crosscheck_snapshot: Snapshot,
    pub dest: *mut DestReceiver,
    pub params: ParamListInfo,
    pub queryEnv: *mut QueryEnvironment,
    pub instrument_options: ::core::ffi::c_int,
    pub tupDesc: TupleDesc,
    pub estate: *mut EState,
    pub planstate: *mut PlanState,
    pub already_executed: bool,
    pub totaltime: *mut Instrumentation,
}
impl Default for QueryDesc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Integer {
    pub type_: NodeTag,
    pub ival: ::core::ffi::c_int,
}
impl Default for Integer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Float {
    pub type_: NodeTag,
    pub fval: *mut ::core::ffi::c_char,
}
impl Default for Float {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Boolean {
    pub type_: NodeTag,
    pub boolval: bool,
}
impl Default for Boolean {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct String {
    pub type_: NodeTag,
    pub sval: *mut ::core::ffi::c_char,
}
impl Default for String {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitString {
    pub type_: NodeTag,
    pub bsval: *mut ::core::ffi::c_char,
}
impl Default for BitString {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod QuerySource {
    pub type Type = ::core::ffi::c_uint;
    pub const QSRC_ORIGINAL: Type = 0;
    pub const QSRC_PARSER: Type = 1;
    pub const QSRC_INSTEAD_RULE: Type = 2;
    pub const QSRC_QUAL_INSTEAD_RULE: Type = 3;
    pub const QSRC_NON_INSTEAD_RULE: Type = 4;
}
pub mod SortByDir {
    pub type Type = ::core::ffi::c_uint;
    pub const SORTBY_DEFAULT: Type = 0;
    pub const SORTBY_ASC: Type = 1;
    pub const SORTBY_DESC: Type = 2;
    pub const SORTBY_USING: Type = 3;
}
pub mod SortByNulls {
    pub type Type = ::core::ffi::c_uint;
    pub const SORTBY_NULLS_DEFAULT: Type = 0;
    pub const SORTBY_NULLS_FIRST: Type = 1;
    pub const SORTBY_NULLS_LAST: Type = 2;
}
pub mod SetQuantifier {
    pub type Type = ::core::ffi::c_uint;
    pub const SET_QUANTIFIER_DEFAULT: Type = 0;
    pub const SET_QUANTIFIER_ALL: Type = 1;
    pub const SET_QUANTIFIER_DISTINCT: Type = 2;
}
pub type AclMode = uint64;
#[doc = "\tQuery Tree"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Query {
    pub type_: NodeTag,
    pub commandType: CmdType::Type,
    pub querySource: QuerySource::Type,
    pub queryId: uint64,
    pub canSetTag: bool,
    pub utilityStmt: *mut Node,
    pub resultRelation: ::core::ffi::c_int,
    pub hasAggs: bool,
    pub hasWindowFuncs: bool,
    pub hasTargetSRFs: bool,
    pub hasSubLinks: bool,
    pub hasDistinctOn: bool,
    pub hasRecursive: bool,
    pub hasModifyingCTE: bool,
    pub hasForUpdate: bool,
    pub hasRowSecurity: bool,
    pub isReturn: bool,
    pub cteList: *mut List,
    pub rtable: *mut List,
    pub rteperminfos: *mut List,
    pub jointree: *mut FromExpr,
    pub mergeActionList: *mut List,
    pub mergeTargetRelation: ::core::ffi::c_int,
    pub mergeJoinCondition: *mut Node,
    pub targetList: *mut List,
    pub override_: OverridingKind::Type,
    pub onConflict: *mut OnConflictExpr,
    pub returningList: *mut List,
    pub groupClause: *mut List,
    pub groupDistinct: bool,
    pub groupingSets: *mut List,
    pub havingQual: *mut Node,
    pub windowClause: *mut List,
    pub distinctClause: *mut List,
    pub sortClause: *mut List,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
    pub limitOption: LimitOption::Type,
    pub rowMarks: *mut List,
    pub setOperations: *mut Node,
    pub constraintDeps: *mut List,
    pub withCheckOptions: *mut List,
    pub stmt_location: ParseLoc,
    pub stmt_len: ParseLoc,
}
impl Default for Query {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\tSupporting data structures for Parse Trees\n\n\tMost of these node types appear in raw parsetrees output by the grammar,\n\tand get transformed to something else by the analyzer.  A few of them\n\tare used as-is in transformed querytrees."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TypeName {
    pub type_: NodeTag,
    pub names: *mut List,
    pub typeOid: Oid,
    pub setof: bool,
    pub pct_type: bool,
    pub typmods: *mut List,
    pub typemod: int32,
    pub arrayBounds: *mut List,
    pub location: ParseLoc,
}
impl Default for TypeName {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ColumnRef {
    pub type_: NodeTag,
    pub fields: *mut List,
    pub location: ParseLoc,
}
impl Default for ColumnRef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParamRef {
    pub type_: NodeTag,
    pub number: ::core::ffi::c_int,
    pub location: ParseLoc,
}
impl Default for ParamRef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod A_Expr_Kind {
    pub type Type = ::core::ffi::c_uint;
    pub const AEXPR_OP: Type = 0;
    pub const AEXPR_OP_ANY: Type = 1;
    pub const AEXPR_OP_ALL: Type = 2;
    pub const AEXPR_DISTINCT: Type = 3;
    pub const AEXPR_NOT_DISTINCT: Type = 4;
    pub const AEXPR_NULLIF: Type = 5;
    pub const AEXPR_IN: Type = 6;
    pub const AEXPR_LIKE: Type = 7;
    pub const AEXPR_ILIKE: Type = 8;
    pub const AEXPR_SIMILAR: Type = 9;
    pub const AEXPR_BETWEEN: Type = 10;
    pub const AEXPR_NOT_BETWEEN: Type = 11;
    pub const AEXPR_BETWEEN_SYM: Type = 12;
    pub const AEXPR_NOT_BETWEEN_SYM: Type = 13;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct A_Expr {
    pub type_: NodeTag,
    pub kind: A_Expr_Kind::Type,
    pub name: *mut List,
    pub lexpr: *mut Node,
    pub rexpr: *mut Node,
    pub location: ParseLoc,
}
impl Default for A_Expr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ValUnion {
    pub node: Node,
    pub ival: Integer,
    pub fval: Float,
    pub boolval: Boolean,
    pub sval: String,
    pub bsval: BitString,
}
impl Default for ValUnion {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct A_Const {
    pub type_: NodeTag,
    pub val: ValUnion,
    pub isnull: bool,
    pub location: ParseLoc,
}
impl Default for A_Const {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TypeCast {
    pub type_: NodeTag,
    pub arg: *mut Node,
    pub typeName: *mut TypeName,
    pub location: ParseLoc,
}
impl Default for TypeCast {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollateClause {
    pub type_: NodeTag,
    pub arg: *mut Node,
    pub collname: *mut List,
    pub location: ParseLoc,
}
impl Default for CollateClause {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod RoleSpecType {
    pub type Type = ::core::ffi::c_uint;
    pub const ROLESPEC_CSTRING: Type = 0;
    pub const ROLESPEC_CURRENT_ROLE: Type = 1;
    pub const ROLESPEC_CURRENT_USER: Type = 2;
    pub const ROLESPEC_SESSION_USER: Type = 3;
    pub const ROLESPEC_PUBLIC: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RoleSpec {
    pub type_: NodeTag,
    pub roletype: RoleSpecType::Type,
    pub rolename: *mut ::core::ffi::c_char,
    pub location: ParseLoc,
}
impl Default for RoleSpec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuncCall {
    pub type_: NodeTag,
    pub funcname: *mut List,
    pub args: *mut List,
    pub agg_order: *mut List,
    pub agg_filter: *mut Node,
    pub over: *mut WindowDef,
    pub agg_within_group: bool,
    pub agg_star: bool,
    pub agg_distinct: bool,
    pub func_variadic: bool,
    pub funcformat: CoercionForm::Type,
    pub location: ParseLoc,
}
impl Default for FuncCall {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct A_Star {
    pub type_: NodeTag,
}
impl Default for A_Star {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct A_Indices {
    pub type_: NodeTag,
    pub is_slice: bool,
    pub lidx: *mut Node,
    pub uidx: *mut Node,
}
impl Default for A_Indices {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct A_Indirection {
    pub type_: NodeTag,
    pub arg: *mut Node,
    pub indirection: *mut List,
}
impl Default for A_Indirection {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct A_ArrayExpr {
    pub type_: NodeTag,
    pub elements: *mut List,
    pub location: ParseLoc,
}
impl Default for A_ArrayExpr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResTarget {
    pub type_: NodeTag,
    pub name: *mut ::core::ffi::c_char,
    pub indirection: *mut List,
    pub val: *mut Node,
    pub location: ParseLoc,
}
impl Default for ResTarget {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MultiAssignRef {
    pub type_: NodeTag,
    pub source: *mut Node,
    pub colno: ::core::ffi::c_int,
    pub ncolumns: ::core::ffi::c_int,
}
impl Default for MultiAssignRef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SortBy {
    pub type_: NodeTag,
    pub node: *mut Node,
    pub sortby_dir: SortByDir::Type,
    pub sortby_nulls: SortByNulls::Type,
    pub useOp: *mut List,
    pub location: ParseLoc,
}
impl Default for SortBy {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowDef {
    pub type_: NodeTag,
    pub name: *mut ::core::ffi::c_char,
    pub refname: *mut ::core::ffi::c_char,
    pub partitionClause: *mut List,
    pub orderClause: *mut List,
    pub frameOptions: ::core::ffi::c_int,
    pub startOffset: *mut Node,
    pub endOffset: *mut Node,
    pub location: ParseLoc,
}
impl Default for WindowDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeSubselect {
    pub type_: NodeTag,
    pub lateral: bool,
    pub subquery: *mut Node,
    pub alias: *mut Alias,
}
impl Default for RangeSubselect {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeFunction {
    pub type_: NodeTag,
    pub lateral: bool,
    pub ordinality: bool,
    pub is_rowsfrom: bool,
    pub functions: *mut List,
    pub alias: *mut Alias,
    pub coldeflist: *mut List,
}
impl Default for RangeFunction {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeTableFunc {
    pub type_: NodeTag,
    pub lateral: bool,
    pub docexpr: *mut Node,
    pub rowexpr: *mut Node,
    pub namespaces: *mut List,
    pub columns: *mut List,
    pub alias: *mut Alias,
    pub location: ParseLoc,
}
impl Default for RangeTableFunc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeTableFuncCol {
    pub type_: NodeTag,
    pub colname: *mut ::core::ffi::c_char,
    pub typeName: *mut TypeName,
    pub for_ordinality: bool,
    pub is_not_null: bool,
    pub colexpr: *mut Node,
    pub coldefexpr: *mut Node,
    pub location: ParseLoc,
}
impl Default for RangeTableFuncCol {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeTableSample {
    pub type_: NodeTag,
    pub relation: *mut Node,
    pub method: *mut List,
    pub args: *mut List,
    pub repeatable: *mut Node,
    pub location: ParseLoc,
}
impl Default for RangeTableSample {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ColumnDef {
    pub type_: NodeTag,
    pub colname: *mut ::core::ffi::c_char,
    pub typeName: *mut TypeName,
    pub compression: *mut ::core::ffi::c_char,
    pub inhcount: ::core::ffi::c_int,
    pub is_local: bool,
    pub is_not_null: bool,
    pub is_from_type: bool,
    pub storage: ::core::ffi::c_char,
    pub storage_name: *mut ::core::ffi::c_char,
    pub raw_default: *mut Node,
    pub cooked_default: *mut Node,
    pub identity: ::core::ffi::c_char,
    pub identitySequence: *mut RangeVar,
    pub generated: ::core::ffi::c_char,
    pub collClause: *mut CollateClause,
    pub collOid: Oid,
    pub constraints: *mut List,
    pub fdwoptions: *mut List,
    pub location: ParseLoc,
}
impl Default for ColumnDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TableLikeClause {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub options: bits32,
    pub relationOid: Oid,
}
impl Default for TableLikeClause {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod TableLikeOption {
    pub type Type = ::core::ffi::c_uint;
    pub const CREATE_TABLE_LIKE_COMMENTS: Type = 1;
    pub const CREATE_TABLE_LIKE_COMPRESSION: Type = 2;
    pub const CREATE_TABLE_LIKE_CONSTRAINTS: Type = 4;
    pub const CREATE_TABLE_LIKE_DEFAULTS: Type = 8;
    pub const CREATE_TABLE_LIKE_GENERATED: Type = 16;
    pub const CREATE_TABLE_LIKE_IDENTITY: Type = 32;
    pub const CREATE_TABLE_LIKE_INDEXES: Type = 64;
    pub const CREATE_TABLE_LIKE_STATISTICS: Type = 128;
    pub const CREATE_TABLE_LIKE_STORAGE: Type = 256;
    pub const CREATE_TABLE_LIKE_ALL: Type = 2147483647;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexElem {
    pub type_: NodeTag,
    pub name: *mut ::core::ffi::c_char,
    pub expr: *mut Node,
    pub indexcolname: *mut ::core::ffi::c_char,
    pub collation: *mut List,
    pub opclass: *mut List,
    pub opclassopts: *mut List,
    pub ordering: SortByDir::Type,
    pub nulls_ordering: SortByNulls::Type,
}
impl Default for IndexElem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod DefElemAction {
    pub type Type = ::core::ffi::c_uint;
    pub const DEFELEM_UNSPEC: Type = 0;
    pub const DEFELEM_SET: Type = 1;
    pub const DEFELEM_ADD: Type = 2;
    pub const DEFELEM_DROP: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DefElem {
    pub type_: NodeTag,
    pub defnamespace: *mut ::core::ffi::c_char,
    pub defname: *mut ::core::ffi::c_char,
    pub arg: *mut Node,
    pub defaction: DefElemAction::Type,
    pub location: ParseLoc,
}
impl Default for DefElem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LockingClause {
    pub type_: NodeTag,
    pub lockedRels: *mut List,
    pub strength: LockClauseStrength::Type,
    pub waitPolicy: LockWaitPolicy::Type,
}
impl Default for LockingClause {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XmlSerialize {
    pub type_: NodeTag,
    pub xmloption: XmlOptionType::Type,
    pub expr: *mut Node,
    pub typeName: *mut TypeName,
    pub indent: bool,
    pub location: ParseLoc,
}
impl Default for XmlSerialize {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionElem {
    pub type_: NodeTag,
    pub name: *mut ::core::ffi::c_char,
    pub expr: *mut Node,
    pub collation: *mut List,
    pub opclass: *mut List,
    pub location: ParseLoc,
}
impl Default for PartitionElem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod PartitionStrategy {
    pub type Type = ::core::ffi::c_uint;
    pub const PARTITION_STRATEGY_LIST: Type = 108;
    pub const PARTITION_STRATEGY_RANGE: Type = 114;
    pub const PARTITION_STRATEGY_HASH: Type = 104;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionSpec {
    pub type_: NodeTag,
    pub strategy: PartitionStrategy::Type,
    pub partParams: *mut List,
    pub location: ParseLoc,
}
impl Default for PartitionSpec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionBoundSpec {
    pub type_: NodeTag,
    pub strategy: ::core::ffi::c_char,
    pub is_default: bool,
    pub modulus: ::core::ffi::c_int,
    pub remainder: ::core::ffi::c_int,
    pub listdatums: *mut List,
    pub lowerdatums: *mut List,
    pub upperdatums: *mut List,
    pub location: ParseLoc,
}
impl Default for PartitionBoundSpec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod PartitionRangeDatumKind {
    pub type Type = ::core::ffi::c_int;
    pub const PARTITION_RANGE_DATUM_MINVALUE: Type = -1;
    pub const PARTITION_RANGE_DATUM_VALUE: Type = 0;
    pub const PARTITION_RANGE_DATUM_MAXVALUE: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionRangeDatum {
    pub type_: NodeTag,
    pub kind: PartitionRangeDatumKind::Type,
    pub value: *mut Node,
    pub location: ParseLoc,
}
impl Default for PartitionRangeDatum {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SinglePartitionSpec {
    pub type_: NodeTag,
}
impl Default for SinglePartitionSpec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionCmd {
    pub type_: NodeTag,
    pub name: *mut RangeVar,
    pub bound: *mut PartitionBoundSpec,
    pub concurrent: bool,
}
impl Default for PartitionCmd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod RTEKind {
    pub type Type = ::core::ffi::c_uint;
    pub const RTE_RELATION: Type = 0;
    pub const RTE_SUBQUERY: Type = 1;
    pub const RTE_JOIN: Type = 2;
    pub const RTE_FUNCTION: Type = 3;
    pub const RTE_TABLEFUNC: Type = 4;
    pub const RTE_VALUES: Type = 5;
    pub const RTE_CTE: Type = 6;
    pub const RTE_NAMEDTUPLESTORE: Type = 7;
    pub const RTE_RESULT: Type = 8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeTblEntry {
    pub type_: NodeTag,
    pub alias: *mut Alias,
    pub eref: *mut Alias,
    pub rtekind: RTEKind::Type,
    pub relid: Oid,
    pub inh: bool,
    pub relkind: ::core::ffi::c_char,
    pub rellockmode: ::core::ffi::c_int,
    pub perminfoindex: Index,
    pub tablesample: *mut TableSampleClause,
    pub subquery: *mut Query,
    pub security_barrier: bool,
    pub jointype: JoinType::Type,
    pub joinmergedcols: ::core::ffi::c_int,
    pub joinaliasvars: *mut List,
    pub joinleftcols: *mut List,
    pub joinrightcols: *mut List,
    pub join_using_alias: *mut Alias,
    pub functions: *mut List,
    pub funcordinality: bool,
    pub tablefunc: *mut TableFunc,
    pub values_lists: *mut List,
    pub ctename: *mut ::core::ffi::c_char,
    pub ctelevelsup: Index,
    pub self_reference: bool,
    pub coltypes: *mut List,
    pub coltypmods: *mut List,
    pub colcollations: *mut List,
    pub enrname: *mut ::core::ffi::c_char,
    pub enrtuples: Cardinality,
    pub lateral: bool,
    pub inFromCl: bool,
    pub securityQuals: *mut List,
}
impl Default for RangeTblEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RTEPermissionInfo {
    pub type_: NodeTag,
    pub relid: Oid,
    pub inh: bool,
    pub requiredPerms: AclMode,
    pub checkAsUser: Oid,
    pub selectedCols: *mut Bitmapset,
    pub insertedCols: *mut Bitmapset,
    pub updatedCols: *mut Bitmapset,
}
impl Default for RTEPermissionInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeTblFunction {
    pub type_: NodeTag,
    pub funcexpr: *mut Node,
    pub funccolcount: ::core::ffi::c_int,
    pub funccolnames: *mut List,
    pub funccoltypes: *mut List,
    pub funccoltypmods: *mut List,
    pub funccolcollations: *mut List,
    pub funcparams: *mut Bitmapset,
}
impl Default for RangeTblFunction {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TableSampleClause {
    pub type_: NodeTag,
    pub tsmhandler: Oid,
    pub args: *mut List,
    pub repeatable: *mut Expr,
}
impl Default for TableSampleClause {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod WCOKind {
    pub type Type = ::core::ffi::c_uint;
    pub const WCO_VIEW_CHECK: Type = 0;
    pub const WCO_RLS_INSERT_CHECK: Type = 1;
    pub const WCO_RLS_UPDATE_CHECK: Type = 2;
    pub const WCO_RLS_CONFLICT_CHECK: Type = 3;
    pub const WCO_RLS_MERGE_UPDATE_CHECK: Type = 4;
    pub const WCO_RLS_MERGE_DELETE_CHECK: Type = 5;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WithCheckOption {
    pub type_: NodeTag,
    pub kind: WCOKind::Type,
    pub relname: *mut ::core::ffi::c_char,
    pub polname: *mut ::core::ffi::c_char,
    pub qual: *mut Node,
    pub cascaded: bool,
}
impl Default for WithCheckOption {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SortGroupClause {
    pub type_: NodeTag,
    pub tleSortGroupRef: Index,
    pub eqop: Oid,
    pub sortop: Oid,
    pub nulls_first: bool,
    pub hashable: bool,
}
impl Default for SortGroupClause {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod GroupingSetKind {
    pub type Type = ::core::ffi::c_uint;
    pub const GROUPING_SET_EMPTY: Type = 0;
    pub const GROUPING_SET_SIMPLE: Type = 1;
    pub const GROUPING_SET_ROLLUP: Type = 2;
    pub const GROUPING_SET_CUBE: Type = 3;
    pub const GROUPING_SET_SETS: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupingSet {
    pub type_: NodeTag,
    pub kind: GroupingSetKind::Type,
    pub content: *mut List,
    pub location: ParseLoc,
}
impl Default for GroupingSet {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowClause {
    pub type_: NodeTag,
    pub name: *mut ::core::ffi::c_char,
    pub refname: *mut ::core::ffi::c_char,
    pub partitionClause: *mut List,
    pub orderClause: *mut List,
    pub frameOptions: ::core::ffi::c_int,
    pub startOffset: *mut Node,
    pub endOffset: *mut Node,
    pub startInRangeFunc: Oid,
    pub endInRangeFunc: Oid,
    pub inRangeColl: Oid,
    pub inRangeAsc: bool,
    pub inRangeNullsFirst: bool,
    pub winref: Index,
    pub copiedOrder: bool,
}
impl Default for WindowClause {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RowMarkClause {
    pub type_: NodeTag,
    pub rti: Index,
    pub strength: LockClauseStrength::Type,
    pub waitPolicy: LockWaitPolicy::Type,
    pub pushedDown: bool,
}
impl Default for RowMarkClause {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WithClause {
    pub type_: NodeTag,
    pub ctes: *mut List,
    pub recursive: bool,
    pub location: ParseLoc,
}
impl Default for WithClause {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InferClause {
    pub type_: NodeTag,
    pub indexElems: *mut List,
    pub whereClause: *mut Node,
    pub conname: *mut ::core::ffi::c_char,
    pub location: ParseLoc,
}
impl Default for InferClause {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OnConflictClause {
    pub type_: NodeTag,
    pub action: OnConflictAction::Type,
    pub infer: *mut InferClause,
    pub targetList: *mut List,
    pub whereClause: *mut Node,
    pub location: ParseLoc,
}
impl Default for OnConflictClause {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod CTEMaterialize {
    pub type Type = ::core::ffi::c_uint;
    pub const CTEMaterializeDefault: Type = 0;
    pub const CTEMaterializeAlways: Type = 1;
    pub const CTEMaterializeNever: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CTESearchClause {
    pub type_: NodeTag,
    pub search_col_list: *mut List,
    pub search_breadth_first: bool,
    pub search_seq_column: *mut ::core::ffi::c_char,
    pub location: ParseLoc,
}
impl Default for CTESearchClause {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CTECycleClause {
    pub type_: NodeTag,
    pub cycle_col_list: *mut List,
    pub cycle_mark_column: *mut ::core::ffi::c_char,
    pub cycle_mark_value: *mut Node,
    pub cycle_mark_default: *mut Node,
    pub cycle_path_column: *mut ::core::ffi::c_char,
    pub location: ParseLoc,
    pub cycle_mark_type: Oid,
    pub cycle_mark_typmod: ::core::ffi::c_int,
    pub cycle_mark_collation: Oid,
    pub cycle_mark_neop: Oid,
}
impl Default for CTECycleClause {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CommonTableExpr {
    pub type_: NodeTag,
    pub ctename: *mut ::core::ffi::c_char,
    pub aliascolnames: *mut List,
    pub ctematerialized: CTEMaterialize::Type,
    pub ctequery: *mut Node,
    pub search_clause: *mut CTESearchClause,
    pub cycle_clause: *mut CTECycleClause,
    pub location: ParseLoc,
    pub cterecursive: bool,
    pub cterefcount: ::core::ffi::c_int,
    pub ctecolnames: *mut List,
    pub ctecoltypes: *mut List,
    pub ctecoltypmods: *mut List,
    pub ctecolcollations: *mut List,
}
impl Default for CommonTableExpr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeWhenClause {
    pub type_: NodeTag,
    pub matchKind: MergeMatchKind::Type,
    pub commandType: CmdType::Type,
    pub override_: OverridingKind::Type,
    pub condition: *mut Node,
    pub targetList: *mut List,
    pub values: *mut List,
}
impl Default for MergeWhenClause {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TriggerTransition {
    pub type_: NodeTag,
    pub name: *mut ::core::ffi::c_char,
    pub isNew: bool,
    pub isTable: bool,
}
impl Default for TriggerTransition {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonOutput {
    pub type_: NodeTag,
    pub typeName: *mut TypeName,
    pub returning: *mut JsonReturning,
}
impl Default for JsonOutput {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonArgument {
    pub type_: NodeTag,
    pub val: *mut JsonValueExpr,
    pub name: *mut ::core::ffi::c_char,
}
impl Default for JsonArgument {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod JsonQuotes {
    pub type Type = ::core::ffi::c_uint;
    pub const JS_QUOTES_UNSPEC: Type = 0;
    pub const JS_QUOTES_KEEP: Type = 1;
    pub const JS_QUOTES_OMIT: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonFuncExpr {
    pub type_: NodeTag,
    pub op: JsonExprOp::Type,
    pub column_name: *mut ::core::ffi::c_char,
    pub context_item: *mut JsonValueExpr,
    pub pathspec: *mut Node,
    pub passing: *mut List,
    pub output: *mut JsonOutput,
    pub on_empty: *mut JsonBehavior,
    pub on_error: *mut JsonBehavior,
    pub wrapper: JsonWrapper::Type,
    pub quotes: JsonQuotes::Type,
    pub location: ParseLoc,
}
impl Default for JsonFuncExpr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonTablePathSpec {
    pub type_: NodeTag,
    pub string: *mut Node,
    pub name: *mut ::core::ffi::c_char,
    pub name_location: ParseLoc,
    pub location: ParseLoc,
}
impl Default for JsonTablePathSpec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonTable {
    pub type_: NodeTag,
    pub context_item: *mut JsonValueExpr,
    pub pathspec: *mut JsonTablePathSpec,
    pub passing: *mut List,
    pub columns: *mut List,
    pub on_error: *mut JsonBehavior,
    pub alias: *mut Alias,
    pub lateral: bool,
    pub location: ParseLoc,
}
impl Default for JsonTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod JsonTableColumnType {
    pub type Type = ::core::ffi::c_uint;
    pub const JTC_FOR_ORDINALITY: Type = 0;
    pub const JTC_REGULAR: Type = 1;
    pub const JTC_EXISTS: Type = 2;
    pub const JTC_FORMATTED: Type = 3;
    pub const JTC_NESTED: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonTableColumn {
    pub type_: NodeTag,
    pub coltype: JsonTableColumnType::Type,
    pub name: *mut ::core::ffi::c_char,
    pub typeName: *mut TypeName,
    pub pathspec: *mut JsonTablePathSpec,
    pub format: *mut JsonFormat,
    pub wrapper: JsonWrapper::Type,
    pub quotes: JsonQuotes::Type,
    pub columns: *mut List,
    pub on_empty: *mut JsonBehavior,
    pub on_error: *mut JsonBehavior,
    pub location: ParseLoc,
}
impl Default for JsonTableColumn {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonKeyValue {
    pub type_: NodeTag,
    pub key: *mut Expr,
    pub value: *mut JsonValueExpr,
}
impl Default for JsonKeyValue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonParseExpr {
    pub type_: NodeTag,
    pub expr: *mut JsonValueExpr,
    pub output: *mut JsonOutput,
    pub unique_keys: bool,
    pub location: ParseLoc,
}
impl Default for JsonParseExpr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonScalarExpr {
    pub type_: NodeTag,
    pub expr: *mut Expr,
    pub output: *mut JsonOutput,
    pub location: ParseLoc,
}
impl Default for JsonScalarExpr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonSerializeExpr {
    pub type_: NodeTag,
    pub expr: *mut JsonValueExpr,
    pub output: *mut JsonOutput,
    pub location: ParseLoc,
}
impl Default for JsonSerializeExpr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonObjectConstructor {
    pub type_: NodeTag,
    pub exprs: *mut List,
    pub output: *mut JsonOutput,
    pub absent_on_null: bool,
    pub unique: bool,
    pub location: ParseLoc,
}
impl Default for JsonObjectConstructor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonArrayConstructor {
    pub type_: NodeTag,
    pub exprs: *mut List,
    pub output: *mut JsonOutput,
    pub absent_on_null: bool,
    pub location: ParseLoc,
}
impl Default for JsonArrayConstructor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonArrayQueryConstructor {
    pub type_: NodeTag,
    pub query: *mut Node,
    pub output: *mut JsonOutput,
    pub format: *mut JsonFormat,
    pub absent_on_null: bool,
    pub location: ParseLoc,
}
impl Default for JsonArrayQueryConstructor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonAggConstructor {
    pub type_: NodeTag,
    pub output: *mut JsonOutput,
    pub agg_filter: *mut Node,
    pub agg_order: *mut List,
    pub over: *mut WindowDef,
    pub location: ParseLoc,
}
impl Default for JsonAggConstructor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonObjectAgg {
    pub type_: NodeTag,
    pub constructor: *mut JsonAggConstructor,
    pub arg: *mut JsonKeyValue,
    pub absent_on_null: bool,
    pub unique: bool,
}
impl Default for JsonObjectAgg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonArrayAgg {
    pub type_: NodeTag,
    pub constructor: *mut JsonAggConstructor,
    pub arg: *mut JsonValueExpr,
    pub absent_on_null: bool,
}
impl Default for JsonArrayAgg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\t\tRaw Grammar Output Statements"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RawStmt {
    pub type_: NodeTag,
    pub stmt: *mut Node,
    pub stmt_location: ParseLoc,
    pub stmt_len: ParseLoc,
}
impl Default for RawStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\t\tOptimizable Statements"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InsertStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub cols: *mut List,
    pub selectStmt: *mut Node,
    pub onConflictClause: *mut OnConflictClause,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
    pub override_: OverridingKind::Type,
}
impl Default for InsertStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeleteStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub usingClause: *mut List,
    pub whereClause: *mut Node,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
}
impl Default for DeleteStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UpdateStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub targetList: *mut List,
    pub whereClause: *mut Node,
    pub fromClause: *mut List,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
}
impl Default for UpdateStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub sourceRelation: *mut Node,
    pub joinCondition: *mut Node,
    pub mergeWhenClauses: *mut List,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
}
impl Default for MergeStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod SetOperation {
    pub type Type = ::core::ffi::c_uint;
    pub const SETOP_NONE: Type = 0;
    pub const SETOP_UNION: Type = 1;
    pub const SETOP_INTERSECT: Type = 2;
    pub const SETOP_EXCEPT: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SelectStmt {
    pub type_: NodeTag,
    pub distinctClause: *mut List,
    pub intoClause: *mut IntoClause,
    pub targetList: *mut List,
    pub fromClause: *mut List,
    pub whereClause: *mut Node,
    pub groupClause: *mut List,
    pub groupDistinct: bool,
    pub havingClause: *mut Node,
    pub windowClause: *mut List,
    pub valuesLists: *mut List,
    pub sortClause: *mut List,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
    pub limitOption: LimitOption::Type,
    pub lockingClause: *mut List,
    pub withClause: *mut WithClause,
    pub op: SetOperation::Type,
    pub all: bool,
    pub larg: *mut SelectStmt,
    pub rarg: *mut SelectStmt,
}
impl Default for SelectStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SetOperationStmt {
    pub type_: NodeTag,
    pub op: SetOperation::Type,
    pub all: bool,
    pub larg: *mut Node,
    pub rarg: *mut Node,
    pub colTypes: *mut List,
    pub colTypmods: *mut List,
    pub colCollations: *mut List,
    pub groupClauses: *mut List,
}
impl Default for SetOperationStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReturnStmt {
    pub type_: NodeTag,
    pub returnval: *mut Node,
}
impl Default for ReturnStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLAssignStmt {
    pub type_: NodeTag,
    pub name: *mut ::core::ffi::c_char,
    pub indirection: *mut List,
    pub nnames: ::core::ffi::c_int,
    pub val: *mut SelectStmt,
    pub location: ParseLoc,
}
impl Default for PLAssignStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod ObjectType {
    #[doc = "\t\tOther Statements (no optimizations required)\n\n\t\tThese are not touched by parser/analyze.c except to put them into\n\t\tthe utilityStmt field of a Query.  This is eventually passed to\n\t\tProcessUtility (by-passing rewriting and planning).  Some of the\n\t\tstatements do need attention from parse analysis, and this is\n\t\tdone by routines in parser/parse_utilcmd.c after ProcessUtility\n\t\treceives the command for execution.\n\t\tDECLARE CURSOR, EXPLAIN, and CREATE TABLE AS are special cases:\n\t\tthey contain optimizable statements, which get processed normally\n\t\tby parser/analyze.c."]
    pub type Type = ::core::ffi::c_uint;
    pub const OBJECT_ACCESS_METHOD: Type = 0;
    pub const OBJECT_AGGREGATE: Type = 1;
    pub const OBJECT_AMOP: Type = 2;
    pub const OBJECT_AMPROC: Type = 3;
    pub const OBJECT_ATTRIBUTE: Type = 4;
    pub const OBJECT_CAST: Type = 5;
    pub const OBJECT_COLUMN: Type = 6;
    pub const OBJECT_COLLATION: Type = 7;
    pub const OBJECT_CONVERSION: Type = 8;
    pub const OBJECT_DATABASE: Type = 9;
    pub const OBJECT_DEFAULT: Type = 10;
    pub const OBJECT_DEFACL: Type = 11;
    pub const OBJECT_DOMAIN: Type = 12;
    pub const OBJECT_DOMCONSTRAINT: Type = 13;
    pub const OBJECT_EVENT_TRIGGER: Type = 14;
    pub const OBJECT_EXTENSION: Type = 15;
    pub const OBJECT_FDW: Type = 16;
    pub const OBJECT_FOREIGN_SERVER: Type = 17;
    pub const OBJECT_FOREIGN_TABLE: Type = 18;
    pub const OBJECT_FUNCTION: Type = 19;
    pub const OBJECT_INDEX: Type = 20;
    pub const OBJECT_LANGUAGE: Type = 21;
    pub const OBJECT_LARGEOBJECT: Type = 22;
    pub const OBJECT_MATVIEW: Type = 23;
    pub const OBJECT_OPCLASS: Type = 24;
    pub const OBJECT_OPERATOR: Type = 25;
    pub const OBJECT_OPFAMILY: Type = 26;
    pub const OBJECT_PARAMETER_ACL: Type = 27;
    pub const OBJECT_POLICY: Type = 28;
    pub const OBJECT_PROCEDURE: Type = 29;
    pub const OBJECT_PUBLICATION: Type = 30;
    pub const OBJECT_PUBLICATION_NAMESPACE: Type = 31;
    pub const OBJECT_PUBLICATION_REL: Type = 32;
    pub const OBJECT_ROLE: Type = 33;
    pub const OBJECT_ROUTINE: Type = 34;
    pub const OBJECT_RULE: Type = 35;
    pub const OBJECT_SCHEMA: Type = 36;
    pub const OBJECT_SEQUENCE: Type = 37;
    pub const OBJECT_SUBSCRIPTION: Type = 38;
    pub const OBJECT_STATISTIC_EXT: Type = 39;
    pub const OBJECT_TABCONSTRAINT: Type = 40;
    pub const OBJECT_TABLE: Type = 41;
    pub const OBJECT_TABLESPACE: Type = 42;
    pub const OBJECT_TRANSFORM: Type = 43;
    pub const OBJECT_TRIGGER: Type = 44;
    pub const OBJECT_TSCONFIGURATION: Type = 45;
    pub const OBJECT_TSDICTIONARY: Type = 46;
    pub const OBJECT_TSPARSER: Type = 47;
    pub const OBJECT_TSTEMPLATE: Type = 48;
    pub const OBJECT_TYPE: Type = 49;
    pub const OBJECT_USER_MAPPING: Type = 50;
    pub const OBJECT_VIEW: Type = 51;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateSchemaStmt {
    pub type_: NodeTag,
    pub schemaname: *mut ::core::ffi::c_char,
    pub authrole: *mut RoleSpec,
    pub schemaElts: *mut List,
    pub if_not_exists: bool,
}
impl Default for CreateSchemaStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod DropBehavior {
    pub type Type = ::core::ffi::c_uint;
    pub const DROP_RESTRICT: Type = 0;
    pub const DROP_CASCADE: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterTableStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub cmds: *mut List,
    pub objtype: ObjectType::Type,
    pub missing_ok: bool,
}
impl Default for AlterTableStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod AlterTableType {
    pub type Type = ::core::ffi::c_uint;
    pub const AT_AddColumn: Type = 0;
    pub const AT_AddColumnToView: Type = 1;
    pub const AT_ColumnDefault: Type = 2;
    pub const AT_CookedColumnDefault: Type = 3;
    pub const AT_DropNotNull: Type = 4;
    pub const AT_SetNotNull: Type = 5;
    pub const AT_SetExpression: Type = 6;
    pub const AT_DropExpression: Type = 7;
    pub const AT_CheckNotNull: Type = 8;
    pub const AT_SetStatistics: Type = 9;
    pub const AT_SetOptions: Type = 10;
    pub const AT_ResetOptions: Type = 11;
    pub const AT_SetStorage: Type = 12;
    pub const AT_SetCompression: Type = 13;
    pub const AT_DropColumn: Type = 14;
    pub const AT_AddIndex: Type = 15;
    pub const AT_ReAddIndex: Type = 16;
    pub const AT_AddConstraint: Type = 17;
    pub const AT_ReAddConstraint: Type = 18;
    pub const AT_ReAddDomainConstraint: Type = 19;
    pub const AT_AlterConstraint: Type = 20;
    pub const AT_ValidateConstraint: Type = 21;
    pub const AT_AddIndexConstraint: Type = 22;
    pub const AT_DropConstraint: Type = 23;
    pub const AT_ReAddComment: Type = 24;
    pub const AT_AlterColumnType: Type = 25;
    pub const AT_AlterColumnGenericOptions: Type = 26;
    pub const AT_ChangeOwner: Type = 27;
    pub const AT_ClusterOn: Type = 28;
    pub const AT_DropCluster: Type = 29;
    pub const AT_SetLogged: Type = 30;
    pub const AT_SetUnLogged: Type = 31;
    pub const AT_DropOids: Type = 32;
    pub const AT_SetAccessMethod: Type = 33;
    pub const AT_SetTableSpace: Type = 34;
    pub const AT_SetRelOptions: Type = 35;
    pub const AT_ResetRelOptions: Type = 36;
    pub const AT_ReplaceRelOptions: Type = 37;
    pub const AT_EnableTrig: Type = 38;
    pub const AT_EnableAlwaysTrig: Type = 39;
    pub const AT_EnableReplicaTrig: Type = 40;
    pub const AT_DisableTrig: Type = 41;
    pub const AT_EnableTrigAll: Type = 42;
    pub const AT_DisableTrigAll: Type = 43;
    pub const AT_EnableTrigUser: Type = 44;
    pub const AT_DisableTrigUser: Type = 45;
    pub const AT_EnableRule: Type = 46;
    pub const AT_EnableAlwaysRule: Type = 47;
    pub const AT_EnableReplicaRule: Type = 48;
    pub const AT_DisableRule: Type = 49;
    pub const AT_AddInherit: Type = 50;
    pub const AT_DropInherit: Type = 51;
    pub const AT_AddOf: Type = 52;
    pub const AT_DropOf: Type = 53;
    pub const AT_ReplicaIdentity: Type = 54;
    pub const AT_EnableRowSecurity: Type = 55;
    pub const AT_DisableRowSecurity: Type = 56;
    pub const AT_ForceRowSecurity: Type = 57;
    pub const AT_NoForceRowSecurity: Type = 58;
    pub const AT_GenericOptions: Type = 59;
    pub const AT_AttachPartition: Type = 60;
    pub const AT_DetachPartition: Type = 61;
    pub const AT_DetachPartitionFinalize: Type = 62;
    pub const AT_AddIdentity: Type = 63;
    pub const AT_SetIdentity: Type = 64;
    pub const AT_DropIdentity: Type = 65;
    pub const AT_ReAddStatistics: Type = 66;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReplicaIdentityStmt {
    pub type_: NodeTag,
    pub identity_type: ::core::ffi::c_char,
    pub name: *mut ::core::ffi::c_char,
}
impl Default for ReplicaIdentityStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterTableCmd {
    pub type_: NodeTag,
    pub subtype: AlterTableType::Type,
    pub name: *mut ::core::ffi::c_char,
    pub num: int16,
    pub newowner: *mut RoleSpec,
    pub def: *mut Node,
    pub behavior: DropBehavior::Type,
    pub missing_ok: bool,
    pub recurse: bool,
}
impl Default for AlterTableCmd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterCollationStmt {
    pub type_: NodeTag,
    pub collname: *mut List,
}
impl Default for AlterCollationStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterDomainStmt {
    pub type_: NodeTag,
    pub subtype: ::core::ffi::c_char,
    pub typeName: *mut List,
    pub name: *mut ::core::ffi::c_char,
    pub def: *mut Node,
    pub behavior: DropBehavior::Type,
    pub missing_ok: bool,
}
impl Default for AlterDomainStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod GrantTargetType {
    pub type Type = ::core::ffi::c_uint;
    pub const ACL_TARGET_OBJECT: Type = 0;
    pub const ACL_TARGET_ALL_IN_SCHEMA: Type = 1;
    pub const ACL_TARGET_DEFAULTS: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrantStmt {
    pub type_: NodeTag,
    pub is_grant: bool,
    pub targtype: GrantTargetType::Type,
    pub objtype: ObjectType::Type,
    pub objects: *mut List,
    pub privileges: *mut List,
    pub grantees: *mut List,
    pub grant_option: bool,
    pub grantor: *mut RoleSpec,
    pub behavior: DropBehavior::Type,
}
impl Default for GrantStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjectWithArgs {
    pub type_: NodeTag,
    pub objname: *mut List,
    pub objargs: *mut List,
    pub objfuncargs: *mut List,
    pub args_unspecified: bool,
}
impl Default for ObjectWithArgs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AccessPriv {
    pub type_: NodeTag,
    pub priv_name: *mut ::core::ffi::c_char,
    pub cols: *mut List,
}
impl Default for AccessPriv {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrantRoleStmt {
    pub type_: NodeTag,
    pub granted_roles: *mut List,
    pub grantee_roles: *mut List,
    pub is_grant: bool,
    pub opt: *mut List,
    pub grantor: *mut RoleSpec,
    pub behavior: DropBehavior::Type,
}
impl Default for GrantRoleStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterDefaultPrivilegesStmt {
    pub type_: NodeTag,
    pub options: *mut List,
    pub action: *mut GrantStmt,
}
impl Default for AlterDefaultPrivilegesStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CopyStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub query: *mut Node,
    pub attlist: *mut List,
    pub is_from: bool,
    pub is_program: bool,
    pub filename: *mut ::core::ffi::c_char,
    pub options: *mut List,
    pub whereClause: *mut Node,
}
impl Default for CopyStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod VariableSetKind {
    pub type Type = ::core::ffi::c_uint;
    pub const VAR_SET_VALUE: Type = 0;
    pub const VAR_SET_DEFAULT: Type = 1;
    pub const VAR_SET_CURRENT: Type = 2;
    pub const VAR_SET_MULTI: Type = 3;
    pub const VAR_RESET: Type = 4;
    pub const VAR_RESET_ALL: Type = 5;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VariableSetStmt {
    pub type_: NodeTag,
    pub kind: VariableSetKind::Type,
    pub name: *mut ::core::ffi::c_char,
    pub args: *mut List,
    pub is_local: bool,
}
impl Default for VariableSetStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VariableShowStmt {
    pub type_: NodeTag,
    pub name: *mut ::core::ffi::c_char,
}
impl Default for VariableShowStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub tableElts: *mut List,
    pub inhRelations: *mut List,
    pub partbound: *mut PartitionBoundSpec,
    pub partspec: *mut PartitionSpec,
    pub ofTypename: *mut TypeName,
    pub constraints: *mut List,
    pub options: *mut List,
    pub oncommit: OnCommitAction::Type,
    pub tablespacename: *mut ::core::ffi::c_char,
    pub accessMethod: *mut ::core::ffi::c_char,
    pub if_not_exists: bool,
}
impl Default for CreateStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod ConstrType {
    pub type Type = ::core::ffi::c_uint;
    pub const CONSTR_NULL: Type = 0;
    pub const CONSTR_NOTNULL: Type = 1;
    pub const CONSTR_DEFAULT: Type = 2;
    pub const CONSTR_IDENTITY: Type = 3;
    pub const CONSTR_GENERATED: Type = 4;
    pub const CONSTR_CHECK: Type = 5;
    pub const CONSTR_PRIMARY: Type = 6;
    pub const CONSTR_UNIQUE: Type = 7;
    pub const CONSTR_EXCLUSION: Type = 8;
    pub const CONSTR_FOREIGN: Type = 9;
    pub const CONSTR_ATTR_DEFERRABLE: Type = 10;
    pub const CONSTR_ATTR_NOT_DEFERRABLE: Type = 11;
    pub const CONSTR_ATTR_DEFERRED: Type = 12;
    pub const CONSTR_ATTR_IMMEDIATE: Type = 13;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Constraint {
    pub type_: NodeTag,
    pub contype: ConstrType::Type,
    pub conname: *mut ::core::ffi::c_char,
    pub deferrable: bool,
    pub initdeferred: bool,
    pub skip_validation: bool,
    pub initially_valid: bool,
    pub is_no_inherit: bool,
    pub raw_expr: *mut Node,
    pub cooked_expr: *mut ::core::ffi::c_char,
    pub generated_when: ::core::ffi::c_char,
    pub inhcount: ::core::ffi::c_int,
    pub nulls_not_distinct: bool,
    pub keys: *mut List,
    pub including: *mut List,
    pub exclusions: *mut List,
    pub options: *mut List,
    pub indexname: *mut ::core::ffi::c_char,
    pub indexspace: *mut ::core::ffi::c_char,
    pub reset_default_tblspc: bool,
    pub access_method: *mut ::core::ffi::c_char,
    pub where_clause: *mut Node,
    pub pktable: *mut RangeVar,
    pub fk_attrs: *mut List,
    pub pk_attrs: *mut List,
    pub fk_matchtype: ::core::ffi::c_char,
    pub fk_upd_action: ::core::ffi::c_char,
    pub fk_del_action: ::core::ffi::c_char,
    pub fk_del_set_cols: *mut List,
    pub old_conpfeqop: *mut List,
    pub old_pktable_oid: Oid,
    pub location: ParseLoc,
}
impl Default for Constraint {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateTableSpaceStmt {
    pub type_: NodeTag,
    pub tablespacename: *mut ::core::ffi::c_char,
    pub owner: *mut RoleSpec,
    pub location: *mut ::core::ffi::c_char,
    pub options: *mut List,
}
impl Default for CreateTableSpaceStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropTableSpaceStmt {
    pub type_: NodeTag,
    pub tablespacename: *mut ::core::ffi::c_char,
    pub missing_ok: bool,
}
impl Default for DropTableSpaceStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterTableSpaceOptionsStmt {
    pub type_: NodeTag,
    pub tablespacename: *mut ::core::ffi::c_char,
    pub options: *mut List,
    pub isReset: bool,
}
impl Default for AlterTableSpaceOptionsStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterTableMoveAllStmt {
    pub type_: NodeTag,
    pub orig_tablespacename: *mut ::core::ffi::c_char,
    pub objtype: ObjectType::Type,
    pub roles: *mut List,
    pub new_tablespacename: *mut ::core::ffi::c_char,
    pub nowait: bool,
}
impl Default for AlterTableMoveAllStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateExtensionStmt {
    pub type_: NodeTag,
    pub extname: *mut ::core::ffi::c_char,
    pub if_not_exists: bool,
    pub options: *mut List,
}
impl Default for CreateExtensionStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterExtensionStmt {
    pub type_: NodeTag,
    pub extname: *mut ::core::ffi::c_char,
    pub options: *mut List,
}
impl Default for AlterExtensionStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterExtensionContentsStmt {
    pub type_: NodeTag,
    pub extname: *mut ::core::ffi::c_char,
    pub action: ::core::ffi::c_int,
    pub objtype: ObjectType::Type,
    pub object: *mut Node,
}
impl Default for AlterExtensionContentsStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateFdwStmt {
    pub type_: NodeTag,
    pub fdwname: *mut ::core::ffi::c_char,
    pub func_options: *mut List,
    pub options: *mut List,
}
impl Default for CreateFdwStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterFdwStmt {
    pub type_: NodeTag,
    pub fdwname: *mut ::core::ffi::c_char,
    pub func_options: *mut List,
    pub options: *mut List,
}
impl Default for AlterFdwStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateForeignServerStmt {
    pub type_: NodeTag,
    pub servername: *mut ::core::ffi::c_char,
    pub servertype: *mut ::core::ffi::c_char,
    pub version: *mut ::core::ffi::c_char,
    pub fdwname: *mut ::core::ffi::c_char,
    pub if_not_exists: bool,
    pub options: *mut List,
}
impl Default for CreateForeignServerStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterForeignServerStmt {
    pub type_: NodeTag,
    pub servername: *mut ::core::ffi::c_char,
    pub version: *mut ::core::ffi::c_char,
    pub options: *mut List,
    pub has_version: bool,
}
impl Default for AlterForeignServerStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateForeignTableStmt {
    pub base: CreateStmt,
    pub servername: *mut ::core::ffi::c_char,
    pub options: *mut List,
}
impl Default for CreateForeignTableStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateUserMappingStmt {
    pub type_: NodeTag,
    pub user: *mut RoleSpec,
    pub servername: *mut ::core::ffi::c_char,
    pub if_not_exists: bool,
    pub options: *mut List,
}
impl Default for CreateUserMappingStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterUserMappingStmt {
    pub type_: NodeTag,
    pub user: *mut RoleSpec,
    pub servername: *mut ::core::ffi::c_char,
    pub options: *mut List,
}
impl Default for AlterUserMappingStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropUserMappingStmt {
    pub type_: NodeTag,
    pub user: *mut RoleSpec,
    pub servername: *mut ::core::ffi::c_char,
    pub missing_ok: bool,
}
impl Default for DropUserMappingStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod ImportForeignSchemaType {
    pub type Type = ::core::ffi::c_uint;
    pub const FDW_IMPORT_SCHEMA_ALL: Type = 0;
    pub const FDW_IMPORT_SCHEMA_LIMIT_TO: Type = 1;
    pub const FDW_IMPORT_SCHEMA_EXCEPT: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImportForeignSchemaStmt {
    pub type_: NodeTag,
    pub server_name: *mut ::core::ffi::c_char,
    pub remote_schema: *mut ::core::ffi::c_char,
    pub local_schema: *mut ::core::ffi::c_char,
    pub list_type: ImportForeignSchemaType::Type,
    pub table_list: *mut List,
    pub options: *mut List,
}
impl Default for ImportForeignSchemaStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreatePolicyStmt {
    pub type_: NodeTag,
    pub policy_name: *mut ::core::ffi::c_char,
    pub table: *mut RangeVar,
    pub cmd_name: *mut ::core::ffi::c_char,
    pub permissive: bool,
    pub roles: *mut List,
    pub qual: *mut Node,
    pub with_check: *mut Node,
}
impl Default for CreatePolicyStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterPolicyStmt {
    pub type_: NodeTag,
    pub policy_name: *mut ::core::ffi::c_char,
    pub table: *mut RangeVar,
    pub roles: *mut List,
    pub qual: *mut Node,
    pub with_check: *mut Node,
}
impl Default for AlterPolicyStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateAmStmt {
    pub type_: NodeTag,
    pub amname: *mut ::core::ffi::c_char,
    pub handler_name: *mut List,
    pub amtype: ::core::ffi::c_char,
}
impl Default for CreateAmStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateTrigStmt {
    pub type_: NodeTag,
    pub replace: bool,
    pub isconstraint: bool,
    pub trigname: *mut ::core::ffi::c_char,
    pub relation: *mut RangeVar,
    pub funcname: *mut List,
    pub args: *mut List,
    pub row: bool,
    pub timing: int16,
    pub events: int16,
    pub columns: *mut List,
    pub whenClause: *mut Node,
    pub transitionRels: *mut List,
    pub deferrable: bool,
    pub initdeferred: bool,
    pub constrrel: *mut RangeVar,
}
impl Default for CreateTrigStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateEventTrigStmt {
    pub type_: NodeTag,
    pub trigname: *mut ::core::ffi::c_char,
    pub eventname: *mut ::core::ffi::c_char,
    pub whenclause: *mut List,
    pub funcname: *mut List,
}
impl Default for CreateEventTrigStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterEventTrigStmt {
    pub type_: NodeTag,
    pub trigname: *mut ::core::ffi::c_char,
    pub tgenabled: ::core::ffi::c_char,
}
impl Default for AlterEventTrigStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreatePLangStmt {
    pub type_: NodeTag,
    pub replace: bool,
    pub plname: *mut ::core::ffi::c_char,
    pub plhandler: *mut List,
    pub plinline: *mut List,
    pub plvalidator: *mut List,
    pub pltrusted: bool,
}
impl Default for CreatePLangStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod RoleStmtType {
    pub type Type = ::core::ffi::c_uint;
    pub const ROLESTMT_ROLE: Type = 0;
    pub const ROLESTMT_USER: Type = 1;
    pub const ROLESTMT_GROUP: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateRoleStmt {
    pub type_: NodeTag,
    pub stmt_type: RoleStmtType::Type,
    pub role: *mut ::core::ffi::c_char,
    pub options: *mut List,
}
impl Default for CreateRoleStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterRoleStmt {
    pub type_: NodeTag,
    pub role: *mut RoleSpec,
    pub options: *mut List,
    pub action: ::core::ffi::c_int,
}
impl Default for AlterRoleStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterRoleSetStmt {
    pub type_: NodeTag,
    pub role: *mut RoleSpec,
    pub database: *mut ::core::ffi::c_char,
    pub setstmt: *mut VariableSetStmt,
}
impl Default for AlterRoleSetStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropRoleStmt {
    pub type_: NodeTag,
    pub roles: *mut List,
    pub missing_ok: bool,
}
impl Default for DropRoleStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateSeqStmt {
    pub type_: NodeTag,
    pub sequence: *mut RangeVar,
    pub options: *mut List,
    pub ownerId: Oid,
    pub for_identity: bool,
    pub if_not_exists: bool,
}
impl Default for CreateSeqStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterSeqStmt {
    pub type_: NodeTag,
    pub sequence: *mut RangeVar,
    pub options: *mut List,
    pub for_identity: bool,
    pub missing_ok: bool,
}
impl Default for AlterSeqStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DefineStmt {
    pub type_: NodeTag,
    pub kind: ObjectType::Type,
    pub oldstyle: bool,
    pub defnames: *mut List,
    pub args: *mut List,
    pub definition: *mut List,
    pub if_not_exists: bool,
    pub replace: bool,
}
impl Default for DefineStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateDomainStmt {
    pub type_: NodeTag,
    pub domainname: *mut List,
    pub typeName: *mut TypeName,
    pub collClause: *mut CollateClause,
    pub constraints: *mut List,
}
impl Default for CreateDomainStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateOpClassStmt {
    pub type_: NodeTag,
    pub opclassname: *mut List,
    pub opfamilyname: *mut List,
    pub amname: *mut ::core::ffi::c_char,
    pub datatype: *mut TypeName,
    pub items: *mut List,
    pub isDefault: bool,
}
impl Default for CreateOpClassStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateOpClassItem {
    pub type_: NodeTag,
    pub itemtype: ::core::ffi::c_int,
    pub name: *mut ObjectWithArgs,
    pub number: ::core::ffi::c_int,
    pub order_family: *mut List,
    pub class_args: *mut List,
    pub storedtype: *mut TypeName,
}
impl Default for CreateOpClassItem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateOpFamilyStmt {
    pub type_: NodeTag,
    pub opfamilyname: *mut List,
    pub amname: *mut ::core::ffi::c_char,
}
impl Default for CreateOpFamilyStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterOpFamilyStmt {
    pub type_: NodeTag,
    pub opfamilyname: *mut List,
    pub amname: *mut ::core::ffi::c_char,
    pub isDrop: bool,
    pub items: *mut List,
}
impl Default for AlterOpFamilyStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropStmt {
    pub type_: NodeTag,
    pub objects: *mut List,
    pub removeType: ObjectType::Type,
    pub behavior: DropBehavior::Type,
    pub missing_ok: bool,
    pub concurrent: bool,
}
impl Default for DropStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TruncateStmt {
    pub type_: NodeTag,
    pub relations: *mut List,
    pub restart_seqs: bool,
    pub behavior: DropBehavior::Type,
}
impl Default for TruncateStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CommentStmt {
    pub type_: NodeTag,
    pub objtype: ObjectType::Type,
    pub object: *mut Node,
    pub comment: *mut ::core::ffi::c_char,
}
impl Default for CommentStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SecLabelStmt {
    pub type_: NodeTag,
    pub objtype: ObjectType::Type,
    pub object: *mut Node,
    pub provider: *mut ::core::ffi::c_char,
    pub label: *mut ::core::ffi::c_char,
}
impl Default for SecLabelStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeclareCursorStmt {
    pub type_: NodeTag,
    pub portalname: *mut ::core::ffi::c_char,
    pub options: ::core::ffi::c_int,
    pub query: *mut Node,
}
impl Default for DeclareCursorStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ClosePortalStmt {
    pub type_: NodeTag,
    pub portalname: *mut ::core::ffi::c_char,
}
impl Default for ClosePortalStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod FetchDirection {
    pub type Type = ::core::ffi::c_uint;
    pub const FETCH_FORWARD: Type = 0;
    pub const FETCH_BACKWARD: Type = 1;
    pub const FETCH_ABSOLUTE: Type = 2;
    pub const FETCH_RELATIVE: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FetchStmt {
    pub type_: NodeTag,
    pub direction: FetchDirection::Type,
    pub howMany: ::core::ffi::c_long,
    pub portalname: *mut ::core::ffi::c_char,
    pub ismove: bool,
}
impl Default for FetchStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexStmt {
    pub type_: NodeTag,
    pub idxname: *mut ::core::ffi::c_char,
    pub relation: *mut RangeVar,
    pub accessMethod: *mut ::core::ffi::c_char,
    pub tableSpace: *mut ::core::ffi::c_char,
    pub indexParams: *mut List,
    pub indexIncludingParams: *mut List,
    pub options: *mut List,
    pub whereClause: *mut Node,
    pub excludeOpNames: *mut List,
    pub idxcomment: *mut ::core::ffi::c_char,
    pub indexOid: Oid,
    pub oldNumber: RelFileNumber,
    pub oldCreateSubid: SubTransactionId,
    pub oldFirstRelfilelocatorSubid: SubTransactionId,
    pub unique: bool,
    pub nulls_not_distinct: bool,
    pub primary: bool,
    pub isconstraint: bool,
    pub deferrable: bool,
    pub initdeferred: bool,
    pub transformed: bool,
    pub concurrent: bool,
    pub if_not_exists: bool,
    pub reset_default_tblspc: bool,
}
impl Default for IndexStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateStatsStmt {
    pub type_: NodeTag,
    pub defnames: *mut List,
    pub stat_types: *mut List,
    pub exprs: *mut List,
    pub relations: *mut List,
    pub stxcomment: *mut ::core::ffi::c_char,
    pub transformed: bool,
    pub if_not_exists: bool,
}
impl Default for CreateStatsStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StatsElem {
    pub type_: NodeTag,
    pub name: *mut ::core::ffi::c_char,
    pub expr: *mut Node,
}
impl Default for StatsElem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterStatsStmt {
    pub type_: NodeTag,
    pub defnames: *mut List,
    pub stxstattarget: *mut Node,
    pub missing_ok: bool,
}
impl Default for AlterStatsStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateFunctionStmt {
    pub type_: NodeTag,
    pub is_procedure: bool,
    pub replace: bool,
    pub funcname: *mut List,
    pub parameters: *mut List,
    pub returnType: *mut TypeName,
    pub options: *mut List,
    pub sql_body: *mut Node,
}
impl Default for CreateFunctionStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod FunctionParameterMode {
    pub type Type = ::core::ffi::c_uint;
    pub const FUNC_PARAM_IN: Type = 105;
    pub const FUNC_PARAM_OUT: Type = 111;
    pub const FUNC_PARAM_INOUT: Type = 98;
    pub const FUNC_PARAM_VARIADIC: Type = 118;
    pub const FUNC_PARAM_TABLE: Type = 116;
    pub const FUNC_PARAM_DEFAULT: Type = 100;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FunctionParameter {
    pub type_: NodeTag,
    pub name: *mut ::core::ffi::c_char,
    pub argType: *mut TypeName,
    pub mode: FunctionParameterMode::Type,
    pub defexpr: *mut Node,
}
impl Default for FunctionParameter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterFunctionStmt {
    pub type_: NodeTag,
    pub objtype: ObjectType::Type,
    pub func: *mut ObjectWithArgs,
    pub actions: *mut List,
}
impl Default for AlterFunctionStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DoStmt {
    pub type_: NodeTag,
    pub args: *mut List,
}
impl Default for DoStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InlineCodeBlock {
    pub type_: NodeTag,
    pub source_text: *mut ::core::ffi::c_char,
    pub langOid: Oid,
    pub langIsTrusted: bool,
    pub atomic: bool,
}
impl Default for InlineCodeBlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CallStmt {
    pub type_: NodeTag,
    pub funccall: *mut FuncCall,
    pub funcexpr: *mut FuncExpr,
    pub outargs: *mut List,
}
impl Default for CallStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CallContext {
    pub type_: NodeTag,
    pub atomic: bool,
}
impl Default for CallContext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RenameStmt {
    pub type_: NodeTag,
    pub renameType: ObjectType::Type,
    pub relationType: ObjectType::Type,
    pub relation: *mut RangeVar,
    pub object: *mut Node,
    pub subname: *mut ::core::ffi::c_char,
    pub newname: *mut ::core::ffi::c_char,
    pub behavior: DropBehavior::Type,
    pub missing_ok: bool,
}
impl Default for RenameStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterObjectDependsStmt {
    pub type_: NodeTag,
    pub objectType: ObjectType::Type,
    pub relation: *mut RangeVar,
    pub object: *mut Node,
    pub extname: *mut String,
    pub remove: bool,
}
impl Default for AlterObjectDependsStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterObjectSchemaStmt {
    pub type_: NodeTag,
    pub objectType: ObjectType::Type,
    pub relation: *mut RangeVar,
    pub object: *mut Node,
    pub newschema: *mut ::core::ffi::c_char,
    pub missing_ok: bool,
}
impl Default for AlterObjectSchemaStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterOwnerStmt {
    pub type_: NodeTag,
    pub objectType: ObjectType::Type,
    pub relation: *mut RangeVar,
    pub object: *mut Node,
    pub newowner: *mut RoleSpec,
}
impl Default for AlterOwnerStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterOperatorStmt {
    pub type_: NodeTag,
    pub opername: *mut ObjectWithArgs,
    pub options: *mut List,
}
impl Default for AlterOperatorStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterTypeStmt {
    pub type_: NodeTag,
    pub typeName: *mut List,
    pub options: *mut List,
}
impl Default for AlterTypeStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RuleStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub rulename: *mut ::core::ffi::c_char,
    pub whereClause: *mut Node,
    pub event: CmdType::Type,
    pub instead: bool,
    pub actions: *mut List,
    pub replace: bool,
}
impl Default for RuleStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotifyStmt {
    pub type_: NodeTag,
    pub conditionname: *mut ::core::ffi::c_char,
    pub payload: *mut ::core::ffi::c_char,
}
impl Default for NotifyStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ListenStmt {
    pub type_: NodeTag,
    pub conditionname: *mut ::core::ffi::c_char,
}
impl Default for ListenStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UnlistenStmt {
    pub type_: NodeTag,
    pub conditionname: *mut ::core::ffi::c_char,
}
impl Default for UnlistenStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod TransactionStmtKind {
    pub type Type = ::core::ffi::c_uint;
    pub const TRANS_STMT_BEGIN: Type = 0;
    pub const TRANS_STMT_START: Type = 1;
    pub const TRANS_STMT_COMMIT: Type = 2;
    pub const TRANS_STMT_ROLLBACK: Type = 3;
    pub const TRANS_STMT_SAVEPOINT: Type = 4;
    pub const TRANS_STMT_RELEASE: Type = 5;
    pub const TRANS_STMT_ROLLBACK_TO: Type = 6;
    pub const TRANS_STMT_PREPARE: Type = 7;
    pub const TRANS_STMT_COMMIT_PREPARED: Type = 8;
    pub const TRANS_STMT_ROLLBACK_PREPARED: Type = 9;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TransactionStmt {
    pub type_: NodeTag,
    pub kind: TransactionStmtKind::Type,
    pub options: *mut List,
    pub savepoint_name: *mut ::core::ffi::c_char,
    pub gid: *mut ::core::ffi::c_char,
    pub chain: bool,
    pub location: ParseLoc,
}
impl Default for TransactionStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CompositeTypeStmt {
    pub type_: NodeTag,
    pub typevar: *mut RangeVar,
    pub coldeflist: *mut List,
}
impl Default for CompositeTypeStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateEnumStmt {
    pub type_: NodeTag,
    pub typeName: *mut List,
    pub vals: *mut List,
}
impl Default for CreateEnumStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateRangeStmt {
    pub type_: NodeTag,
    pub typeName: *mut List,
    pub params: *mut List,
}
impl Default for CreateRangeStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterEnumStmt {
    pub type_: NodeTag,
    pub typeName: *mut List,
    pub oldVal: *mut ::core::ffi::c_char,
    pub newVal: *mut ::core::ffi::c_char,
    pub newValNeighbor: *mut ::core::ffi::c_char,
    pub newValIsAfter: bool,
    pub skipIfNewValExists: bool,
}
impl Default for AlterEnumStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod ViewCheckOption {
    pub type Type = ::core::ffi::c_uint;
    pub const NO_CHECK_OPTION: Type = 0;
    pub const LOCAL_CHECK_OPTION: Type = 1;
    pub const CASCADED_CHECK_OPTION: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ViewStmt {
    pub type_: NodeTag,
    pub view: *mut RangeVar,
    pub aliases: *mut List,
    pub query: *mut Node,
    pub replace: bool,
    pub options: *mut List,
    pub withCheckOption: ViewCheckOption::Type,
}
impl Default for ViewStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LoadStmt {
    pub type_: NodeTag,
    pub filename: *mut ::core::ffi::c_char,
}
impl Default for LoadStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreatedbStmt {
    pub type_: NodeTag,
    pub dbname: *mut ::core::ffi::c_char,
    pub options: *mut List,
}
impl Default for CreatedbStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterDatabaseStmt {
    pub type_: NodeTag,
    pub dbname: *mut ::core::ffi::c_char,
    pub options: *mut List,
}
impl Default for AlterDatabaseStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterDatabaseRefreshCollStmt {
    pub type_: NodeTag,
    pub dbname: *mut ::core::ffi::c_char,
}
impl Default for AlterDatabaseRefreshCollStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterDatabaseSetStmt {
    pub type_: NodeTag,
    pub dbname: *mut ::core::ffi::c_char,
    pub setstmt: *mut VariableSetStmt,
}
impl Default for AlterDatabaseSetStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropdbStmt {
    pub type_: NodeTag,
    pub dbname: *mut ::core::ffi::c_char,
    pub missing_ok: bool,
    pub options: *mut List,
}
impl Default for DropdbStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterSystemStmt {
    pub type_: NodeTag,
    pub setstmt: *mut VariableSetStmt,
}
impl Default for AlterSystemStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ClusterStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub indexname: *mut ::core::ffi::c_char,
    pub params: *mut List,
}
impl Default for ClusterStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VacuumStmt {
    pub type_: NodeTag,
    pub options: *mut List,
    pub rels: *mut List,
    pub is_vacuumcmd: bool,
}
impl Default for VacuumStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VacuumRelation {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub oid: Oid,
    pub va_cols: *mut List,
}
impl Default for VacuumRelation {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExplainStmt {
    pub type_: NodeTag,
    pub query: *mut Node,
    pub options: *mut List,
}
impl Default for ExplainStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateTableAsStmt {
    pub type_: NodeTag,
    pub query: *mut Node,
    pub into: *mut IntoClause,
    pub objtype: ObjectType::Type,
    pub is_select_into: bool,
    pub if_not_exists: bool,
}
impl Default for CreateTableAsStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RefreshMatViewStmt {
    pub type_: NodeTag,
    pub concurrent: bool,
    pub skipData: bool,
    pub relation: *mut RangeVar,
}
impl Default for RefreshMatViewStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CheckPointStmt {
    pub type_: NodeTag,
}
impl Default for CheckPointStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod DiscardMode {
    pub type Type = ::core::ffi::c_uint;
    pub const DISCARD_ALL: Type = 0;
    pub const DISCARD_PLANS: Type = 1;
    pub const DISCARD_SEQUENCES: Type = 2;
    pub const DISCARD_TEMP: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DiscardStmt {
    pub type_: NodeTag,
    pub target: DiscardMode::Type,
}
impl Default for DiscardStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LockStmt {
    pub type_: NodeTag,
    pub relations: *mut List,
    pub mode: ::core::ffi::c_int,
    pub nowait: bool,
}
impl Default for LockStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConstraintsSetStmt {
    pub type_: NodeTag,
    pub constraints: *mut List,
    pub deferred: bool,
}
impl Default for ConstraintsSetStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod ReindexObjectType {
    pub type Type = ::core::ffi::c_uint;
    pub const REINDEX_OBJECT_INDEX: Type = 0;
    pub const REINDEX_OBJECT_TABLE: Type = 1;
    pub const REINDEX_OBJECT_SCHEMA: Type = 2;
    pub const REINDEX_OBJECT_SYSTEM: Type = 3;
    pub const REINDEX_OBJECT_DATABASE: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReindexStmt {
    pub type_: NodeTag,
    pub kind: ReindexObjectType::Type,
    pub relation: *mut RangeVar,
    pub name: *const ::core::ffi::c_char,
    pub params: *mut List,
}
impl Default for ReindexStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateConversionStmt {
    pub type_: NodeTag,
    pub conversion_name: *mut List,
    pub for_encoding_name: *mut ::core::ffi::c_char,
    pub to_encoding_name: *mut ::core::ffi::c_char,
    pub func_name: *mut List,
    pub def: bool,
}
impl Default for CreateConversionStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateCastStmt {
    pub type_: NodeTag,
    pub sourcetype: *mut TypeName,
    pub targettype: *mut TypeName,
    pub func: *mut ObjectWithArgs,
    pub context: CoercionContext::Type,
    pub inout: bool,
}
impl Default for CreateCastStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateTransformStmt {
    pub type_: NodeTag,
    pub replace: bool,
    pub type_name: *mut TypeName,
    pub lang: *mut ::core::ffi::c_char,
    pub fromsql: *mut ObjectWithArgs,
    pub tosql: *mut ObjectWithArgs,
}
impl Default for CreateTransformStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PrepareStmt {
    pub type_: NodeTag,
    pub name: *mut ::core::ffi::c_char,
    pub argtypes: *mut List,
    pub query: *mut Node,
}
impl Default for PrepareStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExecuteStmt {
    pub type_: NodeTag,
    pub name: *mut ::core::ffi::c_char,
    pub params: *mut List,
}
impl Default for ExecuteStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeallocateStmt {
    pub type_: NodeTag,
    pub name: *mut ::core::ffi::c_char,
    pub isall: bool,
    pub location: ParseLoc,
}
impl Default for DeallocateStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropOwnedStmt {
    pub type_: NodeTag,
    pub roles: *mut List,
    pub behavior: DropBehavior::Type,
}
impl Default for DropOwnedStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReassignOwnedStmt {
    pub type_: NodeTag,
    pub roles: *mut List,
    pub newrole: *mut RoleSpec,
}
impl Default for ReassignOwnedStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterTSDictionaryStmt {
    pub type_: NodeTag,
    pub dictname: *mut List,
    pub options: *mut List,
}
impl Default for AlterTSDictionaryStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod AlterTSConfigType {
    pub type Type = ::core::ffi::c_uint;
    pub const ALTER_TSCONFIG_ADD_MAPPING: Type = 0;
    pub const ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN: Type = 1;
    pub const ALTER_TSCONFIG_REPLACE_DICT: Type = 2;
    pub const ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN: Type = 3;
    pub const ALTER_TSCONFIG_DROP_MAPPING: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterTSConfigurationStmt {
    pub type_: NodeTag,
    pub kind: AlterTSConfigType::Type,
    pub cfgname: *mut List,
    pub tokentype: *mut List,
    pub dicts: *mut List,
    pub override_: bool,
    pub replace: bool,
    pub missing_ok: bool,
}
impl Default for AlterTSConfigurationStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PublicationTable {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub whereClause: *mut Node,
    pub columns: *mut List,
}
impl Default for PublicationTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod PublicationObjSpecType {
    pub type Type = ::core::ffi::c_uint;
    pub const PUBLICATIONOBJ_TABLE: Type = 0;
    pub const PUBLICATIONOBJ_TABLES_IN_SCHEMA: Type = 1;
    pub const PUBLICATIONOBJ_TABLES_IN_CUR_SCHEMA: Type = 2;
    pub const PUBLICATIONOBJ_CONTINUATION: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PublicationObjSpec {
    pub type_: NodeTag,
    pub pubobjtype: PublicationObjSpecType::Type,
    pub name: *mut ::core::ffi::c_char,
    pub pubtable: *mut PublicationTable,
    pub location: ParseLoc,
}
impl Default for PublicationObjSpec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreatePublicationStmt {
    pub type_: NodeTag,
    pub pubname: *mut ::core::ffi::c_char,
    pub options: *mut List,
    pub pubobjects: *mut List,
    pub for_all_tables: bool,
}
impl Default for CreatePublicationStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod AlterPublicationAction {
    pub type Type = ::core::ffi::c_uint;
    pub const AP_AddObjects: Type = 0;
    pub const AP_DropObjects: Type = 1;
    pub const AP_SetObjects: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterPublicationStmt {
    pub type_: NodeTag,
    pub pubname: *mut ::core::ffi::c_char,
    pub options: *mut List,
    pub pubobjects: *mut List,
    pub for_all_tables: bool,
    pub action: AlterPublicationAction::Type,
}
impl Default for AlterPublicationStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateSubscriptionStmt {
    pub type_: NodeTag,
    pub subname: *mut ::core::ffi::c_char,
    pub conninfo: *mut ::core::ffi::c_char,
    pub publication: *mut List,
    pub options: *mut List,
}
impl Default for CreateSubscriptionStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod AlterSubscriptionType {
    pub type Type = ::core::ffi::c_uint;
    pub const ALTER_SUBSCRIPTION_OPTIONS: Type = 0;
    pub const ALTER_SUBSCRIPTION_CONNECTION: Type = 1;
    pub const ALTER_SUBSCRIPTION_SET_PUBLICATION: Type = 2;
    pub const ALTER_SUBSCRIPTION_ADD_PUBLICATION: Type = 3;
    pub const ALTER_SUBSCRIPTION_DROP_PUBLICATION: Type = 4;
    pub const ALTER_SUBSCRIPTION_REFRESH: Type = 5;
    pub const ALTER_SUBSCRIPTION_ENABLED: Type = 6;
    pub const ALTER_SUBSCRIPTION_SKIP: Type = 7;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterSubscriptionStmt {
    pub type_: NodeTag,
    pub kind: AlterSubscriptionType::Type,
    pub subname: *mut ::core::ffi::c_char,
    pub conninfo: *mut ::core::ffi::c_char,
    pub publication: *mut List,
    pub options: *mut List,
}
impl Default for AlterSubscriptionStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropSubscriptionStmt {
    pub type_: NodeTag,
    pub subname: *mut ::core::ffi::c_char,
    pub missing_ok: bool,
    pub behavior: DropBehavior::Type,
}
impl Default for DropSubscriptionStmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MemoryContextCounters {
    pub nblocks: Size,
    pub freechunks: Size,
    pub totalspace: Size,
    pub freespace: Size,
}
pub type MemoryStatsPrintFunc = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        context: MemoryContext,
        passthru: *mut ::core::ffi::c_void,
        stats_string: *const ::core::ffi::c_char,
        print_to_stderr: bool,
    ),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MemoryContextMethods {
    pub alloc: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            context: MemoryContext,
            size: Size,
            flags: ::core::ffi::c_int,
        ) -> *mut ::core::ffi::c_void,
    >,
    pub free_p:
        ::core::option::Option<unsafe extern "C-unwind" fn(pointer: *mut ::core::ffi::c_void)>,
    pub realloc: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            pointer: *mut ::core::ffi::c_void,
            size: Size,
            flags: ::core::ffi::c_int,
        ) -> *mut ::core::ffi::c_void,
    >,
    pub reset: ::core::option::Option<unsafe extern "C-unwind" fn(context: MemoryContext)>,
    pub delete_context: ::core::option::Option<unsafe extern "C-unwind" fn(context: MemoryContext)>,
    pub get_chunk_context: ::core::option::Option<
        unsafe extern "C-unwind" fn(pointer: *mut ::core::ffi::c_void) -> MemoryContext,
    >,
    pub get_chunk_space: ::core::option::Option<
        unsafe extern "C-unwind" fn(pointer: *mut ::core::ffi::c_void) -> Size,
    >,
    pub is_empty:
        ::core::option::Option<unsafe extern "C-unwind" fn(context: MemoryContext) -> bool>,
    pub stats: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            context: MemoryContext,
            printfunc: MemoryStatsPrintFunc,
            passthru: *mut ::core::ffi::c_void,
            totals: *mut MemoryContextCounters,
            print_to_stderr: bool,
        ),
    >,
    pub check: ::core::option::Option<unsafe extern "C-unwind" fn(context: MemoryContext)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryContextData {
    pub type_: NodeTag,
    pub isReset: bool,
    pub allowInCritSection: bool,
    pub mem_allocated: Size,
    pub methods: *const MemoryContextMethods,
    pub parent: MemoryContext,
    pub firstchild: MemoryContext,
    pub prevchild: MemoryContext,
    pub nextchild: MemoryContext,
    pub name: *const ::core::ffi::c_char,
    pub ident: *const ::core::ffi::c_char,
    pub reset_cbs: *mut MemoryContextCallback,
}
impl Default for MemoryContextData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ExecutorStart_hook_type = ::core::option::Option<
    unsafe extern "C-unwind" fn(queryDesc: *mut QueryDesc, eflags: ::core::ffi::c_int),
>;
pub type ExecutorRun_hook_type = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        queryDesc: *mut QueryDesc,
        direction: ScanDirection::Type,
        count: uint64,
        execute_once: bool,
    ),
>;
pub type ExecutorFinish_hook_type =
    ::core::option::Option<unsafe extern "C-unwind" fn(queryDesc: *mut QueryDesc)>;
pub type ExecutorEnd_hook_type =
    ::core::option::Option<unsafe extern "C-unwind" fn(queryDesc: *mut QueryDesc)>;
pub type ExecutorCheckPerms_hook_type = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        rangeTable: *mut List,
        rtePermInfos: *mut List,
        ereport_on_violation: bool,
    ) -> bool,
>;
pub type ExecScanAccessMtd = ::core::option::Option<
    unsafe extern "C-unwind" fn(node: *mut ScanState) -> *mut TupleTableSlot,
>;
pub type ExecScanRecheckMtd = ::core::option::Option<
    unsafe extern "C-unwind" fn(node: *mut ScanState, slot: *mut TupleTableSlot) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TupOutputState {
    pub slot: *mut TupleTableSlot,
    pub dest: *mut DestReceiver,
}
impl Default for TupOutputState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AttInMetadata {
    pub tupdesc: TupleDesc,
    pub attinfuncs: *mut FmgrInfo,
    pub attioparams: *mut Oid,
    pub atttypmods: *mut int32,
}
impl Default for AttInMetadata {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuncCallContext {
    pub call_cntr: uint64,
    pub max_calls: uint64,
    pub user_fctx: *mut ::core::ffi::c_void,
    pub attinmeta: *mut AttInMetadata,
    pub multi_call_memory_ctx: MemoryContext,
    pub tuple_desc: TupleDesc,
}
impl Default for FuncCallContext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod TypeFuncClass {
    pub type Type = ::core::ffi::c_uint;
    pub const TYPEFUNC_SCALAR: Type = 0;
    pub const TYPEFUNC_COMPOSITE: Type = 1;
    pub const TYPEFUNC_COMPOSITE_DOMAIN: Type = 2;
    pub const TYPEFUNC_RECORD: Type = 3;
    pub const TYPEFUNC_OTHER: Type = 4;
}
pub type sig_atomic_t = __sig_atomic_t;
pub mod _bindgen_ty_16 {
    pub type Type = ::core::ffi::c_uint;
    pub const SIGEV_SIGNAL: Type = 0;
    pub const SIGEV_NONE: Type = 1;
    pub const SIGEV_THREAD: Type = 2;
    pub const SIGEV_THREAD_ID: Type = 4;
}
pub type pg_time_t = int64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pg_tm {
    pub tm_sec: ::core::ffi::c_int,
    pub tm_min: ::core::ffi::c_int,
    pub tm_hour: ::core::ffi::c_int,
    pub tm_mday: ::core::ffi::c_int,
    pub tm_mon: ::core::ffi::c_int,
    pub tm_year: ::core::ffi::c_int,
    pub tm_wday: ::core::ffi::c_int,
    pub tm_yday: ::core::ffi::c_int,
    pub tm_isdst: ::core::ffi::c_int,
    pub tm_gmtoff: ::core::ffi::c_long,
    pub tm_zone: *const ::core::ffi::c_char,
}
impl Default for pg_tm {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pg_tz {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pg_tzenum {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Port {
    _unused: [u8; 0],
}
pub type pg_stack_base_t = *mut ::core::ffi::c_char;
pub mod BackendType {
    pub type Type = ::core::ffi::c_uint;
    pub const B_INVALID: Type = 0;
    pub const B_BACKEND: Type = 1;
    pub const B_AUTOVAC_LAUNCHER: Type = 2;
    pub const B_AUTOVAC_WORKER: Type = 3;
    pub const B_BG_WORKER: Type = 4;
    pub const B_WAL_SENDER: Type = 5;
    pub const B_SLOTSYNC_WORKER: Type = 6;
    pub const B_STANDALONE_BACKEND: Type = 7;
    pub const B_ARCHIVER: Type = 8;
    pub const B_BG_WRITER: Type = 9;
    pub const B_CHECKPOINTER: Type = 10;
    pub const B_STARTUP: Type = 11;
    pub const B_WAL_RECEIVER: Type = 12;
    pub const B_WAL_SUMMARIZER: Type = 13;
    pub const B_WAL_WRITER: Type = 14;
    pub const B_LOGGER: Type = 15;
}
pub mod ProcessingMode {
    #[doc = "\t  pmod.h --\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t *\n\t\t\tPOSTGRES processing mode definitions.                            *"]
    pub type Type = ::core::ffi::c_uint;
    pub const BootstrapProcessing: Type = 0;
    pub const InitProcessing: Type = 1;
    pub const NormalProcessing: Type = 2;
}
pub type shmem_request_hook_type = ::core::option::Option<unsafe extern "C-unwind" fn()>;
pub mod ProgressCommandType {
    pub type Type = ::core::ffi::c_uint;
    pub const PROGRESS_COMMAND_INVALID: Type = 0;
    pub const PROGRESS_COMMAND_VACUUM: Type = 1;
    pub const PROGRESS_COMMAND_ANALYZE: Type = 2;
    pub const PROGRESS_COMMAND_CLUSTER: Type = 3;
    pub const PROGRESS_COMMAND_CREATE_INDEX: Type = 4;
    pub const PROGRESS_COMMAND_BASEBACKUP: Type = 5;
    pub const PROGRESS_COMMAND_COPY: Type = 6;
}
pub type sa_family_t = ::core::ffi::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::core::ffi::c_char; 118usize],
    pub __ss_align: ::core::ffi::c_ulong,
}
impl Default for sockaddr_storage {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SockAddr {
    pub addr: sockaddr_storage,
    pub salen: socklen_t,
}
impl Default for SockAddr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AddrInfo {
    pub family: ::core::ffi::c_int,
    pub addr: SockAddr,
}
impl Default for AddrInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ProtocolVersion = uint32;
pub type MsgType = ProtocolVersion;
pub type PacketLen = uint32;
pub type AuthRequest = uint32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CancelRequestPacket {
    pub cancelRequestCode: MsgType,
    pub backendPID: uint32,
    pub cancelAuthCode: uint32,
}
pub mod BackendState {
    pub type Type = ::core::ffi::c_uint;
    pub const STATE_UNDEFINED: Type = 0;
    pub const STATE_IDLE: Type = 1;
    pub const STATE_RUNNING: Type = 2;
    pub const STATE_IDLEINTRANSACTION: Type = 3;
    pub const STATE_FASTPATH: Type = 4;
    pub const STATE_IDLEINTRANSACTION_ABORTED: Type = 5;
    pub const STATE_DISABLED: Type = 6;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgBackendSSLStatus {
    pub ssl_bits: ::core::ffi::c_int,
    pub ssl_version: [::core::ffi::c_char; 64usize],
    pub ssl_cipher: [::core::ffi::c_char; 64usize],
    pub ssl_client_dn: [::core::ffi::c_char; 64usize],
    pub ssl_client_serial: [::core::ffi::c_char; 64usize],
    pub ssl_issuer_dn: [::core::ffi::c_char; 64usize],
}
impl Default for PgBackendSSLStatus {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgBackendGSSStatus {
    pub gss_princ: [::core::ffi::c_char; 64usize],
    pub gss_auth: bool,
    pub gss_enc: bool,
    pub gss_delegation: bool,
}
impl Default for PgBackendGSSStatus {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgBackendStatus {
    pub st_changecount: ::core::ffi::c_int,
    pub st_procpid: ::core::ffi::c_int,
    pub st_backendType: BackendType::Type,
    pub st_proc_start_timestamp: TimestampTz,
    pub st_xact_start_timestamp: TimestampTz,
    pub st_activity_start_timestamp: TimestampTz,
    pub st_state_start_timestamp: TimestampTz,
    pub st_databaseid: Oid,
    pub st_userid: Oid,
    pub st_clientaddr: SockAddr,
    pub st_clienthostname: *mut ::core::ffi::c_char,
    pub st_ssl: bool,
    pub st_sslstatus: *mut PgBackendSSLStatus,
    pub st_gss: bool,
    pub st_gssstatus: *mut PgBackendGSSStatus,
    pub st_state: BackendState::Type,
    pub st_appname: *mut ::core::ffi::c_char,
    pub st_activity_raw: *mut ::core::ffi::c_char,
    pub st_progress_command: ProgressCommandType::Type,
    pub st_progress_command_target: Oid,
    pub st_progress_param: [int64; 20usize],
    pub st_query_id: uint64,
}
impl Default for PgBackendStatus {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LocalPgBackendStatus {
    pub backendStatus: PgBackendStatus,
    pub proc_number: ProcNumber,
    pub backend_xid: TransactionId,
    pub backend_xmin: TransactionId,
    pub backend_subxact_count: ::core::ffi::c_int,
    pub backend_subxact_overflowed: bool,
}
impl Default for LocalPgBackendStatus {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod WaitEventActivity {
    pub type Type = ::core::ffi::c_uint;
    pub const WAIT_EVENT_ARCHIVER_MAIN: Type = 83886080;
    pub const WAIT_EVENT_AUTOVACUUM_MAIN: Type = 83886081;
    pub const WAIT_EVENT_BGWRITER_HIBERNATE: Type = 83886082;
    pub const WAIT_EVENT_BGWRITER_MAIN: Type = 83886083;
    pub const WAIT_EVENT_CHECKPOINTER_MAIN: Type = 83886084;
    pub const WAIT_EVENT_LOGICAL_APPLY_MAIN: Type = 83886085;
    pub const WAIT_EVENT_LOGICAL_LAUNCHER_MAIN: Type = 83886086;
    pub const WAIT_EVENT_LOGICAL_PARALLEL_APPLY_MAIN: Type = 83886087;
    pub const WAIT_EVENT_RECOVERY_WAL_STREAM: Type = 83886088;
    pub const WAIT_EVENT_REPLICATION_SLOTSYNC_MAIN: Type = 83886089;
    pub const WAIT_EVENT_REPLICATION_SLOTSYNC_SHUTDOWN: Type = 83886090;
    pub const WAIT_EVENT_SYSLOGGER_MAIN: Type = 83886091;
    pub const WAIT_EVENT_WAL_RECEIVER_MAIN: Type = 83886092;
    pub const WAIT_EVENT_WAL_SENDER_MAIN: Type = 83886093;
    pub const WAIT_EVENT_WAL_SUMMARIZER_WAL: Type = 83886094;
    pub const WAIT_EVENT_WAL_WRITER_MAIN: Type = 83886095;
}
pub mod WaitEventBufferPin {
    pub type Type = ::core::ffi::c_uint;
    pub const WAIT_EVENT_BUFFER_PIN: Type = 67108864;
}
pub mod WaitEventClient {
    pub type Type = ::core::ffi::c_uint;
    pub const WAIT_EVENT_CLIENT_READ: Type = 100663296;
    pub const WAIT_EVENT_CLIENT_WRITE: Type = 100663297;
    pub const WAIT_EVENT_GSS_OPEN_SERVER: Type = 100663298;
    pub const WAIT_EVENT_LIBPQWALRECEIVER_CONNECT: Type = 100663299;
    pub const WAIT_EVENT_LIBPQWALRECEIVER_RECEIVE: Type = 100663300;
    pub const WAIT_EVENT_SSL_OPEN_SERVER: Type = 100663301;
    pub const WAIT_EVENT_WAIT_FOR_STANDBY_CONFIRMATION: Type = 100663302;
    pub const WAIT_EVENT_WAL_SENDER_WAIT_FOR_WAL: Type = 100663303;
    pub const WAIT_EVENT_WAL_SENDER_WRITE_DATA: Type = 100663304;
}
pub mod WaitEventIO {
    pub type Type = ::core::ffi::c_uint;
    pub const WAIT_EVENT_BASEBACKUP_READ: Type = 167772160;
    pub const WAIT_EVENT_BASEBACKUP_SYNC: Type = 167772161;
    pub const WAIT_EVENT_BASEBACKUP_WRITE: Type = 167772162;
    pub const WAIT_EVENT_BUFFILE_READ: Type = 167772163;
    pub const WAIT_EVENT_BUFFILE_TRUNCATE: Type = 167772164;
    pub const WAIT_EVENT_BUFFILE_WRITE: Type = 167772165;
    pub const WAIT_EVENT_CONTROL_FILE_READ: Type = 167772166;
    pub const WAIT_EVENT_CONTROL_FILE_SYNC: Type = 167772167;
    pub const WAIT_EVENT_CONTROL_FILE_SYNC_UPDATE: Type = 167772168;
    pub const WAIT_EVENT_CONTROL_FILE_WRITE: Type = 167772169;
    pub const WAIT_EVENT_CONTROL_FILE_WRITE_UPDATE: Type = 167772170;
    pub const WAIT_EVENT_COPY_FILE_READ: Type = 167772171;
    pub const WAIT_EVENT_COPY_FILE_WRITE: Type = 167772172;
    pub const WAIT_EVENT_DATA_FILE_EXTEND: Type = 167772173;
    pub const WAIT_EVENT_DATA_FILE_FLUSH: Type = 167772174;
    pub const WAIT_EVENT_DATA_FILE_IMMEDIATE_SYNC: Type = 167772175;
    pub const WAIT_EVENT_DATA_FILE_PREFETCH: Type = 167772176;
    pub const WAIT_EVENT_DATA_FILE_READ: Type = 167772177;
    pub const WAIT_EVENT_DATA_FILE_SYNC: Type = 167772178;
    pub const WAIT_EVENT_DATA_FILE_TRUNCATE: Type = 167772179;
    pub const WAIT_EVENT_DATA_FILE_WRITE: Type = 167772180;
    pub const WAIT_EVENT_DSM_ALLOCATE: Type = 167772181;
    pub const WAIT_EVENT_DSM_FILL_ZERO_WRITE: Type = 167772182;
    pub const WAIT_EVENT_LOCK_FILE_ADDTODATADIR_READ: Type = 167772183;
    pub const WAIT_EVENT_LOCK_FILE_ADDTODATADIR_SYNC: Type = 167772184;
    pub const WAIT_EVENT_LOCK_FILE_ADDTODATADIR_WRITE: Type = 167772185;
    pub const WAIT_EVENT_LOCK_FILE_CREATE_READ: Type = 167772186;
    pub const WAIT_EVENT_LOCK_FILE_CREATE_SYNC: Type = 167772187;
    pub const WAIT_EVENT_LOCK_FILE_CREATE_WRITE: Type = 167772188;
    pub const WAIT_EVENT_LOCK_FILE_RECHECKDATADIR_READ: Type = 167772189;
    pub const WAIT_EVENT_LOGICAL_REWRITE_CHECKPOINT_SYNC: Type = 167772190;
    pub const WAIT_EVENT_LOGICAL_REWRITE_MAPPING_SYNC: Type = 167772191;
    pub const WAIT_EVENT_LOGICAL_REWRITE_MAPPING_WRITE: Type = 167772192;
    pub const WAIT_EVENT_LOGICAL_REWRITE_SYNC: Type = 167772193;
    pub const WAIT_EVENT_LOGICAL_REWRITE_TRUNCATE: Type = 167772194;
    pub const WAIT_EVENT_LOGICAL_REWRITE_WRITE: Type = 167772195;
    pub const WAIT_EVENT_RELATION_MAP_READ: Type = 167772196;
    pub const WAIT_EVENT_RELATION_MAP_REPLACE: Type = 167772197;
    pub const WAIT_EVENT_RELATION_MAP_WRITE: Type = 167772198;
    pub const WAIT_EVENT_REORDER_BUFFER_READ: Type = 167772199;
    pub const WAIT_EVENT_REORDER_BUFFER_WRITE: Type = 167772200;
    pub const WAIT_EVENT_REORDER_LOGICAL_MAPPING_READ: Type = 167772201;
    pub const WAIT_EVENT_REPLICATION_SLOT_READ: Type = 167772202;
    pub const WAIT_EVENT_REPLICATION_SLOT_RESTORE_SYNC: Type = 167772203;
    pub const WAIT_EVENT_REPLICATION_SLOT_SYNC: Type = 167772204;
    pub const WAIT_EVENT_REPLICATION_SLOT_WRITE: Type = 167772205;
    pub const WAIT_EVENT_SLRU_FLUSH_SYNC: Type = 167772206;
    pub const WAIT_EVENT_SLRU_READ: Type = 167772207;
    pub const WAIT_EVENT_SLRU_SYNC: Type = 167772208;
    pub const WAIT_EVENT_SLRU_WRITE: Type = 167772209;
    pub const WAIT_EVENT_SNAPBUILD_READ: Type = 167772210;
    pub const WAIT_EVENT_SNAPBUILD_SYNC: Type = 167772211;
    pub const WAIT_EVENT_SNAPBUILD_WRITE: Type = 167772212;
    pub const WAIT_EVENT_TIMELINE_HISTORY_FILE_SYNC: Type = 167772213;
    pub const WAIT_EVENT_TIMELINE_HISTORY_FILE_WRITE: Type = 167772214;
    pub const WAIT_EVENT_TIMELINE_HISTORY_READ: Type = 167772215;
    pub const WAIT_EVENT_TIMELINE_HISTORY_SYNC: Type = 167772216;
    pub const WAIT_EVENT_TIMELINE_HISTORY_WRITE: Type = 167772217;
    pub const WAIT_EVENT_TWOPHASE_FILE_READ: Type = 167772218;
    pub const WAIT_EVENT_TWOPHASE_FILE_SYNC: Type = 167772219;
    pub const WAIT_EVENT_TWOPHASE_FILE_WRITE: Type = 167772220;
    pub const WAIT_EVENT_VERSION_FILE_SYNC: Type = 167772221;
    pub const WAIT_EVENT_VERSION_FILE_WRITE: Type = 167772222;
    pub const WAIT_EVENT_WALSENDER_TIMELINE_HISTORY_READ: Type = 167772223;
    pub const WAIT_EVENT_WAL_BOOTSTRAP_SYNC: Type = 167772224;
    pub const WAIT_EVENT_WAL_BOOTSTRAP_WRITE: Type = 167772225;
    pub const WAIT_EVENT_WAL_COPY_READ: Type = 167772226;
    pub const WAIT_EVENT_WAL_COPY_SYNC: Type = 167772227;
    pub const WAIT_EVENT_WAL_COPY_WRITE: Type = 167772228;
    pub const WAIT_EVENT_WAL_INIT_SYNC: Type = 167772229;
    pub const WAIT_EVENT_WAL_INIT_WRITE: Type = 167772230;
    pub const WAIT_EVENT_WAL_READ: Type = 167772231;
    pub const WAIT_EVENT_WAL_SUMMARY_READ: Type = 167772232;
    pub const WAIT_EVENT_WAL_SUMMARY_WRITE: Type = 167772233;
    pub const WAIT_EVENT_WAL_SYNC: Type = 167772234;
    pub const WAIT_EVENT_WAL_SYNC_METHOD_ASSIGN: Type = 167772235;
    pub const WAIT_EVENT_WAL_WRITE: Type = 167772236;
}
pub mod WaitEventIPC {
    pub type Type = ::core::ffi::c_uint;
    pub const WAIT_EVENT_APPEND_READY: Type = 134217728;
    pub const WAIT_EVENT_ARCHIVE_CLEANUP_COMMAND: Type = 134217729;
    pub const WAIT_EVENT_ARCHIVE_COMMAND: Type = 134217730;
    pub const WAIT_EVENT_BACKEND_TERMINATION: Type = 134217731;
    pub const WAIT_EVENT_BACKUP_WAIT_WAL_ARCHIVE: Type = 134217732;
    pub const WAIT_EVENT_BGWORKER_SHUTDOWN: Type = 134217733;
    pub const WAIT_EVENT_BGWORKER_STARTUP: Type = 134217734;
    pub const WAIT_EVENT_BTREE_PAGE: Type = 134217735;
    pub const WAIT_EVENT_BUFFER_IO: Type = 134217736;
    pub const WAIT_EVENT_CHECKPOINT_DELAY_COMPLETE: Type = 134217737;
    pub const WAIT_EVENT_CHECKPOINT_DELAY_START: Type = 134217738;
    pub const WAIT_EVENT_CHECKPOINT_DONE: Type = 134217739;
    pub const WAIT_EVENT_CHECKPOINT_START: Type = 134217740;
    pub const WAIT_EVENT_EXECUTE_GATHER: Type = 134217741;
    pub const WAIT_EVENT_HASH_BATCH_ALLOCATE: Type = 134217742;
    pub const WAIT_EVENT_HASH_BATCH_ELECT: Type = 134217743;
    pub const WAIT_EVENT_HASH_BATCH_LOAD: Type = 134217744;
    pub const WAIT_EVENT_HASH_BUILD_ALLOCATE: Type = 134217745;
    pub const WAIT_EVENT_HASH_BUILD_ELECT: Type = 134217746;
    pub const WAIT_EVENT_HASH_BUILD_HASH_INNER: Type = 134217747;
    pub const WAIT_EVENT_HASH_BUILD_HASH_OUTER: Type = 134217748;
    pub const WAIT_EVENT_HASH_GROW_BATCHES_DECIDE: Type = 134217749;
    pub const WAIT_EVENT_HASH_GROW_BATCHES_ELECT: Type = 134217750;
    pub const WAIT_EVENT_HASH_GROW_BATCHES_FINISH: Type = 134217751;
    pub const WAIT_EVENT_HASH_GROW_BATCHES_REALLOCATE: Type = 134217752;
    pub const WAIT_EVENT_HASH_GROW_BATCHES_REPARTITION: Type = 134217753;
    pub const WAIT_EVENT_HASH_GROW_BUCKETS_ELECT: Type = 134217754;
    pub const WAIT_EVENT_HASH_GROW_BUCKETS_REALLOCATE: Type = 134217755;
    pub const WAIT_EVENT_HASH_GROW_BUCKETS_REINSERT: Type = 134217756;
    pub const WAIT_EVENT_LOGICAL_APPLY_SEND_DATA: Type = 134217757;
    pub const WAIT_EVENT_LOGICAL_PARALLEL_APPLY_STATE_CHANGE: Type = 134217758;
    pub const WAIT_EVENT_LOGICAL_SYNC_DATA: Type = 134217759;
    pub const WAIT_EVENT_LOGICAL_SYNC_STATE_CHANGE: Type = 134217760;
    pub const WAIT_EVENT_MESSAGE_QUEUE_INTERNAL: Type = 134217761;
    pub const WAIT_EVENT_MESSAGE_QUEUE_PUT_MESSAGE: Type = 134217762;
    pub const WAIT_EVENT_MESSAGE_QUEUE_RECEIVE: Type = 134217763;
    pub const WAIT_EVENT_MESSAGE_QUEUE_SEND: Type = 134217764;
    pub const WAIT_EVENT_MULTIXACT_CREATION: Type = 134217765;
    pub const WAIT_EVENT_PARALLEL_BITMAP_SCAN: Type = 134217766;
    pub const WAIT_EVENT_PARALLEL_CREATE_INDEX_SCAN: Type = 134217767;
    pub const WAIT_EVENT_PARALLEL_FINISH: Type = 134217768;
    pub const WAIT_EVENT_PROCARRAY_GROUP_UPDATE: Type = 134217769;
    pub const WAIT_EVENT_PROC_SIGNAL_BARRIER: Type = 134217770;
    pub const WAIT_EVENT_PROMOTE: Type = 134217771;
    pub const WAIT_EVENT_RECOVERY_CONFLICT_SNAPSHOT: Type = 134217772;
    pub const WAIT_EVENT_RECOVERY_CONFLICT_TABLESPACE: Type = 134217773;
    pub const WAIT_EVENT_RECOVERY_END_COMMAND: Type = 134217774;
    pub const WAIT_EVENT_RECOVERY_PAUSE: Type = 134217775;
    pub const WAIT_EVENT_REPLICATION_ORIGIN_DROP: Type = 134217776;
    pub const WAIT_EVENT_REPLICATION_SLOT_DROP: Type = 134217777;
    pub const WAIT_EVENT_RESTORE_COMMAND: Type = 134217778;
    pub const WAIT_EVENT_SAFE_SNAPSHOT: Type = 134217779;
    pub const WAIT_EVENT_SYNC_REP: Type = 134217780;
    pub const WAIT_EVENT_WAL_RECEIVER_EXIT: Type = 134217781;
    pub const WAIT_EVENT_WAL_RECEIVER_WAIT_START: Type = 134217782;
    pub const WAIT_EVENT_WAL_SUMMARY_READY: Type = 134217783;
    pub const WAIT_EVENT_XACT_GROUP_UPDATE: Type = 134217784;
}
pub mod WaitEventTimeout {
    pub type Type = ::core::ffi::c_uint;
    pub const WAIT_EVENT_BASE_BACKUP_THROTTLE: Type = 150994944;
    pub const WAIT_EVENT_CHECKPOINT_WRITE_DELAY: Type = 150994945;
    pub const WAIT_EVENT_PG_SLEEP: Type = 150994946;
    pub const WAIT_EVENT_RECOVERY_APPLY_DELAY: Type = 150994947;
    pub const WAIT_EVENT_RECOVERY_RETRIEVE_RETRY_INTERVAL: Type = 150994948;
    pub const WAIT_EVENT_REGISTER_SYNC_REQUEST: Type = 150994949;
    pub const WAIT_EVENT_SPIN_DELAY: Type = 150994950;
    pub const WAIT_EVENT_VACUUM_DELAY: Type = 150994951;
    pub const WAIT_EVENT_VACUUM_TRUNCATE: Type = 150994952;
    pub const WAIT_EVENT_WAL_SUMMARIZER_ERROR: Type = 150994953;
}
pub mod PgStat_Kind {
    pub type Type = ::core::ffi::c_uint;
    pub const PGSTAT_KIND_INVALID: Type = 0;
    pub const PGSTAT_KIND_DATABASE: Type = 1;
    pub const PGSTAT_KIND_RELATION: Type = 2;
    pub const PGSTAT_KIND_FUNCTION: Type = 3;
    pub const PGSTAT_KIND_REPLSLOT: Type = 4;
    pub const PGSTAT_KIND_SUBSCRIPTION: Type = 5;
    pub const PGSTAT_KIND_ARCHIVER: Type = 6;
    pub const PGSTAT_KIND_BGWRITER: Type = 7;
    pub const PGSTAT_KIND_CHECKPOINTER: Type = 8;
    pub const PGSTAT_KIND_IO: Type = 9;
    pub const PGSTAT_KIND_SLRU: Type = 10;
    pub const PGSTAT_KIND_WAL: Type = 11;
}
pub mod TrackFunctionsLevel {
    pub type Type = ::core::ffi::c_uint;
    pub const TRACK_FUNC_OFF: Type = 0;
    pub const TRACK_FUNC_PL: Type = 1;
    pub const TRACK_FUNC_ALL: Type = 2;
}
pub mod PgStat_FetchConsistency {
    pub type Type = ::core::ffi::c_uint;
    pub const PGSTAT_FETCH_CONSISTENCY_NONE: Type = 0;
    pub const PGSTAT_FETCH_CONSISTENCY_CACHE: Type = 1;
    pub const PGSTAT_FETCH_CONSISTENCY_SNAPSHOT: Type = 2;
}
pub mod SessionEndType {
    pub type Type = ::core::ffi::c_uint;
    pub const DISCONNECT_NOT_YET: Type = 0;
    pub const DISCONNECT_NORMAL: Type = 1;
    pub const DISCONNECT_CLIENT_EOF: Type = 2;
    pub const DISCONNECT_FATAL: Type = 3;
    pub const DISCONNECT_KILLED: Type = 4;
}
pub type PgStat_Counter = int64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_FunctionCounts {
    pub numcalls: PgStat_Counter,
    pub total_time: instr_time,
    pub self_time: instr_time,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_FunctionCallUsage {
    pub fs: *mut PgStat_FunctionCounts,
    pub save_f_total_time: instr_time,
    pub save_total: instr_time,
    pub start: instr_time,
}
impl Default for PgStat_FunctionCallUsage {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_BackendSubEntry {
    pub apply_error_count: PgStat_Counter,
    pub sync_error_count: PgStat_Counter,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_TableCounts {
    pub numscans: PgStat_Counter,
    pub tuples_returned: PgStat_Counter,
    pub tuples_fetched: PgStat_Counter,
    pub tuples_inserted: PgStat_Counter,
    pub tuples_updated: PgStat_Counter,
    pub tuples_deleted: PgStat_Counter,
    pub tuples_hot_updated: PgStat_Counter,
    pub tuples_newpage_updated: PgStat_Counter,
    pub truncdropped: bool,
    pub delta_live_tuples: PgStat_Counter,
    pub delta_dead_tuples: PgStat_Counter,
    pub changed_tuples: PgStat_Counter,
    pub blocks_fetched: PgStat_Counter,
    pub blocks_hit: PgStat_Counter,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_TableStatus {
    pub id: Oid,
    pub shared: bool,
    pub trans: *mut PgStat_TableXactStatus,
    pub counts: PgStat_TableCounts,
    pub relation: Relation,
}
impl Default for PgStat_TableStatus {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_TableXactStatus {
    pub tuples_inserted: PgStat_Counter,
    pub tuples_updated: PgStat_Counter,
    pub tuples_deleted: PgStat_Counter,
    pub truncdropped: bool,
    pub inserted_pre_truncdrop: PgStat_Counter,
    pub updated_pre_truncdrop: PgStat_Counter,
    pub deleted_pre_truncdrop: PgStat_Counter,
    pub nest_level: ::core::ffi::c_int,
    pub upper: *mut PgStat_TableXactStatus,
    pub parent: *mut PgStat_TableStatus,
    pub next: *mut PgStat_TableXactStatus,
}
impl Default for PgStat_TableXactStatus {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_ArchiverStats {
    pub archived_count: PgStat_Counter,
    pub last_archived_wal: [::core::ffi::c_char; 41usize],
    pub last_archived_timestamp: TimestampTz,
    pub failed_count: PgStat_Counter,
    pub last_failed_wal: [::core::ffi::c_char; 41usize],
    pub last_failed_timestamp: TimestampTz,
    pub stat_reset_timestamp: TimestampTz,
}
impl Default for PgStat_ArchiverStats {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_BgWriterStats {
    pub buf_written_clean: PgStat_Counter,
    pub maxwritten_clean: PgStat_Counter,
    pub buf_alloc: PgStat_Counter,
    pub stat_reset_timestamp: TimestampTz,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_CheckpointerStats {
    pub num_timed: PgStat_Counter,
    pub num_requested: PgStat_Counter,
    pub restartpoints_timed: PgStat_Counter,
    pub restartpoints_requested: PgStat_Counter,
    pub restartpoints_performed: PgStat_Counter,
    pub write_time: PgStat_Counter,
    pub sync_time: PgStat_Counter,
    pub buffers_written: PgStat_Counter,
    pub stat_reset_timestamp: TimestampTz,
}
pub mod IOObject {
    pub type Type = ::core::ffi::c_uint;
    pub const IOOBJECT_RELATION: Type = 0;
    pub const IOOBJECT_TEMP_RELATION: Type = 1;
}
pub mod IOContext {
    pub type Type = ::core::ffi::c_uint;
    pub const IOCONTEXT_BULKREAD: Type = 0;
    pub const IOCONTEXT_BULKWRITE: Type = 1;
    pub const IOCONTEXT_NORMAL: Type = 2;
    pub const IOCONTEXT_VACUUM: Type = 3;
}
pub mod IOOp {
    pub type Type = ::core::ffi::c_uint;
    pub const IOOP_EVICT: Type = 0;
    pub const IOOP_EXTEND: Type = 1;
    pub const IOOP_FSYNC: Type = 2;
    pub const IOOP_HIT: Type = 3;
    pub const IOOP_READ: Type = 4;
    pub const IOOP_REUSE: Type = 5;
    pub const IOOP_WRITE: Type = 6;
    pub const IOOP_WRITEBACK: Type = 7;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_BktypeIO {
    pub counts: [[[PgStat_Counter; 8usize]; 4usize]; 2usize],
    pub times: [[[PgStat_Counter; 8usize]; 4usize]; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_IO {
    pub stat_reset_timestamp: TimestampTz,
    pub stats: [PgStat_BktypeIO; 16usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_StatDBEntry {
    pub xact_commit: PgStat_Counter,
    pub xact_rollback: PgStat_Counter,
    pub blocks_fetched: PgStat_Counter,
    pub blocks_hit: PgStat_Counter,
    pub tuples_returned: PgStat_Counter,
    pub tuples_fetched: PgStat_Counter,
    pub tuples_inserted: PgStat_Counter,
    pub tuples_updated: PgStat_Counter,
    pub tuples_deleted: PgStat_Counter,
    pub last_autovac_time: TimestampTz,
    pub conflict_tablespace: PgStat_Counter,
    pub conflict_lock: PgStat_Counter,
    pub conflict_snapshot: PgStat_Counter,
    pub conflict_logicalslot: PgStat_Counter,
    pub conflict_bufferpin: PgStat_Counter,
    pub conflict_startup_deadlock: PgStat_Counter,
    pub temp_files: PgStat_Counter,
    pub temp_bytes: PgStat_Counter,
    pub deadlocks: PgStat_Counter,
    pub checksum_failures: PgStat_Counter,
    pub last_checksum_failure: TimestampTz,
    pub blk_read_time: PgStat_Counter,
    pub blk_write_time: PgStat_Counter,
    pub sessions: PgStat_Counter,
    pub session_time: PgStat_Counter,
    pub active_time: PgStat_Counter,
    pub idle_in_transaction_time: PgStat_Counter,
    pub sessions_abandoned: PgStat_Counter,
    pub sessions_fatal: PgStat_Counter,
    pub sessions_killed: PgStat_Counter,
    pub stat_reset_timestamp: TimestampTz,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_StatFuncEntry {
    pub numcalls: PgStat_Counter,
    pub total_time: PgStat_Counter,
    pub self_time: PgStat_Counter,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_StatReplSlotEntry {
    pub spill_txns: PgStat_Counter,
    pub spill_count: PgStat_Counter,
    pub spill_bytes: PgStat_Counter,
    pub stream_txns: PgStat_Counter,
    pub stream_count: PgStat_Counter,
    pub stream_bytes: PgStat_Counter,
    pub total_txns: PgStat_Counter,
    pub total_bytes: PgStat_Counter,
    pub stat_reset_timestamp: TimestampTz,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_SLRUStats {
    pub blocks_zeroed: PgStat_Counter,
    pub blocks_hit: PgStat_Counter,
    pub blocks_read: PgStat_Counter,
    pub blocks_written: PgStat_Counter,
    pub blocks_exists: PgStat_Counter,
    pub flush: PgStat_Counter,
    pub truncate: PgStat_Counter,
    pub stat_reset_timestamp: TimestampTz,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_StatSubEntry {
    pub apply_error_count: PgStat_Counter,
    pub sync_error_count: PgStat_Counter,
    pub stat_reset_timestamp: TimestampTz,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_StatTabEntry {
    pub numscans: PgStat_Counter,
    pub lastscan: TimestampTz,
    pub tuples_returned: PgStat_Counter,
    pub tuples_fetched: PgStat_Counter,
    pub tuples_inserted: PgStat_Counter,
    pub tuples_updated: PgStat_Counter,
    pub tuples_deleted: PgStat_Counter,
    pub tuples_hot_updated: PgStat_Counter,
    pub tuples_newpage_updated: PgStat_Counter,
    pub live_tuples: PgStat_Counter,
    pub dead_tuples: PgStat_Counter,
    pub mod_since_analyze: PgStat_Counter,
    pub ins_since_vacuum: PgStat_Counter,
    pub blocks_fetched: PgStat_Counter,
    pub blocks_hit: PgStat_Counter,
    pub last_vacuum_time: TimestampTz,
    pub vacuum_count: PgStat_Counter,
    pub last_autovacuum_time: TimestampTz,
    pub autovacuum_count: PgStat_Counter,
    pub last_analyze_time: TimestampTz,
    pub analyze_count: PgStat_Counter,
    pub last_autoanalyze_time: TimestampTz,
    pub autoanalyze_count: PgStat_Counter,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_WalStats {
    pub wal_records: PgStat_Counter,
    pub wal_fpi: PgStat_Counter,
    pub wal_bytes: uint64,
    pub wal_buffers_full: PgStat_Counter,
    pub wal_write: PgStat_Counter,
    pub wal_sync: PgStat_Counter,
    pub wal_write_time: PgStat_Counter,
    pub wal_sync_time: PgStat_Counter,
    pub stat_reset_timestamp: TimestampTz,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_PendingWalStats {
    pub wal_buffers_full: PgStat_Counter,
    pub wal_write: PgStat_Counter,
    pub wal_sync: PgStat_Counter,
    pub wal_write_time: instr_time,
    pub wal_sync_time: instr_time,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BackupState {
    pub name: [::core::ffi::c_char; 1025usize],
    pub startpoint: XLogRecPtr,
    pub starttli: TimeLineID,
    pub checkpointloc: XLogRecPtr,
    pub starttime: pg_time_t,
    pub started_in_recovery: bool,
    pub istartpoint: XLogRecPtr,
    pub istarttli: TimeLineID,
    pub stoppoint: XLogRecPtr,
    pub stoptli: TimeLineID,
    pub stoptime: pg_time_t,
}
impl Default for BackupState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod WalSyncMethod {
    pub type Type = ::core::ffi::c_uint;
    pub const WAL_SYNC_METHOD_FSYNC: Type = 0;
    pub const WAL_SYNC_METHOD_FDATASYNC: Type = 1;
    pub const WAL_SYNC_METHOD_OPEN: Type = 2;
    pub const WAL_SYNC_METHOD_FSYNC_WRITETHROUGH: Type = 3;
    pub const WAL_SYNC_METHOD_OPEN_DSYNC: Type = 4;
}
pub mod ArchiveMode {
    pub type Type = ::core::ffi::c_uint;
    pub const ARCHIVE_MODE_OFF: Type = 0;
    pub const ARCHIVE_MODE_ON: Type = 1;
    pub const ARCHIVE_MODE_ALWAYS: Type = 2;
}
pub mod WalLevel {
    pub type Type = ::core::ffi::c_uint;
    pub const WAL_LEVEL_MINIMAL: Type = 0;
    pub const WAL_LEVEL_REPLICA: Type = 1;
    pub const WAL_LEVEL_LOGICAL: Type = 2;
}
pub mod WalCompression {
    pub type Type = ::core::ffi::c_uint;
    pub const WAL_COMPRESSION_NONE: Type = 0;
    pub const WAL_COMPRESSION_PGLZ: Type = 1;
    pub const WAL_COMPRESSION_LZ4: Type = 2;
    pub const WAL_COMPRESSION_ZSTD: Type = 3;
}
pub mod RecoveryState {
    pub type Type = ::core::ffi::c_uint;
    pub const RECOVERY_STATE_CRASH: Type = 0;
    pub const RECOVERY_STATE_ARCHIVE: Type = 1;
    pub const RECOVERY_STATE_DONE: Type = 2;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CheckpointStatsData {
    pub ckpt_start_t: TimestampTz,
    pub ckpt_write_t: TimestampTz,
    pub ckpt_sync_t: TimestampTz,
    pub ckpt_sync_end_t: TimestampTz,
    pub ckpt_end_t: TimestampTz,
    pub ckpt_bufs_written: ::core::ffi::c_int,
    pub ckpt_segs_added: ::core::ffi::c_int,
    pub ckpt_segs_removed: ::core::ffi::c_int,
    pub ckpt_segs_recycled: ::core::ffi::c_int,
    pub ckpt_sync_rels: ::core::ffi::c_int,
    pub ckpt_longest_sync: uint64,
    pub ckpt_agg_sync_time: uint64,
}
pub mod WALAvailability {
    pub type Type = ::core::ffi::c_uint;
    pub const WALAVAIL_INVALID_LSN: Type = 0;
    pub const WALAVAIL_RESERVED: Type = 1;
    pub const WALAVAIL_EXTENDED: Type = 2;
    pub const WALAVAIL_UNRESERVED: Type = 3;
    pub const WALAVAIL_REMOVED: Type = 4;
}
pub mod SessionBackupState {
    pub type Type = ::core::ffi::c_uint;
    pub const SESSION_BACKUP_NONE: Type = 0;
    pub const SESSION_BACKUP_RUNNING: Type = 1;
}
pub type RmgrId = uint8;
pub mod RmgrIds {
    pub type Type = ::core::ffi::c_uint;
    pub const RM_XLOG_ID: Type = 0;
    pub const RM_XACT_ID: Type = 1;
    pub const RM_SMGR_ID: Type = 2;
    pub const RM_CLOG_ID: Type = 3;
    pub const RM_DBASE_ID: Type = 4;
    pub const RM_TBLSPC_ID: Type = 5;
    pub const RM_MULTIXACT_ID: Type = 6;
    pub const RM_RELMAP_ID: Type = 7;
    pub const RM_STANDBY_ID: Type = 8;
    pub const RM_HEAP2_ID: Type = 9;
    pub const RM_HEAP_ID: Type = 10;
    pub const RM_BTREE_ID: Type = 11;
    pub const RM_HASH_ID: Type = 12;
    pub const RM_GIN_ID: Type = 13;
    pub const RM_GIST_ID: Type = 14;
    pub const RM_SEQ_ID: Type = 15;
    pub const RM_SPGIST_ID: Type = 16;
    pub const RM_BRIN_ID: Type = 17;
    pub const RM_COMMIT_TS_ID: Type = 18;
    pub const RM_REPLORIGIN_ID: Type = 19;
    pub const RM_GENERIC_ID: Type = 20;
    pub const RM_LOGICALMSG_ID: Type = 21;
    pub const RM_NEXT_ID: Type = 22;
}
pub type pg_crc32c = uint32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RelFileLocator {
    pub spcOid: Oid,
    pub dbOid: Oid,
    pub relNumber: RelFileNumber,
}
impl Default for RelFileLocator {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RelFileLocatorBackend {
    pub locator: RelFileLocator,
    pub backend: ProcNumber,
}
impl Default for RelFileLocatorBackend {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLogRecord {
    pub xl_tot_len: uint32,
    pub xl_xid: TransactionId,
    pub xl_prev: XLogRecPtr,
    pub xl_info: uint8,
    pub xl_rmid: RmgrId,
    pub xl_crc: pg_crc32c,
}
impl Default for XLogRecord {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct XLogRecordBlockHeader {
    pub id: uint8,
    pub fork_flags: uint8,
    pub data_length: uint16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct XLogRecordBlockImageHeader {
    pub length: uint16,
    pub hole_offset: uint16,
    pub bimg_info: uint8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct XLogRecordBlockCompressHeader {
    pub hole_length: uint16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct XLogRecordDataHeaderShort {
    pub id: uint8,
    pub data_length: uint8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct XLogRecordDataHeaderLong {
    pub id: uint8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WALOpenSegment {
    pub ws_file: ::core::ffi::c_int,
    pub ws_segno: XLogSegNo,
    pub ws_tli: TimeLineID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WALSegmentContext {
    pub ws_dir: [::core::ffi::c_char; 1024usize],
    pub ws_segsize: ::core::ffi::c_int,
}
impl Default for WALSegmentContext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type XLogPageReadCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        xlogreader: *mut XLogReaderState,
        targetPagePtr: XLogRecPtr,
        reqLen: ::core::ffi::c_int,
        targetRecPtr: XLogRecPtr,
        readBuf: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int,
>;
pub type WALSegmentOpenCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        xlogreader: *mut XLogReaderState,
        nextSegNo: XLogSegNo,
        tli_p: *mut TimeLineID,
    ),
>;
pub type WALSegmentCloseCB =
    ::core::option::Option<unsafe extern "C-unwind" fn(xlogreader: *mut XLogReaderState)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct XLogReaderRoutine {
    pub page_read: XLogPageReadCB,
    pub segment_open: WALSegmentOpenCB,
    pub segment_close: WALSegmentCloseCB,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DecodedBkpBlock {
    pub in_use: bool,
    pub rlocator: RelFileLocator,
    pub forknum: ForkNumber::Type,
    pub blkno: BlockNumber,
    pub prefetch_buffer: Buffer,
    pub flags: uint8,
    pub has_image: bool,
    pub apply_image: bool,
    pub bkp_image: *mut ::core::ffi::c_char,
    pub hole_offset: uint16,
    pub hole_length: uint16,
    pub bimg_len: uint16,
    pub bimg_info: uint8,
    pub has_data: bool,
    pub data: *mut ::core::ffi::c_char,
    pub data_len: uint16,
    pub data_bufsz: uint16,
}
impl Default for DecodedBkpBlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct DecodedXLogRecord {
    pub size: usize,
    pub oversized: bool,
    pub next: *mut DecodedXLogRecord,
    pub lsn: XLogRecPtr,
    pub next_lsn: XLogRecPtr,
    pub header: XLogRecord,
    pub record_origin: RepOriginId,
    pub toplevel_xid: TransactionId,
    pub main_data: *mut ::core::ffi::c_char,
    pub main_data_len: uint32,
    pub max_block_id: ::core::ffi::c_int,
    pub blocks: __IncompleteArrayField<DecodedBkpBlock>,
}
impl Default for DecodedXLogRecord {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLogReaderState {
    pub routine: XLogReaderRoutine,
    pub system_identifier: uint64,
    pub private_data: *mut ::core::ffi::c_void,
    pub ReadRecPtr: XLogRecPtr,
    pub EndRecPtr: XLogRecPtr,
    pub abortedRecPtr: XLogRecPtr,
    pub missingContrecPtr: XLogRecPtr,
    pub overwrittenRecPtr: XLogRecPtr,
    pub DecodeRecPtr: XLogRecPtr,
    pub NextRecPtr: XLogRecPtr,
    pub PrevRecPtr: XLogRecPtr,
    pub record: *mut DecodedXLogRecord,
    pub decode_buffer: *mut ::core::ffi::c_char,
    pub decode_buffer_size: usize,
    pub free_decode_buffer: bool,
    pub decode_buffer_head: *mut ::core::ffi::c_char,
    pub decode_buffer_tail: *mut ::core::ffi::c_char,
    pub decode_queue_head: *mut DecodedXLogRecord,
    pub decode_queue_tail: *mut DecodedXLogRecord,
    pub readBuf: *mut ::core::ffi::c_char,
    pub readLen: uint32,
    pub segcxt: WALSegmentContext,
    pub seg: WALOpenSegment,
    pub segoff: uint32,
    pub latestPagePtr: XLogRecPtr,
    pub latestPageTLI: TimeLineID,
    pub currRecPtr: XLogRecPtr,
    pub currTLI: TimeLineID,
    pub currTLIValidUntil: XLogRecPtr,
    pub nextTLI: TimeLineID,
    pub readRecordBuf: *mut ::core::ffi::c_char,
    pub readRecordBufSize: uint32,
    pub errormsg_buf: *mut ::core::ffi::c_char,
    pub errormsg_deferred: bool,
    pub nonblocking: bool,
}
impl Default for XLogReaderState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod XLogPageReadResult {
    pub type Type = ::core::ffi::c_int;
    pub const XLREAD_SUCCESS: Type = 0;
    pub const XLREAD_FAIL: Type = -1;
    pub const XLREAD_WOULDBLOCK: Type = -2;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WALReadError {
    pub wre_errno: ::core::ffi::c_int,
    pub wre_off: ::core::ffi::c_int,
    pub wre_req: ::core::ffi::c_int,
    pub wre_read: ::core::ffi::c_int,
    pub wre_seg: WALOpenSegment,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_class {
    pub oid: Oid,
    pub relname: NameData,
    pub relnamespace: Oid,
    pub reltype: Oid,
    pub reloftype: Oid,
    pub relowner: Oid,
    pub relam: Oid,
    pub relfilenode: Oid,
    pub reltablespace: Oid,
    pub relpages: int32,
    pub reltuples: float4,
    pub relallvisible: int32,
    pub reltoastrelid: Oid,
    pub relhasindex: bool,
    pub relisshared: bool,
    pub relpersistence: ::core::ffi::c_char,
    pub relkind: ::core::ffi::c_char,
    pub relnatts: int16,
    pub relchecks: int16,
    pub relhasrules: bool,
    pub relhastriggers: bool,
    pub relhassubclass: bool,
    pub relrowsecurity: bool,
    pub relforcerowsecurity: bool,
    pub relispopulated: bool,
    pub relreplident: ::core::ffi::c_char,
    pub relispartition: bool,
    pub relrewrite: Oid,
    pub relfrozenxid: TransactionId,
    pub relminmxid: TransactionId,
}
impl Default for FormData_pg_class {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_class = *mut FormData_pg_class;
#[repr(C)]
#[derive(Debug)]
pub struct FormData_pg_index {
    pub indexrelid: Oid,
    pub indrelid: Oid,
    pub indnatts: int16,
    pub indnkeyatts: int16,
    pub indisunique: bool,
    pub indnullsnotdistinct: bool,
    pub indisprimary: bool,
    pub indisexclusion: bool,
    pub indimmediate: bool,
    pub indisclustered: bool,
    pub indisvalid: bool,
    pub indcheckxmin: bool,
    pub indisready: bool,
    pub indislive: bool,
    pub indisreplident: bool,
    pub indkey: int2vector,
}
impl Default for FormData_pg_index {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_index = *mut FormData_pg_index;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjectAddress {
    pub classId: Oid,
    pub objectId: Oid,
    pub objectSubId: int32,
}
impl Default for ObjectAddress {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_publication {
    pub oid: Oid,
    pub pubname: NameData,
    pub pubowner: Oid,
    pub puballtables: bool,
    pub pubinsert: bool,
    pub pubupdate: bool,
    pub pubdelete: bool,
    pub pubtruncate: bool,
    pub pubviaroot: bool,
}
impl Default for FormData_pg_publication {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_publication = *mut FormData_pg_publication;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PublicationActions {
    pub pubinsert: bool,
    pub pubupdate: bool,
    pub pubdelete: bool,
    pub pubtruncate: bool,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PublicationDesc {
    pub pubactions: PublicationActions,
    pub rf_valid_for_update: bool,
    pub rf_valid_for_delete: bool,
    pub cols_valid_for_update: bool,
    pub cols_valid_for_delete: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Publication {
    pub oid: Oid,
    pub name: *mut ::core::ffi::c_char,
    pub alltables: bool,
    pub pubviaroot: bool,
    pub pubactions: PublicationActions,
}
impl Default for Publication {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PublicationRelInfo {
    pub relation: Relation,
    pub whereClause: *mut Node,
    pub columns: *mut List,
}
impl Default for PublicationRelInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod PublicationPartOpt {
    pub type Type = ::core::ffi::c_uint;
    pub const PUBLICATION_PART_ROOT: Type = 0;
    pub const PUBLICATION_PART_LEAF: Type = 1;
    pub const PUBLICATION_PART_ALL: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RewriteRule {
    pub ruleId: Oid,
    pub event: CmdType::Type,
    pub qual: *mut Node,
    pub actions: *mut List,
    pub enabled: ::core::ffi::c_char,
    pub isInstead: bool,
}
impl Default for RewriteRule {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RuleLock {
    pub numLocks: ::core::ffi::c_int,
    pub rules: *mut *mut RewriteRule,
}
impl Default for RuleLock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMgrRelationData {
    pub smgr_rlocator: RelFileLocatorBackend,
    pub smgr_targblock: BlockNumber,
    pub smgr_cached_nblocks: [BlockNumber; 4usize],
    pub smgr_which: ::core::ffi::c_int,
    pub md_num_open_segs: [::core::ffi::c_int; 4usize],
    pub md_seg_fds: [*mut _MdfdVec; 4usize],
    pub pincount: ::core::ffi::c_int,
    pub node: dlist_node,
}
impl Default for SMgrRelationData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SMgrRelation = *mut SMgrRelationData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LockRelId {
    pub relId: Oid,
    pub dbId: Oid,
}
impl Default for LockRelId {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LockInfoData {
    pub lockRelId: LockRelId,
}
impl Default for LockInfoData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type LockInfo = *mut LockInfoData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RelationData {
    pub rd_locator: RelFileLocator,
    pub rd_smgr: SMgrRelation,
    pub rd_refcnt: ::core::ffi::c_int,
    pub rd_backend: ProcNumber,
    pub rd_islocaltemp: bool,
    pub rd_isnailed: bool,
    pub rd_isvalid: bool,
    pub rd_indexvalid: bool,
    pub rd_statvalid: bool,
    pub rd_createSubid: SubTransactionId,
    pub rd_newRelfilelocatorSubid: SubTransactionId,
    pub rd_firstRelfilelocatorSubid: SubTransactionId,
    pub rd_droppedSubid: SubTransactionId,
    pub rd_rel: Form_pg_class,
    pub rd_att: TupleDesc,
    pub rd_id: Oid,
    pub rd_lockInfo: LockInfoData,
    pub rd_rules: *mut RuleLock,
    pub rd_rulescxt: MemoryContext,
    pub trigdesc: *mut TriggerDesc,
    pub rd_rsdesc: *mut RowSecurityDesc,
    pub rd_fkeylist: *mut List,
    pub rd_fkeyvalid: bool,
    pub rd_partkey: PartitionKey,
    pub rd_partkeycxt: MemoryContext,
    pub rd_partdesc: PartitionDesc,
    pub rd_pdcxt: MemoryContext,
    pub rd_partdesc_nodetached: PartitionDesc,
    pub rd_pddcxt: MemoryContext,
    pub rd_partdesc_nodetached_xmin: TransactionId,
    pub rd_partcheck: *mut List,
    pub rd_partcheckvalid: bool,
    pub rd_partcheckcxt: MemoryContext,
    pub rd_indexlist: *mut List,
    pub rd_pkindex: Oid,
    pub rd_ispkdeferrable: bool,
    pub rd_replidindex: Oid,
    pub rd_statlist: *mut List,
    pub rd_attrsvalid: bool,
    pub rd_keyattr: *mut Bitmapset,
    pub rd_pkattr: *mut Bitmapset,
    pub rd_idattr: *mut Bitmapset,
    pub rd_hotblockingattr: *mut Bitmapset,
    pub rd_summarizedattr: *mut Bitmapset,
    pub rd_pubdesc: *mut PublicationDesc,
    pub rd_options: *mut bytea,
    pub rd_amhandler: Oid,
    pub rd_tableam: *const TableAmRoutine,
    pub rd_index: Form_pg_index,
    pub rd_indextuple: *mut HeapTupleData,
    pub rd_indexcxt: MemoryContext,
    pub rd_indam: *mut IndexAmRoutine,
    pub rd_opfamily: *mut Oid,
    pub rd_opcintype: *mut Oid,
    pub rd_support: *mut RegProcedure,
    pub rd_supportinfo: *mut FmgrInfo,
    pub rd_indoption: *mut int16,
    pub rd_indexprs: *mut List,
    pub rd_indpred: *mut List,
    pub rd_exclops: *mut Oid,
    pub rd_exclprocs: *mut Oid,
    pub rd_exclstrats: *mut uint16,
    pub rd_indcollation: *mut Oid,
    pub rd_opcoptions: *mut *mut bytea,
    pub rd_amcache: *mut ::core::ffi::c_void,
    pub rd_fdwroutine: *mut FdwRoutine,
    pub rd_toastoid: Oid,
    pub pgstat_enabled: bool,
    pub pgstat_info: *mut PgStat_TableStatus,
}
impl Default for RelationData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForeignKeyCacheInfo {
    pub type_: NodeTag,
    pub conoid: Oid,
    pub conrelid: Oid,
    pub confrelid: Oid,
    pub nkeys: ::core::ffi::c_int,
    pub conkey: [AttrNumber; 32usize],
    pub confkey: [AttrNumber; 32usize],
    pub conpfeqop: [Oid; 32usize],
}
impl Default for ForeignKeyCacheInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AutoVacOpts {
    pub enabled: bool,
    pub vacuum_threshold: ::core::ffi::c_int,
    pub vacuum_ins_threshold: ::core::ffi::c_int,
    pub analyze_threshold: ::core::ffi::c_int,
    pub vacuum_cost_limit: ::core::ffi::c_int,
    pub freeze_min_age: ::core::ffi::c_int,
    pub freeze_max_age: ::core::ffi::c_int,
    pub freeze_table_age: ::core::ffi::c_int,
    pub multixact_freeze_min_age: ::core::ffi::c_int,
    pub multixact_freeze_max_age: ::core::ffi::c_int,
    pub multixact_freeze_table_age: ::core::ffi::c_int,
    pub log_min_duration: ::core::ffi::c_int,
    pub vacuum_cost_delay: float8,
    pub vacuum_scale_factor: float8,
    pub vacuum_ins_scale_factor: float8,
    pub analyze_scale_factor: float8,
}
pub mod StdRdOptIndexCleanup {
    pub type Type = ::core::ffi::c_uint;
    pub const STDRD_OPTION_VACUUM_INDEX_CLEANUP_AUTO: Type = 0;
    pub const STDRD_OPTION_VACUUM_INDEX_CLEANUP_OFF: Type = 1;
    pub const STDRD_OPTION_VACUUM_INDEX_CLEANUP_ON: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StdRdOptions {
    pub vl_len_: int32,
    pub fillfactor: ::core::ffi::c_int,
    pub toast_tuple_target: ::core::ffi::c_int,
    pub autovacuum: AutoVacOpts,
    pub user_catalog_table: bool,
    pub parallel_workers: ::core::ffi::c_int,
    pub vacuum_index_cleanup: StdRdOptIndexCleanup::Type,
    pub vacuum_truncate: bool,
}
impl Default for StdRdOptions {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod ViewOptCheckOption {
    pub type Type = ::core::ffi::c_uint;
    pub const VIEW_OPTION_CHECK_OPTION_NOT_SET: Type = 0;
    pub const VIEW_OPTION_CHECK_OPTION_LOCAL: Type = 1;
    pub const VIEW_OPTION_CHECK_OPTION_CASCADED: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ViewOptions {
    pub vl_len_: int32,
    pub security_barrier: bool,
    pub security_invoker: bool,
    pub check_option: ViewOptCheckOption::Type,
}
impl Default for ViewOptions {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GenericXLogState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GinStatsData {
    pub nPendingPages: BlockNumber,
    pub nTotalPages: BlockNumber,
    pub nEntryPages: BlockNumber,
    pub nDataPages: BlockNumber,
    pub nEntries: int64,
    pub ginVersion: int32,
}
pub type GinTernaryValue = ::core::ffi::c_char;
pub type GistNSN = XLogRecPtr;
pub type PageGistNSN = PageXLogRecPtr;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GISTPageOpaqueData {
    pub nsn: PageGistNSN,
    pub rightlink: BlockNumber,
    pub flags: uint16,
    pub gist_page_id: uint16,
}
pub type GISTPageOpaque = *mut GISTPageOpaqueData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GIST_SPLITVEC {
    pub spl_left: *mut OffsetNumber,
    pub spl_nleft: ::core::ffi::c_int,
    pub spl_ldatum: Datum,
    pub spl_ldatum_exists: bool,
    pub spl_right: *mut OffsetNumber,
    pub spl_nright: ::core::ffi::c_int,
    pub spl_rdatum: Datum,
    pub spl_rdatum_exists: bool,
}
impl Default for GIST_SPLITVEC {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GISTENTRY {
    pub key: Datum,
    pub rel: Relation,
    pub page: Page,
    pub offset: OffsetNumber,
    pub leafkey: bool,
}
impl Default for GISTENTRY {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GISTDeletedPageContents {
    pub deleteXid: FullTransactionId,
}
#[repr(C)]
#[derive(Debug)]
pub struct GistEntryVector {
    pub n: int32,
    pub vector: __IncompleteArrayField<GISTENTRY>,
}
impl Default for GistEntryVector {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TableScanDescData {
    pub rs_rd: Relation,
    pub rs_snapshot: *mut SnapshotData,
    pub rs_nkeys: ::core::ffi::c_int,
    pub rs_key: *mut ScanKeyData,
    pub rs_mintid: ItemPointerData,
    pub rs_maxtid: ItemPointerData,
    pub rs_flags: uint32,
    pub rs_parallel: *mut ParallelTableScanDescData,
}
impl Default for TableScanDescData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TableScanDesc = *mut TableScanDescData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParallelTableScanDescData {
    pub phs_relid: Oid,
    pub phs_syncscan: bool,
    pub phs_snapshot_any: bool,
    pub phs_snapshot_off: Size,
}
impl Default for ParallelTableScanDescData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ParallelTableScanDesc = *mut ParallelTableScanDescData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParallelBlockTableScanDescData {
    pub base: ParallelTableScanDescData,
    pub phs_nblocks: BlockNumber,
    pub phs_mutex: slock_t,
    pub phs_startblock: BlockNumber,
    pub phs_nallocated: pg_atomic_uint64,
}
impl Default for ParallelBlockTableScanDescData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ParallelBlockTableScanDesc = *mut ParallelBlockTableScanDescData;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ParallelBlockTableScanWorkerData {
    pub phsw_nallocated: uint64,
    pub phsw_chunk_remaining: uint32,
    pub phsw_chunk_size: uint32,
}
pub type ParallelBlockTableScanWorker = *mut ParallelBlockTableScanWorkerData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexFetchTableData {
    pub rel: Relation,
}
impl Default for IndexFetchTableData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexScanDescData {
    pub heapRelation: Relation,
    pub indexRelation: Relation,
    pub xs_snapshot: *mut SnapshotData,
    pub numberOfKeys: ::core::ffi::c_int,
    pub numberOfOrderBys: ::core::ffi::c_int,
    pub keyData: *mut ScanKeyData,
    pub orderByData: *mut ScanKeyData,
    pub xs_want_itup: bool,
    pub xs_temp_snap: bool,
    pub kill_prior_tuple: bool,
    pub ignore_killed_tuples: bool,
    pub xactStartedInRecovery: bool,
    pub opaque: *mut ::core::ffi::c_void,
    pub xs_itup: IndexTuple,
    pub xs_itupdesc: *mut TupleDescData,
    pub xs_hitup: HeapTuple,
    pub xs_hitupdesc: *mut TupleDescData,
    pub xs_heaptid: ItemPointerData,
    pub xs_heap_continue: bool,
    pub xs_heapfetch: *mut IndexFetchTableData,
    pub xs_recheck: bool,
    pub xs_orderbyvals: *mut Datum,
    pub xs_orderbynulls: *mut bool,
    pub xs_recheckorderby: bool,
    pub parallel_scan: *mut ParallelIndexScanDescData,
}
impl Default for IndexScanDescData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct ParallelIndexScanDescData {
    pub ps_relid: Oid,
    pub ps_indexid: Oid,
    pub ps_offset: Size,
    pub ps_snapshot_data: __IncompleteArrayField<::core::ffi::c_char>,
}
impl Default for ParallelIndexScanDescData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysScanDescData {
    pub heap_rel: Relation,
    pub irel: Relation,
    pub scan: *mut TableScanDescData,
    pub iscan: *mut IndexScanDescData,
    pub snapshot: *mut SnapshotData,
    pub slot: *mut TupleTableSlot,
}
impl Default for SysScanDescData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SharedInvalCatcacheMsg {
    pub id: int8,
    pub dbId: Oid,
    pub hashValue: uint32,
}
impl Default for SharedInvalCatcacheMsg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SharedInvalCatalogMsg {
    pub id: int8,
    pub dbId: Oid,
    pub catId: Oid,
}
impl Default for SharedInvalCatalogMsg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SharedInvalRelcacheMsg {
    pub id: int8,
    pub dbId: Oid,
    pub relId: Oid,
}
impl Default for SharedInvalRelcacheMsg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SharedInvalSmgrMsg {
    pub id: int8,
    pub backend_hi: int8,
    pub backend_lo: uint16,
    pub rlocator: RelFileLocator,
}
impl Default for SharedInvalSmgrMsg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SharedInvalRelmapMsg {
    pub id: int8,
    pub dbId: Oid,
}
impl Default for SharedInvalRelmapMsg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SharedInvalSnapshotMsg {
    pub id: int8,
    pub dbId: Oid,
    pub relId: Oid,
}
impl Default for SharedInvalSnapshotMsg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SharedInvalidationMessage {
    pub id: int8,
    pub cc: SharedInvalCatcacheMsg,
    pub cat: SharedInvalCatalogMsg,
    pub rc: SharedInvalRelcacheMsg,
    pub sm: SharedInvalSmgrMsg,
    pub rm: SharedInvalRelmapMsg,
    pub sn: SharedInvalSnapshotMsg,
}
impl Default for SharedInvalidationMessage {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod SyncCommitLevel {
    pub type Type = ::core::ffi::c_uint;
    pub const SYNCHRONOUS_COMMIT_OFF: Type = 0;
    pub const SYNCHRONOUS_COMMIT_LOCAL_FLUSH: Type = 1;
    pub const SYNCHRONOUS_COMMIT_REMOTE_WRITE: Type = 2;
    pub const SYNCHRONOUS_COMMIT_REMOTE_FLUSH: Type = 3;
    pub const SYNCHRONOUS_COMMIT_REMOTE_APPLY: Type = 4;
}
pub mod XactEvent {
    pub type Type = ::core::ffi::c_uint;
    pub const XACT_EVENT_COMMIT: Type = 0;
    pub const XACT_EVENT_PARALLEL_COMMIT: Type = 1;
    pub const XACT_EVENT_ABORT: Type = 2;
    pub const XACT_EVENT_PARALLEL_ABORT: Type = 3;
    pub const XACT_EVENT_PREPARE: Type = 4;
    pub const XACT_EVENT_PRE_COMMIT: Type = 5;
    pub const XACT_EVENT_PARALLEL_PRE_COMMIT: Type = 6;
    pub const XACT_EVENT_PRE_PREPARE: Type = 7;
}
pub type XactCallback = ::core::option::Option<
    unsafe extern "C-unwind" fn(event: XactEvent::Type, arg: *mut ::core::ffi::c_void),
>;
pub mod SubXactEvent {
    pub type Type = ::core::ffi::c_uint;
    pub const SUBXACT_EVENT_START_SUB: Type = 0;
    pub const SUBXACT_EVENT_COMMIT_SUB: Type = 1;
    pub const SUBXACT_EVENT_ABORT_SUB: Type = 2;
    pub const SUBXACT_EVENT_PRE_COMMIT_SUB: Type = 3;
}
pub type SubXactCallback = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        event: SubXactEvent::Type,
        mySubid: SubTransactionId,
        parentSubid: SubTransactionId,
        arg: *mut ::core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SavedTransactionCharacteristics {
    pub save_XactIsoLevel: ::core::ffi::c_int,
    pub save_XactReadOnly: bool,
    pub save_XactDeferrable: bool,
}
#[repr(C)]
#[derive(Debug)]
pub struct xl_xact_assignment {
    pub xtop: TransactionId,
    pub nsubxacts: ::core::ffi::c_int,
    pub xsub: __IncompleteArrayField<TransactionId>,
}
impl Default for xl_xact_assignment {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xl_xact_xinfo {
    pub xinfo: uint32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xl_xact_dbinfo {
    pub dbId: Oid,
    pub tsId: Oid,
}
impl Default for xl_xact_dbinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct xl_xact_subxacts {
    pub nsubxacts: ::core::ffi::c_int,
    pub subxacts: __IncompleteArrayField<TransactionId>,
}
impl Default for xl_xact_subxacts {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct xl_xact_relfilelocators {
    pub nrels: ::core::ffi::c_int,
    pub xlocators: __IncompleteArrayField<RelFileLocator>,
}
impl Default for xl_xact_relfilelocators {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xl_xact_stats_item {
    pub kind: ::core::ffi::c_int,
    pub dboid: Oid,
    pub objoid: Oid,
}
impl Default for xl_xact_stats_item {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct xl_xact_stats_items {
    pub nitems: ::core::ffi::c_int,
    pub items: __IncompleteArrayField<xl_xact_stats_item>,
}
impl Default for xl_xact_stats_items {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct xl_xact_invals {
    pub nmsgs: ::core::ffi::c_int,
    pub msgs: __IncompleteArrayField<SharedInvalidationMessage>,
}
impl Default for xl_xact_invals {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xl_xact_twophase {
    pub xid: TransactionId,
}
impl Default for xl_xact_twophase {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xl_xact_origin {
    pub origin_lsn: XLogRecPtr,
    pub origin_timestamp: TimestampTz,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xl_xact_commit {
    pub xact_time: TimestampTz,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xl_xact_abort {
    pub xact_time: TimestampTz,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xl_xact_prepare {
    pub magic: uint32,
    pub total_len: uint32,
    pub xid: TransactionId,
    pub database: Oid,
    pub prepared_at: TimestampTz,
    pub owner: Oid,
    pub nsubxacts: int32,
    pub ncommitrels: int32,
    pub nabortrels: int32,
    pub ncommitstats: int32,
    pub nabortstats: int32,
    pub ninvalmsgs: int32,
    pub initfileinval: bool,
    pub gidlen: uint16,
    pub origin_lsn: XLogRecPtr,
    pub origin_timestamp: TimestampTz,
}
impl Default for xl_xact_prepare {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xl_xact_parsed_commit {
    pub xact_time: TimestampTz,
    pub xinfo: uint32,
    pub dbId: Oid,
    pub tsId: Oid,
    pub nsubxacts: ::core::ffi::c_int,
    pub subxacts: *mut TransactionId,
    pub nrels: ::core::ffi::c_int,
    pub xlocators: *mut RelFileLocator,
    pub nstats: ::core::ffi::c_int,
    pub stats: *mut xl_xact_stats_item,
    pub nmsgs: ::core::ffi::c_int,
    pub msgs: *mut SharedInvalidationMessage,
    pub twophase_xid: TransactionId,
    pub twophase_gid: [::core::ffi::c_char; 200usize],
    pub nabortrels: ::core::ffi::c_int,
    pub abortlocators: *mut RelFileLocator,
    pub nabortstats: ::core::ffi::c_int,
    pub abortstats: *mut xl_xact_stats_item,
    pub origin_lsn: XLogRecPtr,
    pub origin_timestamp: TimestampTz,
}
impl Default for xl_xact_parsed_commit {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type xl_xact_parsed_prepare = xl_xact_parsed_commit;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xl_xact_parsed_abort {
    pub xact_time: TimestampTz,
    pub xinfo: uint32,
    pub dbId: Oid,
    pub tsId: Oid,
    pub nsubxacts: ::core::ffi::c_int,
    pub subxacts: *mut TransactionId,
    pub nrels: ::core::ffi::c_int,
    pub xlocators: *mut RelFileLocator,
    pub nstats: ::core::ffi::c_int,
    pub stats: *mut xl_xact_stats_item,
    pub twophase_xid: TransactionId,
    pub twophase_gid: [::core::ffi::c_char; 200usize],
    pub origin_lsn: XLogRecPtr,
    pub origin_timestamp: TimestampTz,
}
impl Default for xl_xact_parsed_abort {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResourceOwnerData {
    _unused: [u8; 0],
}
pub type ResourceOwner = *mut ResourceOwnerData;
pub mod ResourceReleasePhase {
    pub type Type = ::core::ffi::c_uint;
    pub const RESOURCE_RELEASE_BEFORE_LOCKS: Type = 1;
    pub const RESOURCE_RELEASE_LOCKS: Type = 2;
    pub const RESOURCE_RELEASE_AFTER_LOCKS: Type = 3;
}
pub type ResourceReleasePriority = uint32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResourceOwnerDesc {
    pub name: *const ::core::ffi::c_char,
    pub release_phase: ResourceReleasePhase::Type,
    pub release_priority: ResourceReleasePriority,
    pub ReleaseResource: ::core::option::Option<unsafe extern "C-unwind" fn(res: Datum)>,
    pub DebugPrint:
        ::core::option::Option<unsafe extern "C-unwind" fn(res: Datum) -> *mut ::core::ffi::c_char>,
}
impl Default for ResourceOwnerDesc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ResourceReleaseCallback = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        phase: ResourceReleasePhase::Type,
        isCommit: bool,
        isTopLevel: bool,
        arg: *mut ::core::ffi::c_void,
    ),
>;
pub type Block = *mut ::core::ffi::c_void;
pub mod BufferAccessStrategyType {
    pub type Type = ::core::ffi::c_uint;
    pub const BAS_NORMAL: Type = 0;
    pub const BAS_BULKREAD: Type = 1;
    pub const BAS_BULKWRITE: Type = 2;
    pub const BAS_VACUUM: Type = 3;
}
pub mod ReadBufferMode {
    pub type Type = ::core::ffi::c_uint;
    pub const RBM_NORMAL: Type = 0;
    pub const RBM_ZERO_AND_LOCK: Type = 1;
    pub const RBM_ZERO_AND_CLEANUP_LOCK: Type = 2;
    pub const RBM_ZERO_ON_ERROR: Type = 3;
    pub const RBM_NORMAL_NO_LOG: Type = 4;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PrefetchBufferResult {
    pub recent_buffer: Buffer,
    pub initiated_io: bool,
}
pub mod ExtendBufferedFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const EB_SKIP_EXTENSION_LOCK: Type = 1;
    pub const EB_PERFORMING_RECOVERY: Type = 2;
    pub const EB_CREATE_FORK_IF_NEEDED: Type = 4;
    pub const EB_LOCK_FIRST: Type = 8;
    pub const EB_CLEAR_SIZE_CACHE: Type = 16;
    pub const EB_LOCK_TARGET: Type = 32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BufferManagerRelation {
    pub rel: Relation,
    pub smgr: *mut SMgrRelationData,
    pub relpersistence: ::core::ffi::c_char,
}
impl Default for BufferManagerRelation {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReadBuffersOperation {
    pub rel: Relation,
    pub smgr: *mut SMgrRelationData,
    pub smgr_persistence: ::core::ffi::c_char,
    pub forknum: ForkNumber::Type,
    pub strategy: BufferAccessStrategy,
    pub buffers: *mut Buffer,
    pub blocknum: BlockNumber,
    pub flags: ::core::ffi::c_int,
    pub nblocks: int16,
    pub io_buffers_len: int16,
}
impl Default for ReadBuffersOperation {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReadStream {
    _unused: [u8; 0],
}
pub type ReadStreamBlockNumberCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        stream: *mut ReadStream,
        callback_private_data: *mut ::core::ffi::c_void,
        per_buffer_data: *mut ::core::ffi::c_void,
    ) -> BlockNumber,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BulkInsertStateData {
    _unused: [u8; 0],
}
pub mod ScanOptions {
    pub type Type = ::core::ffi::c_uint;
    pub const SO_TYPE_SEQSCAN: Type = 1;
    pub const SO_TYPE_BITMAPSCAN: Type = 2;
    pub const SO_TYPE_SAMPLESCAN: Type = 4;
    pub const SO_TYPE_TIDSCAN: Type = 8;
    pub const SO_TYPE_TIDRANGESCAN: Type = 16;
    pub const SO_TYPE_ANALYZE: Type = 32;
    pub const SO_ALLOW_STRAT: Type = 64;
    pub const SO_ALLOW_SYNC: Type = 128;
    pub const SO_ALLOW_PAGEMODE: Type = 256;
    pub const SO_TEMP_SNAPSHOT: Type = 512;
    pub const SO_NEED_TUPLES: Type = 1024;
}
pub mod TM_Result {
    pub type Type = ::core::ffi::c_uint;
    pub const TM_Ok: Type = 0;
    pub const TM_Invisible: Type = 1;
    pub const TM_SelfModified: Type = 2;
    pub const TM_Updated: Type = 3;
    pub const TM_Deleted: Type = 4;
    pub const TM_BeingModified: Type = 5;
    pub const TM_WouldBlock: Type = 6;
}
pub mod TU_UpdateIndexes {
    pub type Type = ::core::ffi::c_uint;
    pub const TU_None: Type = 0;
    pub const TU_All: Type = 1;
    pub const TU_Summarizing: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TM_FailureData {
    pub ctid: ItemPointerData,
    pub xmax: TransactionId,
    pub cmax: CommandId,
    pub traversed: bool,
}
impl Default for TM_FailureData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TM_IndexDelete {
    pub tid: ItemPointerData,
    pub id: int16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TM_IndexStatus {
    pub idxoffnum: OffsetNumber,
    pub knowndeletable: bool,
    pub promising: bool,
    pub freespace: int16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TM_IndexDeleteOp {
    pub irel: Relation,
    pub iblknum: BlockNumber,
    pub bottomup: bool,
    pub bottomupfreespace: ::core::ffi::c_int,
    pub ndeltids: ::core::ffi::c_int,
    pub deltids: *mut TM_IndexDelete,
    pub status: *mut TM_IndexStatus,
}
impl Default for TM_IndexDeleteOp {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type IndexBuildCallback = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        index: Relation,
        tid: ItemPointer,
        values: *mut Datum,
        isnull: *mut bool,
        tupleIsAlive: bool,
        state: *mut ::core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TableAmRoutine {
    pub type_: NodeTag,
    pub slot_callbacks: ::core::option::Option<
        unsafe extern "C-unwind" fn(rel: Relation) -> *const TupleTableSlotOps,
    >,
    pub scan_begin: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            rel: Relation,
            snapshot: Snapshot,
            nkeys: ::core::ffi::c_int,
            key: *mut ScanKeyData,
            pscan: ParallelTableScanDesc,
            flags: uint32,
        ) -> TableScanDesc,
    >,
    pub scan_end: ::core::option::Option<unsafe extern "C-unwind" fn(scan: TableScanDesc)>,
    pub scan_rescan: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            scan: TableScanDesc,
            key: *mut ScanKeyData,
            set_params: bool,
            allow_strat: bool,
            allow_sync: bool,
            allow_pagemode: bool,
        ),
    >,
    pub scan_getnextslot: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            scan: TableScanDesc,
            direction: ScanDirection::Type,
            slot: *mut TupleTableSlot,
        ) -> bool,
    >,
    pub scan_set_tidrange: ::core::option::Option<
        unsafe extern "C-unwind" fn(scan: TableScanDesc, mintid: ItemPointer, maxtid: ItemPointer),
    >,
    pub scan_getnextslot_tidrange: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            scan: TableScanDesc,
            direction: ScanDirection::Type,
            slot: *mut TupleTableSlot,
        ) -> bool,
    >,
    pub parallelscan_estimate:
        ::core::option::Option<unsafe extern "C-unwind" fn(rel: Relation) -> Size>,
    pub parallelscan_initialize: ::core::option::Option<
        unsafe extern "C-unwind" fn(rel: Relation, pscan: ParallelTableScanDesc) -> Size,
    >,
    pub parallelscan_reinitialize: ::core::option::Option<
        unsafe extern "C-unwind" fn(rel: Relation, pscan: ParallelTableScanDesc),
    >,
    pub index_fetch_begin: ::core::option::Option<
        unsafe extern "C-unwind" fn(rel: Relation) -> *mut IndexFetchTableData,
    >,
    pub index_fetch_reset:
        ::core::option::Option<unsafe extern "C-unwind" fn(data: *mut IndexFetchTableData)>,
    pub index_fetch_end:
        ::core::option::Option<unsafe extern "C-unwind" fn(data: *mut IndexFetchTableData)>,
    pub index_fetch_tuple: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            scan: *mut IndexFetchTableData,
            tid: ItemPointer,
            snapshot: Snapshot,
            slot: *mut TupleTableSlot,
            call_again: *mut bool,
            all_dead: *mut bool,
        ) -> bool,
    >,
    pub tuple_fetch_row_version: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            rel: Relation,
            tid: ItemPointer,
            snapshot: Snapshot,
            slot: *mut TupleTableSlot,
        ) -> bool,
    >,
    pub tuple_tid_valid: ::core::option::Option<
        unsafe extern "C-unwind" fn(scan: TableScanDesc, tid: ItemPointer) -> bool,
    >,
    pub tuple_get_latest_tid:
        ::core::option::Option<unsafe extern "C-unwind" fn(scan: TableScanDesc, tid: ItemPointer)>,
    pub tuple_satisfies_snapshot: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            rel: Relation,
            slot: *mut TupleTableSlot,
            snapshot: Snapshot,
        ) -> bool,
    >,
    pub index_delete_tuples: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            rel: Relation,
            delstate: *mut TM_IndexDeleteOp,
        ) -> TransactionId,
    >,
    pub tuple_insert: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            rel: Relation,
            slot: *mut TupleTableSlot,
            cid: CommandId,
            options: ::core::ffi::c_int,
            bistate: *mut BulkInsertStateData,
        ),
    >,
    pub tuple_insert_speculative: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            rel: Relation,
            slot: *mut TupleTableSlot,
            cid: CommandId,
            options: ::core::ffi::c_int,
            bistate: *mut BulkInsertStateData,
            specToken: uint32,
        ),
    >,
    pub tuple_complete_speculative: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            rel: Relation,
            slot: *mut TupleTableSlot,
            specToken: uint32,
            succeeded: bool,
        ),
    >,
    pub multi_insert: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            rel: Relation,
            slots: *mut *mut TupleTableSlot,
            nslots: ::core::ffi::c_int,
            cid: CommandId,
            options: ::core::ffi::c_int,
            bistate: *mut BulkInsertStateData,
        ),
    >,
    pub tuple_delete: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            rel: Relation,
            tid: ItemPointer,
            cid: CommandId,
            snapshot: Snapshot,
            crosscheck: Snapshot,
            wait: bool,
            tmfd: *mut TM_FailureData,
            changingPart: bool,
        ) -> TM_Result::Type,
    >,
    pub tuple_update: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            rel: Relation,
            otid: ItemPointer,
            slot: *mut TupleTableSlot,
            cid: CommandId,
            snapshot: Snapshot,
            crosscheck: Snapshot,
            wait: bool,
            tmfd: *mut TM_FailureData,
            lockmode: *mut LockTupleMode::Type,
            update_indexes: *mut TU_UpdateIndexes::Type,
        ) -> TM_Result::Type,
    >,
    pub tuple_lock: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            rel: Relation,
            tid: ItemPointer,
            snapshot: Snapshot,
            slot: *mut TupleTableSlot,
            cid: CommandId,
            mode: LockTupleMode::Type,
            wait_policy: LockWaitPolicy::Type,
            flags: uint8,
            tmfd: *mut TM_FailureData,
        ) -> TM_Result::Type,
    >,
    pub finish_bulk_insert: ::core::option::Option<
        unsafe extern "C-unwind" fn(rel: Relation, options: ::core::ffi::c_int),
    >,
    pub relation_set_new_filelocator: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            rel: Relation,
            newrlocator: *const RelFileLocator,
            persistence: ::core::ffi::c_char,
            freezeXid: *mut TransactionId,
            minmulti: *mut MultiXactId,
        ),
    >,
    pub relation_nontransactional_truncate:
        ::core::option::Option<unsafe extern "C-unwind" fn(rel: Relation)>,
    pub relation_copy_data: ::core::option::Option<
        unsafe extern "C-unwind" fn(rel: Relation, newrlocator: *const RelFileLocator),
    >,
    pub relation_copy_for_cluster: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            OldTable: Relation,
            NewTable: Relation,
            OldIndex: Relation,
            use_sort: bool,
            OldestXmin: TransactionId,
            xid_cutoff: *mut TransactionId,
            multi_cutoff: *mut MultiXactId,
            num_tuples: *mut f64,
            tups_vacuumed: *mut f64,
            tups_recently_dead: *mut f64,
        ),
    >,
    pub relation_vacuum: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            rel: Relation,
            params: *mut VacuumParams,
            bstrategy: BufferAccessStrategy,
        ),
    >,
    pub scan_analyze_next_block: ::core::option::Option<
        unsafe extern "C-unwind" fn(scan: TableScanDesc, stream: *mut ReadStream) -> bool,
    >,
    pub scan_analyze_next_tuple: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            scan: TableScanDesc,
            OldestXmin: TransactionId,
            liverows: *mut f64,
            deadrows: *mut f64,
            slot: *mut TupleTableSlot,
        ) -> bool,
    >,
    pub index_build_range_scan: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            table_rel: Relation,
            index_rel: Relation,
            index_info: *mut IndexInfo,
            allow_sync: bool,
            anyvisible: bool,
            progress: bool,
            start_blockno: BlockNumber,
            numblocks: BlockNumber,
            callback: IndexBuildCallback,
            callback_state: *mut ::core::ffi::c_void,
            scan: TableScanDesc,
        ) -> f64,
    >,
    pub index_validate_scan: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            table_rel: Relation,
            index_rel: Relation,
            index_info: *mut IndexInfo,
            snapshot: Snapshot,
            state: *mut ValidateIndexState,
        ),
    >,
    pub relation_size: ::core::option::Option<
        unsafe extern "C-unwind" fn(rel: Relation, forkNumber: ForkNumber::Type) -> uint64,
    >,
    pub relation_needs_toast_table:
        ::core::option::Option<unsafe extern "C-unwind" fn(rel: Relation) -> bool>,
    pub relation_toast_am:
        ::core::option::Option<unsafe extern "C-unwind" fn(rel: Relation) -> Oid>,
    pub relation_fetch_toast_slice: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            toastrel: Relation,
            valueid: Oid,
            attrsize: int32,
            sliceoffset: int32,
            slicelength: int32,
            result: *mut varlena,
        ),
    >,
    pub relation_estimate_size: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            rel: Relation,
            attr_widths: *mut int32,
            pages: *mut BlockNumber,
            tuples: *mut f64,
            allvisfrac: *mut f64,
        ),
    >,
    pub scan_bitmap_next_block: ::core::option::Option<
        unsafe extern "C-unwind" fn(scan: TableScanDesc, tbmres: *mut TBMIterateResult) -> bool,
    >,
    pub scan_bitmap_next_tuple: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            scan: TableScanDesc,
            tbmres: *mut TBMIterateResult,
            slot: *mut TupleTableSlot,
        ) -> bool,
    >,
    pub scan_sample_next_block: ::core::option::Option<
        unsafe extern "C-unwind" fn(scan: TableScanDesc, scanstate: *mut SampleScanState) -> bool,
    >,
    pub scan_sample_next_tuple: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            scan: TableScanDesc,
            scanstate: *mut SampleScanState,
            slot: *mut TupleTableSlot,
        ) -> bool,
    >,
}
impl Default for TableAmRoutine {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ShmemIndexEnt {
    pub key: [::core::ffi::c_char; 48usize],
    pub location: *mut ::core::ffi::c_void,
    pub size: Size,
    pub allocated_size: Size,
}
impl Default for ShmemIndexEnt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shm_toc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct shm_toc_estimator {
    pub space_for_chunks: Size,
    pub number_of_keys: Size,
}
pub type BulkInsertState = *mut BulkInsertStateData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeapScanDescData {
    pub rs_base: TableScanDescData,
    pub rs_nblocks: BlockNumber,
    pub rs_startblock: BlockNumber,
    pub rs_numblocks: BlockNumber,
    pub rs_inited: bool,
    pub rs_coffset: OffsetNumber,
    pub rs_cblock: BlockNumber,
    pub rs_cbuf: Buffer,
    pub rs_strategy: BufferAccessStrategy,
    pub rs_ctup: HeapTupleData,
    pub rs_read_stream: *mut ReadStream,
    pub rs_dir: ScanDirection::Type,
    pub rs_prefetch_block: BlockNumber,
    pub rs_parallelworkerdata: *mut ParallelBlockTableScanWorkerData,
    pub rs_vmbuffer: Buffer,
    pub rs_empty_tuples_pending: ::core::ffi::c_int,
    pub rs_cindex: ::core::ffi::c_int,
    pub rs_ntuples: ::core::ffi::c_int,
    pub rs_vistuples: [OffsetNumber; 291usize],
}
impl Default for HeapScanDescData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type HeapScanDesc = *mut HeapScanDescData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexFetchHeapData {
    pub xs_base: IndexFetchTableData,
    pub xs_cbuf: Buffer,
}
impl Default for IndexFetchHeapData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod HTSV_Result {
    pub type Type = ::core::ffi::c_uint;
    pub const HEAPTUPLE_DEAD: Type = 0;
    pub const HEAPTUPLE_LIVE: Type = 1;
    pub const HEAPTUPLE_RECENTLY_DEAD: Type = 2;
    pub const HEAPTUPLE_INSERT_IN_PROGRESS: Type = 3;
    pub const HEAPTUPLE_DELETE_IN_PROGRESS: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeapTupleFreeze {
    pub xmax: TransactionId,
    pub t_infomask2: uint16,
    pub t_infomask: uint16,
    pub frzflags: uint8,
    pub checkflags: uint8,
    pub offset: OffsetNumber,
}
impl Default for HeapTupleFreeze {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct HeapPageFreeze {
    pub freeze_required: bool,
    pub FreezePageRelfrozenXid: TransactionId,
    pub FreezePageRelminMxid: MultiXactId,
    pub NoFreezePageRelfrozenXid: TransactionId,
    pub NoFreezePageRelminMxid: MultiXactId,
}
impl Default for HeapPageFreeze {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PruneFreezeResult {
    pub ndeleted: ::core::ffi::c_int,
    pub nnewlpdead: ::core::ffi::c_int,
    pub nfrozen: ::core::ffi::c_int,
    pub live_tuples: ::core::ffi::c_int,
    pub recently_dead_tuples: ::core::ffi::c_int,
    pub all_visible: bool,
    pub all_frozen: bool,
    pub vm_conflict_horizon: TransactionId,
    pub hastup: bool,
    pub lpdead_items: ::core::ffi::c_int,
    pub deadoffsets: [OffsetNumber; 291usize],
}
impl Default for PruneFreezeResult {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod PruneReason {
    pub type Type = ::core::ffi::c_uint;
    pub const PRUNE_ON_ACCESS: Type = 0;
    pub const PRUNE_VACUUM_SCAN: Type = 1;
    pub const PRUNE_VACUUM_CLEANUP: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GlobalVisState {
    _unused: [u8; 0],
}
pub mod SyncRequestType {
    pub type Type = ::core::ffi::c_uint;
    pub const SYNC_REQUEST: Type = 0;
    pub const SYNC_UNLINK_REQUEST: Type = 1;
    pub const SYNC_FORGET_REQUEST: Type = 2;
    pub const SYNC_FILTER_REQUEST: Type = 3;
}
pub mod SyncRequestHandler {
    pub type Type = ::core::ffi::c_uint;
    pub const SYNC_HANDLER_MD: Type = 0;
    pub const SYNC_HANDLER_CLOG: Type = 1;
    pub const SYNC_HANDLER_COMMIT_TS: Type = 2;
    pub const SYNC_HANDLER_MULTIXACT_OFFSET: Type = 3;
    pub const SYNC_HANDLER_MULTIXACT_MEMBER: Type = 4;
    pub const SYNC_HANDLER_NONE: Type = 5;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FileTag {
    pub handler: int16,
    pub forknum: int16,
    pub rlocator: RelFileLocator,
    pub segno: uint64,
}
impl Default for FileTag {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod MultiXactStatus {
    pub type Type = ::core::ffi::c_uint;
    pub const MultiXactStatusForKeyShare: Type = 0;
    pub const MultiXactStatusForShare: Type = 1;
    pub const MultiXactStatusForNoKeyUpdate: Type = 2;
    pub const MultiXactStatusForUpdate: Type = 3;
    pub const MultiXactStatusNoKeyUpdate: Type = 4;
    pub const MultiXactStatusUpdate: Type = 5;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MultiXactMember {
    pub xid: TransactionId,
    pub status: MultiXactStatus::Type,
}
impl Default for MultiXactMember {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct xl_multixact_create {
    pub mid: MultiXactId,
    pub moff: MultiXactOffset,
    pub nmembers: int32,
    pub members: __IncompleteArrayField<MultiXactMember>,
}
impl Default for xl_multixact_create {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct xl_multixact_truncate {
    pub oldestMultiDB: Oid,
    pub startTruncOff: MultiXactId,
    pub endTruncOff: MultiXactId,
    pub startTruncMemb: MultiXactOffset,
    pub endTruncMemb: MultiXactOffset,
}
impl Default for xl_multixact_truncate {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod LWLockWaitState {
    pub type Type = ::core::ffi::c_uint;
    pub const LW_WS_NOT_WAITING: Type = 0;
    pub const LW_WS_WAITING: Type = 1;
    pub const LW_WS_PENDING_WAKEUP: Type = 2;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LWLock {
    pub tranche: uint16,
    pub state: pg_atomic_uint32,
    pub waiters: proclist_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LWLockPadded {
    pub lock: LWLock,
    pub pad: [::core::ffi::c_char; 128usize],
}
impl Default for LWLockPadded {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NamedLWLockTranche {
    pub trancheId: ::core::ffi::c_int,
    pub trancheName: *mut ::core::ffi::c_char,
}
impl Default for NamedLWLockTranche {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod LWLockMode {
    pub type Type = ::core::ffi::c_uint;
    pub const LW_EXCLUSIVE: Type = 0;
    pub const LW_SHARED: Type = 1;
    pub const LW_WAIT_UNTIL_FREE: Type = 2;
}
pub mod BuiltinTrancheIds {
    pub type Type = ::core::ffi::c_uint;
    pub const LWTRANCHE_XACT_BUFFER: Type = 53;
    pub const LWTRANCHE_COMMITTS_BUFFER: Type = 54;
    pub const LWTRANCHE_SUBTRANS_BUFFER: Type = 55;
    pub const LWTRANCHE_MULTIXACTOFFSET_BUFFER: Type = 56;
    pub const LWTRANCHE_MULTIXACTMEMBER_BUFFER: Type = 57;
    pub const LWTRANCHE_NOTIFY_BUFFER: Type = 58;
    pub const LWTRANCHE_SERIAL_BUFFER: Type = 59;
    pub const LWTRANCHE_WAL_INSERT: Type = 60;
    pub const LWTRANCHE_BUFFER_CONTENT: Type = 61;
    pub const LWTRANCHE_REPLICATION_ORIGIN_STATE: Type = 62;
    pub const LWTRANCHE_REPLICATION_SLOT_IO: Type = 63;
    pub const LWTRANCHE_LOCK_FASTPATH: Type = 64;
    pub const LWTRANCHE_BUFFER_MAPPING: Type = 65;
    pub const LWTRANCHE_LOCK_MANAGER: Type = 66;
    pub const LWTRANCHE_PREDICATE_LOCK_MANAGER: Type = 67;
    pub const LWTRANCHE_PARALLEL_HASH_JOIN: Type = 68;
    pub const LWTRANCHE_PARALLEL_QUERY_DSA: Type = 69;
    pub const LWTRANCHE_PER_SESSION_DSA: Type = 70;
    pub const LWTRANCHE_PER_SESSION_RECORD_TYPE: Type = 71;
    pub const LWTRANCHE_PER_SESSION_RECORD_TYPMOD: Type = 72;
    pub const LWTRANCHE_SHARED_TUPLESTORE: Type = 73;
    pub const LWTRANCHE_SHARED_TIDBITMAP: Type = 74;
    pub const LWTRANCHE_PARALLEL_APPEND: Type = 75;
    pub const LWTRANCHE_PER_XACT_PREDICATE_LIST: Type = 76;
    pub const LWTRANCHE_PGSTATS_DSA: Type = 77;
    pub const LWTRANCHE_PGSTATS_HASH: Type = 78;
    pub const LWTRANCHE_PGSTATS_DATA: Type = 79;
    pub const LWTRANCHE_LAUNCHER_DSA: Type = 80;
    pub const LWTRANCHE_LAUNCHER_HASH: Type = 81;
    pub const LWTRANCHE_DSM_REGISTRY_DSA: Type = 82;
    pub const LWTRANCHE_DSM_REGISTRY_HASH: Type = 83;
    pub const LWTRANCHE_COMMITTS_SLRU: Type = 84;
    pub const LWTRANCHE_MULTIXACTMEMBER_SLRU: Type = 85;
    pub const LWTRANCHE_MULTIXACTOFFSET_SLRU: Type = 86;
    pub const LWTRANCHE_NOTIFY_SLRU: Type = 87;
    pub const LWTRANCHE_SERIAL_SLRU: Type = 88;
    pub const LWTRANCHE_SUBTRANS_SLRU: Type = 89;
    pub const LWTRANCHE_XACT_SLRU: Type = 90;
    pub const LWTRANCHE_PARALLEL_VACUUM_DSA: Type = 91;
    pub const LWTRANCHE_FIRST_USER_DEFINED: Type = 92;
}
pub type LWLockId = *mut LWLock;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VirtualTransactionId {
    pub procNumber: ProcNumber,
    pub localTransactionId: LocalTransactionId,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LockMethodData {
    pub numLockModes: ::core::ffi::c_int,
    pub conflictTab: *const LOCKMASK,
    pub lockModeNames: *const *const ::core::ffi::c_char,
    pub trace_flag: *const bool,
}
impl Default for LockMethodData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type LockMethod = *const LockMethodData;
pub type LOCKMETHODID = uint16;
pub mod LockTagType {
    pub type Type = ::core::ffi::c_uint;
    pub const LOCKTAG_RELATION: Type = 0;
    pub const LOCKTAG_RELATION_EXTEND: Type = 1;
    pub const LOCKTAG_DATABASE_FROZEN_IDS: Type = 2;
    pub const LOCKTAG_PAGE: Type = 3;
    pub const LOCKTAG_TUPLE: Type = 4;
    pub const LOCKTAG_TRANSACTION: Type = 5;
    pub const LOCKTAG_VIRTUALTRANSACTION: Type = 6;
    pub const LOCKTAG_SPECULATIVE_TOKEN: Type = 7;
    pub const LOCKTAG_OBJECT: Type = 8;
    pub const LOCKTAG_USERLOCK: Type = 9;
    pub const LOCKTAG_ADVISORY: Type = 10;
    pub const LOCKTAG_APPLY_TRANSACTION: Type = 11;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LOCKTAG {
    pub locktag_field1: uint32,
    pub locktag_field2: uint32,
    pub locktag_field3: uint32,
    pub locktag_field4: uint16,
    pub locktag_type: uint8,
    pub locktag_lockmethodid: uint8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LOCK {
    pub tag: LOCKTAG,
    pub grantMask: LOCKMASK,
    pub waitMask: LOCKMASK,
    pub procLocks: dlist_head,
    pub waitProcs: dclist_head,
    pub requested: [::core::ffi::c_int; 10usize],
    pub nRequested: ::core::ffi::c_int,
    pub granted: [::core::ffi::c_int; 10usize],
    pub nGranted: ::core::ffi::c_int,
}
impl Default for LOCK {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PROCLOCKTAG {
    pub myLock: *mut LOCK,
    pub myProc: *mut PGPROC,
}
impl Default for PROCLOCKTAG {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PROCLOCK {
    pub tag: PROCLOCKTAG,
    pub groupLeader: *mut PGPROC,
    pub holdMask: LOCKMASK,
    pub releaseMask: LOCKMASK,
    pub lockLink: dlist_node,
    pub procLink: dlist_node,
}
impl Default for PROCLOCK {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LOCALLOCKTAG {
    pub lock: LOCKTAG,
    pub mode: LOCKMODE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LOCALLOCKOWNER {
    pub owner: *mut ResourceOwnerData,
    pub nLocks: int64,
}
impl Default for LOCALLOCKOWNER {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LOCALLOCK {
    pub tag: LOCALLOCKTAG,
    pub hashcode: uint32,
    pub lock: *mut LOCK,
    pub proclock: *mut PROCLOCK,
    pub nLocks: int64,
    pub numLockOwners: ::core::ffi::c_int,
    pub maxLockOwners: ::core::ffi::c_int,
    pub lockOwners: *mut LOCALLOCKOWNER,
    pub holdsStrongLockCount: bool,
    pub lockCleared: bool,
}
impl Default for LOCALLOCK {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LockInstanceData {
    pub locktag: LOCKTAG,
    pub holdMask: LOCKMASK,
    pub waitLockMode: LOCKMODE,
    pub vxid: VirtualTransactionId,
    pub waitStart: TimestampTz,
    pub pid: ::core::ffi::c_int,
    pub leaderPid: ::core::ffi::c_int,
    pub fastpath: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LockData {
    pub nelements: ::core::ffi::c_int,
    pub locks: *mut LockInstanceData,
}
impl Default for LockData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BlockedProcData {
    pub pid: ::core::ffi::c_int,
    pub first_lock: ::core::ffi::c_int,
    pub num_locks: ::core::ffi::c_int,
    pub first_waiter: ::core::ffi::c_int,
    pub num_waiters: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BlockedProcsData {
    pub procs: *mut BlockedProcData,
    pub locks: *mut LockInstanceData,
    pub waiter_pids: *mut ::core::ffi::c_int,
    pub nprocs: ::core::ffi::c_int,
    pub maxprocs: ::core::ffi::c_int,
    pub nlocks: ::core::ffi::c_int,
    pub maxlocks: ::core::ffi::c_int,
    pub npids: ::core::ffi::c_int,
    pub maxpids: ::core::ffi::c_int,
}
impl Default for BlockedProcsData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod LockAcquireResult {
    pub type Type = ::core::ffi::c_uint;
    pub const LOCKACQUIRE_NOT_AVAIL: Type = 0;
    pub const LOCKACQUIRE_OK: Type = 1;
    pub const LOCKACQUIRE_ALREADY_HELD: Type = 2;
    pub const LOCKACQUIRE_ALREADY_CLEAR: Type = 3;
}
pub mod DeadLockState {
    pub type Type = ::core::ffi::c_uint;
    pub const DS_NOT_YET_CHECKED: Type = 0;
    pub const DS_NO_DEADLOCK: Type = 1;
    pub const DS_SOFT_DEADLOCK: Type = 2;
    pub const DS_HARD_DEADLOCK: Type = 3;
    pub const DS_BLOCKED_BY_AUTOVACUUM: Type = 4;
}
pub mod relopt_type {
    pub type Type = ::core::ffi::c_uint;
    pub const RELOPT_TYPE_BOOL: Type = 0;
    pub const RELOPT_TYPE_INT: Type = 1;
    pub const RELOPT_TYPE_REAL: Type = 2;
    pub const RELOPT_TYPE_ENUM: Type = 3;
    pub const RELOPT_TYPE_STRING: Type = 4;
}
pub mod relopt_kind {
    pub type Type = ::core::ffi::c_uint;
    pub const RELOPT_KIND_LOCAL: Type = 0;
    pub const RELOPT_KIND_HEAP: Type = 1;
    pub const RELOPT_KIND_TOAST: Type = 2;
    pub const RELOPT_KIND_BTREE: Type = 4;
    pub const RELOPT_KIND_HASH: Type = 8;
    pub const RELOPT_KIND_GIN: Type = 16;
    pub const RELOPT_KIND_GIST: Type = 32;
    pub const RELOPT_KIND_ATTRIBUTE: Type = 64;
    pub const RELOPT_KIND_TABLESPACE: Type = 128;
    pub const RELOPT_KIND_SPGIST: Type = 256;
    pub const RELOPT_KIND_VIEW: Type = 512;
    pub const RELOPT_KIND_BRIN: Type = 1024;
    pub const RELOPT_KIND_PARTITIONED: Type = 2048;
    pub const RELOPT_KIND_LAST_DEFAULT: Type = 2048;
    pub const RELOPT_KIND_MAX: Type = 1073741824;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct relopt_gen {
    pub name: *const ::core::ffi::c_char,
    pub desc: *const ::core::ffi::c_char,
    pub kinds: bits32,
    pub lockmode: LOCKMODE,
    pub namelen: ::core::ffi::c_int,
    pub type_: relopt_type::Type,
}
impl Default for relopt_gen {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct relopt_value {
    pub gen: *mut relopt_gen,
    pub isset: bool,
    pub values: relopt_value__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union relopt_value__bindgen_ty_1 {
    pub bool_val: bool,
    pub int_val: ::core::ffi::c_int,
    pub real_val: f64,
    pub enum_val: ::core::ffi::c_int,
    pub string_val: *mut ::core::ffi::c_char,
}
impl Default for relopt_value__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for relopt_value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct relopt_bool {
    pub gen: relopt_gen,
    pub default_val: bool,
}
impl Default for relopt_bool {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct relopt_int {
    pub gen: relopt_gen,
    pub default_val: ::core::ffi::c_int,
    pub min: ::core::ffi::c_int,
    pub max: ::core::ffi::c_int,
}
impl Default for relopt_int {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct relopt_real {
    pub gen: relopt_gen,
    pub default_val: f64,
    pub min: f64,
    pub max: f64,
}
impl Default for relopt_real {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct relopt_enum_elt_def {
    pub string_val: *const ::core::ffi::c_char,
    pub symbol_val: ::core::ffi::c_int,
}
impl Default for relopt_enum_elt_def {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct relopt_enum {
    pub gen: relopt_gen,
    pub members: *mut relopt_enum_elt_def,
    pub default_val: ::core::ffi::c_int,
    pub detailmsg: *const ::core::ffi::c_char,
}
impl Default for relopt_enum {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type validate_string_relopt =
    ::core::option::Option<unsafe extern "C-unwind" fn(value: *const ::core::ffi::c_char)>;
pub type fill_string_relopt = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        value: *const ::core::ffi::c_char,
        ptr: *mut ::core::ffi::c_void,
    ) -> Size,
>;
pub type relopts_validator = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        parsed_options: *mut ::core::ffi::c_void,
        vals: *mut relopt_value,
        nvals: ::core::ffi::c_int,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct relopt_string {
    pub gen: relopt_gen,
    pub default_len: ::core::ffi::c_int,
    pub default_isnull: bool,
    pub validate_cb: validate_string_relopt,
    pub fill_cb: fill_string_relopt,
    pub default_val: *mut ::core::ffi::c_char,
}
impl Default for relopt_string {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct relopt_parse_elt {
    pub optname: *const ::core::ffi::c_char,
    pub opttype: relopt_type::Type,
    pub offset: ::core::ffi::c_int,
}
impl Default for relopt_parse_elt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_relopt {
    pub option: *mut relopt_gen,
    pub offset: ::core::ffi::c_int,
}
impl Default for local_relopt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_relopts {
    pub options: *mut List,
    pub validators: *mut List,
    pub relopt_struct_size: Size,
}
impl Default for local_relopts {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct XLogPageHeaderData {
    pub xlp_magic: uint16,
    pub xlp_info: uint16,
    pub xlp_tli: TimeLineID,
    pub xlp_pageaddr: XLogRecPtr,
    pub xlp_rem_len: uint32,
}
pub type XLogPageHeader = *mut XLogPageHeaderData;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct XLogLongPageHeaderData {
    pub std: XLogPageHeaderData,
    pub xlp_sysid: uint64,
    pub xlp_seg_size: uint32,
    pub xlp_xlog_blcksz: uint32,
}
pub type XLogLongPageHeader = *mut XLogLongPageHeaderData;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xl_parameter_change {
    pub MaxConnections: ::core::ffi::c_int,
    pub max_worker_processes: ::core::ffi::c_int,
    pub max_wal_senders: ::core::ffi::c_int,
    pub max_prepared_xacts: ::core::ffi::c_int,
    pub max_locks_per_xact: ::core::ffi::c_int,
    pub wal_level: ::core::ffi::c_int,
    pub wal_log_hints: bool,
    pub track_commit_timestamp: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xl_restore_point {
    pub rp_time: TimestampTz,
    pub rp_name: [::core::ffi::c_char; 64usize],
}
impl Default for xl_restore_point {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xl_overwrite_contrecord {
    pub overwritten_lsn: XLogRecPtr,
    pub overwrite_time: TimestampTz,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xl_end_of_recovery {
    pub end_time: TimestampTz,
    pub ThisTimeLineID: TimeLineID,
    pub PrevTimeLineID: TimeLineID,
    pub wal_level: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLogRecData {
    pub next: *mut XLogRecData,
    pub data: *mut ::core::ffi::c_char,
    pub len: uint32,
}
impl Default for XLogRecData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod RecoveryTargetAction {
    pub type Type = ::core::ffi::c_uint;
    pub const RECOVERY_TARGET_ACTION_PAUSE: Type = 0;
    pub const RECOVERY_TARGET_ACTION_PROMOTE: Type = 1;
    pub const RECOVERY_TARGET_ACTION_SHUTDOWN: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLogRecordBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RmgrData {
    pub rm_name: *const ::core::ffi::c_char,
    pub rm_redo: ::core::option::Option<unsafe extern "C-unwind" fn(record: *mut XLogReaderState)>,
    pub rm_desc: ::core::option::Option<
        unsafe extern "C-unwind" fn(buf: StringInfo, record: *mut XLogReaderState),
    >,
    pub rm_identify: ::core::option::Option<
        unsafe extern "C-unwind" fn(info: uint8) -> *const ::core::ffi::c_char,
    >,
    pub rm_startup: ::core::option::Option<unsafe extern "C-unwind" fn()>,
    pub rm_cleanup: ::core::option::Option<unsafe extern "C-unwind" fn()>,
    pub rm_mask: ::core::option::Option<
        unsafe extern "C-unwind" fn(pagedata: *mut ::core::ffi::c_char, blkno: BlockNumber),
    >,
    pub rm_decode: ::core::option::Option<
        unsafe extern "C-unwind" fn(ctx: *mut LogicalDecodingContext, buf: *mut XLogRecordBuffer),
    >,
}
impl Default for RmgrData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct CheckPoint {
    pub redo: XLogRecPtr,
    pub ThisTimeLineID: TimeLineID,
    pub PrevTimeLineID: TimeLineID,
    pub fullPageWrites: bool,
    pub wal_level: ::core::ffi::c_int,
    pub nextXid: FullTransactionId,
    pub nextOid: Oid,
    pub nextMulti: MultiXactId,
    pub nextMultiOffset: MultiXactOffset,
    pub oldestXid: TransactionId,
    pub oldestXidDB: Oid,
    pub oldestMulti: MultiXactId,
    pub oldestMultiDB: Oid,
    pub time: pg_time_t,
    pub oldestCommitTsXid: TransactionId,
    pub newestCommitTsXid: TransactionId,
    pub oldestActiveXid: TransactionId,
}
impl Default for CheckPoint {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod DBState {
    pub type Type = ::core::ffi::c_uint;
    pub const DB_STARTUP: Type = 0;
    pub const DB_SHUTDOWNED: Type = 1;
    pub const DB_SHUTDOWNED_IN_RECOVERY: Type = 2;
    pub const DB_SHUTDOWNING: Type = 3;
    pub const DB_IN_CRASH_RECOVERY: Type = 4;
    pub const DB_IN_ARCHIVE_RECOVERY: Type = 5;
    pub const DB_IN_PRODUCTION: Type = 6;
}
#[repr(C)]
pub struct ControlFileData {
    pub system_identifier: uint64,
    pub pg_control_version: uint32,
    pub catalog_version_no: uint32,
    pub state: DBState::Type,
    pub time: pg_time_t,
    pub checkPoint: XLogRecPtr,
    pub checkPointCopy: CheckPoint,
    pub unloggedLSN: XLogRecPtr,
    pub minRecoveryPoint: XLogRecPtr,
    pub minRecoveryPointTLI: TimeLineID,
    pub backupStartPoint: XLogRecPtr,
    pub backupEndPoint: XLogRecPtr,
    pub backupEndRequired: bool,
    pub wal_level: ::core::ffi::c_int,
    pub wal_log_hints: bool,
    pub MaxConnections: ::core::ffi::c_int,
    pub max_worker_processes: ::core::ffi::c_int,
    pub max_wal_senders: ::core::ffi::c_int,
    pub max_prepared_xacts: ::core::ffi::c_int,
    pub max_locks_per_xact: ::core::ffi::c_int,
    pub track_commit_timestamp: bool,
    pub maxAlign: uint32,
    pub floatFormat: f64,
    pub blcksz: uint32,
    pub relseg_size: uint32,
    pub xlog_blcksz: uint32,
    pub xlog_seg_size: uint32,
    pub nameDataLen: uint32,
    pub indexMaxKeys: uint32,
    pub toast_max_chunk_size: uint32,
    pub loblksize: uint32,
    pub float8ByVal: bool,
    pub data_checksum_version: uint32,
    pub mock_authentication_nonce: [::core::ffi::c_char; 32usize],
    pub crc: pg_crc32c,
}
impl Default for ControlFileData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod RecoveryTargetType {
    pub type Type = ::core::ffi::c_uint;
    pub const RECOVERY_TARGET_UNSET: Type = 0;
    pub const RECOVERY_TARGET_XID: Type = 1;
    pub const RECOVERY_TARGET_TIME: Type = 2;
    pub const RECOVERY_TARGET_NAME: Type = 3;
    pub const RECOVERY_TARGET_LSN: Type = 4;
    pub const RECOVERY_TARGET_IMMEDIATE: Type = 5;
}
pub mod RecoveryTargetTimeLineGoal {
    pub type Type = ::core::ffi::c_uint;
    pub const RECOVERY_TARGET_TIMELINE_CONTROLFILE: Type = 0;
    pub const RECOVERY_TARGET_TIMELINE_LATEST: Type = 1;
    pub const RECOVERY_TARGET_TIMELINE_NUMERIC: Type = 2;
}
pub mod RecoveryPauseState {
    pub type Type = ::core::ffi::c_uint;
    pub const RECOVERY_NOT_PAUSED: Type = 0;
    pub const RECOVERY_PAUSE_REQUESTED: Type = 1;
    pub const RECOVERY_PAUSED: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EndOfWalRecoveryInfo {
    pub lastRec: XLogRecPtr,
    pub lastRecTLI: TimeLineID,
    pub endOfLog: XLogRecPtr,
    pub endOfLogTLI: TimeLineID,
    pub lastPageBeginPtr: XLogRecPtr,
    pub lastPage: *mut ::core::ffi::c_char,
    pub abortedRecPtr: XLogRecPtr,
    pub missingContrecPtr: XLogRecPtr,
    pub recoveryStopReason: *mut ::core::ffi::c_char,
    pub standby_signal_file_found: bool,
    pub recovery_signal_file_found: bool,
}
impl Default for EndOfWalRecoveryInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod HotStandbyState {
    pub type Type = ::core::ffi::c_uint;
    pub const STANDBY_DISABLED: Type = 0;
    pub const STANDBY_INITIALIZED: Type = 1;
    pub const STANDBY_SNAPSHOT_PENDING: Type = 2;
    pub const STANDBY_SNAPSHOT_READY: Type = 3;
}
pub mod XLogRedoAction {
    pub type Type = ::core::ffi::c_uint;
    pub const BLK_NEEDS_REDO: Type = 0;
    pub const BLK_DONE: Type = 1;
    pub const BLK_RESTORED: Type = 2;
    pub const BLK_NOTFOUND: Type = 3;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ReadLocalXLogPageNoWaitPrivate {
    pub end_of_wal: bool,
}
pub mod DependencyType {
    pub type Type = ::core::ffi::c_uint;
    pub const DEPENDENCY_NORMAL: Type = 110;
    pub const DEPENDENCY_AUTO: Type = 97;
    pub const DEPENDENCY_INTERNAL: Type = 105;
    pub const DEPENDENCY_PARTITION_PRI: Type = 80;
    pub const DEPENDENCY_PARTITION_SEC: Type = 83;
    pub const DEPENDENCY_EXTENSION: Type = 101;
    pub const DEPENDENCY_AUTO_EXTENSION: Type = 120;
}
pub mod SharedDependencyType {
    pub type Type = ::core::ffi::c_uint;
    pub const SHARED_DEPENDENCY_OWNER: Type = 111;
    pub const SHARED_DEPENDENCY_ACL: Type = 97;
    pub const SHARED_DEPENDENCY_INITACL: Type = 105;
    pub const SHARED_DEPENDENCY_POLICY: Type = 114;
    pub const SHARED_DEPENDENCY_TABLESPACE: Type = 116;
    pub const SHARED_DEPENDENCY_INVALID: Type = 0;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjectAddresses {
    _unused: [u8; 0],
}
pub mod IndexStateFlagsAction {
    pub type Type = ::core::ffi::c_uint;
    pub const INDEX_CREATE_SET_READY: Type = 0;
    pub const INDEX_CREATE_SET_VALID: Type = 1;
    pub const INDEX_DROP_CLEAR_VALID: Type = 2;
    pub const INDEX_DROP_SET_DEAD: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReindexParams {
    pub options: bits32,
    pub tablespaceOid: Oid,
}
impl Default for ReindexParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ValidateIndexState {
    pub tuplesort: *mut Tuplesortstate,
    pub htups: f64,
    pub itups: f64,
    pub tups_inserted: f64,
}
impl Default for ValidateIndexState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CatalogIndexState = *mut ResultRelInfo;
#[repr(C)]
#[derive(Debug)]
pub struct _FuncCandidateList {
    pub next: *mut _FuncCandidateList,
    pub pathpos: ::core::ffi::c_int,
    pub oid: Oid,
    pub nominalnargs: ::core::ffi::c_int,
    pub nargs: ::core::ffi::c_int,
    pub nvargs: ::core::ffi::c_int,
    pub ndargs: ::core::ffi::c_int,
    pub argnumbers: *mut ::core::ffi::c_int,
    pub args: __IncompleteArrayField<Oid>,
}
impl Default for _FuncCandidateList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FuncCandidateList = *mut _FuncCandidateList;
pub mod TempNamespaceStatus {
    pub type Type = ::core::ffi::c_uint;
    pub const TEMP_NAMESPACE_NOT_TEMP: Type = 0;
    pub const TEMP_NAMESPACE_IDLE: Type = 1;
    pub const TEMP_NAMESPACE_IN_USE: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SearchPathMatcher {
    pub schemas: *mut List,
    pub addCatalog: bool,
    pub addTemp: bool,
    pub generation: uint64,
}
impl Default for SearchPathMatcher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod RVROption {
    pub type Type = ::core::ffi::c_uint;
    pub const RVR_MISSING_OK: Type = 1;
    pub const RVR_NOWAIT: Type = 2;
    pub const RVR_SKIP_LOCKED: Type = 4;
}
pub type RangeVarGetRelidCallback = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        relation: *const RangeVar,
        relId: Oid,
        oldRelId: Oid,
        callback_arg: *mut ::core::ffi::c_void,
    ),
>;
pub mod ObjectAccessType {
    pub type Type = ::core::ffi::c_uint;
    pub const OAT_POST_CREATE: Type = 0;
    pub const OAT_DROP: Type = 1;
    pub const OAT_POST_ALTER: Type = 2;
    pub const OAT_NAMESPACE_SEARCH: Type = 3;
    pub const OAT_FUNCTION_EXECUTE: Type = 4;
    pub const OAT_TRUNCATE: Type = 5;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ObjectAccessPostCreate {
    pub is_internal: bool,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ObjectAccessDrop {
    pub dropflags: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjectAccessPostAlter {
    pub auxiliary_id: Oid,
    pub is_internal: bool,
}
impl Default for ObjectAccessPostAlter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ObjectAccessNamespaceSearch {
    pub ereport_on_violation: bool,
    pub result: bool,
}
pub type object_access_hook_type = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        access: ObjectAccessType::Type,
        classId: Oid,
        objectId: Oid,
        subId: ::core::ffi::c_int,
        arg: *mut ::core::ffi::c_void,
    ),
>;
pub type object_access_hook_type_str = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        access: ObjectAccessType::Type,
        classId: Oid,
        objectStr: *const ::core::ffi::c_char,
        subId: ::core::ffi::c_int,
        arg: *mut ::core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_am {
    pub oid: Oid,
    pub amname: NameData,
    pub amhandler: regproc,
    pub amtype: ::core::ffi::c_char,
}
impl Default for FormData_pg_am {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_am = *mut FormData_pg_am;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_amop {
    pub oid: Oid,
    pub amopfamily: Oid,
    pub amoplefttype: Oid,
    pub amoprighttype: Oid,
    pub amopstrategy: int16,
    pub amoppurpose: ::core::ffi::c_char,
    pub amopopr: Oid,
    pub amopmethod: Oid,
    pub amopsortfamily: Oid,
}
impl Default for FormData_pg_amop {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_amop = *mut FormData_pg_amop;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_amproc {
    pub oid: Oid,
    pub amprocfamily: Oid,
    pub amproclefttype: Oid,
    pub amprocrighttype: Oid,
    pub amprocnum: int16,
    pub amproc: regproc,
}
impl Default for FormData_pg_amproc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_amproc = *mut FormData_pg_amproc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_authid {
    pub oid: Oid,
    pub rolname: NameData,
    pub rolsuper: bool,
    pub rolinherit: bool,
    pub rolcreaterole: bool,
    pub rolcreatedb: bool,
    pub rolcanlogin: bool,
    pub rolreplication: bool,
    pub rolbypassrls: bool,
    pub rolconnlimit: int32,
}
impl Default for FormData_pg_authid {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_authid = *mut FormData_pg_authid;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_collation {
    pub oid: Oid,
    pub collname: NameData,
    pub collnamespace: Oid,
    pub collowner: Oid,
    pub collprovider: ::core::ffi::c_char,
    pub collisdeterministic: bool,
    pub collencoding: int32,
}
impl Default for FormData_pg_collation {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_collation = *mut FormData_pg_collation;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_database {
    pub oid: Oid,
    pub datname: NameData,
    pub datdba: Oid,
    pub encoding: int32,
    pub datlocprovider: ::core::ffi::c_char,
    pub datistemplate: bool,
    pub datallowconn: bool,
    pub dathasloginevt: bool,
    pub datconnlimit: int32,
    pub datfrozenxid: TransactionId,
    pub datminmxid: TransactionId,
    pub dattablespace: Oid,
}
impl Default for FormData_pg_database {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_database = *mut FormData_pg_database;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_enum {
    pub oid: Oid,
    pub enumtypid: Oid,
    pub enumsortorder: float4,
    pub enumlabel: NameData,
}
impl Default for FormData_pg_enum {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_enum = *mut FormData_pg_enum;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_extension {
    pub oid: Oid,
    pub extname: NameData,
    pub extowner: Oid,
    pub extnamespace: Oid,
    pub extrelocatable: bool,
}
impl Default for FormData_pg_extension {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_extension = *mut FormData_pg_extension;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_foreign_data_wrapper {
    pub oid: Oid,
    pub fdwname: NameData,
    pub fdwowner: Oid,
    pub fdwhandler: Oid,
    pub fdwvalidator: Oid,
}
impl Default for FormData_pg_foreign_data_wrapper {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_foreign_data_wrapper = *mut FormData_pg_foreign_data_wrapper;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_foreign_server {
    pub oid: Oid,
    pub srvname: NameData,
    pub srvowner: Oid,
    pub srvfdw: Oid,
}
impl Default for FormData_pg_foreign_server {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_foreign_server = *mut FormData_pg_foreign_server;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_foreign_table {
    pub ftrelid: Oid,
    pub ftserver: Oid,
}
impl Default for FormData_pg_foreign_table {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_foreign_table = *mut FormData_pg_foreign_table;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_operator {
    pub oid: Oid,
    pub oprname: NameData,
    pub oprnamespace: Oid,
    pub oprowner: Oid,
    pub oprkind: ::core::ffi::c_char,
    pub oprcanmerge: bool,
    pub oprcanhash: bool,
    pub oprleft: Oid,
    pub oprright: Oid,
    pub oprresult: Oid,
    pub oprcom: Oid,
    pub oprnegate: Oid,
    pub oprcode: regproc,
    pub oprrest: regproc,
    pub oprjoin: regproc,
}
impl Default for FormData_pg_operator {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_operator = *mut FormData_pg_operator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_opclass {
    pub oid: Oid,
    pub opcmethod: Oid,
    pub opcname: NameData,
    pub opcnamespace: Oid,
    pub opcowner: Oid,
    pub opcfamily: Oid,
    pub opcintype: Oid,
    pub opcdefault: bool,
    pub opckeytype: Oid,
}
impl Default for FormData_pg_opclass {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_opclass = *mut FormData_pg_opclass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_opfamily {
    pub oid: Oid,
    pub opfmethod: Oid,
    pub opfname: NameData,
    pub opfnamespace: Oid,
    pub opfowner: Oid,
}
impl Default for FormData_pg_opfamily {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_opfamily = *mut FormData_pg_opfamily;
#[repr(C)]
#[derive(Debug)]
pub struct FormData_pg_proc {
    pub oid: Oid,
    pub proname: NameData,
    pub pronamespace: Oid,
    pub proowner: Oid,
    pub prolang: Oid,
    pub procost: float4,
    pub prorows: float4,
    pub provariadic: Oid,
    pub prosupport: regproc,
    pub prokind: ::core::ffi::c_char,
    pub prosecdef: bool,
    pub proleakproof: bool,
    pub proisstrict: bool,
    pub proretset: bool,
    pub provolatile: ::core::ffi::c_char,
    pub proparallel: ::core::ffi::c_char,
    pub pronargs: int16,
    pub pronargdefaults: int16,
    pub prorettype: Oid,
    pub proargtypes: oidvector,
}
impl Default for FormData_pg_proc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_proc = *mut FormData_pg_proc;
pub mod ParseExprKind {
    pub type Type = ::core::ffi::c_uint;
    pub const EXPR_KIND_NONE: Type = 0;
    pub const EXPR_KIND_OTHER: Type = 1;
    pub const EXPR_KIND_JOIN_ON: Type = 2;
    pub const EXPR_KIND_JOIN_USING: Type = 3;
    pub const EXPR_KIND_FROM_SUBSELECT: Type = 4;
    pub const EXPR_KIND_FROM_FUNCTION: Type = 5;
    pub const EXPR_KIND_WHERE: Type = 6;
    pub const EXPR_KIND_HAVING: Type = 7;
    pub const EXPR_KIND_FILTER: Type = 8;
    pub const EXPR_KIND_WINDOW_PARTITION: Type = 9;
    pub const EXPR_KIND_WINDOW_ORDER: Type = 10;
    pub const EXPR_KIND_WINDOW_FRAME_RANGE: Type = 11;
    pub const EXPR_KIND_WINDOW_FRAME_ROWS: Type = 12;
    pub const EXPR_KIND_WINDOW_FRAME_GROUPS: Type = 13;
    pub const EXPR_KIND_SELECT_TARGET: Type = 14;
    pub const EXPR_KIND_INSERT_TARGET: Type = 15;
    pub const EXPR_KIND_UPDATE_SOURCE: Type = 16;
    pub const EXPR_KIND_UPDATE_TARGET: Type = 17;
    pub const EXPR_KIND_MERGE_WHEN: Type = 18;
    pub const EXPR_KIND_GROUP_BY: Type = 19;
    pub const EXPR_KIND_ORDER_BY: Type = 20;
    pub const EXPR_KIND_DISTINCT_ON: Type = 21;
    pub const EXPR_KIND_LIMIT: Type = 22;
    pub const EXPR_KIND_OFFSET: Type = 23;
    pub const EXPR_KIND_RETURNING: Type = 24;
    pub const EXPR_KIND_MERGE_RETURNING: Type = 25;
    pub const EXPR_KIND_VALUES: Type = 26;
    pub const EXPR_KIND_VALUES_SINGLE: Type = 27;
    pub const EXPR_KIND_CHECK_CONSTRAINT: Type = 28;
    pub const EXPR_KIND_DOMAIN_CHECK: Type = 29;
    pub const EXPR_KIND_COLUMN_DEFAULT: Type = 30;
    pub const EXPR_KIND_FUNCTION_DEFAULT: Type = 31;
    pub const EXPR_KIND_INDEX_EXPRESSION: Type = 32;
    pub const EXPR_KIND_INDEX_PREDICATE: Type = 33;
    pub const EXPR_KIND_STATS_EXPRESSION: Type = 34;
    pub const EXPR_KIND_ALTER_COL_TRANSFORM: Type = 35;
    pub const EXPR_KIND_EXECUTE_PARAMETER: Type = 36;
    pub const EXPR_KIND_TRIGGER_WHEN: Type = 37;
    pub const EXPR_KIND_POLICY: Type = 38;
    pub const EXPR_KIND_PARTITION_BOUND: Type = 39;
    pub const EXPR_KIND_PARTITION_EXPRESSION: Type = 40;
    pub const EXPR_KIND_CALL_ARGUMENT: Type = 41;
    pub const EXPR_KIND_COPY_WHERE: Type = 42;
    pub const EXPR_KIND_GENERATED_COLUMN: Type = 43;
    pub const EXPR_KIND_CYCLE_MARK: Type = 44;
}
pub type PreParseColumnRefHook = ::core::option::Option<
    unsafe extern "C-unwind" fn(pstate: *mut ParseState, cref: *mut ColumnRef) -> *mut Node,
>;
pub type PostParseColumnRefHook = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        pstate: *mut ParseState,
        cref: *mut ColumnRef,
        var: *mut Node,
    ) -> *mut Node,
>;
pub type ParseParamRefHook = ::core::option::Option<
    unsafe extern "C-unwind" fn(pstate: *mut ParseState, pref: *mut ParamRef) -> *mut Node,
>;
pub type CoerceParamHook = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        pstate: *mut ParseState,
        param: *mut Param,
        targetTypeId: Oid,
        targetTypeMod: int32,
        location: ::core::ffi::c_int,
    ) -> *mut Node,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParseState {
    pub parentParseState: *mut ParseState,
    pub p_sourcetext: *const ::core::ffi::c_char,
    pub p_rtable: *mut List,
    pub p_rteperminfos: *mut List,
    pub p_joinexprs: *mut List,
    pub p_nullingrels: *mut List,
    pub p_joinlist: *mut List,
    pub p_namespace: *mut List,
    pub p_lateral_active: bool,
    pub p_ctenamespace: *mut List,
    pub p_future_ctes: *mut List,
    pub p_parent_cte: *mut CommonTableExpr,
    pub p_target_relation: Relation,
    pub p_target_nsitem: *mut ParseNamespaceItem,
    pub p_is_insert: bool,
    pub p_windowdefs: *mut List,
    pub p_expr_kind: ParseExprKind::Type,
    pub p_next_resno: ::core::ffi::c_int,
    pub p_multiassign_exprs: *mut List,
    pub p_locking_clause: *mut List,
    pub p_locked_from_parent: bool,
    pub p_resolve_unknowns: bool,
    pub p_queryEnv: *mut QueryEnvironment,
    pub p_hasAggs: bool,
    pub p_hasWindowFuncs: bool,
    pub p_hasTargetSRFs: bool,
    pub p_hasSubLinks: bool,
    pub p_hasModifyingCTE: bool,
    pub p_last_srf: *mut Node,
    pub p_pre_columnref_hook: PreParseColumnRefHook,
    pub p_post_columnref_hook: PostParseColumnRefHook,
    pub p_paramref_hook: ParseParamRefHook,
    pub p_coerce_param_hook: CoerceParamHook,
    pub p_ref_hook_state: *mut ::core::ffi::c_void,
}
impl Default for ParseState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParseNamespaceItem {
    pub p_names: *mut Alias,
    pub p_rte: *mut RangeTblEntry,
    pub p_rtindex: ::core::ffi::c_int,
    pub p_perminfo: *mut RTEPermissionInfo,
    pub p_nscolumns: *mut ParseNamespaceColumn,
    pub p_rel_visible: bool,
    pub p_cols_visible: bool,
    pub p_lateral_only: bool,
    pub p_lateral_ok: bool,
}
impl Default for ParseNamespaceItem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParseNamespaceColumn {
    pub p_varno: Index,
    pub p_varattno: AttrNumber,
    pub p_vartype: Oid,
    pub p_vartypmod: int32,
    pub p_varcollid: Oid,
    pub p_varnosyn: Index,
    pub p_varattnosyn: AttrNumber,
    pub p_dontexpand: bool,
}
impl Default for ParseNamespaceColumn {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParseCallbackState {
    pub pstate: *mut ParseState,
    pub location: ::core::ffi::c_int,
    pub errcallback: ErrorContextCallback,
}
impl Default for ParseCallbackState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AclItem {
    pub ai_grantee: Oid,
    pub ai_grantor: Oid,
    pub ai_privs: AclMode,
}
impl Default for AclItem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Acl = ArrayType;
pub mod AclMaskHow {
    pub type Type = ::core::ffi::c_uint;
    pub const ACLMASK_ALL: Type = 0;
    pub const ACLMASK_ANY: Type = 1;
}
pub mod AclResult {
    pub type Type = ::core::ffi::c_uint;
    pub const ACLCHECK_OK: Type = 0;
    pub const ACLCHECK_NO_PRIV: Type = 1;
    pub const ACLCHECK_NOT_OWNER: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_namespace {
    pub oid: Oid,
    pub nspname: NameData,
    pub nspowner: Oid,
}
impl Default for FormData_pg_namespace {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_namespace = *mut FormData_pg_namespace;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_seclabel {
    pub objoid: Oid,
    pub classoid: Oid,
    pub objsubid: int32,
}
impl Default for FormData_pg_seclabel {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_tablespace {
    pub oid: Oid,
    pub spcname: NameData,
    pub spcowner: Oid,
}
impl Default for FormData_pg_tablespace {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_tablespace = *mut FormData_pg_tablespace;
#[repr(C)]
#[derive(Debug)]
pub struct FormData_pg_trigger {
    pub oid: Oid,
    pub tgrelid: Oid,
    pub tgparentid: Oid,
    pub tgname: NameData,
    pub tgfoid: Oid,
    pub tgtype: int16,
    pub tgenabled: ::core::ffi::c_char,
    pub tgisinternal: bool,
    pub tgconstrrelid: Oid,
    pub tgconstrindid: Oid,
    pub tgconstraint: Oid,
    pub tgdeferrable: bool,
    pub tginitdeferred: bool,
    pub tgnargs: int16,
    pub tgattr: int2vector,
}
impl Default for FormData_pg_trigger {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_trigger = *mut FormData_pg_trigger;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_type {
    pub oid: Oid,
    pub typname: NameData,
    pub typnamespace: Oid,
    pub typowner: Oid,
    pub typlen: int16,
    pub typbyval: bool,
    pub typtype: ::core::ffi::c_char,
    pub typcategory: ::core::ffi::c_char,
    pub typispreferred: bool,
    pub typisdefined: bool,
    pub typdelim: ::core::ffi::c_char,
    pub typrelid: Oid,
    pub typsubscript: regproc,
    pub typelem: Oid,
    pub typarray: Oid,
    pub typinput: regproc,
    pub typoutput: regproc,
    pub typreceive: regproc,
    pub typsend: regproc,
    pub typmodin: regproc,
    pub typmodout: regproc,
    pub typanalyze: regproc,
    pub typalign: ::core::ffi::c_char,
    pub typstorage: ::core::ffi::c_char,
    pub typnotnull: bool,
    pub typbasetype: Oid,
    pub typtypmod: int32,
    pub typndims: int32,
    pub typcollation: Oid,
}
impl Default for FormData_pg_type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_type = *mut FormData_pg_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_user_mapping {
    pub oid: Oid,
    pub umuser: Oid,
    pub umserver: Oid,
}
impl Default for FormData_pg_user_mapping {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_user_mapping = *mut FormData_pg_user_mapping;
pub mod CopyHeaderChoice {
    pub type Type = ::core::ffi::c_uint;
    pub const COPY_HEADER_FALSE: Type = 0;
    pub const COPY_HEADER_TRUE: Type = 1;
    pub const COPY_HEADER_MATCH: Type = 2;
}
pub mod CopyOnErrorChoice {
    pub type Type = ::core::ffi::c_uint;
    pub const COPY_ON_ERROR_STOP: Type = 0;
    pub const COPY_ON_ERROR_IGNORE: Type = 1;
}
pub mod CopyLogVerbosityChoice {
    pub type Type = ::core::ffi::c_uint;
    pub const COPY_LOG_VERBOSITY_DEFAULT: Type = 0;
    pub const COPY_LOG_VERBOSITY_VERBOSE: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CopyFormatOptions {
    pub file_encoding: ::core::ffi::c_int,
    pub binary: bool,
    pub freeze: bool,
    pub csv_mode: bool,
    pub header_line: CopyHeaderChoice::Type,
    pub null_print: *mut ::core::ffi::c_char,
    pub null_print_len: ::core::ffi::c_int,
    pub null_print_client: *mut ::core::ffi::c_char,
    pub default_print: *mut ::core::ffi::c_char,
    pub default_print_len: ::core::ffi::c_int,
    pub delim: *mut ::core::ffi::c_char,
    pub quote: *mut ::core::ffi::c_char,
    pub escape: *mut ::core::ffi::c_char,
    pub force_quote: *mut List,
    pub force_quote_all: bool,
    pub force_quote_flags: *mut bool,
    pub force_notnull: *mut List,
    pub force_notnull_all: bool,
    pub force_notnull_flags: *mut bool,
    pub force_null: *mut List,
    pub force_null_all: bool,
    pub force_null_flags: *mut bool,
    pub convert_selectively: bool,
    pub on_error: CopyOnErrorChoice::Type,
    pub log_verbosity: CopyLogVerbosityChoice::Type,
    pub convert_select: *mut List,
}
impl Default for CopyFormatOptions {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CopyFromStateData {
    _unused: [u8; 0],
}
pub type CopyFromState = *mut CopyFromStateData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CopyToStateData {
    _unused: [u8; 0],
}
pub type CopyToState = *mut CopyToStateData;
pub type copy_data_source_cb = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        outbuf: *mut ::core::ffi::c_void,
        minread: ::core::ffi::c_int,
        maxread: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
pub type copy_data_dest_cb = ::core::option::Option<
    unsafe extern "C-unwind" fn(data: *mut ::core::ffi::c_void, len: ::core::ffi::c_int),
>;
pub type EOM_get_flat_size_method =
    ::core::option::Option<unsafe extern "C-unwind" fn(eohptr: *mut ExpandedObjectHeader) -> Size>;
pub type EOM_flatten_into_method = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        eohptr: *mut ExpandedObjectHeader,
        result: *mut ::core::ffi::c_void,
        allocated_size: Size,
    ),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ExpandedObjectMethods {
    pub get_flat_size: EOM_get_flat_size_method,
    pub flatten_into: EOM_flatten_into_method,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExpandedObjectHeader {
    pub vl_len_: int32,
    pub eoh_methods: *const ExpandedObjectMethods,
    pub eoh_context: MemoryContext,
    pub eoh_rw_ptr: [::core::ffi::c_char; 10usize],
    pub eoh_ro_ptr: [::core::ffi::c_char; 10usize],
}
impl Default for ExpandedObjectHeader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayType {
    pub vl_len_: int32,
    pub ndim: ::core::ffi::c_int,
    pub dataoffset: int32,
    pub elemtype: Oid,
}
impl Default for ArrayType {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExpandedArrayHeader {
    pub hdr: ExpandedObjectHeader,
    pub ea_magic: ::core::ffi::c_int,
    pub ndims: ::core::ffi::c_int,
    pub dims: *mut ::core::ffi::c_int,
    pub lbound: *mut ::core::ffi::c_int,
    pub element_type: Oid,
    pub typlen: int16,
    pub typbyval: bool,
    pub typalign: ::core::ffi::c_char,
    pub dvalues: *mut Datum,
    pub dnulls: *mut bool,
    pub dvalueslen: ::core::ffi::c_int,
    pub nelems: ::core::ffi::c_int,
    pub flat_size: Size,
    pub fvalue: *mut ArrayType,
    pub fstartptr: *mut ::core::ffi::c_char,
    pub fendptr: *mut ::core::ffi::c_char,
}
impl Default for ExpandedArrayHeader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AnyArrayType {
    pub flt: ArrayType,
    pub xpn: ExpandedArrayHeader,
}
impl Default for AnyArrayType {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayBuildState {
    pub mcontext: MemoryContext,
    pub dvalues: *mut Datum,
    pub dnulls: *mut bool,
    pub alen: ::core::ffi::c_int,
    pub nelems: ::core::ffi::c_int,
    pub element_type: Oid,
    pub typlen: int16,
    pub typbyval: bool,
    pub typalign: ::core::ffi::c_char,
    pub private_cxt: bool,
}
impl Default for ArrayBuildState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayBuildStateArr {
    pub mcontext: MemoryContext,
    pub data: *mut ::core::ffi::c_char,
    pub nullbitmap: *mut bits8,
    pub abytes: ::core::ffi::c_int,
    pub nbytes: ::core::ffi::c_int,
    pub aitems: ::core::ffi::c_int,
    pub nitems: ::core::ffi::c_int,
    pub ndims: ::core::ffi::c_int,
    pub dims: [::core::ffi::c_int; 6usize],
    pub lbs: [::core::ffi::c_int; 6usize],
    pub array_type: Oid,
    pub element_type: Oid,
    pub private_cxt: bool,
}
impl Default for ArrayBuildStateArr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayBuildStateAny {
    pub scalarstate: *mut ArrayBuildState,
    pub arraystate: *mut ArrayBuildStateArr,
}
impl Default for ArrayBuildStateAny {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayMetaState {
    pub element_type: Oid,
    pub typlen: int16,
    pub typbyval: bool,
    pub typalign: ::core::ffi::c_char,
    pub typdelim: ::core::ffi::c_char,
    pub typioparam: Oid,
    pub typiofunc: Oid,
    pub proc_: FmgrInfo,
}
impl Default for ArrayMetaState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayMapState {
    pub inp_extra: ArrayMetaState,
    pub ret_extra: ArrayMetaState,
}
impl Default for ArrayMapState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayIteratorData {
    _unused: [u8; 0],
}
pub type ArrayIterator = *mut ArrayIteratorData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_event_trigger {
    pub oid: Oid,
    pub evtname: NameData,
    pub evtevent: NameData,
    pub evtowner: Oid,
    pub evtfoid: Oid,
    pub evtenabled: ::core::ffi::c_char,
}
impl Default for FormData_pg_event_trigger {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_event_trigger = *mut FormData_pg_event_trigger;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InternalGrant {
    pub is_grant: bool,
    pub objtype: ObjectType::Type,
    pub objects: *mut List,
    pub all_privs: bool,
    pub privileges: AclMode,
    pub col_privs: *mut List,
    pub grantees: *mut List,
    pub grant_option: bool,
    pub behavior: DropBehavior::Type,
}
impl Default for InternalGrant {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod CollectedCommandType {
    pub type Type = ::core::ffi::c_uint;
    pub const SCT_Simple: Type = 0;
    pub const SCT_AlterTable: Type = 1;
    pub const SCT_Grant: Type = 2;
    pub const SCT_AlterOpFamily: Type = 3;
    pub const SCT_AlterDefaultPrivileges: Type = 4;
    pub const SCT_CreateOpClass: Type = 5;
    pub const SCT_AlterTSConfig: Type = 6;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollectedATSubcmd {
    pub address: ObjectAddress,
    pub parsetree: *mut Node,
}
impl Default for CollectedATSubcmd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CollectedCommand {
    pub type_: CollectedCommandType::Type,
    pub in_extension: bool,
    pub parsetree: *mut Node,
    pub d: CollectedCommand__bindgen_ty_1,
    pub parent: *mut CollectedCommand,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CollectedCommand__bindgen_ty_1 {
    pub simple: CollectedCommand__bindgen_ty_1__bindgen_ty_1,
    pub alterTable: CollectedCommand__bindgen_ty_1__bindgen_ty_2,
    pub grant: CollectedCommand__bindgen_ty_1__bindgen_ty_3,
    pub opfam: CollectedCommand__bindgen_ty_1__bindgen_ty_4,
    pub createopc: CollectedCommand__bindgen_ty_1__bindgen_ty_5,
    pub atscfg: CollectedCommand__bindgen_ty_1__bindgen_ty_6,
    pub defprivs: CollectedCommand__bindgen_ty_1__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollectedCommand__bindgen_ty_1__bindgen_ty_1 {
    pub address: ObjectAddress,
    pub secondaryObject: ObjectAddress,
}
impl Default for CollectedCommand__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollectedCommand__bindgen_ty_1__bindgen_ty_2 {
    pub objectId: Oid,
    pub classId: Oid,
    pub subcmds: *mut List,
}
impl Default for CollectedCommand__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollectedCommand__bindgen_ty_1__bindgen_ty_3 {
    pub istmt: *mut InternalGrant,
}
impl Default for CollectedCommand__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollectedCommand__bindgen_ty_1__bindgen_ty_4 {
    pub address: ObjectAddress,
    pub operators: *mut List,
    pub procedures: *mut List,
}
impl Default for CollectedCommand__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollectedCommand__bindgen_ty_1__bindgen_ty_5 {
    pub address: ObjectAddress,
    pub operators: *mut List,
    pub procedures: *mut List,
}
impl Default for CollectedCommand__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollectedCommand__bindgen_ty_1__bindgen_ty_6 {
    pub address: ObjectAddress,
    pub dictIds: *mut Oid,
    pub ndicts: ::core::ffi::c_int,
}
impl Default for CollectedCommand__bindgen_ty_1__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollectedCommand__bindgen_ty_1__bindgen_ty_7 {
    pub objtype: ObjectType::Type,
}
impl Default for CollectedCommand__bindgen_ty_1__bindgen_ty_7 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for CollectedCommand__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for CollectedCommand {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EventTriggerData {
    pub type_: NodeTag,
    pub event: *const ::core::ffi::c_char,
    pub parsetree: *mut Node,
    pub tag: CommandTag::Type,
}
impl Default for EventTriggerData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod ExplainSerializeOption {
    pub type Type = ::core::ffi::c_uint;
    pub const EXPLAIN_SERIALIZE_NONE: Type = 0;
    pub const EXPLAIN_SERIALIZE_TEXT: Type = 1;
    pub const EXPLAIN_SERIALIZE_BINARY: Type = 2;
}
pub mod ExplainFormat {
    pub type Type = ::core::ffi::c_uint;
    pub const EXPLAIN_FORMAT_TEXT: Type = 0;
    pub const EXPLAIN_FORMAT_XML: Type = 1;
    pub const EXPLAIN_FORMAT_JSON: Type = 2;
    pub const EXPLAIN_FORMAT_YAML: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExplainWorkersState {
    pub num_workers: ::core::ffi::c_int,
    pub worker_inited: *mut bool,
    pub worker_str: *mut StringInfoData,
    pub worker_state_save: *mut ::core::ffi::c_int,
    pub prev_str: StringInfo,
}
impl Default for ExplainWorkersState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExplainState {
    pub str_: StringInfo,
    pub verbose: bool,
    pub analyze: bool,
    pub costs: bool,
    pub buffers: bool,
    pub wal: bool,
    pub timing: bool,
    pub summary: bool,
    pub memory: bool,
    pub settings: bool,
    pub generic: bool,
    pub serialize: ExplainSerializeOption::Type,
    pub format: ExplainFormat::Type,
    pub indent: ::core::ffi::c_int,
    pub grouping_stack: *mut List,
    pub pstmt: *mut PlannedStmt,
    pub rtable: *mut List,
    pub rtable_names: *mut List,
    pub deparse_cxt: *mut List,
    pub printed_subplans: *mut Bitmapset,
    pub hide_workers: bool,
    pub workers_state: *mut ExplainWorkersState,
}
impl Default for ExplainState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ExplainOneQuery_hook_type = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        query: *mut Query,
        cursorOptions: ::core::ffi::c_int,
        into: *mut IntoClause,
        es: *mut ExplainState,
        queryString: *const ::core::ffi::c_char,
        params: ParamListInfo,
        queryEnv: *mut QueryEnvironment,
    ),
>;
pub type explain_get_index_name_hook_type =
    ::core::option::Option<unsafe extern "C-unwind" fn(indexId: Oid) -> *const ::core::ffi::c_char>;
pub mod PlanCacheMode {
    pub type Type = ::core::ffi::c_uint;
    pub const PLAN_CACHE_MODE_AUTO: Type = 0;
    pub const PLAN_CACHE_MODE_FORCE_GENERIC_PLAN: Type = 1;
    pub const PLAN_CACHE_MODE_FORCE_CUSTOM_PLAN: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CachedPlanSource {
    pub magic: ::core::ffi::c_int,
    pub raw_parse_tree: *mut RawStmt,
    pub query_string: *const ::core::ffi::c_char,
    pub commandTag: CommandTag::Type,
    pub param_types: *mut Oid,
    pub num_params: ::core::ffi::c_int,
    pub parserSetup: ParserSetupHook,
    pub parserSetupArg: *mut ::core::ffi::c_void,
    pub cursor_options: ::core::ffi::c_int,
    pub fixed_result: bool,
    pub resultDesc: TupleDesc,
    pub context: MemoryContext,
    pub query_list: *mut List,
    pub relationOids: *mut List,
    pub invalItems: *mut List,
    pub search_path: *mut SearchPathMatcher,
    pub query_context: MemoryContext,
    pub rewriteRoleId: Oid,
    pub rewriteRowSecurity: bool,
    pub dependsOnRLS: bool,
    pub gplan: *mut CachedPlan,
    pub is_oneshot: bool,
    pub is_complete: bool,
    pub is_saved: bool,
    pub is_valid: bool,
    pub generation: ::core::ffi::c_int,
    pub node: dlist_node,
    pub generic_cost: f64,
    pub total_custom_cost: f64,
    pub num_custom_plans: int64,
    pub num_generic_plans: int64,
}
impl Default for CachedPlanSource {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CachedPlan {
    pub magic: ::core::ffi::c_int,
    pub stmt_list: *mut List,
    pub is_oneshot: bool,
    pub is_saved: bool,
    pub is_valid: bool,
    pub planRoleId: Oid,
    pub dependsOnRole: bool,
    pub saved_xmin: TransactionId,
    pub generation: ::core::ffi::c_int,
    pub refcount: ::core::ffi::c_int,
    pub context: MemoryContext,
}
impl Default for CachedPlan {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CachedExpression {
    pub magic: ::core::ffi::c_int,
    pub expr: *mut Node,
    pub is_valid: bool,
    pub relationOids: *mut List,
    pub invalItems: *mut List,
    pub context: MemoryContext,
    pub node: dlist_node,
}
impl Default for CachedExpression {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PreparedStatement {
    pub stmt_name: [::core::ffi::c_char; 64usize],
    pub plansource: *mut CachedPlanSource,
    pub from_sql: bool,
    pub prepare_time: TimestampTz,
}
impl Default for PreparedStatement {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type check_object_relabel_type = ::core::option::Option<
    unsafe extern "C-unwind" fn(object: *const ObjectAddress, seclabel: *const ::core::ffi::c_char),
>;
#[repr(C)]
#[derive(Debug)]
pub struct xl_tblspc_create_rec {
    pub ts_id: Oid,
    pub ts_path: __IncompleteArrayField<::core::ffi::c_char>,
}
impl Default for xl_tblspc_create_rec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xl_tblspc_drop_rec {
    pub ts_id: Oid,
}
impl Default for xl_tblspc_drop_rec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TableSpaceOpts {
    pub vl_len_: int32,
    pub random_page_cost: float8,
    pub seq_page_cost: float8,
    pub effective_io_concurrency: ::core::ffi::c_int,
    pub maintenance_io_concurrency: ::core::ffi::c_int,
}
pub type TriggerEvent = uint32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TriggerData {
    pub type_: NodeTag,
    pub tg_event: TriggerEvent,
    pub tg_relation: Relation,
    pub tg_trigtuple: HeapTuple,
    pub tg_newtuple: HeapTuple,
    pub tg_trigger: *mut Trigger,
    pub tg_trigslot: *mut TupleTableSlot,
    pub tg_newslot: *mut TupleTableSlot,
    pub tg_oldtable: *mut Tuplestorestate,
    pub tg_newtable: *mut Tuplestorestate,
    pub tg_updatedcols: *const Bitmapset,
}
impl Default for TriggerData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AfterTriggersTableData {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TransitionCaptureState {
    pub tcs_delete_old_table: bool,
    pub tcs_update_old_table: bool,
    pub tcs_update_new_table: bool,
    pub tcs_insert_new_table: bool,
    pub tcs_original_insert_tuple: *mut TupleTableSlot,
    pub tcs_private: *mut AfterTriggersTableData,
}
impl Default for TransitionCaptureState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod PasswordType {
    pub type Type = ::core::ffi::c_uint;
    pub const PASSWORD_TYPE_PLAINTEXT: Type = 0;
    pub const PASSWORD_TYPE_MD5: Type = 1;
    pub const PASSWORD_TYPE_SCRAM_SHA_256: Type = 2;
}
pub mod GucContext {
    pub type Type = ::core::ffi::c_uint;
    pub const PGC_INTERNAL: Type = 0;
    pub const PGC_POSTMASTER: Type = 1;
    pub const PGC_SIGHUP: Type = 2;
    pub const PGC_SU_BACKEND: Type = 3;
    pub const PGC_BACKEND: Type = 4;
    pub const PGC_SUSET: Type = 5;
    pub const PGC_USERSET: Type = 6;
}
pub mod GucSource {
    pub type Type = ::core::ffi::c_uint;
    pub const PGC_S_DEFAULT: Type = 0;
    pub const PGC_S_DYNAMIC_DEFAULT: Type = 1;
    pub const PGC_S_ENV_VAR: Type = 2;
    pub const PGC_S_FILE: Type = 3;
    pub const PGC_S_ARGV: Type = 4;
    pub const PGC_S_GLOBAL: Type = 5;
    pub const PGC_S_DATABASE: Type = 6;
    pub const PGC_S_USER: Type = 7;
    pub const PGC_S_DATABASE_USER: Type = 8;
    pub const PGC_S_CLIENT: Type = 9;
    pub const PGC_S_OVERRIDE: Type = 10;
    pub const PGC_S_INTERACTIVE: Type = 11;
    pub const PGC_S_TEST: Type = 12;
    pub const PGC_S_SESSION: Type = 13;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConfigVariable {
    pub name: *mut ::core::ffi::c_char,
    pub value: *mut ::core::ffi::c_char,
    pub errmsg: *mut ::core::ffi::c_char,
    pub filename: *mut ::core::ffi::c_char,
    pub sourceline: ::core::ffi::c_int,
    pub ignore: bool,
    pub applied: bool,
    pub next: *mut ConfigVariable,
}
impl Default for ConfigVariable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct config_generic {
    _unused: [u8; 0],
}
pub type config_handle = config_generic;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct config_enum_entry {
    pub name: *const ::core::ffi::c_char,
    pub val: ::core::ffi::c_int,
    pub hidden: bool,
}
impl Default for config_enum_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type GucBoolCheckHook = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        newval: *mut bool,
        extra: *mut *mut ::core::ffi::c_void,
        source: GucSource::Type,
    ) -> bool,
>;
pub type GucIntCheckHook = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        newval: *mut ::core::ffi::c_int,
        extra: *mut *mut ::core::ffi::c_void,
        source: GucSource::Type,
    ) -> bool,
>;
pub type GucRealCheckHook = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        newval: *mut f64,
        extra: *mut *mut ::core::ffi::c_void,
        source: GucSource::Type,
    ) -> bool,
>;
pub type GucStringCheckHook = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        newval: *mut *mut ::core::ffi::c_char,
        extra: *mut *mut ::core::ffi::c_void,
        source: GucSource::Type,
    ) -> bool,
>;
pub type GucEnumCheckHook = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        newval: *mut ::core::ffi::c_int,
        extra: *mut *mut ::core::ffi::c_void,
        source: GucSource::Type,
    ) -> bool,
>;
pub type GucBoolAssignHook = ::core::option::Option<
    unsafe extern "C-unwind" fn(newval: bool, extra: *mut ::core::ffi::c_void),
>;
pub type GucIntAssignHook = ::core::option::Option<
    unsafe extern "C-unwind" fn(newval: ::core::ffi::c_int, extra: *mut ::core::ffi::c_void),
>;
pub type GucRealAssignHook = ::core::option::Option<
    unsafe extern "C-unwind" fn(newval: f64, extra: *mut ::core::ffi::c_void),
>;
pub type GucStringAssignHook = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        newval: *const ::core::ffi::c_char,
        extra: *mut ::core::ffi::c_void,
    ),
>;
pub type GucEnumAssignHook = ::core::option::Option<
    unsafe extern "C-unwind" fn(newval: ::core::ffi::c_int, extra: *mut ::core::ffi::c_void),
>;
pub type GucShowHook =
    ::core::option::Option<unsafe extern "C-unwind" fn() -> *const ::core::ffi::c_char>;
pub mod GucAction {
    pub type Type = ::core::ffi::c_uint;
    pub const GUC_ACTION_SET: Type = 0;
    pub const GUC_ACTION_LOCAL: Type = 1;
    pub const GUC_ACTION_SAVE: Type = 2;
}
pub type check_password_hook_type = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        username: *const ::core::ffi::c_char,
        shadow_pass: *const ::core::ffi::c_char,
        password_type: PasswordType::Type,
        validuntil_time: Datum,
        validuntil_null: bool,
    ),
>;
pub type bgworker_main_type = ::core::option::Option<unsafe extern "C-unwind" fn(main_arg: Datum)>;
pub mod BgWorkerStartTime {
    pub type Type = ::core::ffi::c_uint;
    pub const BgWorkerStart_PostmasterStart: Type = 0;
    pub const BgWorkerStart_ConsistentState: Type = 1;
    pub const BgWorkerStart_RecoveryFinished: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BackgroundWorker {
    pub bgw_name: [::core::ffi::c_char; 96usize],
    pub bgw_type: [::core::ffi::c_char; 96usize],
    pub bgw_flags: ::core::ffi::c_int,
    pub bgw_start_time: BgWorkerStartTime::Type,
    pub bgw_restart_time: ::core::ffi::c_int,
    pub bgw_library_name: [::core::ffi::c_char; 1024usize],
    pub bgw_function_name: [::core::ffi::c_char; 96usize],
    pub bgw_main_arg: Datum,
    pub bgw_extra: [::core::ffi::c_char; 128usize],
    pub bgw_notify_pid: pid_t,
}
impl Default for BackgroundWorker {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod BgwHandleStatus {
    pub type Type = ::core::ffi::c_uint;
    pub const BGWH_STARTED: Type = 0;
    pub const BGWH_NOT_YET_STARTED: Type = 1;
    pub const BGWH_STOPPED: Type = 2;
    pub const BGWH_POSTMASTER_DIED: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BackgroundWorkerHandle {
    _unused: [u8; 0],
}
pub type XidStatus = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xl_clog_truncate {
    pub pageno: int64,
    pub oldestXact: TransactionId,
    pub oldestXactDb: Oid,
}
impl Default for xl_clog_truncate {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Latch {
    pub is_set: sig_atomic_t,
    pub maybe_sleeping: sig_atomic_t,
    pub is_shared: bool,
    pub owner_pid: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WaitEvent {
    pub pos: ::core::ffi::c_int,
    pub events: uint32,
    pub fd: pgsocket,
    pub user_data: *mut ::core::ffi::c_void,
}
impl Default for WaitEvent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PGSemaphoreData {
    _unused: [u8; 0],
}
pub type PGSemaphore = *mut PGSemaphoreData;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct XidCacheStatus {
    pub count: uint8,
    pub overflowed: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XidCache {
    pub xids: [TransactionId; 64usize],
}
impl Default for XidCache {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod ProcWaitStatus {
    pub type Type = ::core::ffi::c_uint;
    pub const PROC_WAIT_STATUS_OK: Type = 0;
    pub const PROC_WAIT_STATUS_WAITING: Type = 1;
    pub const PROC_WAIT_STATUS_ERROR: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PGPROC {
    pub links: dlist_node,
    pub procgloballist: *mut dlist_head,
    pub sem: PGSemaphore,
    pub waitStatus: ProcWaitStatus::Type,
    pub procLatch: Latch,
    pub xid: TransactionId,
    pub xmin: TransactionId,
    pub pid: ::core::ffi::c_int,
    pub pgxactoff: ::core::ffi::c_int,
    pub vxid: PGPROC__bindgen_ty_1,
    pub databaseId: Oid,
    pub roleId: Oid,
    pub tempNamespaceId: Oid,
    pub isBackgroundWorker: bool,
    pub recoveryConflictPending: bool,
    pub lwWaiting: uint8,
    pub lwWaitMode: uint8,
    pub lwWaitLink: proclist_node,
    pub cvWaitLink: proclist_node,
    pub waitLock: *mut LOCK,
    pub waitProcLock: *mut PROCLOCK,
    pub waitLockMode: LOCKMODE,
    pub heldLocks: LOCKMASK,
    pub waitStart: pg_atomic_uint64,
    pub delayChkptFlags: ::core::ffi::c_int,
    pub statusFlags: uint8,
    pub waitLSN: XLogRecPtr,
    pub syncRepState: ::core::ffi::c_int,
    pub syncRepLinks: dlist_node,
    pub myProcLocks: [dlist_head; 16usize],
    pub subxidStatus: XidCacheStatus,
    pub subxids: XidCache,
    pub procArrayGroupMember: bool,
    pub procArrayGroupNext: pg_atomic_uint32,
    pub procArrayGroupMemberXid: TransactionId,
    pub wait_event_info: uint32,
    pub clogGroupMember: bool,
    pub clogGroupNext: pg_atomic_uint32,
    pub clogGroupMemberXid: TransactionId,
    pub clogGroupMemberXidStatus: XidStatus,
    pub clogGroupMemberPage: int64,
    pub clogGroupMemberLsn: XLogRecPtr,
    pub fpInfoLock: LWLock,
    pub fpLockBits: uint64,
    pub fpRelId: [Oid; 16usize],
    pub fpVXIDLock: bool,
    pub fpLocalTransactionId: LocalTransactionId,
    pub lockGroupLeader: *mut PGPROC,
    pub lockGroupMembers: dlist_head,
    pub lockGroupLink: dlist_node,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PGPROC__bindgen_ty_1 {
    pub procNumber: ProcNumber,
    pub lxid: LocalTransactionId,
}
impl Default for PGPROC {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PROC_HDR {
    pub allProcs: *mut PGPROC,
    pub xids: *mut TransactionId,
    pub subxidStates: *mut XidCacheStatus,
    pub statusFlags: *mut uint8,
    pub allProcCount: uint32,
    pub freeProcs: dlist_head,
    pub autovacFreeProcs: dlist_head,
    pub bgworkerFreeProcs: dlist_head,
    pub walsenderFreeProcs: dlist_head,
    pub procArrayGroupFirst: pg_atomic_uint32,
    pub clogGroupFirst: pg_atomic_uint32,
    pub walwriterLatch: *mut Latch,
    pub checkpointerLatch: *mut Latch,
    pub spins_per_delay: ::core::ffi::c_int,
    pub startupBufferPinWaitBufId: ::core::ffi::c_int,
}
impl Default for PROC_HDR {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shm_mq {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shm_mq_handle {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shm_mq_iovec {
    pub data: *const ::core::ffi::c_char,
    pub len: Size,
}
impl Default for shm_mq_iovec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod shm_mq_result {
    pub type Type = ::core::ffi::c_uint;
    pub const SHM_MQ_SUCCESS: Type = 0;
    pub const SHM_MQ_WOULD_BLOCK: Type = 1;
    pub const SHM_MQ_DETACHED: Type = 2;
}
pub type parallel_worker_main_type =
    ::core::option::Option<unsafe extern "C-unwind" fn(seg: *mut dsm_segment, toc: *mut shm_toc)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParallelWorkerInfo {
    pub bgwhandle: *mut BackgroundWorkerHandle,
    pub error_mqh: *mut shm_mq_handle,
}
impl Default for ParallelWorkerInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParallelContext {
    pub node: dlist_node,
    pub subid: SubTransactionId,
    pub nworkers: ::core::ffi::c_int,
    pub nworkers_to_launch: ::core::ffi::c_int,
    pub nworkers_launched: ::core::ffi::c_int,
    pub library_name: *mut ::core::ffi::c_char,
    pub function_name: *mut ::core::ffi::c_char,
    pub error_context_stack: *mut ErrorContextCallback,
    pub estimator: shm_toc_estimator,
    pub seg: *mut dsm_segment,
    pub private_memory: *mut ::core::ffi::c_void,
    pub toc: *mut shm_toc,
    pub worker: *mut ParallelWorkerInfo,
    pub nknown_attached_workers: ::core::ffi::c_int,
    pub known_attached_workers: *mut bool,
}
impl Default for ParallelContext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParallelWorkerContext {
    pub seg: *mut dsm_segment,
    pub toc: *mut shm_toc,
}
impl Default for ParallelWorkerContext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TidStore {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TidStoreIter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TidStoreIterResult {
    pub blkno: BlockNumber,
    pub max_offset: ::core::ffi::c_int,
    pub num_offsets: ::core::ffi::c_int,
    pub offsets: *mut OffsetNumber,
}
impl Default for TidStoreIterResult {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_statistic {
    pub starelid: Oid,
    pub staattnum: int16,
    pub stainherit: bool,
    pub stanullfrac: float4,
    pub stawidth: int32,
    pub stadistinct: float4,
    pub stakind1: int16,
    pub stakind2: int16,
    pub stakind3: int16,
    pub stakind4: int16,
    pub stakind5: int16,
    pub staop1: Oid,
    pub staop2: Oid,
    pub staop3: Oid,
    pub staop4: Oid,
    pub staop5: Oid,
    pub stacoll1: Oid,
    pub stacoll2: Oid,
    pub stacoll3: Oid,
    pub stacoll4: Oid,
    pub stacoll5: Oid,
}
impl Default for FormData_pg_statistic {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_statistic = *mut FormData_pg_statistic;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParallelVacuumState {
    _unused: [u8; 0],
}
pub type VacAttrStatsP = *mut VacAttrStats;
pub type AnalyzeAttrFetchFunc = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        stats: VacAttrStatsP,
        rownum: ::core::ffi::c_int,
        isNull: *mut bool,
    ) -> Datum,
>;
pub type AnalyzeAttrComputeStatsFunc = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        stats: VacAttrStatsP,
        fetchfunc: AnalyzeAttrFetchFunc,
        samplerows: ::core::ffi::c_int,
        totalrows: f64,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VacAttrStats {
    pub attstattarget: ::core::ffi::c_int,
    pub attrtypid: Oid,
    pub attrtypmod: int32,
    pub attrtype: Form_pg_type,
    pub attrcollid: Oid,
    pub anl_context: MemoryContext,
    pub compute_stats: AnalyzeAttrComputeStatsFunc,
    pub minrows: ::core::ffi::c_int,
    pub extra_data: *mut ::core::ffi::c_void,
    pub stats_valid: bool,
    pub stanullfrac: float4,
    pub stawidth: int32,
    pub stadistinct: float4,
    pub stakind: [int16; 5usize],
    pub staop: [Oid; 5usize],
    pub stacoll: [Oid; 5usize],
    pub numnumbers: [::core::ffi::c_int; 5usize],
    pub stanumbers: [*mut float4; 5usize],
    pub numvalues: [::core::ffi::c_int; 5usize],
    pub stavalues: [*mut Datum; 5usize],
    pub statypid: [Oid; 5usize],
    pub statyplen: [int16; 5usize],
    pub statypbyval: [bool; 5usize],
    pub statypalign: [::core::ffi::c_char; 5usize],
    pub tupattnum: ::core::ffi::c_int,
    pub rows: *mut HeapTuple,
    pub tupDesc: TupleDesc,
    pub exprvals: *mut Datum,
    pub exprnulls: *mut bool,
    pub rowstride: ::core::ffi::c_int,
}
impl Default for VacAttrStats {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod VacOptValue {
    pub type Type = ::core::ffi::c_uint;
    pub const VACOPTVALUE_UNSPECIFIED: Type = 0;
    pub const VACOPTVALUE_AUTO: Type = 1;
    pub const VACOPTVALUE_DISABLED: Type = 2;
    pub const VACOPTVALUE_ENABLED: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VacuumParams {
    pub options: bits32,
    pub freeze_min_age: ::core::ffi::c_int,
    pub freeze_table_age: ::core::ffi::c_int,
    pub multixact_freeze_min_age: ::core::ffi::c_int,
    pub multixact_freeze_table_age: ::core::ffi::c_int,
    pub is_wraparound: bool,
    pub log_min_duration: ::core::ffi::c_int,
    pub index_cleanup: VacOptValue::Type,
    pub truncate: VacOptValue::Type,
    pub toast_parent: Oid,
    pub nworkers: ::core::ffi::c_int,
}
impl Default for VacuumParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct VacuumCutoffs {
    pub relfrozenxid: TransactionId,
    pub relminmxid: MultiXactId,
    pub OldestXmin: TransactionId,
    pub OldestMxact: MultiXactId,
    pub FreezeLimit: TransactionId,
    pub MultiXactCutoff: MultiXactId,
}
impl Default for VacuumCutoffs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VacDeadItemsInfo {
    pub max_bytes: usize,
    pub num_items: int64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConfigData {
    pub name: *mut ::core::ffi::c_char,
    pub setting: *mut ::core::ffi::c_char,
}
impl Default for ConfigData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggStatePerTransData {
    pub aggref: *mut Aggref,
    pub aggshared: bool,
    pub aggsortrequired: bool,
    pub numInputs: ::core::ffi::c_int,
    pub numTransInputs: ::core::ffi::c_int,
    pub transfn_oid: Oid,
    pub serialfn_oid: Oid,
    pub deserialfn_oid: Oid,
    pub aggtranstype: Oid,
    pub transfn: FmgrInfo,
    pub serialfn: FmgrInfo,
    pub deserialfn: FmgrInfo,
    pub aggCollation: Oid,
    pub numSortCols: ::core::ffi::c_int,
    pub numDistinctCols: ::core::ffi::c_int,
    pub sortColIdx: *mut AttrNumber,
    pub sortOperators: *mut Oid,
    pub sortCollations: *mut Oid,
    pub sortNullsFirst: *mut bool,
    pub equalfnOne: FmgrInfo,
    pub equalfnMulti: *mut ExprState,
    pub initValue: Datum,
    pub initValueIsNull: bool,
    pub inputtypeLen: int16,
    pub transtypeLen: int16,
    pub inputtypeByVal: bool,
    pub transtypeByVal: bool,
    pub sortslot: *mut TupleTableSlot,
    pub uniqslot: *mut TupleTableSlot,
    pub sortdesc: TupleDesc,
    pub lastdatum: Datum,
    pub lastisnull: bool,
    pub haslast: bool,
    pub sortstates: *mut *mut Tuplesortstate,
    pub transfn_fcinfo: FunctionCallInfo,
    pub serialfn_fcinfo: FunctionCallInfo,
    pub deserialfn_fcinfo: FunctionCallInfo,
}
impl Default for AggStatePerTransData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggStatePerAggData {
    pub aggref: *mut Aggref,
    pub transno: ::core::ffi::c_int,
    pub finalfn_oid: Oid,
    pub finalfn: FmgrInfo,
    pub numFinalArgs: ::core::ffi::c_int,
    pub aggdirectargs: *mut List,
    pub resulttypeLen: int16,
    pub resulttypeByVal: bool,
    pub shareable: bool,
}
impl Default for AggStatePerAggData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggStatePerGroupData {
    pub transValue: Datum,
    pub transValueIsNull: bool,
    pub noTransValue: bool,
}
impl Default for AggStatePerGroupData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggStatePerPhaseData {
    pub aggstrategy: AggStrategy::Type,
    pub numsets: ::core::ffi::c_int,
    pub gset_lengths: *mut ::core::ffi::c_int,
    pub grouped_cols: *mut *mut Bitmapset,
    pub eqfunctions: *mut *mut ExprState,
    pub aggnode: *mut Agg,
    pub sortnode: *mut Sort,
    pub evaltrans: *mut ExprState,
    pub evaltrans_cache: [[*mut ExprState; 2usize]; 2usize],
}
impl Default for AggStatePerPhaseData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggStatePerHashData {
    pub hashtable: TupleHashTable,
    pub hashiter: TupleHashIterator,
    pub hashslot: *mut TupleTableSlot,
    pub hashfunctions: *mut FmgrInfo,
    pub eqfuncoids: *mut Oid,
    pub numCols: ::core::ffi::c_int,
    pub numhashGrpCols: ::core::ffi::c_int,
    pub largestGrpColIdx: ::core::ffi::c_int,
    pub hashGrpColIdxInput: *mut AttrNumber,
    pub hashGrpColIdxHash: *mut AttrNumber,
    pub aggnode: *mut Agg,
}
impl Default for AggStatePerHashData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScalarArrayOpExprHashTable {
    _unused: [u8; 0],
}
pub type ExecEvalSubroutine = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        state: *mut ExprState,
        op: *mut ExprEvalStep,
        econtext: *mut ExprContext,
    ),
>;
pub type ExecEvalBoolSubroutine = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        state: *mut ExprState,
        op: *mut ExprEvalStep,
        econtext: *mut ExprContext,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalRowtypeCache {
    pub cacheptr: *mut ::core::ffi::c_void,
    pub tupdesc_id: uint64,
}
impl Default for ExprEvalRowtypeCache {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod ExprEvalOp {
    pub type Type = ::core::ffi::c_uint;
    pub const EEOP_DONE: Type = 0;
    pub const EEOP_INNER_FETCHSOME: Type = 1;
    pub const EEOP_OUTER_FETCHSOME: Type = 2;
    pub const EEOP_SCAN_FETCHSOME: Type = 3;
    pub const EEOP_INNER_VAR: Type = 4;
    pub const EEOP_OUTER_VAR: Type = 5;
    pub const EEOP_SCAN_VAR: Type = 6;
    pub const EEOP_INNER_SYSVAR: Type = 7;
    pub const EEOP_OUTER_SYSVAR: Type = 8;
    pub const EEOP_SCAN_SYSVAR: Type = 9;
    pub const EEOP_WHOLEROW: Type = 10;
    pub const EEOP_ASSIGN_INNER_VAR: Type = 11;
    pub const EEOP_ASSIGN_OUTER_VAR: Type = 12;
    pub const EEOP_ASSIGN_SCAN_VAR: Type = 13;
    pub const EEOP_ASSIGN_TMP: Type = 14;
    pub const EEOP_ASSIGN_TMP_MAKE_RO: Type = 15;
    pub const EEOP_CONST: Type = 16;
    pub const EEOP_FUNCEXPR: Type = 17;
    pub const EEOP_FUNCEXPR_STRICT: Type = 18;
    pub const EEOP_FUNCEXPR_FUSAGE: Type = 19;
    pub const EEOP_FUNCEXPR_STRICT_FUSAGE: Type = 20;
    pub const EEOP_BOOL_AND_STEP_FIRST: Type = 21;
    pub const EEOP_BOOL_AND_STEP: Type = 22;
    pub const EEOP_BOOL_AND_STEP_LAST: Type = 23;
    pub const EEOP_BOOL_OR_STEP_FIRST: Type = 24;
    pub const EEOP_BOOL_OR_STEP: Type = 25;
    pub const EEOP_BOOL_OR_STEP_LAST: Type = 26;
    pub const EEOP_BOOL_NOT_STEP: Type = 27;
    pub const EEOP_QUAL: Type = 28;
    pub const EEOP_JUMP: Type = 29;
    pub const EEOP_JUMP_IF_NULL: Type = 30;
    pub const EEOP_JUMP_IF_NOT_NULL: Type = 31;
    pub const EEOP_JUMP_IF_NOT_TRUE: Type = 32;
    pub const EEOP_NULLTEST_ISNULL: Type = 33;
    pub const EEOP_NULLTEST_ISNOTNULL: Type = 34;
    pub const EEOP_NULLTEST_ROWISNULL: Type = 35;
    pub const EEOP_NULLTEST_ROWISNOTNULL: Type = 36;
    pub const EEOP_BOOLTEST_IS_TRUE: Type = 37;
    pub const EEOP_BOOLTEST_IS_NOT_TRUE: Type = 38;
    pub const EEOP_BOOLTEST_IS_FALSE: Type = 39;
    pub const EEOP_BOOLTEST_IS_NOT_FALSE: Type = 40;
    pub const EEOP_PARAM_EXEC: Type = 41;
    pub const EEOP_PARAM_EXTERN: Type = 42;
    pub const EEOP_PARAM_CALLBACK: Type = 43;
    pub const EEOP_CASE_TESTVAL: Type = 44;
    pub const EEOP_MAKE_READONLY: Type = 45;
    pub const EEOP_IOCOERCE: Type = 46;
    pub const EEOP_IOCOERCE_SAFE: Type = 47;
    pub const EEOP_DISTINCT: Type = 48;
    pub const EEOP_NOT_DISTINCT: Type = 49;
    pub const EEOP_NULLIF: Type = 50;
    pub const EEOP_SQLVALUEFUNCTION: Type = 51;
    pub const EEOP_CURRENTOFEXPR: Type = 52;
    pub const EEOP_NEXTVALUEEXPR: Type = 53;
    pub const EEOP_ARRAYEXPR: Type = 54;
    pub const EEOP_ARRAYCOERCE: Type = 55;
    pub const EEOP_ROW: Type = 56;
    pub const EEOP_ROWCOMPARE_STEP: Type = 57;
    pub const EEOP_ROWCOMPARE_FINAL: Type = 58;
    pub const EEOP_MINMAX: Type = 59;
    pub const EEOP_FIELDSELECT: Type = 60;
    pub const EEOP_FIELDSTORE_DEFORM: Type = 61;
    pub const EEOP_FIELDSTORE_FORM: Type = 62;
    pub const EEOP_SBSREF_SUBSCRIPTS: Type = 63;
    pub const EEOP_SBSREF_OLD: Type = 64;
    pub const EEOP_SBSREF_ASSIGN: Type = 65;
    pub const EEOP_SBSREF_FETCH: Type = 66;
    pub const EEOP_DOMAIN_TESTVAL: Type = 67;
    pub const EEOP_DOMAIN_NOTNULL: Type = 68;
    pub const EEOP_DOMAIN_CHECK: Type = 69;
    pub const EEOP_CONVERT_ROWTYPE: Type = 70;
    pub const EEOP_SCALARARRAYOP: Type = 71;
    pub const EEOP_HASHED_SCALARARRAYOP: Type = 72;
    pub const EEOP_XMLEXPR: Type = 73;
    pub const EEOP_JSON_CONSTRUCTOR: Type = 74;
    pub const EEOP_IS_JSON: Type = 75;
    pub const EEOP_JSONEXPR_PATH: Type = 76;
    pub const EEOP_JSONEXPR_COERCION: Type = 77;
    pub const EEOP_JSONEXPR_COERCION_FINISH: Type = 78;
    pub const EEOP_AGGREF: Type = 79;
    pub const EEOP_GROUPING_FUNC: Type = 80;
    pub const EEOP_WINDOW_FUNC: Type = 81;
    pub const EEOP_MERGE_SUPPORT_FUNC: Type = 82;
    pub const EEOP_SUBPLAN: Type = 83;
    pub const EEOP_AGG_STRICT_DESERIALIZE: Type = 84;
    pub const EEOP_AGG_DESERIALIZE: Type = 85;
    pub const EEOP_AGG_STRICT_INPUT_CHECK_ARGS: Type = 86;
    pub const EEOP_AGG_STRICT_INPUT_CHECK_NULLS: Type = 87;
    pub const EEOP_AGG_PLAIN_PERGROUP_NULLCHECK: Type = 88;
    pub const EEOP_AGG_PLAIN_TRANS_INIT_STRICT_BYVAL: Type = 89;
    pub const EEOP_AGG_PLAIN_TRANS_STRICT_BYVAL: Type = 90;
    pub const EEOP_AGG_PLAIN_TRANS_BYVAL: Type = 91;
    pub const EEOP_AGG_PLAIN_TRANS_INIT_STRICT_BYREF: Type = 92;
    pub const EEOP_AGG_PLAIN_TRANS_STRICT_BYREF: Type = 93;
    pub const EEOP_AGG_PLAIN_TRANS_BYREF: Type = 94;
    pub const EEOP_AGG_PRESORTED_DISTINCT_SINGLE: Type = 95;
    pub const EEOP_AGG_PRESORTED_DISTINCT_MULTI: Type = 96;
    pub const EEOP_AGG_ORDERED_TRANS_DATUM: Type = 97;
    pub const EEOP_AGG_ORDERED_TRANS_TUPLE: Type = 98;
    pub const EEOP_LAST: Type = 99;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExprEvalStep {
    pub opcode: isize,
    pub resvalue: *mut Datum,
    pub resnull: *mut bool,
    pub d: ExprEvalStep__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ExprEvalStep__bindgen_ty_1 {
    pub fetch: ExprEvalStep__bindgen_ty_1__bindgen_ty_1,
    pub var: ExprEvalStep__bindgen_ty_1__bindgen_ty_2,
    pub wholerow: ExprEvalStep__bindgen_ty_1__bindgen_ty_3,
    pub assign_var: ExprEvalStep__bindgen_ty_1__bindgen_ty_4,
    pub assign_tmp: ExprEvalStep__bindgen_ty_1__bindgen_ty_5,
    pub constval: ExprEvalStep__bindgen_ty_1__bindgen_ty_6,
    pub func: ExprEvalStep__bindgen_ty_1__bindgen_ty_7,
    pub boolexpr: ExprEvalStep__bindgen_ty_1__bindgen_ty_8,
    pub qualexpr: ExprEvalStep__bindgen_ty_1__bindgen_ty_9,
    pub jump: ExprEvalStep__bindgen_ty_1__bindgen_ty_10,
    pub nulltest_row: ExprEvalStep__bindgen_ty_1__bindgen_ty_11,
    pub param: ExprEvalStep__bindgen_ty_1__bindgen_ty_12,
    pub cparam: ExprEvalStep__bindgen_ty_1__bindgen_ty_13,
    pub casetest: ExprEvalStep__bindgen_ty_1__bindgen_ty_14,
    pub make_readonly: ExprEvalStep__bindgen_ty_1__bindgen_ty_15,
    pub iocoerce: ExprEvalStep__bindgen_ty_1__bindgen_ty_16,
    pub sqlvaluefunction: ExprEvalStep__bindgen_ty_1__bindgen_ty_17,
    pub nextvalueexpr: ExprEvalStep__bindgen_ty_1__bindgen_ty_18,
    pub arrayexpr: ExprEvalStep__bindgen_ty_1__bindgen_ty_19,
    pub arraycoerce: ExprEvalStep__bindgen_ty_1__bindgen_ty_20,
    pub row: ExprEvalStep__bindgen_ty_1__bindgen_ty_21,
    pub rowcompare_step: ExprEvalStep__bindgen_ty_1__bindgen_ty_22,
    pub rowcompare_final: ExprEvalStep__bindgen_ty_1__bindgen_ty_23,
    pub minmax: ExprEvalStep__bindgen_ty_1__bindgen_ty_24,
    pub fieldselect: ExprEvalStep__bindgen_ty_1__bindgen_ty_25,
    pub fieldstore: ExprEvalStep__bindgen_ty_1__bindgen_ty_26,
    pub sbsref_subscript: ExprEvalStep__bindgen_ty_1__bindgen_ty_27,
    pub sbsref: ExprEvalStep__bindgen_ty_1__bindgen_ty_28,
    pub domaincheck: ExprEvalStep__bindgen_ty_1__bindgen_ty_29,
    pub convert_rowtype: ExprEvalStep__bindgen_ty_1__bindgen_ty_30,
    pub scalararrayop: ExprEvalStep__bindgen_ty_1__bindgen_ty_31,
    pub hashedscalararrayop: ExprEvalStep__bindgen_ty_1__bindgen_ty_32,
    pub xmlexpr: ExprEvalStep__bindgen_ty_1__bindgen_ty_33,
    pub json_constructor: ExprEvalStep__bindgen_ty_1__bindgen_ty_34,
    pub aggref: ExprEvalStep__bindgen_ty_1__bindgen_ty_35,
    pub grouping_func: ExprEvalStep__bindgen_ty_1__bindgen_ty_36,
    pub window_func: ExprEvalStep__bindgen_ty_1__bindgen_ty_37,
    pub subplan: ExprEvalStep__bindgen_ty_1__bindgen_ty_38,
    pub agg_deserialize: ExprEvalStep__bindgen_ty_1__bindgen_ty_39,
    pub agg_strict_input_check: ExprEvalStep__bindgen_ty_1__bindgen_ty_40,
    pub agg_plain_pergroup_nullcheck: ExprEvalStep__bindgen_ty_1__bindgen_ty_41,
    pub agg_presorted_distinctcheck: ExprEvalStep__bindgen_ty_1__bindgen_ty_42,
    pub agg_trans: ExprEvalStep__bindgen_ty_1__bindgen_ty_43,
    pub is_json: ExprEvalStep__bindgen_ty_1__bindgen_ty_44,
    pub jsonexpr: ExprEvalStep__bindgen_ty_1__bindgen_ty_45,
    pub jsonexpr_coercion: ExprEvalStep__bindgen_ty_1__bindgen_ty_46,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_1 {
    pub last_var: ::core::ffi::c_int,
    pub fixed: bool,
    pub known_desc: TupleDesc,
    pub kind: *const TupleTableSlotOps,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_2 {
    pub attnum: ::core::ffi::c_int,
    pub vartype: Oid,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_3 {
    pub var: *mut Var,
    pub first: bool,
    pub slow: bool,
    pub tupdesc: TupleDesc,
    pub junkFilter: *mut JunkFilter,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_4 {
    pub resultnum: ::core::ffi::c_int,
    pub attnum: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_5 {
    pub resultnum: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_6 {
    pub value: Datum,
    pub isnull: bool,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_7 {
    pub finfo: *mut FmgrInfo,
    pub fcinfo_data: FunctionCallInfo,
    pub fn_addr: PGFunction,
    pub nargs: ::core::ffi::c_int,
    pub make_ro: bool,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_7 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_8 {
    pub anynull: *mut bool,
    pub jumpdone: ::core::ffi::c_int,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_8 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_9 {
    pub jumpdone: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_10 {
    pub jumpdone: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_11 {
    pub rowcache: ExprEvalRowtypeCache,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_11 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_12 {
    pub paramid: ::core::ffi::c_int,
    pub paramtype: Oid,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_12 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_13 {
    pub paramfunc: ExecEvalSubroutine,
    pub paramarg: *mut ::core::ffi::c_void,
    pub paramid: ::core::ffi::c_int,
    pub paramtype: Oid,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_13 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_14 {
    pub value: *mut Datum,
    pub isnull: *mut bool,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_14 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_15 {
    pub value: *mut Datum,
    pub isnull: *mut bool,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_15 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_16 {
    pub finfo_out: *mut FmgrInfo,
    pub fcinfo_data_out: FunctionCallInfo,
    pub finfo_in: *mut FmgrInfo,
    pub fcinfo_data_in: FunctionCallInfo,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_16 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_17 {
    pub svf: *mut SQLValueFunction,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_17 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_18 {
    pub seqid: Oid,
    pub seqtypid: Oid,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_18 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_19 {
    pub elemvalues: *mut Datum,
    pub elemnulls: *mut bool,
    pub nelems: ::core::ffi::c_int,
    pub elemtype: Oid,
    pub elemlength: int16,
    pub elembyval: bool,
    pub elemalign: ::core::ffi::c_char,
    pub multidims: bool,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_19 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_20 {
    pub elemexprstate: *mut ExprState,
    pub resultelemtype: Oid,
    pub amstate: *mut ArrayMapState,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_20 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_21 {
    pub tupdesc: TupleDesc,
    pub elemvalues: *mut Datum,
    pub elemnulls: *mut bool,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_21 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_22 {
    pub finfo: *mut FmgrInfo,
    pub fcinfo_data: FunctionCallInfo,
    pub fn_addr: PGFunction,
    pub jumpnull: ::core::ffi::c_int,
    pub jumpdone: ::core::ffi::c_int,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_22 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_23 {
    pub rctype: RowCompareType::Type,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_23 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_24 {
    pub values: *mut Datum,
    pub nulls: *mut bool,
    pub nelems: ::core::ffi::c_int,
    pub op: MinMaxOp::Type,
    pub finfo: *mut FmgrInfo,
    pub fcinfo_data: FunctionCallInfo,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_24 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_25 {
    pub fieldnum: AttrNumber,
    pub resulttype: Oid,
    pub rowcache: ExprEvalRowtypeCache,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_25 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_26 {
    pub fstore: *mut FieldStore,
    pub rowcache: *mut ExprEvalRowtypeCache,
    pub values: *mut Datum,
    pub nulls: *mut bool,
    pub ncolumns: ::core::ffi::c_int,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_26 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_27 {
    pub subscriptfunc: ExecEvalBoolSubroutine,
    pub state: *mut SubscriptingRefState,
    pub jumpdone: ::core::ffi::c_int,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_27 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_28 {
    pub subscriptfunc: ExecEvalSubroutine,
    pub state: *mut SubscriptingRefState,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_28 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_29 {
    pub constraintname: *mut ::core::ffi::c_char,
    pub checkvalue: *mut Datum,
    pub checknull: *mut bool,
    pub resulttype: Oid,
    pub escontext: *mut ErrorSaveContext,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_29 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_30 {
    pub inputtype: Oid,
    pub outputtype: Oid,
    pub incache: *mut ExprEvalRowtypeCache,
    pub outcache: *mut ExprEvalRowtypeCache,
    pub map: *mut TupleConversionMap,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_30 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_31 {
    pub element_type: Oid,
    pub useOr: bool,
    pub typlen: int16,
    pub typbyval: bool,
    pub typalign: ::core::ffi::c_char,
    pub finfo: *mut FmgrInfo,
    pub fcinfo_data: FunctionCallInfo,
    pub fn_addr: PGFunction,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_31 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_32 {
    pub has_nulls: bool,
    pub inclause: bool,
    pub elements_tab: *mut ScalarArrayOpExprHashTable,
    pub finfo: *mut FmgrInfo,
    pub fcinfo_data: FunctionCallInfo,
    pub saop: *mut ScalarArrayOpExpr,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_32 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_33 {
    pub xexpr: *mut XmlExpr,
    pub named_argvalue: *mut Datum,
    pub named_argnull: *mut bool,
    pub argvalue: *mut Datum,
    pub argnull: *mut bool,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_33 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_34 {
    pub jcstate: *mut JsonConstructorExprState,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_34 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_35 {
    pub aggno: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_36 {
    pub clauses: *mut List,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_36 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_37 {
    pub wfstate: *mut WindowFuncExprState,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_37 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_38 {
    pub sstate: *mut SubPlanState,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_38 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_39 {
    pub fcinfo_data: FunctionCallInfo,
    pub jumpnull: ::core::ffi::c_int,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_39 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_40 {
    pub args: *mut NullableDatum,
    pub nulls: *mut bool,
    pub nargs: ::core::ffi::c_int,
    pub jumpnull: ::core::ffi::c_int,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_40 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_41 {
    pub setoff: ::core::ffi::c_int,
    pub jumpnull: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_42 {
    pub pertrans: AggStatePerTrans,
    pub aggcontext: *mut ExprContext,
    pub jumpdistinct: ::core::ffi::c_int,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_42 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_43 {
    pub pertrans: AggStatePerTrans,
    pub aggcontext: *mut ExprContext,
    pub setno: ::core::ffi::c_int,
    pub transno: ::core::ffi::c_int,
    pub setoff: ::core::ffi::c_int,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_43 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_44 {
    pub pred: *mut JsonIsPredicate,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_44 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_45 {
    pub jsestate: *mut JsonExprState,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_45 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep__bindgen_ty_1__bindgen_ty_46 {
    pub targettype: Oid,
    pub targettypmod: int32,
    pub omit_quotes: bool,
    pub exists_coerce: bool,
    pub exists_cast_to_int: bool,
    pub exists_check_domain: bool,
    pub json_coercion_cache: *mut ::core::ffi::c_void,
    pub escontext: *mut ErrorSaveContext,
}
impl Default for ExprEvalStep__bindgen_ty_1__bindgen_ty_46 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ExprEvalStep__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ExprEvalStep {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubscriptingRefState {
    pub isassignment: bool,
    pub workspace: *mut ::core::ffi::c_void,
    pub numupper: ::core::ffi::c_int,
    pub upperprovided: *mut bool,
    pub upperindex: *mut Datum,
    pub upperindexnull: *mut bool,
    pub numlower: ::core::ffi::c_int,
    pub lowerprovided: *mut bool,
    pub lowerindex: *mut Datum,
    pub lowerindexnull: *mut bool,
    pub replacevalue: Datum,
    pub replacenull: bool,
    pub prevvalue: Datum,
    pub prevnull: bool,
}
impl Default for SubscriptingRefState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SubscriptExecSteps {
    pub sbs_check_subscripts: ExecEvalBoolSubroutine,
    pub sbs_fetch: ExecEvalSubroutine,
    pub sbs_assign: ExecEvalSubroutine,
    pub sbs_fetch_old: ExecEvalSubroutine,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonConstructorExprState {
    pub constructor: *mut JsonConstructorExpr,
    pub arg_values: *mut Datum,
    pub arg_nulls: *mut bool,
    pub arg_types: *mut Oid,
    pub arg_type_cache: *mut JsonConstructorExprState__bindgen_ty_1,
    pub nargs: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonConstructorExprState__bindgen_ty_1 {
    pub category: ::core::ffi::c_int,
    pub outfuncid: Oid,
}
impl Default for JsonConstructorExprState__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for JsonConstructorExprState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod RawParseMode {
    pub type Type = ::core::ffi::c_uint;
    pub const RAW_PARSE_DEFAULT: Type = 0;
    pub const RAW_PARSE_TYPE_NAME: Type = 1;
    pub const RAW_PARSE_PLPGSQL_EXPR: Type = 2;
    pub const RAW_PARSE_PLPGSQL_ASSIGN1: Type = 3;
    pub const RAW_PARSE_PLPGSQL_ASSIGN2: Type = 4;
    pub const RAW_PARSE_PLPGSQL_ASSIGN3: Type = 5;
}
pub mod BackslashQuoteType {
    pub type Type = ::core::ffi::c_uint;
    pub const BACKSLASH_QUOTE_OFF: Type = 0;
    pub const BACKSLASH_QUOTE_ON: Type = 1;
    pub const BACKSLASH_QUOTE_SAFE_ENCODING: Type = 2;
}
pub mod PortalStrategy {
    pub type Type = ::core::ffi::c_uint;
    pub const PORTAL_ONE_SELECT: Type = 0;
    pub const PORTAL_ONE_RETURNING: Type = 1;
    pub const PORTAL_ONE_MOD_WITH: Type = 2;
    pub const PORTAL_UTIL_SELECT: Type = 3;
    pub const PORTAL_MULTI_QUERY: Type = 4;
}
pub mod PortalStatus {
    pub type Type = ::core::ffi::c_uint;
    pub const PORTAL_NEW: Type = 0;
    pub const PORTAL_DEFINED: Type = 1;
    pub const PORTAL_READY: Type = 2;
    pub const PORTAL_ACTIVE: Type = 3;
    pub const PORTAL_DONE: Type = 4;
    pub const PORTAL_FAILED: Type = 5;
}
pub type Portal = *mut PortalData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PortalData {
    pub name: *const ::core::ffi::c_char,
    pub prepStmtName: *const ::core::ffi::c_char,
    pub portalContext: MemoryContext,
    pub resowner: ResourceOwner,
    pub cleanup: ::core::option::Option<unsafe extern "C-unwind" fn(portal: Portal)>,
    pub createSubid: SubTransactionId,
    pub activeSubid: SubTransactionId,
    pub createLevel: ::core::ffi::c_int,
    pub sourceText: *const ::core::ffi::c_char,
    pub commandTag: CommandTag::Type,
    pub qc: QueryCompletion,
    pub stmts: *mut List,
    pub cplan: *mut CachedPlan,
    pub portalParams: ParamListInfo,
    pub queryEnv: *mut QueryEnvironment,
    pub strategy: PortalStrategy::Type,
    pub cursorOptions: ::core::ffi::c_int,
    pub run_once: bool,
    pub status: PortalStatus::Type,
    pub portalPinned: bool,
    pub autoHeld: bool,
    pub queryDesc: *mut QueryDesc,
    pub tupDesc: TupleDesc,
    pub formats: *mut int16,
    pub portalSnapshot: Snapshot,
    pub holdStore: *mut Tuplestorestate,
    pub holdContext: MemoryContext,
    pub holdSnapshot: Snapshot,
    pub atStart: bool,
    pub atEnd: bool,
    pub portalPos: uint64,
    pub creation_time: TimestampTz,
    pub visible: bool,
}
impl Default for PortalData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPITupleTable {
    pub tupdesc: TupleDesc,
    pub vals: *mut HeapTuple,
    pub numvals: uint64,
    pub alloced: uint64,
    pub tuptabcxt: MemoryContext,
    pub next: slist_node,
    pub subid: SubTransactionId,
}
impl Default for SPITupleTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPIPrepareOptions {
    pub parserSetup: ParserSetupHook,
    pub parserSetupArg: *mut ::core::ffi::c_void,
    pub parseMode: RawParseMode::Type,
    pub cursorOptions: ::core::ffi::c_int,
}
impl Default for SPIPrepareOptions {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPIExecuteOptions {
    pub params: ParamListInfo,
    pub read_only: bool,
    pub allow_nonatomic: bool,
    pub must_return_tuples: bool,
    pub tcount: uint64,
    pub dest: *mut DestReceiver,
    pub owner: ResourceOwner,
}
impl Default for SPIExecuteOptions {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPIParseOpenOptions {
    pub params: ParamListInfo,
    pub cursorOptions: ::core::ffi::c_int,
    pub read_only: bool,
}
impl Default for SPIParseOpenOptions {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SPI_plan {
    _unused: [u8; 0],
}
pub type SPIPlanPtr = *mut _SPI_plan;
pub type Relids = *mut Bitmapset;
pub mod CostSelector {
    pub type Type = ::core::ffi::c_uint;
    pub const STARTUP_COST: Type = 0;
    pub const TOTAL_COST: Type = 1;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct QualCost {
    pub startup: Cost,
    pub per_tuple: Cost,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AggClauseCosts {
    pub transCost: QualCost,
    pub finalCost: QualCost,
    pub transitionSpace: Size,
}
pub mod UpperRelationKind {
    pub type Type = ::core::ffi::c_uint;
    pub const UPPERREL_SETOP: Type = 0;
    pub const UPPERREL_PARTIAL_GROUP_AGG: Type = 1;
    pub const UPPERREL_GROUP_AGG: Type = 2;
    pub const UPPERREL_WINDOW: Type = 3;
    pub const UPPERREL_PARTIAL_DISTINCT: Type = 4;
    pub const UPPERREL_DISTINCT: Type = 5;
    pub const UPPERREL_ORDERED: Type = 6;
    pub const UPPERREL_FINAL: Type = 7;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlannerGlobal {
    pub type_: NodeTag,
    pub boundParams: ParamListInfo,
    pub subplans: *mut List,
    pub subpaths: *mut List,
    pub subroots: *mut List,
    pub rewindPlanIDs: *mut Bitmapset,
    pub finalrtable: *mut List,
    pub finalrteperminfos: *mut List,
    pub finalrowmarks: *mut List,
    pub resultRelations: *mut List,
    pub appendRelations: *mut List,
    pub relationOids: *mut List,
    pub invalItems: *mut List,
    pub paramExecTypes: *mut List,
    pub lastPHId: Index,
    pub lastRowMarkId: Index,
    pub lastPlanNodeId: ::core::ffi::c_int,
    pub transientPlan: bool,
    pub dependsOnRole: bool,
    pub parallelModeOK: bool,
    pub parallelModeNeeded: bool,
    pub maxParallelHazard: ::core::ffi::c_char,
    pub partition_directory: PartitionDirectory,
}
impl Default for PlannerGlobal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlannerInfo {
    pub type_: NodeTag,
    pub parse: *mut Query,
    pub glob: *mut PlannerGlobal,
    pub query_level: Index,
    pub parent_root: *mut PlannerInfo,
    pub plan_params: *mut List,
    pub outer_params: *mut Bitmapset,
    pub simple_rel_array: *mut *mut RelOptInfo,
    pub simple_rel_array_size: ::core::ffi::c_int,
    pub simple_rte_array: *mut *mut RangeTblEntry,
    pub append_rel_array: *mut *mut AppendRelInfo,
    pub all_baserels: Relids,
    pub outer_join_rels: Relids,
    pub all_query_rels: Relids,
    pub join_rel_list: *mut List,
    pub join_rel_hash: *mut HTAB,
    pub join_rel_level: *mut *mut List,
    pub join_cur_level: ::core::ffi::c_int,
    pub init_plans: *mut List,
    pub cte_plan_ids: *mut List,
    pub multiexpr_params: *mut List,
    pub join_domains: *mut List,
    pub eq_classes: *mut List,
    pub ec_merging_done: bool,
    pub canon_pathkeys: *mut List,
    pub left_join_clauses: *mut List,
    pub right_join_clauses: *mut List,
    pub full_join_clauses: *mut List,
    pub join_info_list: *mut List,
    pub last_rinfo_serial: ::core::ffi::c_int,
    pub all_result_relids: Relids,
    pub leaf_result_relids: Relids,
    pub append_rel_list: *mut List,
    pub row_identity_vars: *mut List,
    pub rowMarks: *mut List,
    pub placeholder_list: *mut List,
    pub placeholder_array: *mut *mut PlaceHolderInfo,
    pub placeholder_array_size: ::core::ffi::c_int,
    pub fkey_list: *mut List,
    pub query_pathkeys: *mut List,
    pub group_pathkeys: *mut List,
    pub num_groupby_pathkeys: ::core::ffi::c_int,
    pub window_pathkeys: *mut List,
    pub distinct_pathkeys: *mut List,
    pub sort_pathkeys: *mut List,
    pub setop_pathkeys: *mut List,
    pub part_schemes: *mut List,
    pub initial_rels: *mut List,
    pub upper_rels: [*mut List; 8usize],
    pub upper_targets: [*mut PathTarget; 8usize],
    pub processed_groupClause: *mut List,
    pub processed_distinctClause: *mut List,
    pub processed_tlist: *mut List,
    pub update_colnos: *mut List,
    pub grouping_map: *mut AttrNumber,
    pub minmax_aggs: *mut List,
    pub planner_cxt: MemoryContext,
    pub total_table_pages: Cardinality,
    pub tuple_fraction: Selectivity,
    pub limit_tuples: Cardinality,
    pub qual_security_level: Index,
    pub hasJoinRTEs: bool,
    pub hasLateralRTEs: bool,
    pub hasHavingQual: bool,
    pub hasPseudoConstantQuals: bool,
    pub hasAlternativeSubPlans: bool,
    pub placeholdersFrozen: bool,
    pub hasRecursion: bool,
    pub agginfos: *mut List,
    pub aggtransinfos: *mut List,
    pub numOrderedAggs: ::core::ffi::c_int,
    pub hasNonPartialAggs: bool,
    pub hasNonSerialAggs: bool,
    pub wt_param_id: ::core::ffi::c_int,
    pub non_recursive_path: *mut Path,
    pub curOuterRels: Relids,
    pub curOuterParams: *mut List,
    pub isAltSubplan: *mut bool,
    pub isUsedSubplan: *mut bool,
    pub join_search_private: *mut ::core::ffi::c_void,
    pub partColsUpdated: bool,
}
impl Default for PlannerInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionSchemeData {
    pub strategy: ::core::ffi::c_char,
    pub partnatts: int16,
    pub partopfamily: *mut Oid,
    pub partopcintype: *mut Oid,
    pub partcollation: *mut Oid,
    pub parttyplen: *mut int16,
    pub parttypbyval: *mut bool,
    pub partsupfunc: *mut FmgrInfo,
}
impl Default for PartitionSchemeData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PartitionScheme = *mut PartitionSchemeData;
pub mod RelOptKind {
    pub type Type = ::core::ffi::c_uint;
    pub const RELOPT_BASEREL: Type = 0;
    pub const RELOPT_JOINREL: Type = 1;
    pub const RELOPT_OTHER_MEMBER_REL: Type = 2;
    pub const RELOPT_OTHER_JOINREL: Type = 3;
    pub const RELOPT_UPPER_REL: Type = 4;
    pub const RELOPT_OTHER_UPPER_REL: Type = 5;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RelOptInfo {
    pub type_: NodeTag,
    pub reloptkind: RelOptKind::Type,
    pub relids: Relids,
    pub rows: Cardinality,
    pub consider_startup: bool,
    pub consider_param_startup: bool,
    pub consider_parallel: bool,
    pub reltarget: *mut PathTarget,
    pub pathlist: *mut List,
    pub ppilist: *mut List,
    pub partial_pathlist: *mut List,
    pub cheapest_startup_path: *mut Path,
    pub cheapest_total_path: *mut Path,
    pub cheapest_unique_path: *mut Path,
    pub cheapest_parameterized_paths: *mut List,
    pub direct_lateral_relids: Relids,
    pub lateral_relids: Relids,
    pub relid: Index,
    pub reltablespace: Oid,
    pub rtekind: RTEKind::Type,
    pub min_attr: AttrNumber,
    pub max_attr: AttrNumber,
    pub attr_needed: *mut Relids,
    pub attr_widths: *mut int32,
    pub notnullattnums: *mut Bitmapset,
    pub nulling_relids: Relids,
    pub lateral_vars: *mut List,
    pub lateral_referencers: Relids,
    pub indexlist: *mut List,
    pub statlist: *mut List,
    pub pages: BlockNumber,
    pub tuples: Cardinality,
    pub allvisfrac: f64,
    pub eclass_indexes: *mut Bitmapset,
    pub subroot: *mut PlannerInfo,
    pub subplan_params: *mut List,
    pub rel_parallel_workers: ::core::ffi::c_int,
    pub amflags: uint32,
    pub serverid: Oid,
    pub userid: Oid,
    pub useridiscurrent: bool,
    pub fdwroutine: *mut FdwRoutine,
    pub fdw_private: *mut ::core::ffi::c_void,
    pub unique_for_rels: *mut List,
    pub non_unique_for_rels: *mut List,
    pub baserestrictinfo: *mut List,
    pub baserestrictcost: QualCost,
    pub baserestrict_min_security: Index,
    pub joininfo: *mut List,
    pub has_eclass_joins: bool,
    pub consider_partitionwise_join: bool,
    pub parent: *mut RelOptInfo,
    pub top_parent: *mut RelOptInfo,
    pub top_parent_relids: Relids,
    pub part_scheme: PartitionScheme,
    pub nparts: ::core::ffi::c_int,
    pub boundinfo: *mut PartitionBoundInfoData,
    pub partbounds_merged: bool,
    pub partition_qual: *mut List,
    pub part_rels: *mut *mut RelOptInfo,
    pub live_parts: *mut Bitmapset,
    pub all_partrels: Relids,
    pub partexprs: *mut *mut List,
    pub nullable_partexprs: *mut *mut List,
}
impl Default for RelOptInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexOptInfo {
    pub type_: NodeTag,
    pub indexoid: Oid,
    pub reltablespace: Oid,
    pub rel: *mut RelOptInfo,
    pub pages: BlockNumber,
    pub tuples: Cardinality,
    pub tree_height: ::core::ffi::c_int,
    pub ncolumns: ::core::ffi::c_int,
    pub nkeycolumns: ::core::ffi::c_int,
    pub indexkeys: *mut ::core::ffi::c_int,
    pub indexcollations: *mut Oid,
    pub opfamily: *mut Oid,
    pub opcintype: *mut Oid,
    pub sortopfamily: *mut Oid,
    pub reverse_sort: *mut bool,
    pub nulls_first: *mut bool,
    pub opclassoptions: *mut *mut bytea,
    pub canreturn: *mut bool,
    pub relam: Oid,
    pub indexprs: *mut List,
    pub indpred: *mut List,
    pub indextlist: *mut List,
    pub indrestrictinfo: *mut List,
    pub predOK: bool,
    pub unique: bool,
    pub immediate: bool,
    pub hypothetical: bool,
    pub amcanorderbyop: bool,
    pub amoptionalkey: bool,
    pub amsearcharray: bool,
    pub amsearchnulls: bool,
    pub amhasgettuple: bool,
    pub amhasgetbitmap: bool,
    pub amcanparallel: bool,
    pub amcanmarkpos: bool,
    pub amcostestimate: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            arg1: *mut PlannerInfo,
            arg2: *mut IndexPath,
            arg3: f64,
            arg4: *mut Cost,
            arg5: *mut Cost,
            arg6: *mut Selectivity,
            arg7: *mut f64,
            arg8: *mut f64,
        ),
    >,
}
impl Default for IndexOptInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForeignKeyOptInfo {
    pub type_: NodeTag,
    pub con_relid: Index,
    pub ref_relid: Index,
    pub nkeys: ::core::ffi::c_int,
    pub conkey: [AttrNumber; 32usize],
    pub confkey: [AttrNumber; 32usize],
    pub conpfeqop: [Oid; 32usize],
    pub nmatched_ec: ::core::ffi::c_int,
    pub nconst_ec: ::core::ffi::c_int,
    pub nmatched_rcols: ::core::ffi::c_int,
    pub nmatched_ri: ::core::ffi::c_int,
    pub eclass: [*mut EquivalenceClass; 32usize],
    pub fk_eclass_member: [*mut EquivalenceMember; 32usize],
    pub rinfos: [*mut List; 32usize],
}
impl Default for ForeignKeyOptInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StatisticExtInfo {
    pub type_: NodeTag,
    pub statOid: Oid,
    pub inherit: bool,
    pub rel: *mut RelOptInfo,
    pub kind: ::core::ffi::c_char,
    pub keys: *mut Bitmapset,
    pub exprs: *mut List,
}
impl Default for StatisticExtInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JoinDomain {
    pub type_: NodeTag,
    pub jd_relids: Relids,
}
impl Default for JoinDomain {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EquivalenceClass {
    pub type_: NodeTag,
    pub ec_opfamilies: *mut List,
    pub ec_collation: Oid,
    pub ec_members: *mut List,
    pub ec_sources: *mut List,
    pub ec_derives: *mut List,
    pub ec_relids: Relids,
    pub ec_has_const: bool,
    pub ec_has_volatile: bool,
    pub ec_broken: bool,
    pub ec_sortref: Index,
    pub ec_min_security: Index,
    pub ec_max_security: Index,
    pub ec_merged: *mut EquivalenceClass,
}
impl Default for EquivalenceClass {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EquivalenceMember {
    pub type_: NodeTag,
    pub em_expr: *mut Expr,
    pub em_relids: Relids,
    pub em_is_const: bool,
    pub em_is_child: bool,
    pub em_datatype: Oid,
    pub em_jdomain: *mut JoinDomain,
    pub em_parent: *mut EquivalenceMember,
}
impl Default for EquivalenceMember {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PathKey {
    pub type_: NodeTag,
    pub pk_eclass: *mut EquivalenceClass,
    pub pk_opfamily: Oid,
    pub pk_strategy: ::core::ffi::c_int,
    pub pk_nulls_first: bool,
}
impl Default for PathKey {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupByOrdering {
    pub type_: NodeTag,
    pub pathkeys: *mut List,
    pub clauses: *mut List,
}
impl Default for GroupByOrdering {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod VolatileFunctionStatus {
    pub type Type = ::core::ffi::c_uint;
    pub const VOLATILITY_UNKNOWN: Type = 0;
    pub const VOLATILITY_VOLATILE: Type = 1;
    pub const VOLATILITY_NOVOLATILE: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PathTarget {
    pub type_: NodeTag,
    pub exprs: *mut List,
    pub sortgrouprefs: *mut Index,
    pub cost: QualCost,
    pub width: ::core::ffi::c_int,
    pub has_volatile_expr: VolatileFunctionStatus::Type,
}
impl Default for PathTarget {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParamPathInfo {
    pub type_: NodeTag,
    pub ppi_req_outer: Relids,
    pub ppi_rows: Cardinality,
    pub ppi_clauses: *mut List,
    pub ppi_serials: *mut Bitmapset,
}
impl Default for ParamPathInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Path {
    pub type_: NodeTag,
    pub pathtype: NodeTag,
    pub parent: *mut RelOptInfo,
    pub pathtarget: *mut PathTarget,
    pub param_info: *mut ParamPathInfo,
    pub parallel_aware: bool,
    pub parallel_safe: bool,
    pub parallel_workers: ::core::ffi::c_int,
    pub rows: Cardinality,
    pub startup_cost: Cost,
    pub total_cost: Cost,
    pub pathkeys: *mut List,
}
impl Default for Path {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexPath {
    pub path: Path,
    pub indexinfo: *mut IndexOptInfo,
    pub indexclauses: *mut List,
    pub indexorderbys: *mut List,
    pub indexorderbycols: *mut List,
    pub indexscandir: ScanDirection::Type,
    pub indextotalcost: Cost,
    pub indexselectivity: Selectivity,
}
impl Default for IndexPath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexClause {
    pub type_: NodeTag,
    pub rinfo: *mut RestrictInfo,
    pub indexquals: *mut List,
    pub lossy: bool,
    pub indexcol: AttrNumber,
    pub indexcols: *mut List,
}
impl Default for IndexClause {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapHeapPath {
    pub path: Path,
    pub bitmapqual: *mut Path,
}
impl Default for BitmapHeapPath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapAndPath {
    pub path: Path,
    pub bitmapquals: *mut List,
    pub bitmapselectivity: Selectivity,
}
impl Default for BitmapAndPath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapOrPath {
    pub path: Path,
    pub bitmapquals: *mut List,
    pub bitmapselectivity: Selectivity,
}
impl Default for BitmapOrPath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TidPath {
    pub path: Path,
    pub tidquals: *mut List,
}
impl Default for TidPath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TidRangePath {
    pub path: Path,
    pub tidrangequals: *mut List,
}
impl Default for TidRangePath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubqueryScanPath {
    pub path: Path,
    pub subpath: *mut Path,
}
impl Default for SubqueryScanPath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForeignPath {
    pub path: Path,
    pub fdw_outerpath: *mut Path,
    pub fdw_restrictinfo: *mut List,
    pub fdw_private: *mut List,
}
impl Default for ForeignPath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomPath {
    pub path: Path,
    pub flags: uint32,
    pub custom_paths: *mut List,
    pub custom_restrictinfo: *mut List,
    pub custom_private: *mut List,
    pub methods: *const CustomPathMethods,
}
impl Default for CustomPath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AppendPath {
    pub path: Path,
    pub subpaths: *mut List,
    pub first_partial_path: ::core::ffi::c_int,
    pub limit_tuples: Cardinality,
}
impl Default for AppendPath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeAppendPath {
    pub path: Path,
    pub subpaths: *mut List,
    pub limit_tuples: Cardinality,
}
impl Default for MergeAppendPath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupResultPath {
    pub path: Path,
    pub quals: *mut List,
}
impl Default for GroupResultPath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MaterialPath {
    pub path: Path,
    pub subpath: *mut Path,
}
impl Default for MaterialPath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoizePath {
    pub path: Path,
    pub subpath: *mut Path,
    pub hash_operators: *mut List,
    pub param_exprs: *mut List,
    pub singlerow: bool,
    pub binary_mode: bool,
    pub calls: Cardinality,
    pub est_entries: uint32,
}
impl Default for MemoizePath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod UniquePathMethod {
    pub type Type = ::core::ffi::c_uint;
    pub const UNIQUE_PATH_NOOP: Type = 0;
    pub const UNIQUE_PATH_HASH: Type = 1;
    pub const UNIQUE_PATH_SORT: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UniquePath {
    pub path: Path,
    pub subpath: *mut Path,
    pub umethod: UniquePathMethod::Type,
    pub in_operators: *mut List,
    pub uniq_exprs: *mut List,
}
impl Default for UniquePath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GatherPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub single_copy: bool,
    pub num_workers: ::core::ffi::c_int,
}
impl Default for GatherPath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GatherMergePath {
    pub path: Path,
    pub subpath: *mut Path,
    pub num_workers: ::core::ffi::c_int,
}
impl Default for GatherMergePath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JoinPath {
    pub path: Path,
    pub jointype: JoinType::Type,
    pub inner_unique: bool,
    pub outerjoinpath: *mut Path,
    pub innerjoinpath: *mut Path,
    pub joinrestrictinfo: *mut List,
}
impl Default for JoinPath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NestPath {
    pub jpath: JoinPath,
}
impl Default for NestPath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergePath {
    pub jpath: JoinPath,
    pub path_mergeclauses: *mut List,
    pub outersortkeys: *mut List,
    pub innersortkeys: *mut List,
    pub skip_mark_restore: bool,
    pub materialize_inner: bool,
}
impl Default for MergePath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashPath {
    pub jpath: JoinPath,
    pub path_hashclauses: *mut List,
    pub num_batches: ::core::ffi::c_int,
    pub inner_rows_total: Cardinality,
}
impl Default for HashPath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProjectionPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub dummypp: bool,
}
impl Default for ProjectionPath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProjectSetPath {
    pub path: Path,
    pub subpath: *mut Path,
}
impl Default for ProjectSetPath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SortPath {
    pub path: Path,
    pub subpath: *mut Path,
}
impl Default for SortPath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IncrementalSortPath {
    pub spath: SortPath,
    pub nPresortedCols: ::core::ffi::c_int,
}
impl Default for IncrementalSortPath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub groupClause: *mut List,
    pub qual: *mut List,
}
impl Default for GroupPath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UpperUniquePath {
    pub path: Path,
    pub subpath: *mut Path,
    pub numkeys: ::core::ffi::c_int,
}
impl Default for UpperUniquePath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub aggstrategy: AggStrategy::Type,
    pub aggsplit: AggSplit::Type,
    pub numGroups: Cardinality,
    pub transitionSpace: uint64,
    pub groupClause: *mut List,
    pub qual: *mut List,
}
impl Default for AggPath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupingSetData {
    pub type_: NodeTag,
    pub set: *mut List,
    pub numGroups: Cardinality,
}
impl Default for GroupingSetData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RollupData {
    pub type_: NodeTag,
    pub groupClause: *mut List,
    pub gsets: *mut List,
    pub gsets_data: *mut List,
    pub numGroups: Cardinality,
    pub hashable: bool,
    pub is_hashed: bool,
}
impl Default for RollupData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupingSetsPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub aggstrategy: AggStrategy::Type,
    pub rollups: *mut List,
    pub qual: *mut List,
    pub transitionSpace: uint64,
}
impl Default for GroupingSetsPath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MinMaxAggPath {
    pub path: Path,
    pub mmaggregates: *mut List,
    pub quals: *mut List,
}
impl Default for MinMaxAggPath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowAggPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub winclause: *mut WindowClause,
    pub qual: *mut List,
    pub runCondition: *mut List,
    pub topwindow: bool,
}
impl Default for WindowAggPath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SetOpPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub cmd: SetOpCmd::Type,
    pub strategy: SetOpStrategy::Type,
    pub distinctList: *mut List,
    pub flagColIdx: AttrNumber,
    pub firstFlag: ::core::ffi::c_int,
    pub numGroups: Cardinality,
}
impl Default for SetOpPath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecursiveUnionPath {
    pub path: Path,
    pub leftpath: *mut Path,
    pub rightpath: *mut Path,
    pub distinctList: *mut List,
    pub wtParam: ::core::ffi::c_int,
    pub numGroups: Cardinality,
}
impl Default for RecursiveUnionPath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LockRowsPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub rowMarks: *mut List,
    pub epqParam: ::core::ffi::c_int,
}
impl Default for LockRowsPath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ModifyTablePath {
    pub path: Path,
    pub subpath: *mut Path,
    pub operation: CmdType::Type,
    pub canSetTag: bool,
    pub nominalRelation: Index,
    pub rootRelation: Index,
    pub partColsUpdated: bool,
    pub resultRelations: *mut List,
    pub updateColnosLists: *mut List,
    pub withCheckOptionLists: *mut List,
    pub returningLists: *mut List,
    pub rowMarks: *mut List,
    pub onconflict: *mut OnConflictExpr,
    pub epqParam: ::core::ffi::c_int,
    pub mergeActionLists: *mut List,
    pub mergeJoinConditions: *mut List,
}
impl Default for ModifyTablePath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LimitPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
    pub limitOption: LimitOption::Type,
}
impl Default for LimitPath {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RestrictInfo {
    pub type_: NodeTag,
    pub clause: *mut Expr,
    pub is_pushed_down: bool,
    pub can_join: bool,
    pub pseudoconstant: bool,
    pub has_clone: bool,
    pub is_clone: bool,
    pub leakproof: bool,
    pub has_volatile: VolatileFunctionStatus::Type,
    pub security_level: Index,
    pub num_base_rels: ::core::ffi::c_int,
    pub clause_relids: Relids,
    pub required_relids: Relids,
    pub incompatible_relids: Relids,
    pub outer_relids: Relids,
    pub left_relids: Relids,
    pub right_relids: Relids,
    pub orclause: *mut Expr,
    pub rinfo_serial: ::core::ffi::c_int,
    pub parent_ec: *mut EquivalenceClass,
    pub eval_cost: QualCost,
    pub norm_selec: Selectivity,
    pub outer_selec: Selectivity,
    pub mergeopfamilies: *mut List,
    pub left_ec: *mut EquivalenceClass,
    pub right_ec: *mut EquivalenceClass,
    pub left_em: *mut EquivalenceMember,
    pub right_em: *mut EquivalenceMember,
    pub scansel_cache: *mut List,
    pub outer_is_left: bool,
    pub hashjoinoperator: Oid,
    pub left_bucketsize: Selectivity,
    pub right_bucketsize: Selectivity,
    pub left_mcvfreq: Selectivity,
    pub right_mcvfreq: Selectivity,
    pub left_hasheqoperator: Oid,
    pub right_hasheqoperator: Oid,
}
impl Default for RestrictInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeScanSelCache {
    pub opfamily: Oid,
    pub collation: Oid,
    pub strategy: ::core::ffi::c_int,
    pub nulls_first: bool,
    pub leftstartsel: Selectivity,
    pub leftendsel: Selectivity,
    pub rightstartsel: Selectivity,
    pub rightendsel: Selectivity,
}
impl Default for MergeScanSelCache {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlaceHolderVar {
    pub xpr: Expr,
    pub phexpr: *mut Expr,
    pub phrels: Relids,
    pub phnullingrels: Relids,
    pub phid: Index,
    pub phlevelsup: Index,
}
impl Default for PlaceHolderVar {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SpecialJoinInfo {
    pub type_: NodeTag,
    pub min_lefthand: Relids,
    pub min_righthand: Relids,
    pub syn_lefthand: Relids,
    pub syn_righthand: Relids,
    pub jointype: JoinType::Type,
    pub ojrelid: Index,
    pub commute_above_l: Relids,
    pub commute_above_r: Relids,
    pub commute_below_l: Relids,
    pub commute_below_r: Relids,
    pub lhs_strict: bool,
    pub semi_can_btree: bool,
    pub semi_can_hash: bool,
    pub semi_operators: *mut List,
    pub semi_rhs_exprs: *mut List,
}
impl Default for SpecialJoinInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OuterJoinClauseInfo {
    pub type_: NodeTag,
    pub rinfo: *mut RestrictInfo,
    pub sjinfo: *mut SpecialJoinInfo,
}
impl Default for OuterJoinClauseInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AppendRelInfo {
    pub type_: NodeTag,
    pub parent_relid: Index,
    pub child_relid: Index,
    pub parent_reltype: Oid,
    pub child_reltype: Oid,
    pub translated_vars: *mut List,
    pub num_child_cols: ::core::ffi::c_int,
    pub parent_colnos: *mut AttrNumber,
    pub parent_reloid: Oid,
}
impl Default for AppendRelInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RowIdentityVarInfo {
    pub type_: NodeTag,
    pub rowidvar: *mut Var,
    pub rowidwidth: int32,
    pub rowidname: *mut ::core::ffi::c_char,
    pub rowidrels: Relids,
}
impl Default for RowIdentityVarInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlaceHolderInfo {
    pub type_: NodeTag,
    pub phid: Index,
    pub ph_var: *mut PlaceHolderVar,
    pub ph_eval_at: Relids,
    pub ph_lateral: Relids,
    pub ph_needed: Relids,
    pub ph_width: int32,
}
impl Default for PlaceHolderInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MinMaxAggInfo {
    pub type_: NodeTag,
    pub aggfnoid: Oid,
    pub aggsortop: Oid,
    pub target: *mut Expr,
    pub subroot: *mut PlannerInfo,
    pub path: *mut Path,
    pub pathcost: Cost,
    pub param: *mut Param,
}
impl Default for MinMaxAggInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlannerParamItem {
    pub type_: NodeTag,
    pub item: *mut Node,
    pub paramId: ::core::ffi::c_int,
}
impl Default for PlannerParamItem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SemiAntiJoinFactors {
    pub outer_match_frac: Selectivity,
    pub match_count: Selectivity,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JoinPathExtraData {
    pub restrictlist: *mut List,
    pub mergeclause_list: *mut List,
    pub inner_unique: bool,
    pub sjinfo: *mut SpecialJoinInfo,
    pub semifactors: SemiAntiJoinFactors,
    pub param_source_rels: Relids,
}
impl Default for JoinPathExtraData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod PartitionwiseAggregateType {
    pub type Type = ::core::ffi::c_uint;
    pub const PARTITIONWISE_AGGREGATE_NONE: Type = 0;
    pub const PARTITIONWISE_AGGREGATE_FULL: Type = 1;
    pub const PARTITIONWISE_AGGREGATE_PARTIAL: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupPathExtraData {
    pub flags: ::core::ffi::c_int,
    pub partial_costs_set: bool,
    pub agg_partial_costs: AggClauseCosts,
    pub agg_final_costs: AggClauseCosts,
    pub target_parallel_safe: bool,
    pub havingQual: *mut Node,
    pub targetList: *mut List,
    pub patype: PartitionwiseAggregateType::Type,
}
impl Default for GroupPathExtraData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FinalPathExtraData {
    pub limit_needed: bool,
    pub limit_tuples: Cardinality,
    pub count_est: int64,
    pub offset_est: int64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct JoinCostWorkspace {
    pub startup_cost: Cost,
    pub total_cost: Cost,
    pub run_cost: Cost,
    pub inner_run_cost: Cost,
    pub inner_rescan_run_cost: Cost,
    pub outer_rows: Cardinality,
    pub inner_rows: Cardinality,
    pub outer_skip_rows: Cardinality,
    pub inner_skip_rows: Cardinality,
    pub numbuckets: ::core::ffi::c_int,
    pub numbatches: ::core::ffi::c_int,
    pub inner_rows_total: Cardinality,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggInfo {
    pub type_: NodeTag,
    pub aggrefs: *mut List,
    pub transno: ::core::ffi::c_int,
    pub shareable: bool,
    pub finalfn_oid: Oid,
}
impl Default for AggInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggTransInfo {
    pub type_: NodeTag,
    pub args: *mut List,
    pub aggfilter: *mut Expr,
    pub transfn_oid: Oid,
    pub serialfn_oid: Oid,
    pub deserialfn_oid: Oid,
    pub combinefn_oid: Oid,
    pub aggtranstype: Oid,
    pub aggtranstypmod: int32,
    pub transtypeLen: ::core::ffi::c_int,
    pub transtypeByVal: bool,
    pub aggtransspace: int32,
    pub initValue: Datum,
    pub initValueIsNull: bool,
}
impl Default for AggTransInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type GetForeignRelSize_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        foreigntableid: Oid,
    ),
>;
pub type GetForeignPaths_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        foreigntableid: Oid,
    ),
>;
pub type GetForeignPlan_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        foreigntableid: Oid,
        best_path: *mut ForeignPath,
        tlist: *mut List,
        scan_clauses: *mut List,
        outer_plan: *mut Plan,
    ) -> *mut ForeignScan,
>;
pub type BeginForeignScan_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(node: *mut ForeignScanState, eflags: ::core::ffi::c_int),
>;
pub type IterateForeignScan_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(node: *mut ForeignScanState) -> *mut TupleTableSlot,
>;
pub type RecheckForeignScan_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(node: *mut ForeignScanState, slot: *mut TupleTableSlot) -> bool,
>;
pub type ReScanForeignScan_function =
    ::core::option::Option<unsafe extern "C-unwind" fn(node: *mut ForeignScanState)>;
pub type EndForeignScan_function =
    ::core::option::Option<unsafe extern "C-unwind" fn(node: *mut ForeignScanState)>;
pub type GetForeignJoinPaths_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        root: *mut PlannerInfo,
        joinrel: *mut RelOptInfo,
        outerrel: *mut RelOptInfo,
        innerrel: *mut RelOptInfo,
        jointype: JoinType::Type,
        extra: *mut JoinPathExtraData,
    ),
>;
pub type GetForeignUpperPaths_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        root: *mut PlannerInfo,
        stage: UpperRelationKind::Type,
        input_rel: *mut RelOptInfo,
        output_rel: *mut RelOptInfo,
        extra: *mut ::core::ffi::c_void,
    ),
>;
pub type AddForeignUpdateTargets_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        root: *mut PlannerInfo,
        rtindex: Index,
        target_rte: *mut RangeTblEntry,
        target_relation: Relation,
    ),
>;
pub type PlanForeignModify_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        root: *mut PlannerInfo,
        plan: *mut ModifyTable,
        resultRelation: Index,
        subplan_index: ::core::ffi::c_int,
    ) -> *mut List,
>;
pub type BeginForeignModify_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        mtstate: *mut ModifyTableState,
        rinfo: *mut ResultRelInfo,
        fdw_private: *mut List,
        subplan_index: ::core::ffi::c_int,
        eflags: ::core::ffi::c_int,
    ),
>;
pub type ExecForeignInsert_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        estate: *mut EState,
        rinfo: *mut ResultRelInfo,
        slot: *mut TupleTableSlot,
        planSlot: *mut TupleTableSlot,
    ) -> *mut TupleTableSlot,
>;
pub type ExecForeignBatchInsert_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        estate: *mut EState,
        rinfo: *mut ResultRelInfo,
        slots: *mut *mut TupleTableSlot,
        planSlots: *mut *mut TupleTableSlot,
        numSlots: *mut ::core::ffi::c_int,
    ) -> *mut *mut TupleTableSlot,
>;
pub type GetForeignModifyBatchSize_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(rinfo: *mut ResultRelInfo) -> ::core::ffi::c_int,
>;
pub type ExecForeignUpdate_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        estate: *mut EState,
        rinfo: *mut ResultRelInfo,
        slot: *mut TupleTableSlot,
        planSlot: *mut TupleTableSlot,
    ) -> *mut TupleTableSlot,
>;
pub type ExecForeignDelete_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        estate: *mut EState,
        rinfo: *mut ResultRelInfo,
        slot: *mut TupleTableSlot,
        planSlot: *mut TupleTableSlot,
    ) -> *mut TupleTableSlot,
>;
pub type EndForeignModify_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(estate: *mut EState, rinfo: *mut ResultRelInfo),
>;
pub type BeginForeignInsert_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(mtstate: *mut ModifyTableState, rinfo: *mut ResultRelInfo),
>;
pub type EndForeignInsert_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(estate: *mut EState, rinfo: *mut ResultRelInfo),
>;
pub type IsForeignRelUpdatable_function =
    ::core::option::Option<unsafe extern "C-unwind" fn(rel: Relation) -> ::core::ffi::c_int>;
pub type PlanDirectModify_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        root: *mut PlannerInfo,
        plan: *mut ModifyTable,
        resultRelation: Index,
        subplan_index: ::core::ffi::c_int,
    ) -> bool,
>;
pub type BeginDirectModify_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(node: *mut ForeignScanState, eflags: ::core::ffi::c_int),
>;
pub type IterateDirectModify_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(node: *mut ForeignScanState) -> *mut TupleTableSlot,
>;
pub type EndDirectModify_function =
    ::core::option::Option<unsafe extern "C-unwind" fn(node: *mut ForeignScanState)>;
pub type GetForeignRowMarkType_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        rte: *mut RangeTblEntry,
        strength: LockClauseStrength::Type,
    ) -> RowMarkType::Type,
>;
pub type RefetchForeignRow_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        estate: *mut EState,
        erm: *mut ExecRowMark,
        rowid: Datum,
        slot: *mut TupleTableSlot,
        updated: *mut bool,
    ),
>;
pub type ExplainForeignScan_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(node: *mut ForeignScanState, es: *mut ExplainState),
>;
pub type ExplainForeignModify_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        mtstate: *mut ModifyTableState,
        rinfo: *mut ResultRelInfo,
        fdw_private: *mut List,
        subplan_index: ::core::ffi::c_int,
        es: *mut ExplainState,
    ),
>;
pub type ExplainDirectModify_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(node: *mut ForeignScanState, es: *mut ExplainState),
>;
pub type AcquireSampleRowsFunc = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        relation: Relation,
        elevel: ::core::ffi::c_int,
        rows: *mut HeapTuple,
        targrows: ::core::ffi::c_int,
        totalrows: *mut f64,
        totaldeadrows: *mut f64,
    ) -> ::core::ffi::c_int,
>;
pub type AnalyzeForeignTable_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        relation: Relation,
        func: *mut AcquireSampleRowsFunc,
        totalpages: *mut BlockNumber,
    ) -> bool,
>;
pub type ImportForeignSchema_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(stmt: *mut ImportForeignSchemaStmt, serverOid: Oid) -> *mut List,
>;
pub type ExecForeignTruncate_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(rels: *mut List, behavior: DropBehavior::Type, restart_seqs: bool),
>;
pub type EstimateDSMForeignScan_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(node: *mut ForeignScanState, pcxt: *mut ParallelContext) -> Size,
>;
pub type InitializeDSMForeignScan_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        node: *mut ForeignScanState,
        pcxt: *mut ParallelContext,
        coordinate: *mut ::core::ffi::c_void,
    ),
>;
pub type ReInitializeDSMForeignScan_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        node: *mut ForeignScanState,
        pcxt: *mut ParallelContext,
        coordinate: *mut ::core::ffi::c_void,
    ),
>;
pub type InitializeWorkerForeignScan_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        node: *mut ForeignScanState,
        toc: *mut shm_toc,
        coordinate: *mut ::core::ffi::c_void,
    ),
>;
pub type ShutdownForeignScan_function =
    ::core::option::Option<unsafe extern "C-unwind" fn(node: *mut ForeignScanState)>;
pub type IsForeignScanParallelSafe_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        rte: *mut RangeTblEntry,
    ) -> bool,
>;
pub type ReparameterizeForeignPathByChild_function = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        root: *mut PlannerInfo,
        fdw_private: *mut List,
        child_rel: *mut RelOptInfo,
    ) -> *mut List,
>;
pub type IsForeignPathAsyncCapable_function =
    ::core::option::Option<unsafe extern "C-unwind" fn(path: *mut ForeignPath) -> bool>;
pub type ForeignAsyncRequest_function =
    ::core::option::Option<unsafe extern "C-unwind" fn(areq: *mut AsyncRequest)>;
pub type ForeignAsyncConfigureWait_function =
    ::core::option::Option<unsafe extern "C-unwind" fn(areq: *mut AsyncRequest)>;
pub type ForeignAsyncNotify_function =
    ::core::option::Option<unsafe extern "C-unwind" fn(areq: *mut AsyncRequest)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FdwRoutine {
    pub type_: NodeTag,
    pub GetForeignRelSize: GetForeignRelSize_function,
    pub GetForeignPaths: GetForeignPaths_function,
    pub GetForeignPlan: GetForeignPlan_function,
    pub BeginForeignScan: BeginForeignScan_function,
    pub IterateForeignScan: IterateForeignScan_function,
    pub ReScanForeignScan: ReScanForeignScan_function,
    pub EndForeignScan: EndForeignScan_function,
    pub GetForeignJoinPaths: GetForeignJoinPaths_function,
    pub GetForeignUpperPaths: GetForeignUpperPaths_function,
    pub AddForeignUpdateTargets: AddForeignUpdateTargets_function,
    pub PlanForeignModify: PlanForeignModify_function,
    pub BeginForeignModify: BeginForeignModify_function,
    pub ExecForeignInsert: ExecForeignInsert_function,
    pub ExecForeignBatchInsert: ExecForeignBatchInsert_function,
    pub GetForeignModifyBatchSize: GetForeignModifyBatchSize_function,
    pub ExecForeignUpdate: ExecForeignUpdate_function,
    pub ExecForeignDelete: ExecForeignDelete_function,
    pub EndForeignModify: EndForeignModify_function,
    pub BeginForeignInsert: BeginForeignInsert_function,
    pub EndForeignInsert: EndForeignInsert_function,
    pub IsForeignRelUpdatable: IsForeignRelUpdatable_function,
    pub PlanDirectModify: PlanDirectModify_function,
    pub BeginDirectModify: BeginDirectModify_function,
    pub IterateDirectModify: IterateDirectModify_function,
    pub EndDirectModify: EndDirectModify_function,
    pub GetForeignRowMarkType: GetForeignRowMarkType_function,
    pub RefetchForeignRow: RefetchForeignRow_function,
    pub RecheckForeignScan: RecheckForeignScan_function,
    pub ExplainForeignScan: ExplainForeignScan_function,
    pub ExplainForeignModify: ExplainForeignModify_function,
    pub ExplainDirectModify: ExplainDirectModify_function,
    pub AnalyzeForeignTable: AnalyzeForeignTable_function,
    pub ImportForeignSchema: ImportForeignSchema_function,
    pub ExecForeignTruncate: ExecForeignTruncate_function,
    pub IsForeignScanParallelSafe: IsForeignScanParallelSafe_function,
    pub EstimateDSMForeignScan: EstimateDSMForeignScan_function,
    pub InitializeDSMForeignScan: InitializeDSMForeignScan_function,
    pub ReInitializeDSMForeignScan: ReInitializeDSMForeignScan_function,
    pub InitializeWorkerForeignScan: InitializeWorkerForeignScan_function,
    pub ShutdownForeignScan: ShutdownForeignScan_function,
    pub ReparameterizeForeignPathByChild: ReparameterizeForeignPathByChild_function,
    pub IsForeignPathAsyncCapable: IsForeignPathAsyncCapable_function,
    pub ForeignAsyncRequest: ForeignAsyncRequest_function,
    pub ForeignAsyncConfigureWait: ForeignAsyncConfigureWait_function,
    pub ForeignAsyncNotify: ForeignAsyncNotify_function,
}
impl Default for FdwRoutine {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForeignDataWrapper {
    pub fdwid: Oid,
    pub owner: Oid,
    pub fdwname: *mut ::core::ffi::c_char,
    pub fdwhandler: Oid,
    pub fdwvalidator: Oid,
    pub options: *mut List,
}
impl Default for ForeignDataWrapper {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForeignServer {
    pub serverid: Oid,
    pub fdwid: Oid,
    pub owner: Oid,
    pub servername: *mut ::core::ffi::c_char,
    pub servertype: *mut ::core::ffi::c_char,
    pub serverversion: *mut ::core::ffi::c_char,
    pub options: *mut List,
}
impl Default for ForeignServer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UserMapping {
    pub umid: Oid,
    pub userid: Oid,
    pub serverid: Oid,
    pub options: *mut List,
}
impl Default for UserMapping {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForeignTable {
    pub relid: Oid,
    pub serverid: Oid,
    pub options: *mut List,
}
impl Default for ForeignTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct JitInstrumentation {
    pub created_functions: usize,
    pub generation_counter: instr_time,
    pub deform_counter: instr_time,
    pub inlining_counter: instr_time,
    pub optimization_counter: instr_time,
    pub emission_counter: instr_time,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct SharedJitInstrumentation {
    pub num_workers: ::core::ffi::c_int,
    pub jit_instr: __IncompleteArrayField<JitInstrumentation>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct JitContext {
    pub flags: ::core::ffi::c_int,
    pub instr: JitInstrumentation,
}
pub type JitProviderInit =
    ::core::option::Option<unsafe extern "C-unwind" fn(cb: *mut JitProviderCallbacks)>;
pub type JitProviderResetAfterErrorCB = ::core::option::Option<unsafe extern "C-unwind" fn()>;
pub type JitProviderReleaseContextCB =
    ::core::option::Option<unsafe extern "C-unwind" fn(context: *mut JitContext)>;
pub type JitProviderCompileExprCB =
    ::core::option::Option<unsafe extern "C-unwind" fn(state: *mut ExprState) -> bool>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct JitProviderCallbacks {
    pub reset_after_error: JitProviderResetAfterErrorCB,
    pub release_context: JitProviderReleaseContextCB,
    pub compile_expr: JitProviderCompileExprCB,
}
pub type pg_wchar = ::core::ffi::c_uint;
pub mod pg_enc {
    pub type Type = ::core::ffi::c_uint;
    pub const PG_SQL_ASCII: Type = 0;
    pub const PG_EUC_JP: Type = 1;
    pub const PG_EUC_CN: Type = 2;
    pub const PG_EUC_KR: Type = 3;
    pub const PG_EUC_TW: Type = 4;
    pub const PG_EUC_JIS_2004: Type = 5;
    pub const PG_UTF8: Type = 6;
    pub const PG_MULE_INTERNAL: Type = 7;
    pub const PG_LATIN1: Type = 8;
    pub const PG_LATIN2: Type = 9;
    pub const PG_LATIN3: Type = 10;
    pub const PG_LATIN4: Type = 11;
    pub const PG_LATIN5: Type = 12;
    pub const PG_LATIN6: Type = 13;
    pub const PG_LATIN7: Type = 14;
    pub const PG_LATIN8: Type = 15;
    pub const PG_LATIN9: Type = 16;
    pub const PG_LATIN10: Type = 17;
    pub const PG_WIN1256: Type = 18;
    pub const PG_WIN1258: Type = 19;
    pub const PG_WIN866: Type = 20;
    pub const PG_WIN874: Type = 21;
    pub const PG_KOI8R: Type = 22;
    pub const PG_WIN1251: Type = 23;
    pub const PG_WIN1252: Type = 24;
    pub const PG_ISO_8859_5: Type = 25;
    pub const PG_ISO_8859_6: Type = 26;
    pub const PG_ISO_8859_7: Type = 27;
    pub const PG_ISO_8859_8: Type = 28;
    pub const PG_WIN1250: Type = 29;
    pub const PG_WIN1253: Type = 30;
    pub const PG_WIN1254: Type = 31;
    pub const PG_WIN1255: Type = 32;
    pub const PG_WIN1257: Type = 33;
    pub const PG_KOI8U: Type = 34;
    pub const PG_SJIS: Type = 35;
    pub const PG_BIG5: Type = 36;
    pub const PG_GBK: Type = 37;
    pub const PG_UHC: Type = 38;
    pub const PG_GB18030: Type = 39;
    pub const PG_JOHAB: Type = 40;
    pub const PG_SHIFT_JIS_2004: Type = 41;
    pub const _PG_LAST_ENCODING_: Type = 42;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pg_enc2name {
    pub name: *const ::core::ffi::c_char,
    pub encoding: pg_enc::Type,
}
impl Default for pg_enc2name {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type mb2wchar_with_len_converter = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        from: *const ::core::ffi::c_uchar,
        to: *mut pg_wchar,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
pub type wchar2mb_with_len_converter = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        from: *const pg_wchar,
        to: *mut ::core::ffi::c_uchar,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
pub type mblen_converter = ::core::option::Option<
    unsafe extern "C-unwind" fn(mbstr: *const ::core::ffi::c_uchar) -> ::core::ffi::c_int,
>;
pub type mbdisplaylen_converter = ::core::option::Option<
    unsafe extern "C-unwind" fn(mbstr: *const ::core::ffi::c_uchar) -> ::core::ffi::c_int,
>;
pub type mbcharacter_incrementer = ::core::option::Option<
    unsafe extern "C-unwind" fn(mbstr: *mut ::core::ffi::c_uchar, len: ::core::ffi::c_int) -> bool,
>;
pub type mbchar_verifier = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        mbstr: *const ::core::ffi::c_uchar,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
pub type mbstr_verifier = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        mbstr: *const ::core::ffi::c_uchar,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pg_wchar_tbl {
    pub mb2wchar_with_len: mb2wchar_with_len_converter,
    pub wchar2mb_with_len: wchar2mb_with_len_converter,
    pub mblen: mblen_converter,
    pub dsplen: mbdisplaylen_converter,
    pub mbverifychar: mbchar_verifier,
    pub mbverifystr: mbstr_verifier,
    pub maxmblen: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pg_mb_radix_tree {
    pub chars16: *const uint16,
    pub chars32: *const uint32,
    pub b1root: uint32,
    pub b1_lower: uint8,
    pub b1_upper: uint8,
    pub b2root: uint32,
    pub b2_1_lower: uint8,
    pub b2_1_upper: uint8,
    pub b2_2_lower: uint8,
    pub b2_2_upper: uint8,
    pub b3root: uint32,
    pub b3_1_lower: uint8,
    pub b3_1_upper: uint8,
    pub b3_2_lower: uint8,
    pub b3_2_upper: uint8,
    pub b3_3_lower: uint8,
    pub b3_3_upper: uint8,
    pub b4root: uint32,
    pub b4_1_lower: uint8,
    pub b4_1_upper: uint8,
    pub b4_2_lower: uint8,
    pub b4_2_upper: uint8,
    pub b4_3_lower: uint8,
    pub b4_3_upper: uint8,
    pub b4_4_lower: uint8,
    pub b4_4_upper: uint8,
}
impl Default for pg_mb_radix_tree {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pg_utf_to_local_combined {
    pub utf1: uint32,
    pub utf2: uint32,
    pub code: uint32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pg_local_to_utf_combined {
    pub code: uint32,
    pub utf1: uint32,
    pub utf2: uint32,
}
pub type utf_local_conversion_func =
    ::core::option::Option<unsafe extern "C-unwind" fn(code: uint32) -> uint32>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExtensibleNode {
    pub type_: NodeTag,
    pub extnodename: *const ::core::ffi::c_char,
}
impl Default for ExtensibleNode {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExtensibleNodeMethods {
    pub extnodename: *const ::core::ffi::c_char,
    pub node_size: Size,
    pub nodeCopy: ::core::option::Option<
        unsafe extern "C-unwind" fn(newnode: *mut ExtensibleNode, oldnode: *const ExtensibleNode),
    >,
    pub nodeEqual: ::core::option::Option<
        unsafe extern "C-unwind" fn(a: *const ExtensibleNode, b: *const ExtensibleNode) -> bool,
    >,
    pub nodeOut: ::core::option::Option<
        unsafe extern "C-unwind" fn(str_: *mut StringInfoData, node: *const ExtensibleNode),
    >,
    pub nodeRead: ::core::option::Option<unsafe extern "C-unwind" fn(node: *mut ExtensibleNode)>,
}
impl Default for ExtensibleNodeMethods {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomPathMethods {
    pub CustomName: *const ::core::ffi::c_char,
    pub PlanCustomPath: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            root: *mut PlannerInfo,
            rel: *mut RelOptInfo,
            best_path: *mut CustomPath,
            tlist: *mut List,
            clauses: *mut List,
            custom_plans: *mut List,
        ) -> *mut Plan,
    >,
    pub ReparameterizeCustomPathByChild: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            root: *mut PlannerInfo,
            custom_private: *mut List,
            child_rel: *mut RelOptInfo,
        ) -> *mut List,
    >,
}
impl Default for CustomPathMethods {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomScanMethods {
    pub CustomName: *const ::core::ffi::c_char,
    pub CreateCustomScanState:
        ::core::option::Option<unsafe extern "C-unwind" fn(cscan: *mut CustomScan) -> *mut Node>,
}
impl Default for CustomScanMethods {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomExecMethods {
    pub CustomName: *const ::core::ffi::c_char,
    pub BeginCustomScan: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            node: *mut CustomScanState,
            estate: *mut EState,
            eflags: ::core::ffi::c_int,
        ),
    >,
    pub ExecCustomScan: ::core::option::Option<
        unsafe extern "C-unwind" fn(node: *mut CustomScanState) -> *mut TupleTableSlot,
    >,
    pub EndCustomScan:
        ::core::option::Option<unsafe extern "C-unwind" fn(node: *mut CustomScanState)>,
    pub ReScanCustomScan:
        ::core::option::Option<unsafe extern "C-unwind" fn(node: *mut CustomScanState)>,
    pub MarkPosCustomScan:
        ::core::option::Option<unsafe extern "C-unwind" fn(node: *mut CustomScanState)>,
    pub RestrPosCustomScan:
        ::core::option::Option<unsafe extern "C-unwind" fn(node: *mut CustomScanState)>,
    pub EstimateDSMCustomScan: ::core::option::Option<
        unsafe extern "C-unwind" fn(node: *mut CustomScanState, pcxt: *mut ParallelContext) -> Size,
    >,
    pub InitializeDSMCustomScan: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            node: *mut CustomScanState,
            pcxt: *mut ParallelContext,
            coordinate: *mut ::core::ffi::c_void,
        ),
    >,
    pub ReInitializeDSMCustomScan: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            node: *mut CustomScanState,
            pcxt: *mut ParallelContext,
            coordinate: *mut ::core::ffi::c_void,
        ),
    >,
    pub InitializeWorkerCustomScan: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            node: *mut CustomScanState,
            toc: *mut shm_toc,
            coordinate: *mut ::core::ffi::c_void,
        ),
    >,
    pub ShutdownCustomScan:
        ::core::option::Option<unsafe extern "C-unwind" fn(node: *mut CustomScanState)>,
    pub ExplainCustomScan: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            node: *mut CustomScanState,
            ancestors: *mut List,
            es: *mut ExplainState,
        ),
    >,
}
impl Default for CustomExecMethods {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type check_function_callback = ::core::option::Option<
    unsafe extern "C-unwind" fn(func_id: Oid, context: *mut ::core::ffi::c_void) -> bool,
>;
pub type tree_walker_callback = ::core::option::Option<
    unsafe extern "C-unwind" fn(node: *mut Node, context: *mut ::core::ffi::c_void) -> bool,
>;
pub type planstate_tree_walker_callback = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        planstate: *mut PlanState,
        context: *mut ::core::ffi::c_void,
    ) -> bool,
>;
pub type tree_mutator_callback = ::core::option::Option<
    unsafe extern "C-unwind" fn(node: *mut Node, context: *mut ::core::ffi::c_void) -> *mut Node,
>;
pub mod ReplicationKind {
    pub type Type = ::core::ffi::c_uint;
    pub const REPLICATION_KIND_PHYSICAL: Type = 0;
    pub const REPLICATION_KIND_LOGICAL: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IdentifySystemCmd {
    pub type_: NodeTag,
}
impl Default for IdentifySystemCmd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BaseBackupCmd {
    pub type_: NodeTag,
    pub options: *mut List,
}
impl Default for BaseBackupCmd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateReplicationSlotCmd {
    pub type_: NodeTag,
    pub slotname: *mut ::core::ffi::c_char,
    pub kind: ReplicationKind::Type,
    pub plugin: *mut ::core::ffi::c_char,
    pub temporary: bool,
    pub options: *mut List,
}
impl Default for CreateReplicationSlotCmd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropReplicationSlotCmd {
    pub type_: NodeTag,
    pub slotname: *mut ::core::ffi::c_char,
    pub wait: bool,
}
impl Default for DropReplicationSlotCmd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterReplicationSlotCmd {
    pub type_: NodeTag,
    pub slotname: *mut ::core::ffi::c_char,
    pub options: *mut List,
}
impl Default for AlterReplicationSlotCmd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StartReplicationCmd {
    pub type_: NodeTag,
    pub kind: ReplicationKind::Type,
    pub slotname: *mut ::core::ffi::c_char,
    pub timeline: TimeLineID,
    pub startpoint: XLogRecPtr,
    pub options: *mut List,
}
impl Default for StartReplicationCmd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReadReplicationSlotCmd {
    pub type_: NodeTag,
    pub slotname: *mut ::core::ffi::c_char,
}
impl Default for ReadReplicationSlotCmd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TimeLineHistoryCmd {
    pub type_: NodeTag,
    pub timeline: TimeLineID,
}
impl Default for TimeLineHistoryCmd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UploadManifestCmd {
    pub type_: NodeTag,
}
impl Default for UploadManifestCmd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SubscriptTransform = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        sbsref: *mut SubscriptingRef,
        indirection: *mut List,
        pstate: *mut ParseState,
        isSlice: bool,
        isAssignment: bool,
    ),
>;
pub type SubscriptExecSetup = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        sbsref: *const SubscriptingRef,
        sbsrefstate: *mut SubscriptingRefState,
        methods: *mut SubscriptExecSteps,
    ),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SubscriptRoutines {
    pub transform: SubscriptTransform,
    pub exec_setup: SubscriptExecSetup,
    pub fetch_strict: bool,
    pub fetch_leakproof: bool,
    pub store_leakproof: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SupportRequestSimplify {
    pub type_: NodeTag,
    pub root: *mut PlannerInfo,
    pub fcall: *mut FuncExpr,
}
impl Default for SupportRequestSimplify {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SupportRequestSelectivity {
    pub type_: NodeTag,
    pub root: *mut PlannerInfo,
    pub funcid: Oid,
    pub args: *mut List,
    pub inputcollid: Oid,
    pub is_join: bool,
    pub varRelid: ::core::ffi::c_int,
    pub jointype: JoinType::Type,
    pub sjinfo: *mut SpecialJoinInfo,
    pub selectivity: Selectivity,
}
impl Default for SupportRequestSelectivity {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SupportRequestCost {
    pub type_: NodeTag,
    pub root: *mut PlannerInfo,
    pub funcid: Oid,
    pub node: *mut Node,
    pub startup: Cost,
    pub per_tuple: Cost,
}
impl Default for SupportRequestCost {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SupportRequestRows {
    pub type_: NodeTag,
    pub root: *mut PlannerInfo,
    pub funcid: Oid,
    pub node: *mut Node,
    pub rows: f64,
}
impl Default for SupportRequestRows {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SupportRequestIndexCondition {
    pub type_: NodeTag,
    pub root: *mut PlannerInfo,
    pub funcid: Oid,
    pub node: *mut Node,
    pub indexarg: ::core::ffi::c_int,
    pub index: *mut IndexOptInfo,
    pub indexcol: ::core::ffi::c_int,
    pub opfamily: Oid,
    pub indexcollation: Oid,
    pub lossy: bool,
}
impl Default for SupportRequestIndexCondition {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SupportRequestWFuncMonotonic {
    pub type_: NodeTag,
    pub window_func: *mut WindowFunc,
    pub window_clause: *mut WindowClause,
    pub monotonic: MonotonicFunction::Type,
}
impl Default for SupportRequestWFuncMonotonic {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SupportRequestOptimizeWindowClause {
    pub type_: NodeTag,
    pub window_func: *mut WindowFunc,
    pub window_clause: *mut WindowClause,
    pub frameOptions: ::core::ffi::c_int,
}
impl Default for SupportRequestOptimizeWindowClause {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowFuncLists {
    pub numWindowFuncs: ::core::ffi::c_int,
    pub maxWinRef: Index,
    pub windowFuncs: *mut *mut List,
}
impl Default for WindowFuncLists {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod ConstraintExclusionType {
    pub type Type = ::core::ffi::c_uint;
    pub const CONSTRAINT_EXCLUSION_OFF: Type = 0;
    pub const CONSTRAINT_EXCLUSION_ON: Type = 1;
    pub const CONSTRAINT_EXCLUSION_PARTITION: Type = 2;
}
pub mod DebugParallelMode {
    pub type Type = ::core::ffi::c_uint;
    pub const DEBUG_PARALLEL_OFF: Type = 0;
    pub const DEBUG_PARALLEL_ON: Type = 1;
    pub const DEBUG_PARALLEL_REGRESS: Type = 2;
}
pub type set_rel_pathlist_hook_type = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        rti: Index,
        rte: *mut RangeTblEntry,
    ),
>;
pub type set_join_pathlist_hook_type = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        root: *mut PlannerInfo,
        joinrel: *mut RelOptInfo,
        outerrel: *mut RelOptInfo,
        innerrel: *mut RelOptInfo,
        jointype: JoinType::Type,
        extra: *mut JoinPathExtraData,
    ),
>;
pub type join_search_hook_type = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        root: *mut PlannerInfo,
        levels_needed: ::core::ffi::c_int,
        initial_rels: *mut List,
    ) -> *mut RelOptInfo,
>;
pub type ec_matches_callback_type = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        ec: *mut EquivalenceClass,
        em: *mut EquivalenceMember,
        arg: *mut ::core::ffi::c_void,
    ) -> bool,
>;
pub mod PathKeysComparison {
    pub type Type = ::core::ffi::c_uint;
    pub const PATHKEYS_EQUAL: Type = 0;
    pub const PATHKEYS_BETTER1: Type = 1;
    pub const PATHKEYS_BETTER2: Type = 2;
    pub const PATHKEYS_DIFFERENT: Type = 3;
}
pub type get_relation_info_hook_type = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        root: *mut PlannerInfo,
        relationObjectId: Oid,
        inhparent: bool,
        rel: *mut RelOptInfo,
    ),
>;
pub type query_pathkeys_callback = ::core::option::Option<
    unsafe extern "C-unwind" fn(root: *mut PlannerInfo, extra: *mut ::core::ffi::c_void),
>;
pub type planner_hook_type = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        parse: *mut Query,
        query_string: *const ::core::ffi::c_char,
        cursorOptions: ::core::ffi::c_int,
        boundParams: ParamListInfo,
    ) -> *mut PlannedStmt,
>;
pub type create_upper_paths_hook_type = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        root: *mut PlannerInfo,
        stage: UpperRelationKind::Type,
        input_rel: *mut RelOptInfo,
        output_rel: *mut RelOptInfo,
        extra: *mut ::core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LocationLen {
    pub location: ::core::ffi::c_int,
    pub length: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JumbleState {
    pub jumble: *mut ::core::ffi::c_uchar,
    pub jumble_len: Size,
    pub clocations: *mut LocationLen,
    pub clocations_buf_size: ::core::ffi::c_int,
    pub clocations_count: ::core::ffi::c_int,
    pub highest_extern_param_id: ::core::ffi::c_int,
}
impl Default for JumbleState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod ComputeQueryIdType {
    pub type Type = ::core::ffi::c_uint;
    pub const COMPUTE_QUERY_ID_OFF: Type = 0;
    pub const COMPUTE_QUERY_ID_ON: Type = 1;
    pub const COMPUTE_QUERY_ID_AUTO: Type = 2;
    pub const COMPUTE_QUERY_ID_REGRESS: Type = 3;
}
pub type post_parse_analyze_hook_type = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        pstate: *mut ParseState,
        query: *mut Query,
        jstate: *mut JumbleState,
    ),
>;
pub mod FuncDetailCode {
    pub type Type = ::core::ffi::c_uint;
    pub const FUNCDETAIL_NOTFOUND: Type = 0;
    pub const FUNCDETAIL_MULTIPLE: Type = 1;
    pub const FUNCDETAIL_NORMAL: Type = 2;
    pub const FUNCDETAIL_PROCEDURE: Type = 3;
    pub const FUNCDETAIL_AGGREGATE: Type = 4;
    pub const FUNCDETAIL_WINDOWFUNC: Type = 5;
    pub const FUNCDETAIL_COERCION: Type = 6;
}
pub type Operator = HeapTuple;
pub type Type = HeapTuple;
pub type TYPCATEGORY = ::core::ffi::c_char;
pub mod CoercionPathType {
    pub type Type = ::core::ffi::c_uint;
    pub const COERCION_PATH_NONE: Type = 0;
    pub const COERCION_PATH_FUNC: Type = 1;
    pub const COERCION_PATH_RELABELTYPE: Type = 2;
    pub const COERCION_PATH_ARRAYCOERCE: Type = 3;
    pub const COERCION_PATH_COERCEVIAIO: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionBoundInfoData {
    pub strategy: PartitionStrategy::Type,
    pub ndatums: ::core::ffi::c_int,
    pub datums: *mut *mut Datum,
    pub kind: *mut *mut PartitionRangeDatumKind::Type,
    pub interleaved_parts: *mut Bitmapset,
    pub nindexes: ::core::ffi::c_int,
    pub indexes: *mut ::core::ffi::c_int,
    pub null_index: ::core::ffi::c_int,
    pub default_index: ::core::ffi::c_int,
}
impl Default for PartitionBoundInfoData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionDescData {
    pub nparts: ::core::ffi::c_int,
    pub detached_exist: bool,
    pub oids: *mut Oid,
    pub is_leaf: *mut bool,
    pub boundinfo: PartitionBoundInfo,
    pub last_found_datum_index: ::core::ffi::c_int,
    pub last_found_part_index: ::core::ffi::c_int,
    pub last_found_count: ::core::ffi::c_int,
}
impl Default for PartitionDescData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionPruneContext {
    pub strategy: ::core::ffi::c_char,
    pub partnatts: ::core::ffi::c_int,
    pub nparts: ::core::ffi::c_int,
    pub boundinfo: PartitionBoundInfo,
    pub partcollation: *mut Oid,
    pub partsupfunc: *mut FmgrInfo,
    pub stepcmpfuncs: *mut FmgrInfo,
    pub ppccontext: MemoryContext,
    pub planstate: *mut PlanState,
    pub exprcontext: *mut ExprContext,
    pub exprstates: *mut *mut ExprState,
}
impl Default for PartitionPruneContext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExpandedRecordHeader {
    pub hdr: ExpandedObjectHeader,
    pub er_magic: ::core::ffi::c_int,
    pub flags: ::core::ffi::c_int,
    pub er_decltypeid: Oid,
    pub er_typeid: Oid,
    pub er_typmod: int32,
    pub er_tupdesc: TupleDesc,
    pub er_tupdesc_id: uint64,
    pub dvalues: *mut Datum,
    pub dnulls: *mut bool,
    pub nfields: ::core::ffi::c_int,
    pub flat_size: Size,
    pub data_len: Size,
    pub hoff: ::core::ffi::c_int,
    pub hasnull: bool,
    pub fvalue: HeapTuple,
    pub fstartptr: *mut ::core::ffi::c_char,
    pub fendptr: *mut ::core::ffi::c_char,
    pub er_short_term_cxt: MemoryContext,
    pub er_dummy_header: *mut ExpandedRecordHeader,
    pub er_domaininfo: *mut ::core::ffi::c_void,
    pub er_mcb: MemoryContextCallback,
}
impl Default for ExpandedRecordHeader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExpandedRecordFieldInfo {
    pub fnumber: ::core::ffi::c_int,
    pub ftypeid: Oid,
    pub ftypmod: int32,
    pub fcollation: Oid,
}
impl Default for ExpandedRecordFieldInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod PLpgSQL_nsitem_type {
    pub type Type = ::core::ffi::c_uint;
    pub const PLPGSQL_NSTYPE_LABEL: Type = 0;
    pub const PLPGSQL_NSTYPE_VAR: Type = 1;
    pub const PLPGSQL_NSTYPE_REC: Type = 2;
}
pub mod PLpgSQL_label_type {
    pub type Type = ::core::ffi::c_uint;
    pub const PLPGSQL_LABEL_BLOCK: Type = 0;
    pub const PLPGSQL_LABEL_LOOP: Type = 1;
    pub const PLPGSQL_LABEL_OTHER: Type = 2;
}
pub mod PLpgSQL_datum_type {
    pub type Type = ::core::ffi::c_uint;
    pub const PLPGSQL_DTYPE_VAR: Type = 0;
    pub const PLPGSQL_DTYPE_ROW: Type = 1;
    pub const PLPGSQL_DTYPE_REC: Type = 2;
    pub const PLPGSQL_DTYPE_RECFIELD: Type = 3;
    pub const PLPGSQL_DTYPE_PROMISE: Type = 4;
}
pub mod PLpgSQL_promise_type {
    pub type Type = ::core::ffi::c_uint;
    pub const PLPGSQL_PROMISE_NONE: Type = 0;
    pub const PLPGSQL_PROMISE_TG_NAME: Type = 1;
    pub const PLPGSQL_PROMISE_TG_WHEN: Type = 2;
    pub const PLPGSQL_PROMISE_TG_LEVEL: Type = 3;
    pub const PLPGSQL_PROMISE_TG_OP: Type = 4;
    pub const PLPGSQL_PROMISE_TG_RELID: Type = 5;
    pub const PLPGSQL_PROMISE_TG_TABLE_NAME: Type = 6;
    pub const PLPGSQL_PROMISE_TG_TABLE_SCHEMA: Type = 7;
    pub const PLPGSQL_PROMISE_TG_NARGS: Type = 8;
    pub const PLPGSQL_PROMISE_TG_ARGV: Type = 9;
    pub const PLPGSQL_PROMISE_TG_EVENT: Type = 10;
    pub const PLPGSQL_PROMISE_TG_TAG: Type = 11;
}
pub mod PLpgSQL_type_type {
    pub type Type = ::core::ffi::c_uint;
    pub const PLPGSQL_TTYPE_SCALAR: Type = 0;
    pub const PLPGSQL_TTYPE_REC: Type = 1;
    pub const PLPGSQL_TTYPE_PSEUDO: Type = 2;
}
pub mod PLpgSQL_stmt_type {
    pub type Type = ::core::ffi::c_uint;
    pub const PLPGSQL_STMT_BLOCK: Type = 0;
    pub const PLPGSQL_STMT_ASSIGN: Type = 1;
    pub const PLPGSQL_STMT_IF: Type = 2;
    pub const PLPGSQL_STMT_CASE: Type = 3;
    pub const PLPGSQL_STMT_LOOP: Type = 4;
    pub const PLPGSQL_STMT_WHILE: Type = 5;
    pub const PLPGSQL_STMT_FORI: Type = 6;
    pub const PLPGSQL_STMT_FORS: Type = 7;
    pub const PLPGSQL_STMT_FORC: Type = 8;
    pub const PLPGSQL_STMT_FOREACH_A: Type = 9;
    pub const PLPGSQL_STMT_EXIT: Type = 10;
    pub const PLPGSQL_STMT_RETURN: Type = 11;
    pub const PLPGSQL_STMT_RETURN_NEXT: Type = 12;
    pub const PLPGSQL_STMT_RETURN_QUERY: Type = 13;
    pub const PLPGSQL_STMT_RAISE: Type = 14;
    pub const PLPGSQL_STMT_ASSERT: Type = 15;
    pub const PLPGSQL_STMT_EXECSQL: Type = 16;
    pub const PLPGSQL_STMT_DYNEXECUTE: Type = 17;
    pub const PLPGSQL_STMT_DYNFORS: Type = 18;
    pub const PLPGSQL_STMT_GETDIAG: Type = 19;
    pub const PLPGSQL_STMT_OPEN: Type = 20;
    pub const PLPGSQL_STMT_FETCH: Type = 21;
    pub const PLPGSQL_STMT_CLOSE: Type = 22;
    pub const PLPGSQL_STMT_PERFORM: Type = 23;
    pub const PLPGSQL_STMT_CALL: Type = 24;
    pub const PLPGSQL_STMT_COMMIT: Type = 25;
    pub const PLPGSQL_STMT_ROLLBACK: Type = 26;
}
pub mod _bindgen_ty_25 {
    pub type Type = ::core::ffi::c_uint;
    pub const PLPGSQL_RC_OK: Type = 0;
    pub const PLPGSQL_RC_EXIT: Type = 1;
    pub const PLPGSQL_RC_RETURN: Type = 2;
    pub const PLPGSQL_RC_CONTINUE: Type = 3;
}
pub mod PLpgSQL_getdiag_kind {
    pub type Type = ::core::ffi::c_uint;
    pub const PLPGSQL_GETDIAG_ROW_COUNT: Type = 0;
    pub const PLPGSQL_GETDIAG_ROUTINE_OID: Type = 1;
    pub const PLPGSQL_GETDIAG_CONTEXT: Type = 2;
    pub const PLPGSQL_GETDIAG_ERROR_CONTEXT: Type = 3;
    pub const PLPGSQL_GETDIAG_ERROR_DETAIL: Type = 4;
    pub const PLPGSQL_GETDIAG_ERROR_HINT: Type = 5;
    pub const PLPGSQL_GETDIAG_RETURNED_SQLSTATE: Type = 6;
    pub const PLPGSQL_GETDIAG_COLUMN_NAME: Type = 7;
    pub const PLPGSQL_GETDIAG_CONSTRAINT_NAME: Type = 8;
    pub const PLPGSQL_GETDIAG_DATATYPE_NAME: Type = 9;
    pub const PLPGSQL_GETDIAG_MESSAGE_TEXT: Type = 10;
    pub const PLPGSQL_GETDIAG_TABLE_NAME: Type = 11;
    pub const PLPGSQL_GETDIAG_SCHEMA_NAME: Type = 12;
}
pub mod PLpgSQL_raise_option_type {
    pub type Type = ::core::ffi::c_uint;
    pub const PLPGSQL_RAISEOPTION_ERRCODE: Type = 0;
    pub const PLPGSQL_RAISEOPTION_MESSAGE: Type = 1;
    pub const PLPGSQL_RAISEOPTION_DETAIL: Type = 2;
    pub const PLPGSQL_RAISEOPTION_HINT: Type = 3;
    pub const PLPGSQL_RAISEOPTION_COLUMN: Type = 4;
    pub const PLPGSQL_RAISEOPTION_CONSTRAINT: Type = 5;
    pub const PLPGSQL_RAISEOPTION_DATATYPE: Type = 6;
    pub const PLPGSQL_RAISEOPTION_TABLE: Type = 7;
    pub const PLPGSQL_RAISEOPTION_SCHEMA: Type = 8;
}
pub mod PLpgSQL_resolve_option {
    pub type Type = ::core::ffi::c_uint;
    pub const PLPGSQL_RESOLVE_ERROR: Type = 0;
    pub const PLPGSQL_RESOLVE_VARIABLE: Type = 1;
    pub const PLPGSQL_RESOLVE_COLUMN: Type = 2;
}
#[doc = " Node and structure definitions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_type {
    pub typname: *mut ::core::ffi::c_char,
    pub typoid: Oid,
    pub ttype: PLpgSQL_type_type::Type,
    pub typlen: int16,
    pub typbyval: bool,
    pub typtype: ::core::ffi::c_char,
    pub collation: Oid,
    pub typisarray: bool,
    pub atttypmod: int32,
    pub origtypname: *mut TypeName,
    pub tcache: *mut TypeCacheEntry,
    pub tupdesc_id: uint64,
}
impl Default for PLpgSQL_type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_expr {
    pub query: *mut ::core::ffi::c_char,
    pub parseMode: RawParseMode::Type,
    pub plan: SPIPlanPtr,
    pub paramnos: *mut Bitmapset,
    pub func: *mut PLpgSQL_function,
    pub ns: *mut PLpgSQL_nsitem,
    pub expr_simple_expr: *mut Expr,
    pub expr_simple_type: Oid,
    pub expr_simple_typmod: int32,
    pub expr_simple_mutable: bool,
    pub target_param: ::core::ffi::c_int,
    pub expr_rw_param: *mut Param,
    pub expr_simple_plansource: *mut CachedPlanSource,
    pub expr_simple_plan: *mut CachedPlan,
    pub expr_simple_plan_lxid: LocalTransactionId,
    pub expr_simple_state: *mut ExprState,
    pub expr_simple_in_use: bool,
    pub expr_simple_lxid: LocalTransactionId,
}
impl Default for PLpgSQL_expr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_datum {
    pub dtype: PLpgSQL_datum_type::Type,
    pub dno: ::core::ffi::c_int,
}
impl Default for PLpgSQL_datum {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_variable {
    pub dtype: PLpgSQL_datum_type::Type,
    pub dno: ::core::ffi::c_int,
    pub refname: *mut ::core::ffi::c_char,
    pub lineno: ::core::ffi::c_int,
    pub isconst: bool,
    pub notnull: bool,
    pub default_val: *mut PLpgSQL_expr,
}
impl Default for PLpgSQL_variable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_var {
    pub dtype: PLpgSQL_datum_type::Type,
    pub dno: ::core::ffi::c_int,
    pub refname: *mut ::core::ffi::c_char,
    pub lineno: ::core::ffi::c_int,
    pub isconst: bool,
    pub notnull: bool,
    pub default_val: *mut PLpgSQL_expr,
    pub datatype: *mut PLpgSQL_type,
    pub cursor_explicit_expr: *mut PLpgSQL_expr,
    pub cursor_explicit_argrow: ::core::ffi::c_int,
    pub cursor_options: ::core::ffi::c_int,
    pub value: Datum,
    pub isnull: bool,
    pub freeval: bool,
    pub promise: PLpgSQL_promise_type::Type,
}
impl Default for PLpgSQL_var {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_row {
    pub dtype: PLpgSQL_datum_type::Type,
    pub dno: ::core::ffi::c_int,
    pub refname: *mut ::core::ffi::c_char,
    pub lineno: ::core::ffi::c_int,
    pub isconst: bool,
    pub notnull: bool,
    pub default_val: *mut PLpgSQL_expr,
    pub rowtupdesc: TupleDesc,
    pub nfields: ::core::ffi::c_int,
    pub fieldnames: *mut *mut ::core::ffi::c_char,
    pub varnos: *mut ::core::ffi::c_int,
}
impl Default for PLpgSQL_row {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_rec {
    pub dtype: PLpgSQL_datum_type::Type,
    pub dno: ::core::ffi::c_int,
    pub refname: *mut ::core::ffi::c_char,
    pub lineno: ::core::ffi::c_int,
    pub isconst: bool,
    pub notnull: bool,
    pub default_val: *mut PLpgSQL_expr,
    pub datatype: *mut PLpgSQL_type,
    pub rectypeid: Oid,
    pub firstfield: ::core::ffi::c_int,
    pub erh: *mut ExpandedRecordHeader,
}
impl Default for PLpgSQL_rec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_recfield {
    pub dtype: PLpgSQL_datum_type::Type,
    pub dno: ::core::ffi::c_int,
    pub fieldname: *mut ::core::ffi::c_char,
    pub recparentno: ::core::ffi::c_int,
    pub nextfield: ::core::ffi::c_int,
    pub rectupledescid: uint64,
    pub finfo: ExpandedRecordFieldInfo,
}
impl Default for PLpgSQL_recfield {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct PLpgSQL_nsitem {
    pub itemtype: PLpgSQL_nsitem_type::Type,
    pub itemno: ::core::ffi::c_int,
    pub prev: *mut PLpgSQL_nsitem,
    pub name: __IncompleteArrayField<::core::ffi::c_char>,
}
impl Default for PLpgSQL_nsitem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt {
    pub cmd_type: PLpgSQL_stmt_type::Type,
    pub lineno: ::core::ffi::c_int,
    pub stmtid: ::core::ffi::c_uint,
}
impl Default for PLpgSQL_stmt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_condition {
    pub sqlerrstate: ::core::ffi::c_int,
    pub condname: *mut ::core::ffi::c_char,
    pub next: *mut PLpgSQL_condition,
}
impl Default for PLpgSQL_condition {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_exception_block {
    pub sqlstate_varno: ::core::ffi::c_int,
    pub sqlerrm_varno: ::core::ffi::c_int,
    pub exc_list: *mut List,
}
impl Default for PLpgSQL_exception_block {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_exception {
    pub lineno: ::core::ffi::c_int,
    pub conditions: *mut PLpgSQL_condition,
    pub action: *mut List,
}
impl Default for PLpgSQL_exception {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_block {
    pub cmd_type: PLpgSQL_stmt_type::Type,
    pub lineno: ::core::ffi::c_int,
    pub stmtid: ::core::ffi::c_uint,
    pub label: *mut ::core::ffi::c_char,
    pub body: *mut List,
    pub n_initvars: ::core::ffi::c_int,
    pub initvarnos: *mut ::core::ffi::c_int,
    pub exceptions: *mut PLpgSQL_exception_block,
}
impl Default for PLpgSQL_stmt_block {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_assign {
    pub cmd_type: PLpgSQL_stmt_type::Type,
    pub lineno: ::core::ffi::c_int,
    pub stmtid: ::core::ffi::c_uint,
    pub varno: ::core::ffi::c_int,
    pub expr: *mut PLpgSQL_expr,
}
impl Default for PLpgSQL_stmt_assign {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_perform {
    pub cmd_type: PLpgSQL_stmt_type::Type,
    pub lineno: ::core::ffi::c_int,
    pub stmtid: ::core::ffi::c_uint,
    pub expr: *mut PLpgSQL_expr,
}
impl Default for PLpgSQL_stmt_perform {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_call {
    pub cmd_type: PLpgSQL_stmt_type::Type,
    pub lineno: ::core::ffi::c_int,
    pub stmtid: ::core::ffi::c_uint,
    pub expr: *mut PLpgSQL_expr,
    pub is_call: bool,
    pub target: *mut PLpgSQL_variable,
}
impl Default for PLpgSQL_stmt_call {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_commit {
    pub cmd_type: PLpgSQL_stmt_type::Type,
    pub lineno: ::core::ffi::c_int,
    pub stmtid: ::core::ffi::c_uint,
    pub chain: bool,
}
impl Default for PLpgSQL_stmt_commit {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_rollback {
    pub cmd_type: PLpgSQL_stmt_type::Type,
    pub lineno: ::core::ffi::c_int,
    pub stmtid: ::core::ffi::c_uint,
    pub chain: bool,
}
impl Default for PLpgSQL_stmt_rollback {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_diag_item {
    pub kind: PLpgSQL_getdiag_kind::Type,
    pub target: ::core::ffi::c_int,
}
impl Default for PLpgSQL_diag_item {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_getdiag {
    pub cmd_type: PLpgSQL_stmt_type::Type,
    pub lineno: ::core::ffi::c_int,
    pub stmtid: ::core::ffi::c_uint,
    pub is_stacked: bool,
    pub diag_items: *mut List,
}
impl Default for PLpgSQL_stmt_getdiag {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_if {
    pub cmd_type: PLpgSQL_stmt_type::Type,
    pub lineno: ::core::ffi::c_int,
    pub stmtid: ::core::ffi::c_uint,
    pub cond: *mut PLpgSQL_expr,
    pub then_body: *mut List,
    pub elsif_list: *mut List,
    pub else_body: *mut List,
}
impl Default for PLpgSQL_stmt_if {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_if_elsif {
    pub lineno: ::core::ffi::c_int,
    pub cond: *mut PLpgSQL_expr,
    pub stmts: *mut List,
}
impl Default for PLpgSQL_if_elsif {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_case {
    pub cmd_type: PLpgSQL_stmt_type::Type,
    pub lineno: ::core::ffi::c_int,
    pub stmtid: ::core::ffi::c_uint,
    pub t_expr: *mut PLpgSQL_expr,
    pub t_varno: ::core::ffi::c_int,
    pub case_when_list: *mut List,
    pub have_else: bool,
    pub else_stmts: *mut List,
}
impl Default for PLpgSQL_stmt_case {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_case_when {
    pub lineno: ::core::ffi::c_int,
    pub expr: *mut PLpgSQL_expr,
    pub stmts: *mut List,
}
impl Default for PLpgSQL_case_when {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_loop {
    pub cmd_type: PLpgSQL_stmt_type::Type,
    pub lineno: ::core::ffi::c_int,
    pub stmtid: ::core::ffi::c_uint,
    pub label: *mut ::core::ffi::c_char,
    pub body: *mut List,
}
impl Default for PLpgSQL_stmt_loop {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_while {
    pub cmd_type: PLpgSQL_stmt_type::Type,
    pub lineno: ::core::ffi::c_int,
    pub stmtid: ::core::ffi::c_uint,
    pub label: *mut ::core::ffi::c_char,
    pub cond: *mut PLpgSQL_expr,
    pub body: *mut List,
}
impl Default for PLpgSQL_stmt_while {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_fori {
    pub cmd_type: PLpgSQL_stmt_type::Type,
    pub lineno: ::core::ffi::c_int,
    pub stmtid: ::core::ffi::c_uint,
    pub label: *mut ::core::ffi::c_char,
    pub var: *mut PLpgSQL_var,
    pub lower: *mut PLpgSQL_expr,
    pub upper: *mut PLpgSQL_expr,
    pub step: *mut PLpgSQL_expr,
    pub reverse: ::core::ffi::c_int,
    pub body: *mut List,
}
impl Default for PLpgSQL_stmt_fori {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_forq {
    pub cmd_type: PLpgSQL_stmt_type::Type,
    pub lineno: ::core::ffi::c_int,
    pub stmtid: ::core::ffi::c_uint,
    pub label: *mut ::core::ffi::c_char,
    pub var: *mut PLpgSQL_variable,
    pub body: *mut List,
}
impl Default for PLpgSQL_stmt_forq {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_fors {
    pub cmd_type: PLpgSQL_stmt_type::Type,
    pub lineno: ::core::ffi::c_int,
    pub stmtid: ::core::ffi::c_uint,
    pub label: *mut ::core::ffi::c_char,
    pub var: *mut PLpgSQL_variable,
    pub body: *mut List,
    pub query: *mut PLpgSQL_expr,
}
impl Default for PLpgSQL_stmt_fors {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_forc {
    pub cmd_type: PLpgSQL_stmt_type::Type,
    pub lineno: ::core::ffi::c_int,
    pub stmtid: ::core::ffi::c_uint,
    pub label: *mut ::core::ffi::c_char,
    pub var: *mut PLpgSQL_variable,
    pub body: *mut List,
    pub curvar: ::core::ffi::c_int,
    pub argquery: *mut PLpgSQL_expr,
}
impl Default for PLpgSQL_stmt_forc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_dynfors {
    pub cmd_type: PLpgSQL_stmt_type::Type,
    pub lineno: ::core::ffi::c_int,
    pub stmtid: ::core::ffi::c_uint,
    pub label: *mut ::core::ffi::c_char,
    pub var: *mut PLpgSQL_variable,
    pub body: *mut List,
    pub query: *mut PLpgSQL_expr,
    pub params: *mut List,
}
impl Default for PLpgSQL_stmt_dynfors {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_foreach_a {
    pub cmd_type: PLpgSQL_stmt_type::Type,
    pub lineno: ::core::ffi::c_int,
    pub stmtid: ::core::ffi::c_uint,
    pub label: *mut ::core::ffi::c_char,
    pub varno: ::core::ffi::c_int,
    pub slice: ::core::ffi::c_int,
    pub expr: *mut PLpgSQL_expr,
    pub body: *mut List,
}
impl Default for PLpgSQL_stmt_foreach_a {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_open {
    pub cmd_type: PLpgSQL_stmt_type::Type,
    pub lineno: ::core::ffi::c_int,
    pub stmtid: ::core::ffi::c_uint,
    pub curvar: ::core::ffi::c_int,
    pub cursor_options: ::core::ffi::c_int,
    pub argquery: *mut PLpgSQL_expr,
    pub query: *mut PLpgSQL_expr,
    pub dynquery: *mut PLpgSQL_expr,
    pub params: *mut List,
}
impl Default for PLpgSQL_stmt_open {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_fetch {
    pub cmd_type: PLpgSQL_stmt_type::Type,
    pub lineno: ::core::ffi::c_int,
    pub stmtid: ::core::ffi::c_uint,
    pub target: *mut PLpgSQL_variable,
    pub curvar: ::core::ffi::c_int,
    pub direction: FetchDirection::Type,
    pub how_many: ::core::ffi::c_long,
    pub expr: *mut PLpgSQL_expr,
    pub is_move: bool,
    pub returns_multiple_rows: bool,
}
impl Default for PLpgSQL_stmt_fetch {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_close {
    pub cmd_type: PLpgSQL_stmt_type::Type,
    pub lineno: ::core::ffi::c_int,
    pub stmtid: ::core::ffi::c_uint,
    pub curvar: ::core::ffi::c_int,
}
impl Default for PLpgSQL_stmt_close {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_exit {
    pub cmd_type: PLpgSQL_stmt_type::Type,
    pub lineno: ::core::ffi::c_int,
    pub stmtid: ::core::ffi::c_uint,
    pub is_exit: bool,
    pub label: *mut ::core::ffi::c_char,
    pub cond: *mut PLpgSQL_expr,
}
impl Default for PLpgSQL_stmt_exit {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_return {
    pub cmd_type: PLpgSQL_stmt_type::Type,
    pub lineno: ::core::ffi::c_int,
    pub stmtid: ::core::ffi::c_uint,
    pub expr: *mut PLpgSQL_expr,
    pub retvarno: ::core::ffi::c_int,
}
impl Default for PLpgSQL_stmt_return {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_return_next {
    pub cmd_type: PLpgSQL_stmt_type::Type,
    pub lineno: ::core::ffi::c_int,
    pub stmtid: ::core::ffi::c_uint,
    pub expr: *mut PLpgSQL_expr,
    pub retvarno: ::core::ffi::c_int,
}
impl Default for PLpgSQL_stmt_return_next {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_return_query {
    pub cmd_type: PLpgSQL_stmt_type::Type,
    pub lineno: ::core::ffi::c_int,
    pub stmtid: ::core::ffi::c_uint,
    pub query: *mut PLpgSQL_expr,
    pub dynquery: *mut PLpgSQL_expr,
    pub params: *mut List,
}
impl Default for PLpgSQL_stmt_return_query {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_raise {
    pub cmd_type: PLpgSQL_stmt_type::Type,
    pub lineno: ::core::ffi::c_int,
    pub stmtid: ::core::ffi::c_uint,
    pub elog_level: ::core::ffi::c_int,
    pub condname: *mut ::core::ffi::c_char,
    pub message: *mut ::core::ffi::c_char,
    pub params: *mut List,
    pub options: *mut List,
}
impl Default for PLpgSQL_stmt_raise {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_raise_option {
    pub opt_type: PLpgSQL_raise_option_type::Type,
    pub expr: *mut PLpgSQL_expr,
}
impl Default for PLpgSQL_raise_option {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_assert {
    pub cmd_type: PLpgSQL_stmt_type::Type,
    pub lineno: ::core::ffi::c_int,
    pub stmtid: ::core::ffi::c_uint,
    pub cond: *mut PLpgSQL_expr,
    pub message: *mut PLpgSQL_expr,
}
impl Default for PLpgSQL_stmt_assert {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_execsql {
    pub cmd_type: PLpgSQL_stmt_type::Type,
    pub lineno: ::core::ffi::c_int,
    pub stmtid: ::core::ffi::c_uint,
    pub sqlstmt: *mut PLpgSQL_expr,
    pub mod_stmt: bool,
    pub mod_stmt_set: bool,
    pub into: bool,
    pub strict: bool,
    pub target: *mut PLpgSQL_variable,
}
impl Default for PLpgSQL_stmt_execsql {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_dynexecute {
    pub cmd_type: PLpgSQL_stmt_type::Type,
    pub lineno: ::core::ffi::c_int,
    pub stmtid: ::core::ffi::c_uint,
    pub query: *mut PLpgSQL_expr,
    pub into: bool,
    pub strict: bool,
    pub target: *mut PLpgSQL_variable,
    pub params: *mut List,
}
impl Default for PLpgSQL_stmt_dynexecute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_func_hashkey {
    pub funcOid: Oid,
    pub isTrigger: bool,
    pub isEventTrigger: bool,
    pub trigOid: Oid,
    pub inputCollation: Oid,
    pub argtypes: [Oid; 100usize],
}
impl Default for PLpgSQL_func_hashkey {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod PLpgSQL_trigtype {
    pub type Type = ::core::ffi::c_uint;
    pub const PLPGSQL_DML_TRIGGER: Type = 0;
    pub const PLPGSQL_EVENT_TRIGGER: Type = 1;
    pub const PLPGSQL_NOT_TRIGGER: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_function {
    pub fn_signature: *mut ::core::ffi::c_char,
    pub fn_oid: Oid,
    pub fn_xmin: TransactionId,
    pub fn_tid: ItemPointerData,
    pub fn_is_trigger: PLpgSQL_trigtype::Type,
    pub fn_input_collation: Oid,
    pub fn_hashkey: *mut PLpgSQL_func_hashkey,
    pub fn_cxt: MemoryContext,
    pub fn_rettype: Oid,
    pub fn_rettyplen: ::core::ffi::c_int,
    pub fn_retbyval: bool,
    pub fn_retistuple: bool,
    pub fn_retisdomain: bool,
    pub fn_retset: bool,
    pub fn_readonly: bool,
    pub fn_prokind: ::core::ffi::c_char,
    pub fn_nargs: ::core::ffi::c_int,
    pub fn_argvarnos: [::core::ffi::c_int; 100usize],
    pub out_param_varno: ::core::ffi::c_int,
    pub found_varno: ::core::ffi::c_int,
    pub new_varno: ::core::ffi::c_int,
    pub old_varno: ::core::ffi::c_int,
    pub resolve_option: PLpgSQL_resolve_option::Type,
    pub print_strict_params: bool,
    pub extra_warnings: ::core::ffi::c_int,
    pub extra_errors: ::core::ffi::c_int,
    pub ndatums: ::core::ffi::c_int,
    pub datums: *mut *mut PLpgSQL_datum,
    pub copiable_size: Size,
    pub action: *mut PLpgSQL_stmt_block,
    pub nstatements: ::core::ffi::c_uint,
    pub requires_procedure_resowner: bool,
    pub cur_estate: *mut PLpgSQL_execstate,
    pub use_count: ::core::ffi::c_ulong,
}
impl Default for PLpgSQL_function {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_execstate {
    pub func: *mut PLpgSQL_function,
    pub trigdata: *mut TriggerData,
    pub evtrigdata: *mut EventTriggerData,
    pub retval: Datum,
    pub retisnull: bool,
    pub rettype: Oid,
    pub fn_rettype: Oid,
    pub retistuple: bool,
    pub retisset: bool,
    pub readonly_func: bool,
    pub atomic: bool,
    pub exitlabel: *mut ::core::ffi::c_char,
    pub cur_error: *mut ErrorData,
    pub tuple_store: *mut Tuplestorestate,
    pub tuple_store_desc: TupleDesc,
    pub tuple_store_cxt: MemoryContext,
    pub tuple_store_owner: ResourceOwner,
    pub rsi: *mut ReturnSetInfo,
    pub found_varno: ::core::ffi::c_int,
    pub ndatums: ::core::ffi::c_int,
    pub datums: *mut *mut PLpgSQL_datum,
    pub datum_context: MemoryContext,
    pub paramLI: ParamListInfo,
    pub simple_eval_estate: *mut EState,
    pub simple_eval_resowner: ResourceOwner,
    pub procedure_resowner: ResourceOwner,
    pub cast_hash: *mut HTAB,
    pub stmt_mcontext: MemoryContext,
    pub stmt_mcontext_parent: MemoryContext,
    pub eval_tuptable: *mut SPITupleTable,
    pub eval_processed: uint64,
    pub eval_econtext: *mut ExprContext,
    pub err_stmt: *mut PLpgSQL_stmt,
    pub err_var: *mut PLpgSQL_variable,
    pub err_text: *const ::core::ffi::c_char,
    pub plugin_info: *mut ::core::ffi::c_void,
}
impl Default for PLpgSQL_execstate {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PLpgSQL_plugin {
    pub func_setup: ::core::option::Option<
        unsafe extern "C-unwind" fn(estate: *mut PLpgSQL_execstate, func: *mut PLpgSQL_function),
    >,
    pub func_beg: ::core::option::Option<
        unsafe extern "C-unwind" fn(estate: *mut PLpgSQL_execstate, func: *mut PLpgSQL_function),
    >,
    pub func_end: ::core::option::Option<
        unsafe extern "C-unwind" fn(estate: *mut PLpgSQL_execstate, func: *mut PLpgSQL_function),
    >,
    pub stmt_beg: ::core::option::Option<
        unsafe extern "C-unwind" fn(estate: *mut PLpgSQL_execstate, stmt: *mut PLpgSQL_stmt),
    >,
    pub stmt_end: ::core::option::Option<
        unsafe extern "C-unwind" fn(estate: *mut PLpgSQL_execstate, stmt: *mut PLpgSQL_stmt),
    >,
    pub error_callback:
        ::core::option::Option<unsafe extern "C-unwind" fn(arg: *mut ::core::ffi::c_void)>,
    pub assign_expr: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            estate: *mut PLpgSQL_execstate,
            target: *mut PLpgSQL_datum,
            expr: *mut PLpgSQL_expr,
        ),
    >,
    pub assign_value: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            estate: *mut PLpgSQL_execstate,
            target: *mut PLpgSQL_datum,
            value: Datum,
            isNull: bool,
            valtype: Oid,
            valtypmod: int32,
        ),
    >,
    pub eval_datum: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            estate: *mut PLpgSQL_execstate,
            datum: *mut PLpgSQL_datum,
            typeId: *mut Oid,
            typetypmod: *mut int32,
            value: *mut Datum,
            isnull: *mut bool,
        ),
    >,
    pub cast_value: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            estate: *mut PLpgSQL_execstate,
            value: Datum,
            isnull: *mut bool,
            valtype: Oid,
            valtypmod: int32,
            reqtype: Oid,
            reqtypmod: int32,
        ) -> Datum,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLword {
    pub ident: *mut ::core::ffi::c_char,
    pub quoted: bool,
}
impl Default for PLword {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLcword {
    pub idents: *mut List,
}
impl Default for PLcword {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLwdatum {
    pub datum: *mut PLpgSQL_datum,
    pub ident: *mut ::core::ffi::c_char,
    pub quoted: bool,
    pub idents: *mut List,
}
impl Default for PLwdatum {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod IdentifierLookup {
    #[doc = " Global variable declarations"]
    pub type Type = ::core::ffi::c_uint;
    pub const IDENTIFIER_LOOKUP_NORMAL: Type = 0;
    pub const IDENTIFIER_LOOKUP_DECLARE: Type = 1;
    pub const IDENTIFIER_LOOKUP_EXPR: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ClientSocket {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct PipeProtoHeader {
    pub nuls: [::core::ffi::c_char; 2usize],
    pub len: uint16,
    pub pid: int32,
    pub flags: bits8,
    pub data: __IncompleteArrayField<::core::ffi::c_char>,
}
#[repr(C)]
pub union PipeProtoChunk {
    pub proto: ::core::mem::ManuallyDrop<PipeProtoHeader>,
    pub filler: ::core::mem::ManuallyDrop<[::core::ffi::c_char; 4096usize]>,
}
impl Default for PipeProtoChunk {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod DebugLogicalRepStreamingMode {
    pub type Type = ::core::ffi::c_uint;
    pub const DEBUG_LOGICAL_REP_STREAMING_BUFFERED: Type = 0;
    pub const DEBUG_LOGICAL_REP_STREAMING_IMMEDIATE: Type = 1;
}
pub mod ReorderBufferChangeType {
    pub type Type = ::core::ffi::c_uint;
    pub const REORDER_BUFFER_CHANGE_INSERT: Type = 0;
    pub const REORDER_BUFFER_CHANGE_UPDATE: Type = 1;
    pub const REORDER_BUFFER_CHANGE_DELETE: Type = 2;
    pub const REORDER_BUFFER_CHANGE_MESSAGE: Type = 3;
    pub const REORDER_BUFFER_CHANGE_INVALIDATION: Type = 4;
    pub const REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT: Type = 5;
    pub const REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID: Type = 6;
    pub const REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID: Type = 7;
    pub const REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT: Type = 8;
    pub const REORDER_BUFFER_CHANGE_INTERNAL_SPEC_CONFIRM: Type = 9;
    pub const REORDER_BUFFER_CHANGE_INTERNAL_SPEC_ABORT: Type = 10;
    pub const REORDER_BUFFER_CHANGE_TRUNCATE: Type = 11;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ReorderBufferChange {
    pub lsn: XLogRecPtr,
    pub action: ReorderBufferChangeType::Type,
    pub txn: *mut ReorderBufferTXN,
    pub origin_id: RepOriginId,
    pub data: ReorderBufferChange__bindgen_ty_1,
    pub node: dlist_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ReorderBufferChange__bindgen_ty_1 {
    pub tp: ReorderBufferChange__bindgen_ty_1__bindgen_ty_1,
    pub truncate: ReorderBufferChange__bindgen_ty_1__bindgen_ty_2,
    pub msg: ReorderBufferChange__bindgen_ty_1__bindgen_ty_3,
    pub snapshot: Snapshot,
    pub command_id: CommandId,
    pub tuplecid: ReorderBufferChange__bindgen_ty_1__bindgen_ty_4,
    pub inval: ReorderBufferChange__bindgen_ty_1__bindgen_ty_5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReorderBufferChange__bindgen_ty_1__bindgen_ty_1 {
    pub rlocator: RelFileLocator,
    pub clear_toast_afterwards: bool,
    pub oldtuple: HeapTuple,
    pub newtuple: HeapTuple,
}
impl Default for ReorderBufferChange__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReorderBufferChange__bindgen_ty_1__bindgen_ty_2 {
    pub nrelids: Size,
    pub cascade: bool,
    pub restart_seqs: bool,
    pub relids: *mut Oid,
}
impl Default for ReorderBufferChange__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReorderBufferChange__bindgen_ty_1__bindgen_ty_3 {
    pub prefix: *mut ::core::ffi::c_char,
    pub message_size: Size,
    pub message: *mut ::core::ffi::c_char,
}
impl Default for ReorderBufferChange__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReorderBufferChange__bindgen_ty_1__bindgen_ty_4 {
    pub locator: RelFileLocator,
    pub tid: ItemPointerData,
    pub cmin: CommandId,
    pub cmax: CommandId,
    pub combocid: CommandId,
}
impl Default for ReorderBufferChange__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReorderBufferChange__bindgen_ty_1__bindgen_ty_5 {
    pub ninvalidations: uint32,
    pub invalidations: *mut SharedInvalidationMessage,
}
impl Default for ReorderBufferChange__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ReorderBufferChange__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ReorderBufferChange {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ReorderBufferTXN {
    pub txn_flags: bits32,
    pub xid: TransactionId,
    pub toplevel_xid: TransactionId,
    pub gid: *mut ::core::ffi::c_char,
    pub first_lsn: XLogRecPtr,
    pub final_lsn: XLogRecPtr,
    pub end_lsn: XLogRecPtr,
    pub toptxn: *mut ReorderBufferTXN,
    pub restart_decoding_lsn: XLogRecPtr,
    pub origin_id: RepOriginId,
    pub origin_lsn: XLogRecPtr,
    pub xact_time: ReorderBufferTXN__bindgen_ty_1,
    pub base_snapshot: Snapshot,
    pub base_snapshot_lsn: XLogRecPtr,
    pub base_snapshot_node: dlist_node,
    pub snapshot_now: Snapshot,
    pub command_id: CommandId,
    pub nentries: uint64,
    pub nentries_mem: uint64,
    pub changes: dlist_head,
    pub tuplecids: dlist_head,
    pub ntuplecids: uint64,
    pub tuplecid_hash: *mut HTAB,
    pub toast_hash: *mut HTAB,
    pub subtxns: dlist_head,
    pub nsubtxns: uint32,
    pub ninvalidations: uint32,
    pub invalidations: *mut SharedInvalidationMessage,
    pub node: dlist_node,
    pub catchange_node: dlist_node,
    pub txn_node: pairingheap_node,
    pub size: Size,
    pub total_size: Size,
    pub concurrent_abort: bool,
    pub output_plugin_private: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ReorderBufferTXN__bindgen_ty_1 {
    pub commit_time: TimestampTz,
    pub prepare_time: TimestampTz,
    pub abort_time: TimestampTz,
}
impl Default for ReorderBufferTXN__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ReorderBufferTXN {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ReorderBufferApplyChangeCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        relation: Relation,
        change: *mut ReorderBufferChange,
    ),
>;
pub type ReorderBufferApplyTruncateCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        nrelations: ::core::ffi::c_int,
        relations: *mut Relation,
        change: *mut ReorderBufferChange,
    ),
>;
pub type ReorderBufferBeginCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(rb: *mut ReorderBuffer, txn: *mut ReorderBufferTXN),
>;
pub type ReorderBufferCommitCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        commit_lsn: XLogRecPtr,
    ),
>;
pub type ReorderBufferMessageCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        message_lsn: XLogRecPtr,
        transactional: bool,
        prefix: *const ::core::ffi::c_char,
        sz: Size,
        message: *const ::core::ffi::c_char,
    ),
>;
pub type ReorderBufferBeginPrepareCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(rb: *mut ReorderBuffer, txn: *mut ReorderBufferTXN),
>;
pub type ReorderBufferPrepareCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        prepare_lsn: XLogRecPtr,
    ),
>;
pub type ReorderBufferCommitPreparedCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        commit_lsn: XLogRecPtr,
    ),
>;
pub type ReorderBufferRollbackPreparedCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        prepare_end_lsn: XLogRecPtr,
        prepare_time: TimestampTz,
    ),
>;
pub type ReorderBufferStreamStartCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        first_lsn: XLogRecPtr,
    ),
>;
pub type ReorderBufferStreamStopCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        last_lsn: XLogRecPtr,
    ),
>;
pub type ReorderBufferStreamAbortCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        abort_lsn: XLogRecPtr,
    ),
>;
pub type ReorderBufferStreamPrepareCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        prepare_lsn: XLogRecPtr,
    ),
>;
pub type ReorderBufferStreamCommitCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        commit_lsn: XLogRecPtr,
    ),
>;
pub type ReorderBufferStreamChangeCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        relation: Relation,
        change: *mut ReorderBufferChange,
    ),
>;
pub type ReorderBufferStreamMessageCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        message_lsn: XLogRecPtr,
        transactional: bool,
        prefix: *const ::core::ffi::c_char,
        sz: Size,
        message: *const ::core::ffi::c_char,
    ),
>;
pub type ReorderBufferStreamTruncateCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        nrelations: ::core::ffi::c_int,
        relations: *mut Relation,
        change: *mut ReorderBufferChange,
    ),
>;
pub type ReorderBufferUpdateProgressTxnCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        lsn: XLogRecPtr,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReorderBuffer {
    pub by_txn: *mut HTAB,
    pub toplevel_by_lsn: dlist_head,
    pub txns_by_base_snapshot_lsn: dlist_head,
    pub catchange_txns: dclist_head,
    pub by_txn_last_xid: TransactionId,
    pub by_txn_last_txn: *mut ReorderBufferTXN,
    pub begin: ReorderBufferBeginCB,
    pub apply_change: ReorderBufferApplyChangeCB,
    pub apply_truncate: ReorderBufferApplyTruncateCB,
    pub commit: ReorderBufferCommitCB,
    pub message: ReorderBufferMessageCB,
    pub begin_prepare: ReorderBufferBeginCB,
    pub prepare: ReorderBufferPrepareCB,
    pub commit_prepared: ReorderBufferCommitPreparedCB,
    pub rollback_prepared: ReorderBufferRollbackPreparedCB,
    pub stream_start: ReorderBufferStreamStartCB,
    pub stream_stop: ReorderBufferStreamStopCB,
    pub stream_abort: ReorderBufferStreamAbortCB,
    pub stream_prepare: ReorderBufferStreamPrepareCB,
    pub stream_commit: ReorderBufferStreamCommitCB,
    pub stream_change: ReorderBufferStreamChangeCB,
    pub stream_message: ReorderBufferStreamMessageCB,
    pub stream_truncate: ReorderBufferStreamTruncateCB,
    pub update_progress_txn: ReorderBufferUpdateProgressTxnCB,
    pub private_data: *mut ::core::ffi::c_void,
    pub output_rewrites: bool,
    pub context: MemoryContext,
    pub change_context: MemoryContext,
    pub txn_context: MemoryContext,
    pub tup_context: MemoryContext,
    pub current_restart_decoding_lsn: XLogRecPtr,
    pub outbuf: *mut ::core::ffi::c_char,
    pub outbufsize: Size,
    pub size: Size,
    pub txn_heap: *mut pairingheap,
    pub spillTxns: int64,
    pub spillCount: int64,
    pub spillBytes: int64,
    pub streamTxns: int64,
    pub streamCount: int64,
    pub streamBytes: int64,
    pub totalTxns: int64,
    pub totalBytes: int64,
}
impl Default for ReorderBuffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod OutputPluginOutputType {
    pub type Type = ::core::ffi::c_uint;
    pub const OUTPUT_PLUGIN_BINARY_OUTPUT: Type = 0;
    pub const OUTPUT_PLUGIN_TEXTUAL_OUTPUT: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OutputPluginOptions {
    pub output_type: OutputPluginOutputType::Type,
    pub receive_rewrites: bool,
}
impl Default for OutputPluginOptions {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type LogicalOutputPluginInit =
    ::core::option::Option<unsafe extern "C-unwind" fn(cb: *mut OutputPluginCallbacks)>;
pub type LogicalDecodeStartupCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        ctx: *mut LogicalDecodingContext,
        options: *mut OutputPluginOptions,
        is_init: bool,
    ),
>;
pub type LogicalDecodeBeginCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(ctx: *mut LogicalDecodingContext, txn: *mut ReorderBufferTXN),
>;
pub type LogicalDecodeChangeCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        ctx: *mut LogicalDecodingContext,
        txn: *mut ReorderBufferTXN,
        relation: Relation,
        change: *mut ReorderBufferChange,
    ),
>;
pub type LogicalDecodeTruncateCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        ctx: *mut LogicalDecodingContext,
        txn: *mut ReorderBufferTXN,
        nrelations: ::core::ffi::c_int,
        relations: *mut Relation,
        change: *mut ReorderBufferChange,
    ),
>;
pub type LogicalDecodeCommitCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        ctx: *mut LogicalDecodingContext,
        txn: *mut ReorderBufferTXN,
        commit_lsn: XLogRecPtr,
    ),
>;
pub type LogicalDecodeMessageCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        ctx: *mut LogicalDecodingContext,
        txn: *mut ReorderBufferTXN,
        message_lsn: XLogRecPtr,
        transactional: bool,
        prefix: *const ::core::ffi::c_char,
        message_size: Size,
        message: *const ::core::ffi::c_char,
    ),
>;
pub type LogicalDecodeFilterByOriginCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(ctx: *mut LogicalDecodingContext, origin_id: RepOriginId) -> bool,
>;
pub type LogicalDecodeShutdownCB =
    ::core::option::Option<unsafe extern "C-unwind" fn(ctx: *mut LogicalDecodingContext)>;
pub type LogicalDecodeFilterPrepareCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        ctx: *mut LogicalDecodingContext,
        xid: TransactionId,
        gid: *const ::core::ffi::c_char,
    ) -> bool,
>;
pub type LogicalDecodeBeginPrepareCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(ctx: *mut LogicalDecodingContext, txn: *mut ReorderBufferTXN),
>;
pub type LogicalDecodePrepareCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        ctx: *mut LogicalDecodingContext,
        txn: *mut ReorderBufferTXN,
        prepare_lsn: XLogRecPtr,
    ),
>;
pub type LogicalDecodeCommitPreparedCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        ctx: *mut LogicalDecodingContext,
        txn: *mut ReorderBufferTXN,
        commit_lsn: XLogRecPtr,
    ),
>;
pub type LogicalDecodeRollbackPreparedCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        ctx: *mut LogicalDecodingContext,
        txn: *mut ReorderBufferTXN,
        prepare_end_lsn: XLogRecPtr,
        prepare_time: TimestampTz,
    ),
>;
pub type LogicalDecodeStreamStartCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(ctx: *mut LogicalDecodingContext, txn: *mut ReorderBufferTXN),
>;
pub type LogicalDecodeStreamStopCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(ctx: *mut LogicalDecodingContext, txn: *mut ReorderBufferTXN),
>;
pub type LogicalDecodeStreamAbortCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        ctx: *mut LogicalDecodingContext,
        txn: *mut ReorderBufferTXN,
        abort_lsn: XLogRecPtr,
    ),
>;
pub type LogicalDecodeStreamPrepareCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        ctx: *mut LogicalDecodingContext,
        txn: *mut ReorderBufferTXN,
        prepare_lsn: XLogRecPtr,
    ),
>;
pub type LogicalDecodeStreamCommitCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        ctx: *mut LogicalDecodingContext,
        txn: *mut ReorderBufferTXN,
        commit_lsn: XLogRecPtr,
    ),
>;
pub type LogicalDecodeStreamChangeCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        ctx: *mut LogicalDecodingContext,
        txn: *mut ReorderBufferTXN,
        relation: Relation,
        change: *mut ReorderBufferChange,
    ),
>;
pub type LogicalDecodeStreamMessageCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        ctx: *mut LogicalDecodingContext,
        txn: *mut ReorderBufferTXN,
        message_lsn: XLogRecPtr,
        transactional: bool,
        prefix: *const ::core::ffi::c_char,
        message_size: Size,
        message: *const ::core::ffi::c_char,
    ),
>;
pub type LogicalDecodeStreamTruncateCB = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        ctx: *mut LogicalDecodingContext,
        txn: *mut ReorderBufferTXN,
        nrelations: ::core::ffi::c_int,
        relations: *mut Relation,
        change: *mut ReorderBufferChange,
    ),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct OutputPluginCallbacks {
    pub startup_cb: LogicalDecodeStartupCB,
    pub begin_cb: LogicalDecodeBeginCB,
    pub change_cb: LogicalDecodeChangeCB,
    pub truncate_cb: LogicalDecodeTruncateCB,
    pub commit_cb: LogicalDecodeCommitCB,
    pub message_cb: LogicalDecodeMessageCB,
    pub filter_by_origin_cb: LogicalDecodeFilterByOriginCB,
    pub shutdown_cb: LogicalDecodeShutdownCB,
    pub filter_prepare_cb: LogicalDecodeFilterPrepareCB,
    pub begin_prepare_cb: LogicalDecodeBeginPrepareCB,
    pub prepare_cb: LogicalDecodePrepareCB,
    pub commit_prepared_cb: LogicalDecodeCommitPreparedCB,
    pub rollback_prepared_cb: LogicalDecodeRollbackPreparedCB,
    pub stream_start_cb: LogicalDecodeStreamStartCB,
    pub stream_stop_cb: LogicalDecodeStreamStopCB,
    pub stream_abort_cb: LogicalDecodeStreamAbortCB,
    pub stream_prepare_cb: LogicalDecodeStreamPrepareCB,
    pub stream_commit_cb: LogicalDecodeStreamCommitCB,
    pub stream_change_cb: LogicalDecodeStreamChangeCB,
    pub stream_message_cb: LogicalDecodeStreamMessageCB,
    pub stream_truncate_cb: LogicalDecodeStreamTruncateCB,
}
pub mod LogicalRepMsgType {
    pub type Type = ::core::ffi::c_uint;
    pub const LOGICAL_REP_MSG_BEGIN: Type = 66;
    pub const LOGICAL_REP_MSG_COMMIT: Type = 67;
    pub const LOGICAL_REP_MSG_ORIGIN: Type = 79;
    pub const LOGICAL_REP_MSG_INSERT: Type = 73;
    pub const LOGICAL_REP_MSG_UPDATE: Type = 85;
    pub const LOGICAL_REP_MSG_DELETE: Type = 68;
    pub const LOGICAL_REP_MSG_TRUNCATE: Type = 84;
    pub const LOGICAL_REP_MSG_RELATION: Type = 82;
    pub const LOGICAL_REP_MSG_TYPE: Type = 89;
    pub const LOGICAL_REP_MSG_MESSAGE: Type = 77;
    pub const LOGICAL_REP_MSG_BEGIN_PREPARE: Type = 98;
    pub const LOGICAL_REP_MSG_PREPARE: Type = 80;
    pub const LOGICAL_REP_MSG_COMMIT_PREPARED: Type = 75;
    pub const LOGICAL_REP_MSG_ROLLBACK_PREPARED: Type = 114;
    pub const LOGICAL_REP_MSG_STREAM_START: Type = 83;
    pub const LOGICAL_REP_MSG_STREAM_STOP: Type = 69;
    pub const LOGICAL_REP_MSG_STREAM_COMMIT: Type = 99;
    pub const LOGICAL_REP_MSG_STREAM_ABORT: Type = 65;
    pub const LOGICAL_REP_MSG_STREAM_PREPARE: Type = 112;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LogicalRepTupleData {
    pub colvalues: *mut StringInfoData,
    pub colstatus: *mut ::core::ffi::c_char,
    pub ncols: ::core::ffi::c_int,
}
impl Default for LogicalRepTupleData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type LogicalRepRelId = uint32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LogicalRepRelation {
    pub remoteid: LogicalRepRelId,
    pub nspname: *mut ::core::ffi::c_char,
    pub relname: *mut ::core::ffi::c_char,
    pub natts: ::core::ffi::c_int,
    pub attnames: *mut *mut ::core::ffi::c_char,
    pub atttyps: *mut Oid,
    pub replident: ::core::ffi::c_char,
    pub relkind: ::core::ffi::c_char,
    pub attkeys: *mut Bitmapset,
}
impl Default for LogicalRepRelation {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LogicalRepTyp {
    pub remoteid: Oid,
    pub nspname: *mut ::core::ffi::c_char,
    pub typname: *mut ::core::ffi::c_char,
}
impl Default for LogicalRepTyp {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LogicalRepBeginData {
    pub final_lsn: XLogRecPtr,
    pub committime: TimestampTz,
    pub xid: TransactionId,
}
impl Default for LogicalRepBeginData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LogicalRepCommitData {
    pub commit_lsn: XLogRecPtr,
    pub end_lsn: XLogRecPtr,
    pub committime: TimestampTz,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LogicalRepPreparedTxnData {
    pub prepare_lsn: XLogRecPtr,
    pub end_lsn: XLogRecPtr,
    pub prepare_time: TimestampTz,
    pub xid: TransactionId,
    pub gid: [::core::ffi::c_char; 200usize],
}
impl Default for LogicalRepPreparedTxnData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LogicalRepCommitPreparedTxnData {
    pub commit_lsn: XLogRecPtr,
    pub end_lsn: XLogRecPtr,
    pub commit_time: TimestampTz,
    pub xid: TransactionId,
    pub gid: [::core::ffi::c_char; 200usize],
}
impl Default for LogicalRepCommitPreparedTxnData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LogicalRepRollbackPreparedTxnData {
    pub prepare_end_lsn: XLogRecPtr,
    pub rollback_end_lsn: XLogRecPtr,
    pub prepare_time: TimestampTz,
    pub rollback_time: TimestampTz,
    pub xid: TransactionId,
    pub gid: [::core::ffi::c_char; 200usize],
}
impl Default for LogicalRepRollbackPreparedTxnData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LogicalRepStreamAbortData {
    pub xid: TransactionId,
    pub subxid: TransactionId,
    pub abort_lsn: XLogRecPtr,
    pub abort_time: TimestampTz,
}
impl Default for LogicalRepStreamAbortData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod CRSSnapshotAction {
    pub type Type = ::core::ffi::c_uint;
    pub const CRS_EXPORT_SNAPSHOT: Type = 0;
    pub const CRS_NOEXPORT_SNAPSHOT: Type = 1;
    pub const CRS_USE_SNAPSHOT: Type = 2;
}
pub mod WalRcvState {
    pub type Type = ::core::ffi::c_uint;
    pub const WALRCV_STOPPED: Type = 0;
    pub const WALRCV_STARTING: Type = 1;
    pub const WALRCV_STREAMING: Type = 2;
    pub const WALRCV_WAITING: Type = 3;
    pub const WALRCV_RESTARTING: Type = 4;
    pub const WALRCV_STOPPING: Type = 5;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WalRcvData {
    pub pid: pid_t,
    pub walRcvState: WalRcvState::Type,
    pub walRcvStoppedCV: ConditionVariable,
    pub startTime: pg_time_t,
    pub receiveStart: XLogRecPtr,
    pub receiveStartTLI: TimeLineID,
    pub flushedUpto: XLogRecPtr,
    pub receivedTLI: TimeLineID,
    pub latestChunkStart: XLogRecPtr,
    pub lastMsgSendTime: TimestampTz,
    pub lastMsgReceiptTime: TimestampTz,
    pub latestWalEnd: XLogRecPtr,
    pub latestWalEndTime: TimestampTz,
    pub conninfo: [::core::ffi::c_char; 1024usize],
    pub sender_host: [::core::ffi::c_char; 1025usize],
    pub sender_port: ::core::ffi::c_int,
    pub slotname: [::core::ffi::c_char; 64usize],
    pub is_temp_slot: bool,
    pub ready_to_display: bool,
    pub latch: *mut Latch,
    pub mutex: slock_t,
    pub writtenUpto: pg_atomic_uint64,
    pub force_reply: sig_atomic_t,
}
impl Default for WalRcvData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WalRcvStreamOptions {
    pub logical: bool,
    pub slotname: *mut ::core::ffi::c_char,
    pub startpoint: XLogRecPtr,
    pub proto: WalRcvStreamOptions__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WalRcvStreamOptions__bindgen_ty_1 {
    pub physical: WalRcvStreamOptions__bindgen_ty_1__bindgen_ty_1,
    pub logical: WalRcvStreamOptions__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WalRcvStreamOptions__bindgen_ty_1__bindgen_ty_1 {
    pub startpointTLI: TimeLineID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WalRcvStreamOptions__bindgen_ty_1__bindgen_ty_2 {
    pub proto_version: uint32,
    pub publication_names: *mut List,
    pub binary: bool,
    pub streaming_str: *mut ::core::ffi::c_char,
    pub twophase: bool,
    pub origin: *mut ::core::ffi::c_char,
}
impl Default for WalRcvStreamOptions__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for WalRcvStreamOptions__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for WalRcvStreamOptions {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WalReceiverConn {
    _unused: [u8; 0],
}
pub mod WalRcvExecStatus {
    pub type Type = ::core::ffi::c_uint;
    pub const WALRCV_ERROR: Type = 0;
    pub const WALRCV_OK_COMMAND: Type = 1;
    pub const WALRCV_OK_TUPLES: Type = 2;
    pub const WALRCV_OK_COPY_IN: Type = 3;
    pub const WALRCV_OK_COPY_OUT: Type = 4;
    pub const WALRCV_OK_COPY_BOTH: Type = 5;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WalRcvExecResult {
    pub status: WalRcvExecStatus::Type,
    pub sqlstate: ::core::ffi::c_int,
    pub err: *mut ::core::ffi::c_char,
    pub tuplestore: *mut Tuplestorestate,
    pub tupledesc: TupleDesc,
}
impl Default for WalRcvExecResult {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type walrcv_connect_fn = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        conninfo: *const ::core::ffi::c_char,
        replication: bool,
        logical: bool,
        must_use_password: bool,
        appname: *const ::core::ffi::c_char,
        err: *mut *mut ::core::ffi::c_char,
    ) -> *mut WalReceiverConn,
>;
pub type walrcv_check_conninfo_fn = ::core::option::Option<
    unsafe extern "C-unwind" fn(conninfo: *const ::core::ffi::c_char, must_use_password: bool),
>;
pub type walrcv_get_conninfo_fn = ::core::option::Option<
    unsafe extern "C-unwind" fn(conn: *mut WalReceiverConn) -> *mut ::core::ffi::c_char,
>;
pub type walrcv_get_senderinfo_fn = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        conn: *mut WalReceiverConn,
        sender_host: *mut *mut ::core::ffi::c_char,
        sender_port: *mut ::core::ffi::c_int,
    ),
>;
pub type walrcv_identify_system_fn = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        conn: *mut WalReceiverConn,
        primary_tli: *mut TimeLineID,
    ) -> *mut ::core::ffi::c_char,
>;
pub type walrcv_get_dbname_from_conninfo_fn = ::core::option::Option<
    unsafe extern "C-unwind" fn(conninfo: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char,
>;
pub type walrcv_server_version_fn = ::core::option::Option<
    unsafe extern "C-unwind" fn(conn: *mut WalReceiverConn) -> ::core::ffi::c_int,
>;
pub type walrcv_readtimelinehistoryfile_fn = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        conn: *mut WalReceiverConn,
        tli: TimeLineID,
        filename: *mut *mut ::core::ffi::c_char,
        content: *mut *mut ::core::ffi::c_char,
        size: *mut ::core::ffi::c_int,
    ),
>;
pub type walrcv_startstreaming_fn = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        conn: *mut WalReceiverConn,
        options: *const WalRcvStreamOptions,
    ) -> bool,
>;
pub type walrcv_endstreaming_fn = ::core::option::Option<
    unsafe extern "C-unwind" fn(conn: *mut WalReceiverConn, next_tli: *mut TimeLineID),
>;
pub type walrcv_receive_fn = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        conn: *mut WalReceiverConn,
        buffer: *mut *mut ::core::ffi::c_char,
        wait_fd: *mut pgsocket,
    ) -> ::core::ffi::c_int,
>;
pub type walrcv_send_fn = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        conn: *mut WalReceiverConn,
        buffer: *const ::core::ffi::c_char,
        nbytes: ::core::ffi::c_int,
    ),
>;
pub type walrcv_create_slot_fn = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        conn: *mut WalReceiverConn,
        slotname: *const ::core::ffi::c_char,
        temporary: bool,
        two_phase: bool,
        failover: bool,
        snapshot_action: CRSSnapshotAction::Type,
        lsn: *mut XLogRecPtr,
    ) -> *mut ::core::ffi::c_char,
>;
pub type walrcv_alter_slot_fn = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        conn: *mut WalReceiverConn,
        slotname: *const ::core::ffi::c_char,
        failover: bool,
    ),
>;
pub type walrcv_get_backend_pid_fn =
    ::core::option::Option<unsafe extern "C-unwind" fn(conn: *mut WalReceiverConn) -> pid_t>;
pub type walrcv_exec_fn = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        conn: *mut WalReceiverConn,
        query: *const ::core::ffi::c_char,
        nRetTypes: ::core::ffi::c_int,
        retTypes: *const Oid,
    ) -> *mut WalRcvExecResult,
>;
pub type walrcv_disconnect_fn =
    ::core::option::Option<unsafe extern "C-unwind" fn(conn: *mut WalReceiverConn)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WalReceiverFunctionsType {
    pub walrcv_connect: walrcv_connect_fn,
    pub walrcv_check_conninfo: walrcv_check_conninfo_fn,
    pub walrcv_get_conninfo: walrcv_get_conninfo_fn,
    pub walrcv_get_senderinfo: walrcv_get_senderinfo_fn,
    pub walrcv_identify_system: walrcv_identify_system_fn,
    pub walrcv_get_dbname_from_conninfo: walrcv_get_dbname_from_conninfo_fn,
    pub walrcv_server_version: walrcv_server_version_fn,
    pub walrcv_readtimelinehistoryfile: walrcv_readtimelinehistoryfile_fn,
    pub walrcv_startstreaming: walrcv_startstreaming_fn,
    pub walrcv_endstreaming: walrcv_endstreaming_fn,
    pub walrcv_receive: walrcv_receive_fn,
    pub walrcv_send: walrcv_send_fn,
    pub walrcv_create_slot: walrcv_create_slot_fn,
    pub walrcv_alter_slot: walrcv_alter_slot_fn,
    pub walrcv_get_backend_pid: walrcv_get_backend_pid_fn,
    pub walrcv_exec: walrcv_exec_fn,
    pub walrcv_disconnect: walrcv_disconnect_fn,
}
pub mod ReplicationSlotPersistency {
    pub type Type = ::core::ffi::c_uint;
    pub const RS_PERSISTENT: Type = 0;
    pub const RS_EPHEMERAL: Type = 1;
    pub const RS_TEMPORARY: Type = 2;
}
pub mod ReplicationSlotInvalidationCause {
    pub type Type = ::core::ffi::c_uint;
    pub const RS_INVAL_NONE: Type = 0;
    pub const RS_INVAL_WAL_REMOVED: Type = 1;
    pub const RS_INVAL_HORIZON: Type = 2;
    pub const RS_INVAL_WAL_LEVEL: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReplicationSlotPersistentData {
    pub name: NameData,
    pub database: Oid,
    pub persistency: ReplicationSlotPersistency::Type,
    pub xmin: TransactionId,
    pub catalog_xmin: TransactionId,
    pub restart_lsn: XLogRecPtr,
    pub invalidated: ReplicationSlotInvalidationCause::Type,
    pub confirmed_flush: XLogRecPtr,
    pub two_phase_at: XLogRecPtr,
    pub two_phase: bool,
    pub plugin: NameData,
    pub synced: ::core::ffi::c_char,
    pub failover: bool,
}
impl Default for ReplicationSlotPersistentData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReplicationSlot {
    pub mutex: slock_t,
    pub in_use: bool,
    pub active_pid: pid_t,
    pub just_dirtied: bool,
    pub dirty: bool,
    pub effective_xmin: TransactionId,
    pub effective_catalog_xmin: TransactionId,
    pub data: ReplicationSlotPersistentData,
    pub io_in_progress_lock: LWLock,
    pub active_cv: ConditionVariable,
    pub candidate_catalog_xmin: TransactionId,
    pub candidate_xmin_lsn: XLogRecPtr,
    pub candidate_restart_valid: XLogRecPtr,
    pub candidate_restart_lsn: XLogRecPtr,
    pub last_saved_confirmed_flush: XLogRecPtr,
    pub inactive_since: TimestampTz,
}
impl Default for ReplicationSlot {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReplicationSlotCtlData {
    pub replication_slots: [ReplicationSlot; 1usize],
}
impl Default for ReplicationSlotCtlData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type LogicalOutputPluginWriterWrite = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        lr: *mut LogicalDecodingContext,
        Ptr: XLogRecPtr,
        xid: TransactionId,
        last_write: bool,
    ),
>;
pub type LogicalOutputPluginWriterPrepareWrite = LogicalOutputPluginWriterWrite;
pub type LogicalOutputPluginWriterUpdateProgress = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        lr: *mut LogicalDecodingContext,
        Ptr: XLogRecPtr,
        xid: TransactionId,
        skipped_xact: bool,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LogicalDecodingContext {
    pub context: MemoryContext,
    pub slot: *mut ReplicationSlot,
    pub reader: *mut XLogReaderState,
    pub reorder: *mut ReorderBuffer,
    pub snapshot_builder: *mut SnapBuild,
    pub fast_forward: bool,
    pub callbacks: OutputPluginCallbacks,
    pub options: OutputPluginOptions,
    pub output_plugin_options: *mut List,
    pub prepare_write: LogicalOutputPluginWriterPrepareWrite,
    pub write: LogicalOutputPluginWriterWrite,
    pub update_progress: LogicalOutputPluginWriterUpdateProgress,
    pub out: StringInfo,
    pub output_plugin_private: *mut ::core::ffi::c_void,
    pub output_writer_private: *mut ::core::ffi::c_void,
    pub streaming: bool,
    pub twophase: bool,
    pub twophase_opt_given: bool,
    pub accept_writes: bool,
    pub prepared_write: bool,
    pub write_location: XLogRecPtr,
    pub write_xid: TransactionId,
    pub end_xact: bool,
    pub processing_required: bool,
}
impl Default for LogicalDecodingContext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RowSecurityPolicy {
    pub policy_name: *mut ::core::ffi::c_char,
    pub polcmd: ::core::ffi::c_char,
    pub roles: *mut ArrayType,
    pub permissive: bool,
    pub qual: *mut Expr,
    pub with_check_qual: *mut Expr,
    pub hassublinks: bool,
}
impl Default for RowSecurityPolicy {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RowSecurityDesc {
    pub rscxt: MemoryContext,
    pub policies: *mut List,
}
impl Default for RowSecurityDesc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type row_security_policy_hook_type = ::core::option::Option<
    unsafe extern "C-unwind" fn(cmdtype: CmdType::Type, relation: Relation) -> *mut List,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct buftag {
    pub spcOid: Oid,
    pub dbOid: Oid,
    pub relNumber: RelFileNumber,
    pub forkNum: ForkNumber::Type,
    pub blockNum: BlockNumber,
}
impl Default for buftag {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type BufferTag = buftag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BufferDesc {
    pub tag: BufferTag,
    pub buf_id: ::core::ffi::c_int,
    pub state: pg_atomic_uint32,
    pub wait_backend_pgprocno: ::core::ffi::c_int,
    pub freeNext: ::core::ffi::c_int,
    pub content_lock: LWLock,
}
impl Default for BufferDesc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union BufferDescPadded {
    pub bufferdesc: BufferDesc,
    pub pad: [::core::ffi::c_char; 64usize],
}
impl Default for BufferDescPadded {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PendingWriteback {
    pub tag: BufferTag,
}
impl Default for PendingWriteback {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WritebackContext {
    pub max_pending: *mut ::core::ffi::c_int,
    pub nr_pending: ::core::ffi::c_int,
    pub pending_writebacks: [PendingWriteback; 256usize],
}
impl Default for WritebackContext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CkptSortItem {
    pub tsId: Oid,
    pub relNumber: RelFileNumber,
    pub forkNum: ForkNumber::Type,
    pub blockNum: BlockNumber,
    pub buf_id: ::core::ffi::c_int,
}
impl Default for CkptSortItem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BufFile {
    _unused: [u8; 0],
}
pub type pg_on_exit_callback =
    ::core::option::Option<unsafe extern "C-unwind" fn(code: ::core::ffi::c_int, arg: Datum)>;
pub type shmem_startup_hook_type = ::core::option::Option<unsafe extern "C-unwind" fn()>;
pub mod XLTW_Oper {
    pub type Type = ::core::ffi::c_uint;
    pub const XLTW_None: Type = 0;
    pub const XLTW_Update: Type = 1;
    pub const XLTW_Delete: Type = 2;
    pub const XLTW_Lock: Type = 3;
    pub const XLTW_LockUpdated: Type = 4;
    pub const XLTW_InsertIndex: Type = 5;
    pub const XLTW_InsertIndexUnique: Type = 6;
    pub const XLTW_FetchUpdated: Type = 7;
    pub const XLTW_RecheckExclusionConstr: Type = 8;
}
pub mod ProcSignalReason {
    pub type Type = ::core::ffi::c_uint;
    pub const PROCSIG_CATCHUP_INTERRUPT: Type = 0;
    pub const PROCSIG_NOTIFY_INTERRUPT: Type = 1;
    pub const PROCSIG_PARALLEL_MESSAGE: Type = 2;
    pub const PROCSIG_WALSND_INIT_STOPPING: Type = 3;
    pub const PROCSIG_BARRIER: Type = 4;
    pub const PROCSIG_LOG_MEMORY_CONTEXT: Type = 5;
    pub const PROCSIG_PARALLEL_APPLY_MESSAGE: Type = 6;
    pub const PROCSIG_RECOVERY_CONFLICT_FIRST: Type = 7;
    pub const PROCSIG_RECOVERY_CONFLICT_DATABASE: Type = 7;
    pub const PROCSIG_RECOVERY_CONFLICT_TABLESPACE: Type = 8;
    pub const PROCSIG_RECOVERY_CONFLICT_LOCK: Type = 9;
    pub const PROCSIG_RECOVERY_CONFLICT_SNAPSHOT: Type = 10;
    pub const PROCSIG_RECOVERY_CONFLICT_LOGICALSLOT: Type = 11;
    pub const PROCSIG_RECOVERY_CONFLICT_BUFFERPIN: Type = 12;
    pub const PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK: Type = 13;
    pub const PROCSIG_RECOVERY_CONFLICT_LAST: Type = 13;
    pub const NUM_PROCSIGNALS: Type = 14;
}
pub mod ProcSignalBarrierType {
    pub type Type = ::core::ffi::c_uint;
    pub const PROCSIGNAL_BARRIER_SMGRRELEASE: Type = 0;
}
#[repr(C)]
#[derive(Debug)]
pub struct xl_standby_locks {
    pub nlocks: ::core::ffi::c_int,
    pub locks: __IncompleteArrayField<xl_standby_lock>,
}
impl Default for xl_standby_locks {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct xl_running_xacts {
    pub xcnt: ::core::ffi::c_int,
    pub subxcnt: ::core::ffi::c_int,
    pub subxid_overflow: bool,
    pub nextXid: TransactionId,
    pub oldestRunningXid: TransactionId,
    pub latestCompletedXid: TransactionId,
    pub xids: __IncompleteArrayField<TransactionId>,
}
impl Default for xl_running_xacts {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct xl_invalidations {
    pub dbId: Oid,
    pub tsId: Oid,
    pub relcacheInitFileInval: bool,
    pub nmsgs: ::core::ffi::c_int,
    pub msgs: __IncompleteArrayField<SharedInvalidationMessage>,
}
impl Default for xl_invalidations {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod subxids_array_status {
    pub type Type = ::core::ffi::c_uint;
    pub const SUBXIDS_IN_ARRAY: Type = 0;
    pub const SUBXIDS_MISSING: Type = 1;
    pub const SUBXIDS_IN_SUBTRANS: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RunningTransactionsData {
    pub xcnt: ::core::ffi::c_int,
    pub subxcnt: ::core::ffi::c_int,
    pub subxid_status: subxids_array_status::Type,
    pub nextXid: TransactionId,
    pub oldestRunningXid: TransactionId,
    pub oldestDatabaseRunningXid: TransactionId,
    pub latestCompletedXid: TransactionId,
    pub xids: *mut TransactionId,
}
impl Default for RunningTransactionsData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type RunningTransactions = *mut RunningTransactionsData;
pub mod LogStmtLevel {
    pub type Type = ::core::ffi::c_uint;
    pub const LOGSTMT_NONE: Type = 0;
    pub const LOGSTMT_DDL: Type = 1;
    pub const LOGSTMT_MOD: Type = 2;
    pub const LOGSTMT_ALL: Type = 3;
}
pub mod ProcessUtilityContext {
    pub type Type = ::core::ffi::c_uint;
    pub const PROCESS_UTILITY_TOPLEVEL: Type = 0;
    pub const PROCESS_UTILITY_QUERY: Type = 1;
    pub const PROCESS_UTILITY_QUERY_NONATOMIC: Type = 2;
    pub const PROCESS_UTILITY_SUBCOMMAND: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterTableUtilityContext {
    pub pstmt: *mut PlannedStmt,
    pub queryString: *const ::core::ffi::c_char,
    pub relid: Oid,
    pub params: ParamListInfo,
    pub queryEnv: *mut QueryEnvironment,
}
impl Default for AlterTableUtilityContext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ProcessUtility_hook_type = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        pstmt: *mut PlannedStmt,
        queryString: *const ::core::ffi::c_char,
        readOnlyTree: bool,
        context: ProcessUtilityContext::Type,
        params: ParamListInfo,
        queryEnv: *mut QueryEnvironment,
        dest: *mut DestReceiver,
        qc: *mut QueryCompletion,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSAnyCacheEntry {
    pub objId: Oid,
    pub isvalid: bool,
}
impl Default for TSAnyCacheEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSParserCacheEntry {
    pub prsId: Oid,
    pub isvalid: bool,
    pub startOid: Oid,
    pub tokenOid: Oid,
    pub endOid: Oid,
    pub headlineOid: Oid,
    pub lextypeOid: Oid,
    pub prsstart: FmgrInfo,
    pub prstoken: FmgrInfo,
    pub prsend: FmgrInfo,
    pub prsheadline: FmgrInfo,
}
impl Default for TSParserCacheEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSDictionaryCacheEntry {
    pub dictId: Oid,
    pub isvalid: bool,
    pub lexizeOid: Oid,
    pub lexize: FmgrInfo,
    pub dictCtx: MemoryContext,
    pub dictData: *mut ::core::ffi::c_void,
}
impl Default for TSDictionaryCacheEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ListDictionary {
    pub len: ::core::ffi::c_int,
    pub dictIds: *mut Oid,
}
impl Default for ListDictionary {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSConfigCacheEntry {
    pub cfgId: Oid,
    pub isvalid: bool,
    pub prsId: Oid,
    pub lenmap: ::core::ffi::c_int,
    pub map: *mut ListDictionary,
}
impl Default for TSConfigCacheEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WordEntry {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl WordEntry {
    #[inline]
    pub fn haspos(&self) -> uint32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_haspos(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn haspos_raw(this: *const Self) -> uint32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_haspos_raw(this: *mut Self, val: uint32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn len(&self) -> uint32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_len(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn len_raw(this: *const Self) -> uint32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                11u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_len_raw(this: *mut Self, val: uint32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                11u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pos(&self) -> uint32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_pos(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pos_raw(this: *const Self) -> uint32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                20u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pos_raw(this: *mut Self, val: uint32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                20u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        haspos: uint32,
        len: uint32,
        pos: uint32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let haspos: u32 = unsafe { ::core::mem::transmute(haspos) };
            haspos as u64
        });
        __bindgen_bitfield_unit.set(1usize, 11u8, {
            let len: u32 = unsafe { ::core::mem::transmute(len) };
            len as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let pos: u32 = unsafe { ::core::mem::transmute(pos) };
            pos as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WordEntryPos = uint16;
#[repr(C)]
#[derive(Debug, Default)]
pub struct WordEntryPosVector {
    pub npos: uint16,
    pub pos: __IncompleteArrayField<WordEntryPos>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WordEntryPosVector1 {
    pub npos: uint16,
    pub pos: [WordEntryPos; 1usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct TSVectorData {
    pub vl_len_: int32,
    pub size: int32,
    pub entries: __IncompleteArrayField<WordEntry>,
}
pub type TSVector = *mut TSVectorData;
pub type QueryItemType = int8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct QueryOperand {
    pub type_: QueryItemType,
    pub weight: uint8,
    pub prefix: bool,
    pub valcrc: int32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl QueryOperand {
    #[inline]
    pub fn length(&self) -> uint32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_length(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn length_raw(this: *const Self) -> uint32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                12u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_length_raw(this: *mut Self, val: uint32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn distance(&self) -> uint32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_distance(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn distance_raw(this: *const Self) -> uint32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                20u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_distance_raw(this: *mut Self, val: uint32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                20u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(length: uint32, distance: uint32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let length: u32 = unsafe { ::core::mem::transmute(length) };
            length as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let distance: u32 = unsafe { ::core::mem::transmute(distance) };
            distance as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct QueryOperator {
    pub type_: QueryItemType,
    pub oper: int8,
    pub distance: int16,
    pub left: uint32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union QueryItem {
    pub type_: QueryItemType,
    pub qoperator: QueryOperator,
    pub qoperand: QueryOperand,
}
impl Default for QueryItem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct TSQueryData {
    pub vl_len_: int32,
    pub size: int32,
    pub data: __IncompleteArrayField<::core::ffi::c_char>,
}
pub type TSQuery = *mut TSQueryData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LexDescr {
    pub lexid: ::core::ffi::c_int,
    pub alias: *mut ::core::ffi::c_char,
    pub descr: *mut ::core::ffi::c_char,
}
impl Default for LexDescr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeadlineWordEntry {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub pos: WordEntryPos,
    pub word: *mut ::core::ffi::c_char,
    pub item: *mut QueryOperand,
}
impl Default for HeadlineWordEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl HeadlineWordEntry {
    #[inline]
    pub fn selected(&self) -> uint32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_selected(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn selected_raw(this: *const Self) -> uint32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_selected_raw(this: *mut Self, val: uint32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn in_(&self) -> uint32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn in__raw(this: *const Self) -> uint32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_in_raw(this: *mut Self, val: uint32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn replace(&self) -> uint32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_replace(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn replace_raw(this: *const Self) -> uint32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_replace_raw(this: *mut Self, val: uint32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn repeated(&self) -> uint32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repeated(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn repeated_raw(this: *const Self) -> uint32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_repeated_raw(this: *mut Self, val: uint32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn skip(&self) -> uint32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn skip_raw(this: *const Self) -> uint32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_skip_raw(this: *mut Self, val: uint32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn unused(&self) -> uint32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn unused_raw(this: *const Self) -> uint32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_unused_raw(this: *mut Self, val: uint32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> uint32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn type__raw(this: *const Self) -> uint32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_type_raw(this: *mut Self, val: uint32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn len(&self) -> uint32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_len(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn len_raw(this: *const Self) -> uint32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_len_raw(this: *mut Self, val: uint32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        selected: uint32,
        in_: uint32,
        replace: uint32,
        repeated: uint32,
        skip: uint32,
        unused: uint32,
        type_: uint32,
        len: uint32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let selected: u32 = unsafe { ::core::mem::transmute(selected) };
            selected as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let in_: u32 = unsafe { ::core::mem::transmute(in_) };
            in_ as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let replace: u32 = unsafe { ::core::mem::transmute(replace) };
            replace as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let repeated: u32 = unsafe { ::core::mem::transmute(repeated) };
            repeated as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let skip: u32 = unsafe { ::core::mem::transmute(skip) };
            skip as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let unused: u32 = unsafe { ::core::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let type_: u32 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let len: u32 = unsafe { ::core::mem::transmute(len) };
            len as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeadlineParsedText {
    pub words: *mut HeadlineWordEntry,
    pub lenwords: int32,
    pub curwords: int32,
    pub vectorpos: int32,
    pub startsel: *mut ::core::ffi::c_char,
    pub stopsel: *mut ::core::ffi::c_char,
    pub fragdelim: *mut ::core::ffi::c_char,
    pub startsellen: int16,
    pub stopsellen: int16,
    pub fragdelimlen: int16,
}
impl Default for HeadlineParsedText {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StopList {
    pub len: ::core::ffi::c_int,
    pub stop: *mut *mut ::core::ffi::c_char,
}
impl Default for StopList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSLexeme {
    pub nvariant: uint16,
    pub flags: uint16,
    pub lexeme: *mut ::core::ffi::c_char,
}
impl Default for TSLexeme {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DictSubState {
    pub isend: bool,
    pub getnext: bool,
    pub private_state: *mut ::core::ffi::c_void,
}
impl Default for DictSubState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSVectorParseStateData {
    _unused: [u8; 0],
}
pub type TSVectorParseState = *mut TSVectorParseStateData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSQueryParserStateData {
    _unused: [u8; 0],
}
pub type TSQueryParserState = *mut TSQueryParserStateData;
pub type PushFunction = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        opaque: Datum,
        state: TSQueryParserState,
        token: *mut ::core::ffi::c_char,
        tokenlen: ::core::ffi::c_int,
        tokenweights: int16,
        prefix: bool,
    ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ParsedWord {
    pub flags: uint16,
    pub len: uint16,
    pub nvariant: uint16,
    pub alen: uint16,
    pub pos: ParsedWord__bindgen_ty_1,
    pub word: *mut ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ParsedWord__bindgen_ty_1 {
    pub pos: uint16,
    pub apos: *mut uint16,
}
impl Default for ParsedWord__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ParsedWord {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParsedText {
    pub words: *mut ParsedWord,
    pub lenwords: int32,
    pub curwords: int32,
    pub pos: int32,
}
impl Default for ParsedText {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod TSTernaryValue {
    pub type Type = ::core::ffi::c_uint;
    pub const TS_NO: Type = 0;
    pub const TS_YES: Type = 1;
    pub const TS_MAYBE: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExecPhraseData {
    pub npos: ::core::ffi::c_int,
    pub allocated: bool,
    pub negate: bool,
    pub pos: *mut WordEntryPos,
    pub width: ::core::ffi::c_int,
}
impl Default for ExecPhraseData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TSExecuteCallback = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        arg: *mut ::core::ffi::c_void,
        val: *mut QueryOperand,
        data: *mut ExecPhraseData,
    ) -> TSTernaryValue::Type,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QTNode {
    pub valnode: *mut QueryItem,
    pub flags: uint32,
    pub nchild: int32,
    pub word: *mut ::core::ffi::c_char,
    pub sign: uint32,
    pub child: *mut *mut QTNode,
}
impl Default for QTNode {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TSQuerySign = uint64;
pub type DateADT = int32;
pub type TimeADT = int64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TimeTzADT {
    pub time: TimeADT,
    pub zone: int32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tzEntry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct datetkn {
    pub token: [::core::ffi::c_char; 11usize],
    pub type_: ::core::ffi::c_char,
    pub value: int32,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct TimeZoneAbbrevTable {
    pub tblsize: Size,
    pub numabbrevs: ::core::ffi::c_int,
    pub abbrevs: __IncompleteArrayField<datetkn>,
}
#[repr(C)]
#[derive(Debug)]
pub struct DynamicZoneAbbrev {
    pub tz: *mut pg_tz,
    pub zone: __IncompleteArrayField<::core::ffi::c_char>,
}
impl Default for DynamicZoneAbbrev {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DateTimeErrorExtra {
    pub dtee_timezone: *const ::core::ffi::c_char,
    pub dtee_abbrev: *const ::core::ffi::c_char,
}
impl Default for DateTimeErrorExtra {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Point {
    pub x: float8,
    pub y: float8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LSEG {
    pub p: [Point; 2usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct PATH {
    pub vl_len_: int32,
    pub npts: int32,
    pub closed: int32,
    pub dummy: int32,
    pub p: __IncompleteArrayField<Point>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LINE {
    pub A: float8,
    pub B: float8,
    pub C: float8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BOX {
    pub high: Point,
    pub low: Point,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct POLYGON {
    pub vl_len_: int32,
    pub npts: int32,
    pub boundbox: BOX,
    pub p: __IncompleteArrayField<Point>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CIRCLE {
    pub center: Point,
    pub radius: float8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pg_prng_state {
    pub s0: uint64,
    pub s1: uint64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NumericData {
    _unused: [u8; 0],
}
pub type Numeric = *mut NumericData;
pub mod JsonbIteratorToken {
    pub type Type = ::core::ffi::c_uint;
    pub const WJB_DONE: Type = 0;
    pub const WJB_KEY: Type = 1;
    pub const WJB_VALUE: Type = 2;
    pub const WJB_ELEM: Type = 3;
    pub const WJB_BEGIN_ARRAY: Type = 4;
    pub const WJB_END_ARRAY: Type = 5;
    pub const WJB_BEGIN_OBJECT: Type = 6;
    pub const WJB_END_OBJECT: Type = 7;
}
pub type JEntry = uint32;
#[repr(C)]
#[derive(Debug, Default)]
pub struct JsonbContainer {
    pub header: uint32,
    pub children: __IncompleteArrayField<JEntry>,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct Jsonb {
    pub vl_len_: int32,
    pub root: JsonbContainer,
}
pub mod jbvType {
    pub type Type = ::core::ffi::c_uint;
    pub const jbvNull: Type = 0;
    pub const jbvString: Type = 1;
    pub const jbvNumeric: Type = 2;
    pub const jbvBool: Type = 3;
    pub const jbvArray: Type = 16;
    pub const jbvObject: Type = 17;
    pub const jbvBinary: Type = 18;
    pub const jbvDatetime: Type = 32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JsonbValue {
    pub type_: jbvType::Type,
    pub val: JsonbValue__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JsonbValue__bindgen_ty_1 {
    pub numeric: Numeric,
    pub boolean: bool,
    pub string: JsonbValue__bindgen_ty_1__bindgen_ty_1,
    pub array: JsonbValue__bindgen_ty_1__bindgen_ty_2,
    pub object: JsonbValue__bindgen_ty_1__bindgen_ty_3,
    pub binary: JsonbValue__bindgen_ty_1__bindgen_ty_4,
    pub datetime: JsonbValue__bindgen_ty_1__bindgen_ty_5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonbValue__bindgen_ty_1__bindgen_ty_1 {
    pub len: ::core::ffi::c_int,
    pub val: *mut ::core::ffi::c_char,
}
impl Default for JsonbValue__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonbValue__bindgen_ty_1__bindgen_ty_2 {
    pub nElems: ::core::ffi::c_int,
    pub elems: *mut JsonbValue,
    pub rawScalar: bool,
}
impl Default for JsonbValue__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonbValue__bindgen_ty_1__bindgen_ty_3 {
    pub nPairs: ::core::ffi::c_int,
    pub pairs: *mut JsonbPair,
}
impl Default for JsonbValue__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonbValue__bindgen_ty_1__bindgen_ty_4 {
    pub len: ::core::ffi::c_int,
    pub data: *mut JsonbContainer,
}
impl Default for JsonbValue__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonbValue__bindgen_ty_1__bindgen_ty_5 {
    pub value: Datum,
    pub typid: Oid,
    pub typmod: int32,
    pub tz: ::core::ffi::c_int,
}
impl Default for JsonbValue__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for JsonbValue__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for JsonbValue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JsonbPair {
    pub key: JsonbValue,
    pub value: JsonbValue,
    pub order: uint32,
}
impl Default for JsonbPair {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JsonbParseState {
    pub contVal: JsonbValue,
    pub size: Size,
    pub next: *mut JsonbParseState,
    pub unique_keys: bool,
    pub skip_nulls: bool,
}
impl Default for JsonbParseState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod JsonbIterState {
    pub type Type = ::core::ffi::c_uint;
    pub const JBI_ARRAY_START: Type = 0;
    pub const JBI_ARRAY_ELEM: Type = 1;
    pub const JBI_OBJECT_START: Type = 2;
    pub const JBI_OBJECT_KEY: Type = 3;
    pub const JBI_OBJECT_VALUE: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonbIterator {
    pub container: *mut JsonbContainer,
    pub nElems: uint32,
    pub isScalar: bool,
    pub children: *mut JEntry,
    pub dataProper: *mut ::core::ffi::c_char,
    pub curIndex: ::core::ffi::c_int,
    pub curDataOffset: uint32,
    pub curValueOffset: uint32,
    pub state: JsonbIterState::Type,
    pub parent: *mut JsonbIterator,
}
impl Default for JsonbIterator {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpBtreeInterpretation {
    pub opfamily_id: Oid,
    pub strategy: ::core::ffi::c_int,
    pub oplefttype: Oid,
    pub oprighttype: Oid,
}
impl Default for OpBtreeInterpretation {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod IOFuncSelector {
    pub type Type = ::core::ffi::c_uint;
    pub const IOFunc_input: Type = 0;
    pub const IOFunc_output: Type = 1;
    pub const IOFunc_receive: Type = 2;
    pub const IOFunc_send: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AttStatsSlot {
    pub staop: Oid,
    pub stacoll: Oid,
    pub valuetype: Oid,
    pub values: *mut Datum,
    pub nvalues: ::core::ffi::c_int,
    pub numbers: *mut float4,
    pub nnumbers: ::core::ffi::c_int,
    pub values_arr: *mut ::core::ffi::c_void,
    pub numbers_arr: *mut ::core::ffi::c_void,
}
impl Default for AttStatsSlot {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type get_attavgwidth_hook_type =
    ::core::option::Option<unsafe extern "C-unwind" fn(relid: Oid, attnum: AttrNumber) -> int32>;
pub mod CheckEnableRlsResult {
    pub type Type = ::core::ffi::c_uint;
    pub const RLS_NONE: Type = 0;
    pub const RLS_NONE_ENV: Type = 1;
    pub const RLS_ENABLED: Type = 2;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BlockSamplerData {
    pub N: BlockNumber,
    pub n: ::core::ffi::c_int,
    pub t: BlockNumber,
    pub m: ::core::ffi::c_int,
    pub randstate: pg_prng_state,
}
pub type BlockSampler = *mut BlockSamplerData;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ReservoirStateData {
    pub W: f64,
    pub randstate: pg_prng_state,
}
pub type ReservoirState = *mut ReservoirStateData;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct EstimationInfo {
    pub flags: uint32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VariableStatData {
    pub var: *mut Node,
    pub rel: *mut RelOptInfo,
    pub statsTuple: HeapTuple,
    pub freefunc: ::core::option::Option<unsafe extern "C-unwind" fn(tuple: HeapTuple)>,
    pub vartype: Oid,
    pub atttype: Oid,
    pub atttypmod: int32,
    pub isunique: bool,
    pub acl_ok: bool,
}
impl Default for VariableStatData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GenericCosts {
    pub indexStartupCost: Cost,
    pub indexTotalCost: Cost,
    pub indexSelectivity: Selectivity,
    pub indexCorrelation: f64,
    pub numIndexPages: f64,
    pub numIndexTuples: f64,
    pub spc_random_page_cost: f64,
    pub num_sa_scans: f64,
}
pub type get_relation_stats_hook_type = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        root: *mut PlannerInfo,
        rte: *mut RangeTblEntry,
        attnum: AttrNumber,
        vardata: *mut VariableStatData,
    ) -> bool,
>;
pub type get_index_stats_hook_type = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        root: *mut PlannerInfo,
        indexOid: Oid,
        indexattnum: AttrNumber,
        vardata: *mut VariableStatData,
    ) -> bool,
>;
pub type CCHashFN = ::core::option::Option<unsafe extern "C-unwind" fn(datum: Datum) -> uint32>;
pub type CCFastEqualFN =
    ::core::option::Option<unsafe extern "C-unwind" fn(a: Datum, b: Datum) -> bool>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct catcache {
    pub id: ::core::ffi::c_int,
    pub cc_nbuckets: ::core::ffi::c_int,
    pub cc_tupdesc: TupleDesc,
    pub cc_bucket: *mut dlist_head,
    pub cc_hashfunc: [CCHashFN; 4usize],
    pub cc_fastequal: [CCFastEqualFN; 4usize],
    pub cc_keyno: [::core::ffi::c_int; 4usize],
    pub cc_nkeys: ::core::ffi::c_int,
    pub cc_ntup: ::core::ffi::c_int,
    pub cc_nlist: ::core::ffi::c_int,
    pub cc_nlbuckets: ::core::ffi::c_int,
    pub cc_lbucket: *mut dlist_head,
    pub cc_relname: *const ::core::ffi::c_char,
    pub cc_reloid: Oid,
    pub cc_indexoid: Oid,
    pub cc_relisshared: bool,
    pub cc_next: slist_node,
    pub cc_skey: [ScanKeyData; 4usize],
}
impl Default for catcache {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CatCache = catcache;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct catctup {
    pub ct_magic: ::core::ffi::c_int,
    pub hash_value: uint32,
    pub keys: [Datum; 4usize],
    pub cache_elem: dlist_node,
    pub refcount: ::core::ffi::c_int,
    pub dead: bool,
    pub negative: bool,
    pub tuple: HeapTupleData,
    pub c_list: *mut catclist,
    pub my_cache: *mut CatCache,
}
impl Default for catctup {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CatCTup = catctup;
#[repr(C)]
#[derive(Debug)]
pub struct catclist {
    pub cl_magic: ::core::ffi::c_int,
    pub hash_value: uint32,
    pub cache_elem: dlist_node,
    pub keys: [Datum; 4usize],
    pub refcount: ::core::ffi::c_int,
    pub dead: bool,
    pub ordered: bool,
    pub nkeys: ::core::ffi::c_short,
    pub n_members: ::core::ffi::c_int,
    pub my_cache: *mut CatCache,
    pub members: __IncompleteArrayField<*mut CatCTup>,
}
impl Default for catclist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CatCList = catclist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct catcacheheader {
    pub ch_caches: slist_head,
    pub ch_ntup: ::core::ffi::c_int,
}
impl Default for catcacheheader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CatCacheHeader = catcacheheader;
pub mod SysCacheIdentifier {
    pub type Type = ::core::ffi::c_uint;
    pub const AGGFNOID: Type = 0;
    pub const AMNAME: Type = 1;
    pub const AMOID: Type = 2;
    pub const AMOPOPID: Type = 3;
    pub const AMOPSTRATEGY: Type = 4;
    pub const AMPROCNUM: Type = 5;
    pub const ATTNAME: Type = 6;
    pub const ATTNUM: Type = 7;
    pub const AUTHMEMMEMROLE: Type = 8;
    pub const AUTHMEMROLEMEM: Type = 9;
    pub const AUTHNAME: Type = 10;
    pub const AUTHOID: Type = 11;
    pub const CASTSOURCETARGET: Type = 12;
    pub const CLAAMNAMENSP: Type = 13;
    pub const CLAOID: Type = 14;
    pub const COLLNAMEENCNSP: Type = 15;
    pub const COLLOID: Type = 16;
    pub const CONDEFAULT: Type = 17;
    pub const CONNAMENSP: Type = 18;
    pub const CONSTROID: Type = 19;
    pub const CONVOID: Type = 20;
    pub const DATABASEOID: Type = 21;
    pub const DEFACLROLENSPOBJ: Type = 22;
    pub const ENUMOID: Type = 23;
    pub const ENUMTYPOIDNAME: Type = 24;
    pub const EVENTTRIGGERNAME: Type = 25;
    pub const EVENTTRIGGEROID: Type = 26;
    pub const FOREIGNDATAWRAPPERNAME: Type = 27;
    pub const FOREIGNDATAWRAPPEROID: Type = 28;
    pub const FOREIGNSERVERNAME: Type = 29;
    pub const FOREIGNSERVEROID: Type = 30;
    pub const FOREIGNTABLEREL: Type = 31;
    pub const INDEXRELID: Type = 32;
    pub const LANGNAME: Type = 33;
    pub const LANGOID: Type = 34;
    pub const NAMESPACENAME: Type = 35;
    pub const NAMESPACEOID: Type = 36;
    pub const OPERNAMENSP: Type = 37;
    pub const OPEROID: Type = 38;
    pub const OPFAMILYAMNAMENSP: Type = 39;
    pub const OPFAMILYOID: Type = 40;
    pub const PARAMETERACLNAME: Type = 41;
    pub const PARAMETERACLOID: Type = 42;
    pub const PARTRELID: Type = 43;
    pub const PROCNAMEARGSNSP: Type = 44;
    pub const PROCOID: Type = 45;
    pub const PUBLICATIONNAME: Type = 46;
    pub const PUBLICATIONNAMESPACE: Type = 47;
    pub const PUBLICATIONNAMESPACEMAP: Type = 48;
    pub const PUBLICATIONOID: Type = 49;
    pub const PUBLICATIONREL: Type = 50;
    pub const PUBLICATIONRELMAP: Type = 51;
    pub const RANGEMULTIRANGE: Type = 52;
    pub const RANGETYPE: Type = 53;
    pub const RELNAMENSP: Type = 54;
    pub const RELOID: Type = 55;
    pub const REPLORIGIDENT: Type = 56;
    pub const REPLORIGNAME: Type = 57;
    pub const RULERELNAME: Type = 58;
    pub const SEQRELID: Type = 59;
    pub const STATEXTDATASTXOID: Type = 60;
    pub const STATEXTNAMENSP: Type = 61;
    pub const STATEXTOID: Type = 62;
    pub const STATRELATTINH: Type = 63;
    pub const SUBSCRIPTIONNAME: Type = 64;
    pub const SUBSCRIPTIONOID: Type = 65;
    pub const SUBSCRIPTIONRELMAP: Type = 66;
    pub const TABLESPACEOID: Type = 67;
    pub const TRFOID: Type = 68;
    pub const TRFTYPELANG: Type = 69;
    pub const TSCONFIGMAP: Type = 70;
    pub const TSCONFIGNAMENSP: Type = 71;
    pub const TSCONFIGOID: Type = 72;
    pub const TSDICTNAMENSP: Type = 73;
    pub const TSDICTOID: Type = 74;
    pub const TSPARSERNAMENSP: Type = 75;
    pub const TSPARSEROID: Type = 76;
    pub const TSTEMPLATENAMENSP: Type = 77;
    pub const TSTEMPLATEOID: Type = 78;
    pub const TYPENAMENSP: Type = 79;
    pub const TYPEOID: Type = 80;
    pub const USERMAPPINGOID: Type = 81;
    pub const USERMAPPINGUSERSERVER: Type = 82;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeType {
    pub vl_len_: int32,
    pub rangetypid: Oid,
}
impl Default for RangeType {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeBound {
    pub val: Datum,
    pub infinite: bool,
    pub inclusive: bool,
    pub lower: bool,
}
impl Default for RangeBound {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ClosestMatchState {
    pub source: *const ::core::ffi::c_char,
    pub min_d: ::core::ffi::c_int,
    pub max_d: ::core::ffi::c_int,
    pub match_: *const ::core::ffi::c_char,
}
impl Default for ClosestMatchState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::core::ffi::c_uint,
    pub fp_offset: ::core::ffi::c_uint,
    pub overflow_arg_area: *mut ::core::ffi::c_void,
    pub reg_save_area: *mut ::core::ffi::c_void,
}
impl Default for __va_list_tag {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AttrMissing {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PartitionTupleRouting {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WaitEventSet {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct binaryheap {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TsmRoutine {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TableFuncRoutine {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct memoize_hash {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HashAggSpill {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WindowObjectData {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ParallelExecutorInfo {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TupleQueueReader {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MdfdVec {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SnapBuild {
    pub _address: u8,
}
#[pgrx_macros::pg_guard]
unsafe extern "C-unwind" {
    pub fn ExceptionalCondition(
        conditionName: *const ::core::ffi::c_char,
        fileName: *const ::core::ffi::c_char,
        lineNumber: ::core::ffi::c_int,
    ) -> !;
    pub fn pg_set_noblock(sock: pgsocket) -> bool;
    pub fn pg_set_block(sock: pgsocket) -> bool;
    pub fn has_drive_prefix(path: *const ::core::ffi::c_char) -> bool;
    pub fn first_dir_separator(filename: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn last_dir_separator(filename: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn first_path_var_separator(
        pathlist: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn join_path_components(
        ret_path: *mut ::core::ffi::c_char,
        head: *const ::core::ffi::c_char,
        tail: *const ::core::ffi::c_char,
    );
    pub fn canonicalize_path(path: *mut ::core::ffi::c_char);
    pub fn canonicalize_path_enc(path: *mut ::core::ffi::c_char, encoding: ::core::ffi::c_int);
    pub fn make_native_path(filename: *mut ::core::ffi::c_char);
    pub fn cleanup_path(path: *mut ::core::ffi::c_char);
    pub fn path_contains_parent_reference(path: *const ::core::ffi::c_char) -> bool;
    pub fn path_is_relative_and_below_cwd(path: *const ::core::ffi::c_char) -> bool;
    pub fn path_is_prefix_of_path(
        path1: *const ::core::ffi::c_char,
        path2: *const ::core::ffi::c_char,
    ) -> bool;
    pub fn make_absolute_path(path: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn get_progname(argv0: *const ::core::ffi::c_char) -> *const ::core::ffi::c_char;
    pub fn get_share_path(
        my_exec_path: *const ::core::ffi::c_char,
        ret_path: *mut ::core::ffi::c_char,
    );
    pub fn get_etc_path(
        my_exec_path: *const ::core::ffi::c_char,
        ret_path: *mut ::core::ffi::c_char,
    );
    pub fn get_include_path(
        my_exec_path: *const ::core::ffi::c_char,
        ret_path: *mut ::core::ffi::c_char,
    );
    pub fn get_pkginclude_path(
        my_exec_path: *const ::core::ffi::c_char,
        ret_path: *mut ::core::ffi::c_char,
    );
    pub fn get_includeserver_path(
        my_exec_path: *const ::core::ffi::c_char,
        ret_path: *mut ::core::ffi::c_char,
    );
    pub fn get_lib_path(
        my_exec_path: *const ::core::ffi::c_char,
        ret_path: *mut ::core::ffi::c_char,
    );
    pub fn get_pkglib_path(
        my_exec_path: *const ::core::ffi::c_char,
        ret_path: *mut ::core::ffi::c_char,
    );
    pub fn get_locale_path(
        my_exec_path: *const ::core::ffi::c_char,
        ret_path: *mut ::core::ffi::c_char,
    );
    pub fn get_doc_path(
        my_exec_path: *const ::core::ffi::c_char,
        ret_path: *mut ::core::ffi::c_char,
    );
    pub fn get_html_path(
        my_exec_path: *const ::core::ffi::c_char,
        ret_path: *mut ::core::ffi::c_char,
    );
    pub fn get_man_path(
        my_exec_path: *const ::core::ffi::c_char,
        ret_path: *mut ::core::ffi::c_char,
    );
    pub fn get_home_path(ret_path: *mut ::core::ffi::c_char) -> bool;
    pub fn get_parent_directory(path: *mut ::core::ffi::c_char);
    pub fn pgfnames(path: *const ::core::ffi::c_char) -> *mut *mut ::core::ffi::c_char;
    pub fn pgfnames_cleanup(filenames: *mut *mut ::core::ffi::c_char);
    pub fn set_pglocale_pgservice(
        argv0: *const ::core::ffi::c_char,
        app: *const ::core::ffi::c_char,
    );
    pub fn validate_exec(path: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn find_my_exec(
        argv0: *const ::core::ffi::c_char,
        retpath: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn find_other_exec(
        argv0: *const ::core::ffi::c_char,
        target: *const ::core::ffi::c_char,
        versionstr: *const ::core::ffi::c_char,
        retpath: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn pipe_read_line(cmd: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn pg_usleep(microsec: ::core::ffi::c_long);
    pub fn pg_strcasecmp(
        s1: *const ::core::ffi::c_char,
        s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn pg_strncasecmp(
        s1: *const ::core::ffi::c_char,
        s2: *const ::core::ffi::c_char,
        n: usize,
    ) -> ::core::ffi::c_int;
    pub fn pg_toupper(ch: ::core::ffi::c_uchar) -> ::core::ffi::c_uchar;
    pub fn pg_tolower(ch: ::core::ffi::c_uchar) -> ::core::ffi::c_uchar;
    pub fn pg_ascii_toupper(ch: ::core::ffi::c_uchar) -> ::core::ffi::c_uchar;
    pub fn pg_ascii_tolower(ch: ::core::ffi::c_uchar) -> ::core::ffi::c_uchar;
    pub fn pg_vsnprintf(
        str_: *mut ::core::ffi::c_char,
        count: usize,
        fmt: *const ::core::ffi::c_char,
        args: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
    pub fn pg_snprintf(
        str_: *mut ::core::ffi::c_char,
        count: usize,
        fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn pg_vsprintf(
        str_: *mut ::core::ffi::c_char,
        fmt: *const ::core::ffi::c_char,
        args: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
    pub fn pg_sprintf(
        str_: *mut ::core::ffi::c_char,
        fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn pg_vfprintf(
        stream: *mut FILE,
        fmt: *const ::core::ffi::c_char,
        args: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
    pub fn pg_fprintf(
        stream: *mut FILE,
        fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn pg_vprintf(
        fmt: *const ::core::ffi::c_char,
        args: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
    pub fn pg_printf(fmt: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn pg_strfromd(
        str_: *mut ::core::ffi::c_char,
        count: usize,
        precision: ::core::ffi::c_int,
        value: f64,
    ) -> ::core::ffi::c_int;
    pub fn pg_strerror(errnum: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
    pub fn pg_strerror_r(
        errnum: ::core::ffi::c_int,
        buf: *mut ::core::ffi::c_char,
        buflen: usize,
    ) -> *mut ::core::ffi::c_char;
    pub fn pg_strsignal(signum: ::core::ffi::c_int) -> *const ::core::ffi::c_char;
    pub fn pclose_check(stream: *mut FILE) -> ::core::ffi::c_int;
    pub fn rmtree(path: *const ::core::ffi::c_char, rmtopdir: bool) -> bool;
    pub fn getpeereid(
        sock: ::core::ffi::c_int,
        uid: *mut uid_t,
        gid: *mut gid_t,
    ) -> ::core::ffi::c_int;
    pub fn strlcat(
        dst: *mut ::core::ffi::c_char,
        src: *const ::core::ffi::c_char,
        siz: usize,
    ) -> usize;
    pub fn strlcpy(
        dst: *mut ::core::ffi::c_char,
        src: *const ::core::ffi::c_char,
        siz: usize,
    ) -> usize;
    pub fn pg_get_user_name(
        user_id: uid_t,
        buffer: *mut ::core::ffi::c_char,
        buflen: usize,
    ) -> bool;
    pub fn pg_get_user_home_dir(
        user_id: uid_t,
        buffer: *mut ::core::ffi::c_char,
        buflen: usize,
    ) -> bool;
    pub fn pg_qsort(
        base: *mut ::core::ffi::c_void,
        nel: usize,
        elsize: usize,
        cmp: ::core::option::Option<
            unsafe extern "C-unwind" fn(
                arg1: *const ::core::ffi::c_void,
                arg2: *const ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
    );
    pub fn pg_qsort_strcmp(
        a: *const ::core::ffi::c_void,
        b: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn qsort_arg(
        base: *mut ::core::ffi::c_void,
        nel: usize,
        elsize: usize,
        cmp: qsort_arg_comparator,
        arg: *mut ::core::ffi::c_void,
    );
    pub fn qsort_interruptible(
        base: *mut ::core::ffi::c_void,
        nel: usize,
        elsize: usize,
        cmp: qsort_arg_comparator,
        arg: *mut ::core::ffi::c_void,
    );
    pub fn bsearch_arg(
        key: *const ::core::ffi::c_void,
        base0: *const ::core::ffi::c_void,
        nmemb: usize,
        size: usize,
        compar: ::core::option::Option<
            unsafe extern "C-unwind" fn(
                arg1: *const ::core::ffi::c_void,
                arg2: *const ::core::ffi::c_void,
                arg3: *mut ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
        arg: *mut ::core::ffi::c_void,
    ) -> *mut ::core::ffi::c_void;
    pub fn pg_get_encoding_from_locale(
        ctype: *const ::core::ffi::c_char,
        write_message: bool,
    ) -> ::core::ffi::c_int;
    pub fn pg_inet_net_ntop(
        af: ::core::ffi::c_int,
        src: *const ::core::ffi::c_void,
        bits: ::core::ffi::c_int,
        dst: *mut ::core::ffi::c_char,
        size: usize,
    ) -> *mut ::core::ffi::c_char;
    pub fn pg_strong_random_init();
    pub fn pg_strong_random(buf: *mut ::core::ffi::c_void, len: usize) -> bool;
    pub fn pg_check_dir(dir: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn pg_mkdir_p(
        path: *mut ::core::ffi::c_char,
        omode: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn pqsignal(signo: ::core::ffi::c_int, func: pqsigfunc) -> pqsigfunc;
    pub fn escape_single_quotes_ascii(src: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn wait_result_to_str(exitstatus: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
    pub fn wait_result_is_signal(
        exit_status: ::core::ffi::c_int,
        signum: ::core::ffi::c_int,
    ) -> bool;
    pub fn wait_result_is_any_signal(
        exit_status: ::core::ffi::c_int,
        include_command_not_found: bool,
    ) -> bool;
    pub fn wait_result_to_exit_code(exit_status: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn makeStringInfo() -> StringInfo;
    pub fn initStringInfo(str_: StringInfo);
    pub fn resetStringInfo(str_: StringInfo);
    pub fn appendStringInfo(str_: StringInfo, fmt: *const ::core::ffi::c_char, ...);
    pub fn appendStringInfoVA(
        str_: StringInfo,
        fmt: *const ::core::ffi::c_char,
        args: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
    pub fn appendStringInfoString(str_: StringInfo, s: *const ::core::ffi::c_char);
    pub fn appendStringInfoChar(str_: StringInfo, ch: ::core::ffi::c_char);
    pub fn appendStringInfoSpaces(str_: StringInfo, count: ::core::ffi::c_int);
    pub fn appendBinaryStringInfo(
        str_: StringInfo,
        data: *const ::core::ffi::c_void,
        datalen: ::core::ffi::c_int,
    );
    pub fn appendBinaryStringInfoNT(
        str_: StringInfo,
        data: *const ::core::ffi::c_void,
        datalen: ::core::ffi::c_int,
    );
    pub fn enlargeStringInfo(str_: StringInfo, needed: ::core::ffi::c_int);
    pub fn destroyStringInfo(str_: StringInfo);
    pub fn message_level_is_interesting(elevel: ::core::ffi::c_int) -> bool;
    pub fn errstart_cold(elevel: ::core::ffi::c_int, domain: *const ::core::ffi::c_char) -> bool;
    pub fn errcode_for_file_access() -> ::core::ffi::c_int;
    pub fn errcode_for_socket_access() -> ::core::ffi::c_int;
    pub fn errmsg_internal(fmt: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn errmsg_plural(
        fmt_singular: *const ::core::ffi::c_char,
        fmt_plural: *const ::core::ffi::c_char,
        n: ::core::ffi::c_ulong,
        ...
    ) -> ::core::ffi::c_int;
    pub fn errdetail_internal(fmt: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn errdetail_log(fmt: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn errdetail_log_plural(
        fmt_singular: *const ::core::ffi::c_char,
        fmt_plural: *const ::core::ffi::c_char,
        n: ::core::ffi::c_ulong,
        ...
    ) -> ::core::ffi::c_int;
    pub fn errdetail_plural(
        fmt_singular: *const ::core::ffi::c_char,
        fmt_plural: *const ::core::ffi::c_char,
        n: ::core::ffi::c_ulong,
        ...
    ) -> ::core::ffi::c_int;
    pub fn errhint_plural(
        fmt_singular: *const ::core::ffi::c_char,
        fmt_plural: *const ::core::ffi::c_char,
        n: ::core::ffi::c_ulong,
        ...
    ) -> ::core::ffi::c_int;
    pub fn set_errcontext_domain(domain: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn errhidestmt(hide_stmt: bool) -> ::core::ffi::c_int;
    pub fn errhidecontext(hide_ctx: bool) -> ::core::ffi::c_int;
    pub fn errbacktrace() -> ::core::ffi::c_int;
    pub fn errposition(cursorpos: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn internalerrposition(cursorpos: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn internalerrquery(query: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn err_generic_string(
        field: ::core::ffi::c_int,
        str_: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn geterrcode() -> ::core::ffi::c_int;
    pub fn geterrlevel() -> ::core::ffi::c_int;
    pub fn geterrposition() -> ::core::ffi::c_int;
    pub fn getinternalerrposition() -> ::core::ffi::c_int;
    pub fn errsave_start(context: *mut Node, domain: *const ::core::ffi::c_char) -> bool;
    pub fn errsave_finish(
        context: *mut Node,
        filename: *const ::core::ffi::c_char,
        lineno: ::core::ffi::c_int,
        funcname: *const ::core::ffi::c_char,
    );
    pub fn pre_format_elog_string(
        errnumber: ::core::ffi::c_int,
        domain: *const ::core::ffi::c_char,
    );
    pub fn format_elog_string(fmt: *const ::core::ffi::c_char, ...) -> *mut ::core::ffi::c_char;
    pub static mut error_context_stack: *mut ErrorContextCallback;
    pub static mut PG_exception_stack: *mut sigjmp_buf;
    pub fn EmitErrorReport();
    pub fn CopyErrorData() -> *mut ErrorData;
    pub fn FreeErrorData(edata: *mut ErrorData);
    pub fn FlushErrorState();
    pub fn ReThrowError(edata: *mut ErrorData) -> !;
    pub fn ThrowErrorData(edata: *mut ErrorData);
    pub fn GetErrorContextStack() -> *mut ::core::ffi::c_char;
    pub static mut emit_log_hook: emit_log_hook_type;
    pub static mut Log_error_verbosity: ::core::ffi::c_int;
    pub static mut Log_line_prefix: *mut ::core::ffi::c_char;
    pub static mut Log_destination: ::core::ffi::c_int;
    pub static mut Log_destination_string: *mut ::core::ffi::c_char;
    pub static mut syslog_sequence_numbers: bool;
    pub static mut syslog_split_messages: bool;
    pub fn log_status_format(
        buf: StringInfo,
        format: *const ::core::ffi::c_char,
        edata: *mut ErrorData,
    );
    pub fn DebugFileOpen();
    pub fn unpack_sql_state(sql_state: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
    pub fn in_error_recursion_trouble() -> bool;
    pub fn reset_formatted_start_time();
    pub fn get_formatted_start_time() -> *mut ::core::ffi::c_char;
    pub fn get_formatted_log_time() -> *mut ::core::ffi::c_char;
    pub fn get_backend_type_for_log() -> *const ::core::ffi::c_char;
    pub fn check_log_of_query(edata: *mut ErrorData) -> bool;
    pub fn error_severity(elevel: ::core::ffi::c_int) -> *const ::core::ffi::c_char;
    pub fn write_pipe_chunks(
        data: *mut ::core::ffi::c_char,
        len: ::core::ffi::c_int,
        dest: ::core::ffi::c_int,
    );
    pub fn write_csvlog(edata: *mut ErrorData);
    pub fn write_jsonlog(edata: *mut ErrorData);
    pub fn write_stderr(fmt: *const ::core::ffi::c_char, ...);
    pub static mut CurrentMemoryContext: MemoryContext;
    pub fn MemoryContextAlloc(context: MemoryContext, size: Size) -> *mut ::core::ffi::c_void;
    pub fn MemoryContextAllocZero(context: MemoryContext, size: Size) -> *mut ::core::ffi::c_void;
    pub fn MemoryContextAllocExtended(
        context: MemoryContext,
        size: Size,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn MemoryContextAllocAligned(
        context: MemoryContext,
        size: Size,
        alignto: Size,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn palloc(size: Size) -> *mut ::core::ffi::c_void;
    pub fn palloc0(size: Size) -> *mut ::core::ffi::c_void;
    pub fn palloc_extended(size: Size, flags: ::core::ffi::c_int) -> *mut ::core::ffi::c_void;
    pub fn palloc_aligned(
        size: Size,
        alignto: Size,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn repalloc(pointer: *mut ::core::ffi::c_void, size: Size) -> *mut ::core::ffi::c_void;
    pub fn repalloc_extended(
        pointer: *mut ::core::ffi::c_void,
        size: Size,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn repalloc0(
        pointer: *mut ::core::ffi::c_void,
        oldsize: Size,
        size: Size,
    ) -> *mut ::core::ffi::c_void;
    pub fn pfree(pointer: *mut ::core::ffi::c_void);
    pub fn MemoryContextAllocHuge(context: MemoryContext, size: Size) -> *mut ::core::ffi::c_void;
    pub fn repalloc_huge(pointer: *mut ::core::ffi::c_void, size: Size)
        -> *mut ::core::ffi::c_void;
    pub fn MemoryContextRegisterResetCallback(
        context: MemoryContext,
        cb: *mut MemoryContextCallback,
    );
    pub fn MemoryContextStrdup(
        context: MemoryContext,
        string: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn pstrdup(in_: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn pnstrdup(in_: *const ::core::ffi::c_char, len: Size) -> *mut ::core::ffi::c_char;
    pub fn pchomp(in_: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn psprintf(fmt: *const ::core::ffi::c_char, ...) -> *mut ::core::ffi::c_char;
    pub fn pvsnprintf(
        buf: *mut ::core::ffi::c_char,
        len: usize,
        fmt: *const ::core::ffi::c_char,
        args: *mut __va_list_tag,
    ) -> usize;
    pub static mut no_such_variable: ::core::ffi::c_int;
    pub fn outNode(str_: *mut StringInfoData, obj: *const ::core::ffi::c_void);
    pub fn outToken(str_: *mut StringInfoData, s: *const ::core::ffi::c_char);
    pub fn outBitmapset(str_: *mut StringInfoData, bms: *const Bitmapset);
    pub fn outDatum(
        str_: *mut StringInfoData,
        value: usize,
        typlen: ::core::ffi::c_int,
        typbyval: bool,
    );
    pub fn nodeToString(obj: *const ::core::ffi::c_void) -> *mut ::core::ffi::c_char;
    pub fn nodeToStringWithLocations(obj: *const ::core::ffi::c_void) -> *mut ::core::ffi::c_char;
    pub fn bmsToString(bms: *const Bitmapset) -> *mut ::core::ffi::c_char;
    pub fn stringToNode(str_: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_void;
    pub fn readBitmapset() -> *mut Bitmapset;
    pub fn readDatum(typbyval: bool) -> usize;
    pub fn readBoolCols(numCols: ::core::ffi::c_int) -> *mut bool;
    pub fn readIntCols(numCols: ::core::ffi::c_int) -> *mut ::core::ffi::c_int;
    pub fn readOidCols(numCols: ::core::ffi::c_int) -> *mut Oid;
    pub fn readAttrNumberCols(numCols: ::core::ffi::c_int) -> *mut int16;
    pub fn copyObjectImpl(from: *const ::core::ffi::c_void) -> *mut ::core::ffi::c_void;
    pub fn equal(a: *const ::core::ffi::c_void, b: *const ::core::ffi::c_void) -> bool;
    pub fn list_make1_impl(t: NodeTag, datum1: ListCell) -> *mut List;
    pub fn list_make2_impl(t: NodeTag, datum1: ListCell, datum2: ListCell) -> *mut List;
    pub fn list_make3_impl(
        t: NodeTag,
        datum1: ListCell,
        datum2: ListCell,
        datum3: ListCell,
    ) -> *mut List;
    pub fn list_make4_impl(
        t: NodeTag,
        datum1: ListCell,
        datum2: ListCell,
        datum3: ListCell,
        datum4: ListCell,
    ) -> *mut List;
    pub fn list_make5_impl(
        t: NodeTag,
        datum1: ListCell,
        datum2: ListCell,
        datum3: ListCell,
        datum4: ListCell,
        datum5: ListCell,
    ) -> *mut List;
    pub fn lappend(list: *mut List, datum: *mut ::core::ffi::c_void) -> *mut List;
    pub fn lappend_int(list: *mut List, datum: ::core::ffi::c_int) -> *mut List;
    pub fn lappend_oid(list: *mut List, datum: Oid) -> *mut List;
    pub fn lappend_xid(list: *mut List, datum: TransactionId) -> *mut List;
    pub fn list_insert_nth(
        list: *mut List,
        pos: ::core::ffi::c_int,
        datum: *mut ::core::ffi::c_void,
    ) -> *mut List;
    pub fn list_insert_nth_int(
        list: *mut List,
        pos: ::core::ffi::c_int,
        datum: ::core::ffi::c_int,
    ) -> *mut List;
    pub fn list_insert_nth_oid(list: *mut List, pos: ::core::ffi::c_int, datum: Oid) -> *mut List;
    pub fn lcons(datum: *mut ::core::ffi::c_void, list: *mut List) -> *mut List;
    pub fn lcons_int(datum: ::core::ffi::c_int, list: *mut List) -> *mut List;
    pub fn lcons_oid(datum: Oid, list: *mut List) -> *mut List;
    pub fn list_concat(list1: *mut List, list2: *const List) -> *mut List;
    pub fn list_concat_copy(list1: *const List, list2: *const List) -> *mut List;
    pub fn list_truncate(list: *mut List, new_size: ::core::ffi::c_int) -> *mut List;
    pub fn list_member(list: *const List, datum: *const ::core::ffi::c_void) -> bool;
    pub fn list_member_ptr(list: *const List, datum: *const ::core::ffi::c_void) -> bool;
    pub fn list_member_int(list: *const List, datum: ::core::ffi::c_int) -> bool;
    pub fn list_member_oid(list: *const List, datum: Oid) -> bool;
    pub fn list_member_xid(list: *const List, datum: TransactionId) -> bool;
    pub fn list_delete(list: *mut List, datum: *mut ::core::ffi::c_void) -> *mut List;
    pub fn list_delete_ptr(list: *mut List, datum: *mut ::core::ffi::c_void) -> *mut List;
    pub fn list_delete_int(list: *mut List, datum: ::core::ffi::c_int) -> *mut List;
    pub fn list_delete_oid(list: *mut List, datum: Oid) -> *mut List;
    pub fn list_delete_first(list: *mut List) -> *mut List;
    pub fn list_delete_last(list: *mut List) -> *mut List;
    pub fn list_delete_first_n(list: *mut List, n: ::core::ffi::c_int) -> *mut List;
    pub fn list_delete_nth_cell(list: *mut List, n: ::core::ffi::c_int) -> *mut List;
    pub fn list_delete_cell(list: *mut List, cell: *mut ListCell) -> *mut List;
    pub fn list_union(list1: *const List, list2: *const List) -> *mut List;
    pub fn list_union_ptr(list1: *const List, list2: *const List) -> *mut List;
    pub fn list_union_int(list1: *const List, list2: *const List) -> *mut List;
    pub fn list_union_oid(list1: *const List, list2: *const List) -> *mut List;
    pub fn list_intersection(list1: *const List, list2: *const List) -> *mut List;
    pub fn list_intersection_int(list1: *const List, list2: *const List) -> *mut List;
    pub fn list_difference(list1: *const List, list2: *const List) -> *mut List;
    pub fn list_difference_ptr(list1: *const List, list2: *const List) -> *mut List;
    pub fn list_difference_int(list1: *const List, list2: *const List) -> *mut List;
    pub fn list_difference_oid(list1: *const List, list2: *const List) -> *mut List;
    pub fn list_append_unique(list: *mut List, datum: *mut ::core::ffi::c_void) -> *mut List;
    pub fn list_append_unique_ptr(list: *mut List, datum: *mut ::core::ffi::c_void) -> *mut List;
    pub fn list_append_unique_int(list: *mut List, datum: ::core::ffi::c_int) -> *mut List;
    pub fn list_append_unique_oid(list: *mut List, datum: Oid) -> *mut List;
    pub fn list_concat_unique(list1: *mut List, list2: *const List) -> *mut List;
    pub fn list_concat_unique_ptr(list1: *mut List, list2: *const List) -> *mut List;
    pub fn list_concat_unique_int(list1: *mut List, list2: *const List) -> *mut List;
    pub fn list_concat_unique_oid(list1: *mut List, list2: *const List) -> *mut List;
    pub fn list_deduplicate_oid(list: *mut List);
    pub fn list_free(list: *mut List);
    pub fn list_free_deep(list: *mut List);
    pub fn list_copy(oldlist: *const List) -> *mut List;
    pub fn list_copy_head(oldlist: *const List, len: ::core::ffi::c_int) -> *mut List;
    pub fn list_copy_tail(oldlist: *const List, nskip: ::core::ffi::c_int) -> *mut List;
    pub fn list_copy_deep(oldlist: *const List) -> *mut List;
    pub fn list_sort(list: *mut List, cmp: list_sort_comparator);
    pub fn list_int_cmp(p1: *const ListCell, p2: *const ListCell) -> ::core::ffi::c_int;
    pub fn list_oid_cmp(p1: *const ListCell, p2: *const ListCell) -> ::core::ffi::c_int;
    pub fn CreateTemplateTupleDesc(natts: ::core::ffi::c_int) -> TupleDesc;
    pub fn CreateTupleDesc(natts: ::core::ffi::c_int, attrs: *mut Form_pg_attribute) -> TupleDesc;
    pub fn CreateTupleDescCopy(tupdesc: TupleDesc) -> TupleDesc;
    pub fn CreateTupleDescCopyConstr(tupdesc: TupleDesc) -> TupleDesc;
    pub fn TupleDescCopy(dst: TupleDesc, src: TupleDesc);
    pub fn TupleDescCopyEntry(
        dst: TupleDesc,
        dstAttno: AttrNumber,
        src: TupleDesc,
        srcAttno: AttrNumber,
    );
    pub fn FreeTupleDesc(tupdesc: TupleDesc);
    pub fn IncrTupleDescRefCount(tupdesc: TupleDesc);
    pub fn DecrTupleDescRefCount(tupdesc: TupleDesc);
    pub fn equalTupleDescs(tupdesc1: TupleDesc, tupdesc2: TupleDesc) -> bool;
    pub fn equalRowTypes(tupdesc1: TupleDesc, tupdesc2: TupleDesc) -> bool;
    pub fn hashRowType(desc: TupleDesc) -> uint32;
    pub fn TupleDescInitEntry(
        desc: TupleDesc,
        attributeNumber: AttrNumber,
        attributeName: *const ::core::ffi::c_char,
        oidtypeid: Oid,
        typmod: int32,
        attdim: ::core::ffi::c_int,
    );
    pub fn TupleDescInitBuiltinEntry(
        desc: TupleDesc,
        attributeNumber: AttrNumber,
        attributeName: *const ::core::ffi::c_char,
        oidtypeid: Oid,
        typmod: int32,
        attdim: ::core::ffi::c_int,
    );
    pub fn TupleDescInitEntryCollation(
        desc: TupleDesc,
        attributeNumber: AttrNumber,
        collationid: Oid,
    );
    pub fn BuildDescFromLists(
        names: *const List,
        types: *const List,
        typmods: *const List,
        collations: *const List,
    ) -> TupleDesc;
    pub fn TupleDescGetDefault(tupdesc: TupleDesc, attnum: AttrNumber) -> *mut Node;
    pub fn make_attrmap(maplen: ::core::ffi::c_int) -> *mut AttrMap;
    pub fn free_attrmap(map: *mut AttrMap);
    pub fn build_attrmap_by_name(
        indesc: TupleDesc,
        outdesc: TupleDesc,
        missing_ok: bool,
    ) -> *mut AttrMap;
    pub fn build_attrmap_by_name_if_req(
        indesc: TupleDesc,
        outdesc: TupleDesc,
        missing_ok: bool,
    ) -> *mut AttrMap;
    pub fn build_attrmap_by_position(
        indesc: TupleDesc,
        outdesc: TupleDesc,
        msg: *const ::core::ffi::c_char,
    ) -> *mut AttrMap;
    pub fn ItemPointerEquals(pointer1: ItemPointer, pointer2: ItemPointer) -> bool;
    pub fn ItemPointerCompare(arg1: ItemPointer, arg2: ItemPointer) -> int32;
    pub fn ItemPointerInc(pointer: ItemPointer);
    pub fn ItemPointerDec(pointer: ItemPointer);
    pub fn HeapTupleHeaderGetCmin(tup: HeapTupleHeader) -> CommandId;
    pub fn HeapTupleHeaderGetCmax(tup: HeapTupleHeader) -> CommandId;
    pub fn HeapTupleHeaderAdjustCmax(
        tup: HeapTupleHeader,
        cmax: *mut CommandId,
        iscombo: *mut bool,
    );
    pub fn HeapTupleGetUpdateXid(tuple: HeapTupleHeader) -> TransactionId;
    pub fn TransactionStartedDuringRecovery() -> bool;
    pub static mut TransamVariables: *mut TransamVariablesData;
    pub fn TransactionIdDidCommit(transactionId: TransactionId) -> bool;
    pub fn TransactionIdDidAbort(transactionId: TransactionId) -> bool;
    pub fn TransactionIdCommitTree(
        xid: TransactionId,
        nxids: ::core::ffi::c_int,
        xids: *mut TransactionId,
    );
    pub fn TransactionIdAsyncCommitTree(
        xid: TransactionId,
        nxids: ::core::ffi::c_int,
        xids: *mut TransactionId,
        lsn: XLogRecPtr,
    );
    pub fn TransactionIdAbortTree(
        xid: TransactionId,
        nxids: ::core::ffi::c_int,
        xids: *mut TransactionId,
    );
    pub fn TransactionIdPrecedes(id1: TransactionId, id2: TransactionId) -> bool;
    pub fn TransactionIdPrecedesOrEquals(id1: TransactionId, id2: TransactionId) -> bool;
    pub fn TransactionIdFollows(id1: TransactionId, id2: TransactionId) -> bool;
    pub fn TransactionIdFollowsOrEquals(id1: TransactionId, id2: TransactionId) -> bool;
    pub fn TransactionIdLatest(
        mainxid: TransactionId,
        nxids: ::core::ffi::c_int,
        xids: *const TransactionId,
    ) -> TransactionId;
    pub fn TransactionIdGetCommitLSN(xid: TransactionId) -> XLogRecPtr;
    pub fn VarsupShmemSize() -> Size;
    pub fn VarsupShmemInit();
    pub fn GetNewTransactionId(isSubXact: bool) -> FullTransactionId;
    pub fn AdvanceNextFullTransactionIdPastXid(xid: TransactionId);
    pub fn ReadNextFullTransactionId() -> FullTransactionId;
    pub fn SetTransactionIdLimit(oldest_datfrozenxid: TransactionId, oldest_datoid: Oid);
    pub fn AdvanceOldestClogXid(oldest_datfrozenxid: TransactionId);
    pub fn ForceTransactionIdLimitUpdate() -> bool;
    pub fn GetNewObjectId() -> Oid;
    pub fn StopGeneratingPinnedObjectIds();
    pub fn AssertTransactionIdInAllowableRange(xid: TransactionId);
    pub fn PageInit(page: Page, pageSize: Size, specialSize: Size);
    pub fn PageIsVerifiedExtended(
        page: Page,
        blkno: BlockNumber,
        flags: ::core::ffi::c_int,
    ) -> bool;
    pub fn PageAddItemExtended(
        page: Page,
        item: Item,
        size: Size,
        offsetNumber: OffsetNumber,
        flags: ::core::ffi::c_int,
    ) -> OffsetNumber;
    pub fn PageGetTempPage(page: Page) -> Page;
    pub fn PageGetTempPageCopy(page: Page) -> Page;
    pub fn PageGetTempPageCopySpecial(page: Page) -> Page;
    pub fn PageRestoreTempPage(tempPage: Page, oldPage: Page);
    pub fn PageRepairFragmentation(page: Page);
    pub fn PageTruncateLinePointerArray(page: Page);
    pub fn PageGetFreeSpace(page: Page) -> Size;
    pub fn PageGetFreeSpaceForMultipleTuples(page: Page, ntups: ::core::ffi::c_int) -> Size;
    pub fn PageGetExactFreeSpace(page: Page) -> Size;
    pub fn PageGetHeapFreeSpace(page: Page) -> Size;
    pub fn PageIndexTupleDelete(page: Page, offnum: OffsetNumber);
    pub fn PageIndexMultiDelete(page: Page, itemnos: *mut OffsetNumber, nitems: ::core::ffi::c_int);
    pub fn PageIndexTupleDeleteNoCompact(page: Page, offnum: OffsetNumber);
    pub fn PageIndexTupleOverwrite(
        page: Page,
        offnum: OffsetNumber,
        newtup: Item,
        newsize: Size,
    ) -> bool;
    pub fn PageSetChecksumCopy(page: Page, blkno: BlockNumber) -> *mut ::core::ffi::c_char;
    pub fn PageSetChecksumInplace(page: Page, blkno: BlockNumber);
    pub fn heap_compute_data_size(
        tupleDesc: TupleDesc,
        values: *const Datum,
        isnull: *const bool,
    ) -> Size;
    pub fn heap_fill_tuple(
        tupleDesc: TupleDesc,
        values: *const Datum,
        isnull: *const bool,
        data: *mut ::core::ffi::c_char,
        data_size: Size,
        infomask: *mut uint16,
        bit: *mut bits8,
    );
    pub fn heap_attisnull(tup: HeapTuple, attnum: ::core::ffi::c_int, tupleDesc: TupleDesc)
        -> bool;
    pub fn nocachegetattr(
        tup: HeapTuple,
        attnum: ::core::ffi::c_int,
        tupleDesc: TupleDesc,
    ) -> Datum;
    pub fn heap_getsysattr(
        tup: HeapTuple,
        attnum: ::core::ffi::c_int,
        tupleDesc: TupleDesc,
        isnull: *mut bool,
    ) -> Datum;
    pub fn getmissingattr(
        tupleDesc: TupleDesc,
        attnum: ::core::ffi::c_int,
        isnull: *mut bool,
    ) -> Datum;
    pub fn heap_copytuple(tuple: HeapTuple) -> HeapTuple;
    pub fn heap_copytuple_with_tuple(src: HeapTuple, dest: HeapTuple);
    pub fn heap_copy_tuple_as_datum(tuple: HeapTuple, tupleDesc: TupleDesc) -> Datum;
    pub fn heap_form_tuple(
        tupleDescriptor: TupleDesc,
        values: *const Datum,
        isnull: *const bool,
    ) -> HeapTuple;
    pub fn heap_modify_tuple(
        tuple: HeapTuple,
        tupleDesc: TupleDesc,
        replValues: *const Datum,
        replIsnull: *const bool,
        doReplace: *const bool,
    ) -> HeapTuple;
    pub fn heap_modify_tuple_by_cols(
        tuple: HeapTuple,
        tupleDesc: TupleDesc,
        nCols: ::core::ffi::c_int,
        replCols: *const ::core::ffi::c_int,
        replValues: *const Datum,
        replIsnull: *const bool,
    ) -> HeapTuple;
    pub fn heap_deform_tuple(
        tuple: HeapTuple,
        tupleDesc: TupleDesc,
        values: *mut Datum,
        isnull: *mut bool,
    );
    pub fn heap_freetuple(htup: HeapTuple);
    pub fn heap_form_minimal_tuple(
        tupleDescriptor: TupleDesc,
        values: *const Datum,
        isnull: *const bool,
    ) -> MinimalTuple;
    pub fn heap_free_minimal_tuple(mtup: MinimalTuple);
    pub fn heap_copy_minimal_tuple(mtup: MinimalTuple) -> MinimalTuple;
    pub fn heap_tuple_from_minimal_tuple(mtup: MinimalTuple) -> HeapTuple;
    pub fn minimal_tuple_from_heap_tuple(htup: HeapTuple) -> MinimalTuple;
    pub fn heap_expand_tuple(sourceTuple: HeapTuple, tupleDesc: TupleDesc) -> HeapTuple;
    pub fn minimal_expand_tuple(sourceTuple: HeapTuple, tupleDesc: TupleDesc) -> MinimalTuple;
    pub static TTSOpsVirtual: TupleTableSlotOps;
    pub static TTSOpsHeapTuple: TupleTableSlotOps;
    pub static TTSOpsMinimalTuple: TupleTableSlotOps;
    pub static TTSOpsBufferHeapTuple: TupleTableSlotOps;
    pub fn MakeTupleTableSlot(
        tupleDesc: TupleDesc,
        tts_ops: *const TupleTableSlotOps,
    ) -> *mut TupleTableSlot;
    pub fn ExecAllocTableSlot(
        tupleTable: *mut *mut List,
        desc: TupleDesc,
        tts_ops: *const TupleTableSlotOps,
    ) -> *mut TupleTableSlot;
    pub fn ExecResetTupleTable(tupleTable: *mut List, shouldFree: bool);
    pub fn MakeSingleTupleTableSlot(
        tupdesc: TupleDesc,
        tts_ops: *const TupleTableSlotOps,
    ) -> *mut TupleTableSlot;
    pub fn ExecDropSingleTupleTableSlot(slot: *mut TupleTableSlot);
    pub fn ExecSetSlotDescriptor(slot: *mut TupleTableSlot, tupdesc: TupleDesc);
    pub fn ExecStoreHeapTuple(
        tuple: HeapTuple,
        slot: *mut TupleTableSlot,
        shouldFree: bool,
    ) -> *mut TupleTableSlot;
    pub fn ExecForceStoreHeapTuple(tuple: HeapTuple, slot: *mut TupleTableSlot, shouldFree: bool);
    pub fn ExecStoreBufferHeapTuple(
        tuple: HeapTuple,
        slot: *mut TupleTableSlot,
        buffer: Buffer,
    ) -> *mut TupleTableSlot;
    pub fn ExecStorePinnedBufferHeapTuple(
        tuple: HeapTuple,
        slot: *mut TupleTableSlot,
        buffer: Buffer,
    ) -> *mut TupleTableSlot;
    pub fn ExecStoreMinimalTuple(
        mtup: MinimalTuple,
        slot: *mut TupleTableSlot,
        shouldFree: bool,
    ) -> *mut TupleTableSlot;
    pub fn ExecForceStoreMinimalTuple(
        mtup: MinimalTuple,
        slot: *mut TupleTableSlot,
        shouldFree: bool,
    );
    pub fn ExecStoreVirtualTuple(slot: *mut TupleTableSlot) -> *mut TupleTableSlot;
    pub fn ExecStoreAllNullTuple(slot: *mut TupleTableSlot) -> *mut TupleTableSlot;
    pub fn ExecStoreHeapTupleDatum(data: Datum, slot: *mut TupleTableSlot);
    pub fn ExecFetchSlotHeapTuple(
        slot: *mut TupleTableSlot,
        materialize: bool,
        shouldFree: *mut bool,
    ) -> HeapTuple;
    pub fn ExecFetchSlotMinimalTuple(
        slot: *mut TupleTableSlot,
        shouldFree: *mut bool,
    ) -> MinimalTuple;
    pub fn ExecFetchSlotHeapTupleDatum(slot: *mut TupleTableSlot) -> Datum;
    pub fn slot_getmissingattrs(
        slot: *mut TupleTableSlot,
        startAttNum: ::core::ffi::c_int,
        lastAttNum: ::core::ffi::c_int,
    );
    pub fn slot_getsomeattrs_int(slot: *mut TupleTableSlot, attnum: ::core::ffi::c_int);
    pub fn bms_copy(a: *const Bitmapset) -> *mut Bitmapset;
    pub fn bms_equal(a: *const Bitmapset, b: *const Bitmapset) -> bool;
    pub fn bms_compare(a: *const Bitmapset, b: *const Bitmapset) -> ::core::ffi::c_int;
    pub fn bms_make_singleton(x: ::core::ffi::c_int) -> *mut Bitmapset;
    pub fn bms_free(a: *mut Bitmapset);
    pub fn bms_union(a: *const Bitmapset, b: *const Bitmapset) -> *mut Bitmapset;
    pub fn bms_intersect(a: *const Bitmapset, b: *const Bitmapset) -> *mut Bitmapset;
    pub fn bms_difference(a: *const Bitmapset, b: *const Bitmapset) -> *mut Bitmapset;
    pub fn bms_is_subset(a: *const Bitmapset, b: *const Bitmapset) -> bool;
    pub fn bms_subset_compare(a: *const Bitmapset, b: *const Bitmapset) -> BMS_Comparison::Type;
    pub fn bms_is_member(x: ::core::ffi::c_int, a: *const Bitmapset) -> bool;
    pub fn bms_member_index(a: *mut Bitmapset, x: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn bms_overlap(a: *const Bitmapset, b: *const Bitmapset) -> bool;
    pub fn bms_overlap_list(a: *const Bitmapset, b: *const List) -> bool;
    pub fn bms_nonempty_difference(a: *const Bitmapset, b: *const Bitmapset) -> bool;
    pub fn bms_singleton_member(a: *const Bitmapset) -> ::core::ffi::c_int;
    pub fn bms_get_singleton_member(a: *const Bitmapset, member: *mut ::core::ffi::c_int) -> bool;
    pub fn bms_num_members(a: *const Bitmapset) -> ::core::ffi::c_int;
    pub fn bms_membership(a: *const Bitmapset) -> BMS_Membership::Type;
    pub fn bms_add_member(a: *mut Bitmapset, x: ::core::ffi::c_int) -> *mut Bitmapset;
    pub fn bms_del_member(a: *mut Bitmapset, x: ::core::ffi::c_int) -> *mut Bitmapset;
    pub fn bms_add_members(a: *mut Bitmapset, b: *const Bitmapset) -> *mut Bitmapset;
    pub fn bms_replace_members(a: *mut Bitmapset, b: *const Bitmapset) -> *mut Bitmapset;
    pub fn bms_add_range(
        a: *mut Bitmapset,
        lower: ::core::ffi::c_int,
        upper: ::core::ffi::c_int,
    ) -> *mut Bitmapset;
    pub fn bms_int_members(a: *mut Bitmapset, b: *const Bitmapset) -> *mut Bitmapset;
    pub fn bms_del_members(a: *mut Bitmapset, b: *const Bitmapset) -> *mut Bitmapset;
    pub fn bms_join(a: *mut Bitmapset, b: *mut Bitmapset) -> *mut Bitmapset;
    pub fn bms_next_member(a: *const Bitmapset, prevbit: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn bms_prev_member(a: *const Bitmapset, prevbit: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn bms_hash_value(a: *const Bitmapset) -> uint32;
    pub fn bitmap_hash(key: *const ::core::ffi::c_void, keysize: Size) -> uint32;
    pub fn bitmap_match(
        key1: *const ::core::ffi::c_void,
        key2: *const ::core::ffi::c_void,
        keysize: Size,
    ) -> ::core::ffi::c_int;
    pub fn convert_tuples_by_position(
        indesc: TupleDesc,
        outdesc: TupleDesc,
        msg: *const ::core::ffi::c_char,
    ) -> *mut TupleConversionMap;
    pub fn convert_tuples_by_name(indesc: TupleDesc, outdesc: TupleDesc)
        -> *mut TupleConversionMap;
    pub fn convert_tuples_by_name_attrmap(
        indesc: TupleDesc,
        outdesc: TupleDesc,
        attrMap: *mut AttrMap,
    ) -> *mut TupleConversionMap;
    pub fn execute_attr_map_tuple(tuple: HeapTuple, map: *mut TupleConversionMap) -> HeapTuple;
    pub fn execute_attr_map_slot(
        attrMap: *mut AttrMap,
        in_slot: *mut TupleTableSlot,
        out_slot: *mut TupleTableSlot,
    ) -> *mut TupleTableSlot;
    pub fn execute_attr_map_cols(attrMap: *mut AttrMap, in_cols: *mut Bitmapset) -> *mut Bitmapset;
    pub fn free_conversion_map(map: *mut TupleConversionMap);
    pub static mut pgBufferUsage: BufferUsage;
    pub static mut pgWalUsage: WalUsage;
    pub fn InstrAlloc(
        n: ::core::ffi::c_int,
        instrument_options: ::core::ffi::c_int,
        async_mode: bool,
    ) -> *mut Instrumentation;
    pub fn InstrInit(instr: *mut Instrumentation, instrument_options: ::core::ffi::c_int);
    pub fn InstrStartNode(instr: *mut Instrumentation);
    pub fn InstrStopNode(instr: *mut Instrumentation, nTuples: f64);
    pub fn InstrUpdateTupleCount(instr: *mut Instrumentation, nTuples: f64);
    pub fn InstrEndLoop(instr: *mut Instrumentation);
    pub fn InstrAggNode(dst: *mut Instrumentation, add: *mut Instrumentation);
    pub fn InstrStartParallelQuery();
    pub fn InstrEndParallelQuery(bufusage: *mut BufferUsage, walusage: *mut WalUsage);
    pub fn InstrAccumParallelQuery(bufusage: *mut BufferUsage, walusage: *mut WalUsage);
    pub fn BufferUsageAccumDiff(
        dst: *mut BufferUsage,
        add: *const BufferUsage,
        sub: *const BufferUsage,
    );
    pub fn WalUsageAccumDiff(dst: *mut WalUsage, add: *const WalUsage, sub: *const WalUsage);
    pub fn fmgr_info(functionId: Oid, finfo: *mut FmgrInfo);
    pub fn fmgr_info_cxt(functionId: Oid, finfo: *mut FmgrInfo, mcxt: MemoryContext);
    pub fn fmgr_info_copy(dstinfo: *mut FmgrInfo, srcinfo: *mut FmgrInfo, destcxt: MemoryContext);
    pub fn fmgr_symbol(
        functionId: Oid,
        mod_: *mut *mut ::core::ffi::c_char,
        fn_: *mut *mut ::core::ffi::c_char,
    );
    pub fn pg_detoast_datum(datum: *mut varlena) -> *mut varlena;
    pub fn pg_detoast_datum_copy(datum: *mut varlena) -> *mut varlena;
    pub fn pg_detoast_datum_slice(datum: *mut varlena, first: int32, count: int32) -> *mut varlena;
    pub fn pg_detoast_datum_packed(datum: *mut varlena) -> *mut varlena;
    pub fn _PG_init();
    pub fn _PG_fini();
    pub fn DirectFunctionCall1Coll(func: PGFunction, collation: Oid, arg1: Datum) -> Datum;
    pub fn DirectFunctionCall2Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
    ) -> Datum;
    pub fn DirectFunctionCall3Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
    ) -> Datum;
    pub fn DirectFunctionCall4Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
    ) -> Datum;
    pub fn DirectFunctionCall5Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
    ) -> Datum;
    pub fn DirectFunctionCall6Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
    ) -> Datum;
    pub fn DirectFunctionCall7Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
    ) -> Datum;
    pub fn DirectFunctionCall8Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
        arg8: Datum,
    ) -> Datum;
    pub fn DirectFunctionCall9Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
        arg8: Datum,
        arg9: Datum,
    ) -> Datum;
    pub fn CallerFInfoFunctionCall1(
        func: PGFunction,
        flinfo: *mut FmgrInfo,
        collation: Oid,
        arg1: Datum,
    ) -> Datum;
    pub fn CallerFInfoFunctionCall2(
        func: PGFunction,
        flinfo: *mut FmgrInfo,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
    ) -> Datum;
    pub fn FunctionCall0Coll(flinfo: *mut FmgrInfo, collation: Oid) -> Datum;
    pub fn FunctionCall1Coll(flinfo: *mut FmgrInfo, collation: Oid, arg1: Datum) -> Datum;
    pub fn FunctionCall2Coll(
        flinfo: *mut FmgrInfo,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
    ) -> Datum;
    pub fn FunctionCall3Coll(
        flinfo: *mut FmgrInfo,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
    ) -> Datum;
    pub fn FunctionCall4Coll(
        flinfo: *mut FmgrInfo,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
    ) -> Datum;
    pub fn FunctionCall5Coll(
        flinfo: *mut FmgrInfo,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
    ) -> Datum;
    pub fn FunctionCall6Coll(
        flinfo: *mut FmgrInfo,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
    ) -> Datum;
    pub fn FunctionCall7Coll(
        flinfo: *mut FmgrInfo,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
    ) -> Datum;
    pub fn FunctionCall8Coll(
        flinfo: *mut FmgrInfo,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
        arg8: Datum,
    ) -> Datum;
    pub fn FunctionCall9Coll(
        flinfo: *mut FmgrInfo,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
        arg8: Datum,
        arg9: Datum,
    ) -> Datum;
    pub fn OidFunctionCall0Coll(functionId: Oid, collation: Oid) -> Datum;
    pub fn OidFunctionCall1Coll(functionId: Oid, collation: Oid, arg1: Datum) -> Datum;
    pub fn OidFunctionCall2Coll(functionId: Oid, collation: Oid, arg1: Datum, arg2: Datum)
        -> Datum;
    pub fn OidFunctionCall3Coll(
        functionId: Oid,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
    ) -> Datum;
    pub fn OidFunctionCall4Coll(
        functionId: Oid,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
    ) -> Datum;
    pub fn OidFunctionCall5Coll(
        functionId: Oid,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
    ) -> Datum;
    pub fn OidFunctionCall6Coll(
        functionId: Oid,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
    ) -> Datum;
    pub fn OidFunctionCall7Coll(
        functionId: Oid,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
    ) -> Datum;
    pub fn OidFunctionCall8Coll(
        functionId: Oid,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
        arg8: Datum,
    ) -> Datum;
    pub fn OidFunctionCall9Coll(
        functionId: Oid,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
        arg8: Datum,
        arg9: Datum,
    ) -> Datum;
    pub fn InputFunctionCall(
        flinfo: *mut FmgrInfo,
        str_: *mut ::core::ffi::c_char,
        typioparam: Oid,
        typmod: int32,
    ) -> Datum;
    pub fn InputFunctionCallSafe(
        flinfo: *mut FmgrInfo,
        str_: *mut ::core::ffi::c_char,
        typioparam: Oid,
        typmod: int32,
        escontext: fmNodePtr,
        result: *mut Datum,
    ) -> bool;
    pub fn DirectInputFunctionCallSafe(
        func: PGFunction,
        str_: *mut ::core::ffi::c_char,
        typioparam: Oid,
        typmod: int32,
        escontext: fmNodePtr,
        result: *mut Datum,
    ) -> bool;
    pub fn OidInputFunctionCall(
        functionId: Oid,
        str_: *mut ::core::ffi::c_char,
        typioparam: Oid,
        typmod: int32,
    ) -> Datum;
    pub fn OutputFunctionCall(flinfo: *mut FmgrInfo, val: Datum) -> *mut ::core::ffi::c_char;
    pub fn OidOutputFunctionCall(functionId: Oid, val: Datum) -> *mut ::core::ffi::c_char;
    pub fn ReceiveFunctionCall(
        flinfo: *mut FmgrInfo,
        buf: fmStringInfo,
        typioparam: Oid,
        typmod: int32,
    ) -> Datum;
    pub fn OidReceiveFunctionCall(
        functionId: Oid,
        buf: fmStringInfo,
        typioparam: Oid,
        typmod: int32,
    ) -> Datum;
    pub fn SendFunctionCall(flinfo: *mut FmgrInfo, val: Datum) -> *mut bytea;
    pub fn OidSendFunctionCall(functionId: Oid, val: Datum) -> *mut bytea;
    pub fn fetch_finfo_record(
        filehandle: *mut ::core::ffi::c_void,
        funcname: *const ::core::ffi::c_char,
    ) -> *const Pg_finfo_record;
    pub fn fmgr_internal_function(proname: *const ::core::ffi::c_char) -> Oid;
    pub fn get_fn_expr_rettype(flinfo: *mut FmgrInfo) -> Oid;
    pub fn get_fn_expr_argtype(flinfo: *mut FmgrInfo, argnum: ::core::ffi::c_int) -> Oid;
    pub fn get_call_expr_argtype(expr: fmNodePtr, argnum: ::core::ffi::c_int) -> Oid;
    pub fn get_fn_expr_arg_stable(flinfo: *mut FmgrInfo, argnum: ::core::ffi::c_int) -> bool;
    pub fn get_call_expr_arg_stable(expr: fmNodePtr, argnum: ::core::ffi::c_int) -> bool;
    pub fn get_fn_expr_variadic(flinfo: *mut FmgrInfo) -> bool;
    pub fn get_fn_opclass_options(flinfo: *mut FmgrInfo) -> *mut bytea;
    pub fn has_fn_opclass_options(flinfo: *mut FmgrInfo) -> bool;
    pub fn set_fn_opclass_options(flinfo: *mut FmgrInfo, options: *mut bytea);
    pub fn CheckFunctionValidatorAccess(validatorOid: Oid, functionOid: Oid) -> bool;
    pub static mut Dynamic_library_path: *mut ::core::ffi::c_char;
    pub fn load_external_function(
        filename: *const ::core::ffi::c_char,
        funcname: *const ::core::ffi::c_char,
        signalNotFound: bool,
        filehandle: *mut *mut ::core::ffi::c_void,
    ) -> *mut ::core::ffi::c_void;
    pub fn lookup_external_function(
        filehandle: *mut ::core::ffi::c_void,
        funcname: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_void;
    pub fn load_file(filename: *const ::core::ffi::c_char, restricted: bool);
    pub fn find_rendezvous_variable(
        varName: *const ::core::ffi::c_char,
    ) -> *mut *mut ::core::ffi::c_void;
    pub fn EstimateLibraryStateSpace() -> Size;
    pub fn SerializeLibraryState(maxsize: Size, start_address: *mut ::core::ffi::c_char);
    pub fn RestoreLibraryState(start_address: *mut ::core::ffi::c_char);
    pub fn AggCheckCallContext(
        fcinfo: FunctionCallInfo,
        aggcontext: *mut MemoryContext,
    ) -> ::core::ffi::c_int;
    pub fn AggGetAggref(fcinfo: FunctionCallInfo) -> fmAggrefPtr;
    pub fn AggGetTempMemoryContext(fcinfo: FunctionCallInfo) -> MemoryContext;
    pub fn AggStateIsShared(fcinfo: FunctionCallInfo) -> bool;
    pub fn AggRegisterCallback(
        fcinfo: FunctionCallInfo,
        func: fmExprContextCallbackFunction,
        arg: Datum,
    );
    pub static mut needs_fmgr_hook: needs_fmgr_hook_type;
    pub static mut fmgr_hook: fmgr_hook_type;
    pub fn slist_delete(head: *mut slist_head, node: *const slist_node);
    pub fn pairingheap_allocate(
        compare: pairingheap_comparator,
        arg: *mut ::core::ffi::c_void,
    ) -> *mut pairingheap;
    pub fn pairingheap_free(heap: *mut pairingheap);
    pub fn pairingheap_add(heap: *mut pairingheap, node: *mut pairingheap_node);
    pub fn pairingheap_first(heap: *mut pairingheap) -> *mut pairingheap_node;
    pub fn pairingheap_remove_first(heap: *mut pairingheap) -> *mut pairingheap_node;
    pub fn pairingheap_remove(heap: *mut pairingheap, node: *mut pairingheap_node);
    pub fn makeParamList(numParams: ::core::ffi::c_int) -> ParamListInfo;
    pub fn copyParamList(from: ParamListInfo) -> ParamListInfo;
    pub fn EstimateParamListSpace(paramLI: ParamListInfo) -> Size;
    pub fn SerializeParamList(paramLI: ParamListInfo, start_address: *mut *mut ::core::ffi::c_char);
    pub fn RestoreParamList(start_address: *mut *mut ::core::ffi::c_char) -> ParamListInfo;
    pub fn BuildParamLogString(
        params: ParamListInfo,
        knownTextValues: *mut *mut ::core::ffi::c_char,
        maxlen: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn ParamsErrorCallback(arg: *mut ::core::ffi::c_void);
    pub static forkNames: [*const ::core::ffi::c_char; 0usize];
    pub fn forkname_to_number(forkName: *const ::core::ffi::c_char) -> ForkNumber::Type;
    pub fn forkname_chars(
        str_: *const ::core::ffi::c_char,
        fork: *mut ForkNumber::Type,
    ) -> ::core::ffi::c_int;
    pub fn GetDatabasePath(dbOid: Oid, spcOid: Oid) -> *mut ::core::ffi::c_char;
    pub fn GetRelationPath(
        dbOid: Oid,
        spcOid: Oid,
        relNumber: RelFileNumber,
        procNumber: ::core::ffi::c_int,
        forkNumber: ForkNumber::Type,
    ) -> *mut ::core::ffi::c_char;
    pub static mut dynamic_shared_memory_type: ::core::ffi::c_int;
    pub static mut min_dynamic_shared_memory: ::core::ffi::c_int;
    pub fn dsm_impl_op(
        op: dsm_op::Type,
        handle: dsm_handle,
        request_size: Size,
        impl_private: *mut *mut ::core::ffi::c_void,
        mapped_address: *mut *mut ::core::ffi::c_void,
        mapped_size: *mut Size,
        elevel: ::core::ffi::c_int,
    ) -> bool;
    pub fn dsm_impl_pin_segment(
        handle: dsm_handle,
        impl_private: *mut ::core::ffi::c_void,
        impl_private_pm_handle: *mut *mut ::core::ffi::c_void,
    );
    pub fn dsm_impl_unpin_segment(handle: dsm_handle, impl_private: *mut *mut ::core::ffi::c_void);
    pub fn dsm_cleanup_using_control_segment(old_control_handle: dsm_handle);
    pub fn dsm_postmaster_startup(arg1: *mut PGShmemHeader);
    pub fn dsm_backend_shutdown();
    pub fn dsm_detach_all();
    pub fn dsm_estimate_size() -> usize;
    pub fn dsm_shmem_init();
    pub fn dsm_create(size: Size, flags: ::core::ffi::c_int) -> *mut dsm_segment;
    pub fn dsm_attach(h: dsm_handle) -> *mut dsm_segment;
    pub fn dsm_detach(seg: *mut dsm_segment);
    pub fn dsm_pin_mapping(seg: *mut dsm_segment);
    pub fn dsm_unpin_mapping(seg: *mut dsm_segment);
    pub fn dsm_pin_segment(seg: *mut dsm_segment);
    pub fn dsm_unpin_segment(handle: dsm_handle);
    pub fn dsm_find_mapping(handle: dsm_handle) -> *mut dsm_segment;
    pub fn dsm_segment_address(seg: *mut dsm_segment) -> *mut ::core::ffi::c_void;
    pub fn dsm_segment_map_length(seg: *mut dsm_segment) -> Size;
    pub fn dsm_segment_handle(seg: *mut dsm_segment) -> dsm_handle;
    pub fn on_dsm_detach(seg: *mut dsm_segment, function: on_dsm_detach_callback, arg: Datum);
    pub fn cancel_on_dsm_detach(
        seg: *mut dsm_segment,
        function: on_dsm_detach_callback,
        arg: Datum,
    );
    pub fn reset_on_dsm_detach();
    pub fn dsa_create_ext(
        tranche_id: ::core::ffi::c_int,
        init_segment_size: usize,
        max_segment_size: usize,
    ) -> *mut dsa_area;
    pub fn dsa_create_in_place_ext(
        place: *mut ::core::ffi::c_void,
        size: usize,
        tranche_id: ::core::ffi::c_int,
        segment: *mut dsm_segment,
        init_segment_size: usize,
        max_segment_size: usize,
    ) -> *mut dsa_area;
    pub fn dsa_attach(handle: dsa_handle) -> *mut dsa_area;
    pub fn dsa_attach_in_place(
        place: *mut ::core::ffi::c_void,
        segment: *mut dsm_segment,
    ) -> *mut dsa_area;
    pub fn dsa_release_in_place(place: *mut ::core::ffi::c_void);
    pub fn dsa_on_dsm_detach_release_in_place(arg1: *mut dsm_segment, arg2: Datum);
    pub fn dsa_on_shmem_exit_release_in_place(arg1: ::core::ffi::c_int, arg2: Datum);
    pub fn dsa_pin_mapping(area: *mut dsa_area);
    pub fn dsa_detach(area: *mut dsa_area);
    pub fn dsa_pin(area: *mut dsa_area);
    pub fn dsa_unpin(area: *mut dsa_area);
    pub fn dsa_set_size_limit(area: *mut dsa_area, limit: usize);
    pub fn dsa_minimum_size() -> usize;
    pub fn dsa_get_handle(area: *mut dsa_area) -> dsa_handle;
    pub fn dsa_allocate_extended(
        area: *mut dsa_area,
        size: usize,
        flags: ::core::ffi::c_int,
    ) -> dsa_pointer;
    pub fn dsa_free(area: *mut dsa_area, dp: dsa_pointer);
    pub fn dsa_get_address(area: *mut dsa_area, dp: dsa_pointer) -> *mut ::core::ffi::c_void;
    pub fn dsa_get_total_size(area: *mut dsa_area) -> usize;
    pub fn dsa_trim(area: *mut dsa_area);
    pub fn dsa_dump(area: *mut dsa_area);
    pub fn tbm_create(maxbytes: ::core::ffi::c_long, dsa: *mut dsa_area) -> *mut TIDBitmap;
    pub fn tbm_free(tbm: *mut TIDBitmap);
    pub fn tbm_free_shared_area(dsa: *mut dsa_area, dp: dsa_pointer);
    pub fn tbm_add_tuples(
        tbm: *mut TIDBitmap,
        tids: ItemPointer,
        ntids: ::core::ffi::c_int,
        recheck: bool,
    );
    pub fn tbm_add_page(tbm: *mut TIDBitmap, pageno: BlockNumber);
    pub fn tbm_union(a: *mut TIDBitmap, b: *const TIDBitmap);
    pub fn tbm_intersect(a: *mut TIDBitmap, b: *const TIDBitmap);
    pub fn tbm_is_empty(tbm: *const TIDBitmap) -> bool;
    pub fn tbm_begin_iterate(tbm: *mut TIDBitmap) -> *mut TBMIterator;
    pub fn tbm_prepare_shared_iterate(tbm: *mut TIDBitmap) -> dsa_pointer;
    pub fn tbm_iterate(iterator: *mut TBMIterator) -> *mut TBMIterateResult;
    pub fn tbm_shared_iterate(iterator: *mut TBMSharedIterator) -> *mut TBMIterateResult;
    pub fn tbm_end_iterate(iterator: *mut TBMIterator);
    pub fn tbm_end_shared_iterate(iterator: *mut TBMSharedIterator);
    pub fn tbm_attach_shared_iterate(dsa: *mut dsa_area, dp: dsa_pointer)
        -> *mut TBMSharedIterator;
    pub fn tbm_calculate_entries(maxbytes: f64) -> ::core::ffi::c_long;
    pub static mut MyProcNumber: ProcNumber;
    pub static mut ParallelLeaderProcNumber: ProcNumber;
    pub fn s_lock(
        lock: *mut slock_t,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
        func: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn set_spins_per_delay(shared_spins_per_delay: ::core::ffi::c_int);
    pub fn update_spins_per_delay(shared_spins_per_delay: ::core::ffi::c_int)
        -> ::core::ffi::c_int;
    pub fn perform_spin_delay(status: *mut SpinDelayStatus);
    pub fn finish_spin_delay(status: *mut SpinDelayStatus);
    pub fn SpinlockSemas() -> ::core::ffi::c_int;
    pub fn SpinlockSemaSize() -> Size;
    pub fn ConditionVariableInit(cv: *mut ConditionVariable);
    pub fn ConditionVariableSleep(cv: *mut ConditionVariable, wait_event_info: uint32);
    pub fn ConditionVariableTimedSleep(
        cv: *mut ConditionVariable,
        timeout: ::core::ffi::c_long,
        wait_event_info: uint32,
    ) -> bool;
    pub fn ConditionVariableCancelSleep() -> bool;
    pub fn ConditionVariablePrepareToSleep(cv: *mut ConditionVariable);
    pub fn ConditionVariableSignal(cv: *mut ConditionVariable);
    pub fn ConditionVariableBroadcast(cv: *mut ConditionVariable);
    pub fn hash_create(
        tabname: *const ::core::ffi::c_char,
        nelem: ::core::ffi::c_long,
        info: *const HASHCTL,
        flags: ::core::ffi::c_int,
    ) -> *mut HTAB;
    pub fn hash_destroy(hashp: *mut HTAB);
    pub fn hash_stats(where_: *const ::core::ffi::c_char, hashp: *mut HTAB);
    pub fn hash_search(
        hashp: *mut HTAB,
        keyPtr: *const ::core::ffi::c_void,
        action: HASHACTION::Type,
        foundPtr: *mut bool,
    ) -> *mut ::core::ffi::c_void;
    pub fn get_hash_value(hashp: *mut HTAB, keyPtr: *const ::core::ffi::c_void) -> uint32;
    pub fn hash_search_with_hash_value(
        hashp: *mut HTAB,
        keyPtr: *const ::core::ffi::c_void,
        hashvalue: uint32,
        action: HASHACTION::Type,
        foundPtr: *mut bool,
    ) -> *mut ::core::ffi::c_void;
    pub fn hash_update_hash_key(
        hashp: *mut HTAB,
        existingEntry: *mut ::core::ffi::c_void,
        newKeyPtr: *const ::core::ffi::c_void,
    ) -> bool;
    pub fn hash_get_num_entries(hashp: *mut HTAB) -> ::core::ffi::c_long;
    pub fn hash_seq_init(status: *mut HASH_SEQ_STATUS, hashp: *mut HTAB);
    pub fn hash_seq_search(status: *mut HASH_SEQ_STATUS) -> *mut ::core::ffi::c_void;
    pub fn hash_seq_term(status: *mut HASH_SEQ_STATUS);
    pub fn hash_freeze(hashp: *mut HTAB);
    pub fn hash_estimate_size(num_entries: ::core::ffi::c_long, entrysize: Size) -> Size;
    pub fn hash_select_dirsize(num_entries: ::core::ffi::c_long) -> ::core::ffi::c_long;
    pub fn hash_get_shared_size(info: *mut HASHCTL, flags: ::core::ffi::c_int) -> Size;
    pub fn AtEOXact_HashTables(isCommit: bool);
    pub fn AtEOSubXact_HashTables(isCommit: bool, nestDepth: ::core::ffi::c_int);
    pub fn create_queryEnv() -> *mut QueryEnvironment;
    pub fn get_visible_ENR_metadata(
        queryEnv: *mut QueryEnvironment,
        refname: *const ::core::ffi::c_char,
    ) -> EphemeralNamedRelationMetadata;
    pub fn register_ENR(queryEnv: *mut QueryEnvironment, enr: EphemeralNamedRelation);
    pub fn unregister_ENR(queryEnv: *mut QueryEnvironment, name: *const ::core::ffi::c_char);
    pub fn get_ENR(
        queryEnv: *mut QueryEnvironment,
        name: *const ::core::ffi::c_char,
    ) -> EphemeralNamedRelation;
    pub fn ENRMetadataGetTupDesc(enrmd: EphemeralNamedRelationMetadata) -> TupleDesc;
    pub static mut max_files_per_process: ::core::ffi::c_int;
    pub static mut data_sync_retry: bool;
    pub static mut recovery_init_sync_method: ::core::ffi::c_int;
    pub static mut io_direct_flags: ::core::ffi::c_int;
    pub static mut max_safe_fds: ::core::ffi::c_int;
    pub fn PathNameOpenFile(
        fileName: *const ::core::ffi::c_char,
        fileFlags: ::core::ffi::c_int,
    ) -> File;
    pub fn PathNameOpenFilePerm(
        fileName: *const ::core::ffi::c_char,
        fileFlags: ::core::ffi::c_int,
        fileMode: mode_t,
    ) -> File;
    pub fn OpenTemporaryFile(interXact: bool) -> File;
    pub fn FileClose(file: File);
    pub fn FilePrefetch(
        file: File,
        offset: off_t,
        amount: off_t,
        wait_event_info: uint32,
    ) -> ::core::ffi::c_int;
    pub fn FileReadV(
        file: File,
        iov: *const iovec,
        iovcnt: ::core::ffi::c_int,
        offset: off_t,
        wait_event_info: uint32,
    ) -> isize;
    pub fn FileWriteV(
        file: File,
        iov: *const iovec,
        iovcnt: ::core::ffi::c_int,
        offset: off_t,
        wait_event_info: uint32,
    ) -> isize;
    pub fn FileSync(file: File, wait_event_info: uint32) -> ::core::ffi::c_int;
    pub fn FileZero(
        file: File,
        offset: off_t,
        amount: off_t,
        wait_event_info: uint32,
    ) -> ::core::ffi::c_int;
    pub fn FileFallocate(
        file: File,
        offset: off_t,
        amount: off_t,
        wait_event_info: uint32,
    ) -> ::core::ffi::c_int;
    pub fn FileSize(file: File) -> off_t;
    pub fn FileTruncate(file: File, offset: off_t, wait_event_info: uint32) -> ::core::ffi::c_int;
    pub fn FileWriteback(file: File, offset: off_t, nbytes: off_t, wait_event_info: uint32);
    pub fn FilePathName(file: File) -> *mut ::core::ffi::c_char;
    pub fn FileGetRawDesc(file: File) -> ::core::ffi::c_int;
    pub fn FileGetRawFlags(file: File) -> ::core::ffi::c_int;
    pub fn FileGetRawMode(file: File) -> mode_t;
    pub fn PathNameCreateTemporaryFile(
        path: *const ::core::ffi::c_char,
        error_on_failure: bool,
    ) -> File;
    pub fn PathNameOpenTemporaryFile(
        path: *const ::core::ffi::c_char,
        mode: ::core::ffi::c_int,
    ) -> File;
    pub fn PathNameDeleteTemporaryFile(
        path: *const ::core::ffi::c_char,
        error_on_failure: bool,
    ) -> bool;
    pub fn PathNameCreateTemporaryDir(
        basedir: *const ::core::ffi::c_char,
        directory: *const ::core::ffi::c_char,
    );
    pub fn PathNameDeleteTemporaryDir(dirname: *const ::core::ffi::c_char);
    pub fn TempTablespacePath(path: *mut ::core::ffi::c_char, tablespace: Oid);
    pub fn AllocateFile(
        name: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
    ) -> *mut FILE;
    pub fn FreeFile(file: *mut FILE) -> ::core::ffi::c_int;
    pub fn OpenPipeStream(
        command: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
    ) -> *mut FILE;
    pub fn ClosePipeStream(file: *mut FILE) -> ::core::ffi::c_int;
    pub fn AllocateDir(dirname: *const ::core::ffi::c_char) -> *mut DIR;
    pub fn ReadDir(dir: *mut DIR, dirname: *const ::core::ffi::c_char) -> *mut dirent;
    pub fn ReadDirExtended(
        dir: *mut DIR,
        dirname: *const ::core::ffi::c_char,
        elevel: ::core::ffi::c_int,
    ) -> *mut dirent;
    pub fn FreeDir(dir: *mut DIR) -> ::core::ffi::c_int;
    pub fn OpenTransientFile(
        fileName: *const ::core::ffi::c_char,
        fileFlags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn OpenTransientFilePerm(
        fileName: *const ::core::ffi::c_char,
        fileFlags: ::core::ffi::c_int,
        fileMode: mode_t,
    ) -> ::core::ffi::c_int;
    pub fn CloseTransientFile(fd: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn BasicOpenFile(
        fileName: *const ::core::ffi::c_char,
        fileFlags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn BasicOpenFilePerm(
        fileName: *const ::core::ffi::c_char,
        fileFlags: ::core::ffi::c_int,
        fileMode: mode_t,
    ) -> ::core::ffi::c_int;
    pub fn AcquireExternalFD() -> bool;
    pub fn ReserveExternalFD();
    pub fn ReleaseExternalFD();
    pub fn MakePGDirectory(directoryName: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn InitFileAccess();
    pub fn InitTemporaryFileAccess();
    pub fn set_max_safe_fds();
    pub fn closeAllVfds();
    pub fn SetTempTablespaces(tableSpaces: *mut Oid, numSpaces: ::core::ffi::c_int);
    pub fn TempTablespacesAreSet() -> bool;
    pub fn GetTempTablespaces(
        tableSpaces: *mut Oid,
        numSpaces: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn GetNextTempTableSpace() -> Oid;
    pub fn AtEOXact_Files(isCommit: bool);
    pub fn AtEOSubXact_Files(
        isCommit: bool,
        mySubid: SubTransactionId,
        parentSubid: SubTransactionId,
    );
    pub fn RemovePgTempFiles();
    pub fn RemovePgTempFilesInDir(
        tmpdirname: *const ::core::ffi::c_char,
        missing_ok: bool,
        unlink_all: bool,
    );
    pub fn looks_like_temp_rel_name(name: *const ::core::ffi::c_char) -> bool;
    pub fn pg_fsync(fd: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn pg_fsync_no_writethrough(fd: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn pg_fsync_writethrough(fd: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn pg_fdatasync(fd: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn pg_file_exists(name: *const ::core::ffi::c_char) -> bool;
    pub fn pg_flush_data(fd: ::core::ffi::c_int, offset: off_t, nbytes: off_t);
    pub fn pg_truncate(path: *const ::core::ffi::c_char, length: off_t) -> ::core::ffi::c_int;
    pub fn fsync_fname(fname: *const ::core::ffi::c_char, isdir: bool);
    pub fn fsync_fname_ext(
        fname: *const ::core::ffi::c_char,
        isdir: bool,
        ignore_perm: bool,
        elevel: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn durable_rename(
        oldfile: *const ::core::ffi::c_char,
        newfile: *const ::core::ffi::c_char,
        elevel: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn durable_unlink(
        fname: *const ::core::ffi::c_char,
        elevel: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn SyncDataDirectory();
    pub fn data_sync_elevel(elevel: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn FileSetInit(fileset: *mut FileSet);
    pub fn FileSetCreate(fileset: *mut FileSet, name: *const ::core::ffi::c_char) -> File;
    pub fn FileSetOpen(
        fileset: *mut FileSet,
        name: *const ::core::ffi::c_char,
        mode: ::core::ffi::c_int,
    ) -> File;
    pub fn FileSetDelete(
        fileset: *mut FileSet,
        name: *const ::core::ffi::c_char,
        error_on_failure: bool,
    ) -> bool;
    pub fn FileSetDeleteAll(fileset: *mut FileSet);
    pub fn SharedFileSetInit(fileset: *mut SharedFileSet, seg: *mut dsm_segment);
    pub fn SharedFileSetAttach(fileset: *mut SharedFileSet, seg: *mut dsm_segment);
    pub fn SharedFileSetDeleteAll(fileset: *mut SharedFileSet);
    pub fn sts_estimate(participants: ::core::ffi::c_int) -> usize;
    pub fn sts_initialize(
        sts: *mut SharedTuplestore,
        participants: ::core::ffi::c_int,
        my_participant_number: ::core::ffi::c_int,
        meta_data_size: usize,
        flags: ::core::ffi::c_int,
        fileset: *mut SharedFileSet,
        name: *const ::core::ffi::c_char,
    ) -> *mut SharedTuplestoreAccessor;
    pub fn sts_attach(
        sts: *mut SharedTuplestore,
        my_participant_number: ::core::ffi::c_int,
        fileset: *mut SharedFileSet,
    ) -> *mut SharedTuplestoreAccessor;
    pub fn sts_end_write(accessor: *mut SharedTuplestoreAccessor);
    pub fn sts_reinitialize(accessor: *mut SharedTuplestoreAccessor);
    pub fn sts_begin_parallel_scan(accessor: *mut SharedTuplestoreAccessor);
    pub fn sts_end_parallel_scan(accessor: *mut SharedTuplestoreAccessor);
    pub fn sts_puttuple(
        accessor: *mut SharedTuplestoreAccessor,
        meta_data: *mut ::core::ffi::c_void,
        tuple: MinimalTuple,
    );
    pub fn sts_parallel_scan_next(
        accessor: *mut SharedTuplestoreAccessor,
        meta_data: *mut ::core::ffi::c_void,
    ) -> MinimalTuple;
    pub fn RelationIdGetRelation(relationId: Oid) -> Relation;
    pub fn RelationClose(relation: Relation);
    pub fn RelationGetFKeyList(relation: Relation) -> *mut List;
    pub fn RelationGetIndexList(relation: Relation) -> *mut List;
    pub fn RelationGetStatExtList(relation: Relation) -> *mut List;
    pub fn RelationGetPrimaryKeyIndex(relation: Relation) -> Oid;
    pub fn RelationGetReplicaIndex(relation: Relation) -> Oid;
    pub fn RelationGetIndexExpressions(relation: Relation) -> *mut List;
    pub fn RelationGetDummyIndexExpressions(relation: Relation) -> *mut List;
    pub fn RelationGetIndexPredicate(relation: Relation) -> *mut List;
    pub fn RelationGetIndexAttOptions(relation: Relation, copy: bool) -> *mut *mut bytea;
    pub fn RelationGetIndexAttrBitmap(
        relation: Relation,
        attrKind: IndexAttrBitmapKind::Type,
    ) -> *mut Bitmapset;
    pub fn RelationGetIdentityKeyBitmap(relation: Relation) -> *mut Bitmapset;
    pub fn RelationGetExclusionInfo(
        indexRelation: Relation,
        operators: *mut *mut Oid,
        procs: *mut *mut Oid,
        strategies: *mut *mut uint16,
    );
    pub fn RelationInitIndexAccessInfo(relation: Relation);
    pub fn RelationBuildPublicationDesc(relation: Relation, pubdesc: *mut PublicationDesc);
    pub fn RelationInitTableAccessMethod(relation: Relation);
    pub fn errtable(rel: Relation) -> ::core::ffi::c_int;
    pub fn errtablecol(rel: Relation, attnum: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn errtablecolname(
        rel: Relation,
        colname: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn errtableconstraint(
        rel: Relation,
        conname: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn RelationCacheInitialize();
    pub fn RelationCacheInitializePhase2();
    pub fn RelationCacheInitializePhase3();
    pub fn RelationBuildLocalRelation(
        relname: *const ::core::ffi::c_char,
        relnamespace: Oid,
        tupDesc: TupleDesc,
        relid: Oid,
        accessmtd: Oid,
        relfilenumber: RelFileNumber,
        reltablespace: Oid,
        shared_relation: bool,
        mapped_relation: bool,
        relpersistence: ::core::ffi::c_char,
        relkind: ::core::ffi::c_char,
    ) -> Relation;
    pub fn RelationSetNewRelfilenumber(relation: Relation, persistence: ::core::ffi::c_char);
    pub fn RelationAssumeNewRelfilelocator(relation: Relation);
    pub fn RelationForgetRelation(rid: Oid);
    pub fn RelationCacheInvalidateEntry(relationId: Oid);
    pub fn RelationCacheInvalidate(debug_discard: bool);
    pub fn AssertPendingSyncs_RelationCache();
    pub fn AtEOXact_RelationCache(isCommit: bool);
    pub fn AtEOSubXact_RelationCache(
        isCommit: bool,
        mySubid: SubTransactionId,
        parentSubid: SubTransactionId,
    );
    pub fn RelationIdIsInInitFile(relationId: Oid) -> bool;
    pub fn RelationCacheInitFilePreInvalidate();
    pub fn RelationCacheInitFilePostInvalidate();
    pub fn RelationCacheInitFileRemove();
    pub static mut criticalRelcachesBuilt: bool;
    pub static mut criticalSharedRelcachesBuilt: bool;
    pub fn ssup_datum_unsigned_cmp(x: Datum, y: Datum, ssup: SortSupport) -> ::core::ffi::c_int;
    pub fn ssup_datum_signed_cmp(x: Datum, y: Datum, ssup: SortSupport) -> ::core::ffi::c_int;
    pub fn ssup_datum_int32_cmp(x: Datum, y: Datum, ssup: SortSupport) -> ::core::ffi::c_int;
    pub fn PrepareSortSupportComparisonShim(cmpFunc: Oid, ssup: SortSupport);
    pub fn PrepareSortSupportFromOrderingOp(orderingOp: Oid, ssup: SortSupport);
    pub fn PrepareSortSupportFromIndexRel(indexRel: Relation, strategy: int16, ssup: SortSupport);
    pub fn PrepareSortSupportFromGistIndexRel(indexRel: Relation, ssup: SortSupport);
    pub fn ScanKeyInit(
        entry: ScanKey,
        attributeNumber: AttrNumber,
        strategy: StrategyNumber,
        procedure: RegProcedure,
        argument: Datum,
    );
    pub fn ScanKeyEntryInitialize(
        entry: ScanKey,
        flags: ::core::ffi::c_int,
        attributeNumber: AttrNumber,
        strategy: StrategyNumber,
        subtype: Oid,
        collation: Oid,
        procedure: RegProcedure,
        argument: Datum,
    );
    pub fn ScanKeyEntryInitializeWithInfo(
        entry: ScanKey,
        flags: ::core::ffi::c_int,
        attributeNumber: AttrNumber,
        strategy: StrategyNumber,
        subtype: Oid,
        collation: Oid,
        finfo: *mut FmgrInfo,
        argument: Datum,
    );
    pub fn index_open(relationId: Oid, lockmode: LOCKMODE) -> Relation;
    pub fn try_index_open(relationId: Oid, lockmode: LOCKMODE) -> Relation;
    pub fn index_close(relation: Relation, lockmode: LOCKMODE);
    pub fn index_insert(
        indexRelation: Relation,
        values: *mut Datum,
        isnull: *mut bool,
        heap_t_ctid: ItemPointer,
        heapRelation: Relation,
        checkUnique: IndexUniqueCheck::Type,
        indexUnchanged: bool,
        indexInfo: *mut IndexInfo,
    ) -> bool;
    pub fn index_insert_cleanup(indexRelation: Relation, indexInfo: *mut IndexInfo);
    pub fn index_beginscan(
        heapRelation: Relation,
        indexRelation: Relation,
        snapshot: Snapshot,
        nkeys: ::core::ffi::c_int,
        norderbys: ::core::ffi::c_int,
    ) -> IndexScanDesc;
    pub fn index_beginscan_bitmap(
        indexRelation: Relation,
        snapshot: Snapshot,
        nkeys: ::core::ffi::c_int,
    ) -> IndexScanDesc;
    pub fn index_rescan(
        scan: IndexScanDesc,
        keys: ScanKey,
        nkeys: ::core::ffi::c_int,
        orderbys: ScanKey,
        norderbys: ::core::ffi::c_int,
    );
    pub fn index_endscan(scan: IndexScanDesc);
    pub fn index_markpos(scan: IndexScanDesc);
    pub fn index_restrpos(scan: IndexScanDesc);
    pub fn index_parallelscan_estimate(
        indexRelation: Relation,
        nkeys: ::core::ffi::c_int,
        norderbys: ::core::ffi::c_int,
        snapshot: Snapshot,
    ) -> Size;
    pub fn index_parallelscan_initialize(
        heapRelation: Relation,
        indexRelation: Relation,
        snapshot: Snapshot,
        target: ParallelIndexScanDesc,
    );
    pub fn index_parallelrescan(scan: IndexScanDesc);
    pub fn index_beginscan_parallel(
        heaprel: Relation,
        indexrel: Relation,
        nkeys: ::core::ffi::c_int,
        norderbys: ::core::ffi::c_int,
        pscan: ParallelIndexScanDesc,
    ) -> IndexScanDesc;
    pub fn index_getnext_tid(scan: IndexScanDesc, direction: ScanDirection::Type) -> ItemPointer;
    pub fn index_fetch_heap(scan: IndexScanDesc, slot: *mut TupleTableSlot) -> bool;
    pub fn index_getnext_slot(
        scan: IndexScanDesc,
        direction: ScanDirection::Type,
        slot: *mut TupleTableSlot,
    ) -> bool;
    pub fn index_getbitmap(scan: IndexScanDesc, bitmap: *mut TIDBitmap) -> int64;
    pub fn index_bulk_delete(
        info: *mut IndexVacuumInfo,
        istat: *mut IndexBulkDeleteResult,
        callback: IndexBulkDeleteCallback,
        callback_state: *mut ::core::ffi::c_void,
    ) -> *mut IndexBulkDeleteResult;
    pub fn index_vacuum_cleanup(
        info: *mut IndexVacuumInfo,
        istat: *mut IndexBulkDeleteResult,
    ) -> *mut IndexBulkDeleteResult;
    pub fn index_can_return(indexRelation: Relation, attno: ::core::ffi::c_int) -> bool;
    pub fn index_getprocid(irel: Relation, attnum: AttrNumber, procnum: uint16) -> RegProcedure;
    pub fn index_getprocinfo(irel: Relation, attnum: AttrNumber, procnum: uint16) -> *mut FmgrInfo;
    pub fn index_store_float8_orderby_distances(
        scan: IndexScanDesc,
        orderByTypes: *mut Oid,
        distances: *mut IndexOrderByDistance,
        recheckOrderBy: bool,
    );
    pub fn index_opclass_options(
        indrel: Relation,
        attnum: AttrNumber,
        attoptions: Datum,
        validate: bool,
    ) -> *mut bytea;
    pub fn RelationGetIndexScan(
        indexRelation: Relation,
        nkeys: ::core::ffi::c_int,
        norderbys: ::core::ffi::c_int,
    ) -> IndexScanDesc;
    pub fn IndexScanEnd(scan: IndexScanDesc);
    pub fn BuildIndexValueDescription(
        indexRelation: Relation,
        values: *const Datum,
        isnull: *const bool,
    ) -> *mut ::core::ffi::c_char;
    pub fn index_compute_xid_horizon_for_tuples(
        irel: Relation,
        hrel: Relation,
        ibuf: Buffer,
        itemnos: *mut OffsetNumber,
        nitems: ::core::ffi::c_int,
    ) -> TransactionId;
    pub fn systable_beginscan(
        heapRelation: Relation,
        indexId: Oid,
        indexOK: bool,
        snapshot: Snapshot,
        nkeys: ::core::ffi::c_int,
        key: ScanKey,
    ) -> SysScanDesc;
    pub fn systable_getnext(sysscan: SysScanDesc) -> HeapTuple;
    pub fn systable_recheck_tuple(sysscan: SysScanDesc, tup: HeapTuple) -> bool;
    pub fn systable_endscan(sysscan: SysScanDesc);
    pub fn systable_beginscan_ordered(
        heapRelation: Relation,
        indexRelation: Relation,
        snapshot: Snapshot,
        nkeys: ::core::ffi::c_int,
        key: ScanKey,
    ) -> SysScanDesc;
    pub fn systable_getnext_ordered(
        sysscan: SysScanDesc,
        direction: ScanDirection::Type,
    ) -> HeapTuple;
    pub fn systable_endscan_ordered(sysscan: SysScanDesc);
    pub fn systable_inplace_update_begin(
        relation: Relation,
        indexId: Oid,
        indexOK: bool,
        snapshot: Snapshot,
        nkeys: ::core::ffi::c_int,
        key: *const ScanKeyData,
        oldtupcopy: *mut HeapTuple,
        state: *mut *mut ::core::ffi::c_void,
    );
    pub fn systable_inplace_update_finish(state: *mut ::core::ffi::c_void, tuple: HeapTuple);
    pub fn systable_inplace_update_cancel(state: *mut ::core::ffi::c_void);
    pub fn GetIndexAmRoutine(amhandler: Oid) -> *mut IndexAmRoutine;
    pub fn GetIndexAmRoutineByAmId(amoid: Oid, noerror: bool) -> *mut IndexAmRoutine;
    pub fn lookup_type_cache(type_id: Oid, flags: ::core::ffi::c_int) -> *mut TypeCacheEntry;
    pub fn InitDomainConstraintRef(
        type_id: Oid,
        ref_: *mut DomainConstraintRef,
        refctx: MemoryContext,
        need_exprstate: bool,
    );
    pub fn UpdateDomainConstraintRef(ref_: *mut DomainConstraintRef);
    pub fn DomainHasConstraints(type_id: Oid) -> bool;
    pub fn lookup_rowtype_tupdesc(type_id: Oid, typmod: int32) -> TupleDesc;
    pub fn lookup_rowtype_tupdesc_noerror(type_id: Oid, typmod: int32, noError: bool) -> TupleDesc;
    pub fn lookup_rowtype_tupdesc_copy(type_id: Oid, typmod: int32) -> TupleDesc;
    pub fn lookup_rowtype_tupdesc_domain(type_id: Oid, typmod: int32, noError: bool) -> TupleDesc;
    pub fn assign_record_type_typmod(tupDesc: TupleDesc);
    pub fn assign_record_type_identifier(type_id: Oid, typmod: int32) -> uint64;
    pub fn compare_values_of_enum(
        tcache: *mut TypeCacheEntry,
        arg1: Oid,
        arg2: Oid,
    ) -> ::core::ffi::c_int;
    pub fn SharedRecordTypmodRegistryEstimate() -> usize;
    pub fn SharedRecordTypmodRegistryInit(
        arg1: *mut SharedRecordTypmodRegistry,
        segment: *mut dsm_segment,
        area: *mut dsa_area,
    );
    pub fn SharedRecordTypmodRegistryAttach(arg1: *mut SharedRecordTypmodRegistry);
    pub fn brin_build_desc(rel: Relation) -> *mut BrinDesc;
    pub fn brin_free_desc(bdesc: *mut BrinDesc);
    pub fn brinbuild(
        heap: Relation,
        index: Relation,
        indexInfo: *mut IndexInfo,
    ) -> *mut IndexBuildResult;
    pub fn brinbuildempty(index: Relation);
    pub fn brininsert(
        idxRel: Relation,
        values: *mut Datum,
        nulls: *mut bool,
        heaptid: ItemPointer,
        heapRel: Relation,
        checkUnique: IndexUniqueCheck::Type,
        indexUnchanged: bool,
        indexInfo: *mut IndexInfo,
    ) -> bool;
    pub fn brininsertcleanup(index: Relation, indexInfo: *mut IndexInfo);
    pub fn brinbeginscan(
        r: Relation,
        nkeys: ::core::ffi::c_int,
        norderbys: ::core::ffi::c_int,
    ) -> IndexScanDesc;
    pub fn bringetbitmap(scan: IndexScanDesc, tbm: *mut TIDBitmap) -> int64;
    pub fn brinrescan(
        scan: IndexScanDesc,
        scankey: ScanKey,
        nscankeys: ::core::ffi::c_int,
        orderbys: ScanKey,
        norderbys: ::core::ffi::c_int,
    );
    pub fn brinendscan(scan: IndexScanDesc);
    pub fn brinbulkdelete(
        info: *mut IndexVacuumInfo,
        stats: *mut IndexBulkDeleteResult,
        callback: IndexBulkDeleteCallback,
        callback_state: *mut ::core::ffi::c_void,
    ) -> *mut IndexBulkDeleteResult;
    pub fn brinvacuumcleanup(
        info: *mut IndexVacuumInfo,
        stats: *mut IndexBulkDeleteResult,
    ) -> *mut IndexBulkDeleteResult;
    pub fn brinoptions(reloptions: Datum, validate: bool) -> *mut bytea;
    pub fn brinvalidate(opclassoid: Oid) -> bool;
    pub fn brin_form_tuple(
        brdesc: *mut BrinDesc,
        blkno: BlockNumber,
        tuple: *mut BrinMemTuple,
        size: *mut Size,
    ) -> *mut BrinTuple;
    pub fn brin_form_placeholder_tuple(
        brdesc: *mut BrinDesc,
        blkno: BlockNumber,
        size: *mut Size,
    ) -> *mut BrinTuple;
    pub fn brin_free_tuple(tuple: *mut BrinTuple);
    pub fn brin_copy_tuple(
        tuple: *mut BrinTuple,
        len: Size,
        dest: *mut BrinTuple,
        destsz: *mut Size,
    ) -> *mut BrinTuple;
    pub fn brin_tuples_equal(
        a: *const BrinTuple,
        alen: Size,
        b: *const BrinTuple,
        blen: Size,
    ) -> bool;
    pub fn brin_new_memtuple(brdesc: *mut BrinDesc) -> *mut BrinMemTuple;
    pub fn brin_memtuple_initialize(
        dtuple: *mut BrinMemTuple,
        brdesc: *mut BrinDesc,
    ) -> *mut BrinMemTuple;
    pub fn brin_deform_tuple(
        brdesc: *mut BrinDesc,
        tuple: *mut BrinTuple,
        dMemtuple: *mut BrinMemTuple,
    ) -> *mut BrinMemTuple;
    pub fn index_form_tuple(
        tupleDescriptor: TupleDesc,
        values: *const Datum,
        isnull: *const bool,
    ) -> IndexTuple;
    pub fn index_form_tuple_context(
        tupleDescriptor: TupleDesc,
        values: *const Datum,
        isnull: *const bool,
        context: MemoryContext,
    ) -> IndexTuple;
    pub fn nocache_index_getattr(
        tup: IndexTuple,
        attnum: ::core::ffi::c_int,
        tupleDesc: TupleDesc,
    ) -> Datum;
    pub fn index_deform_tuple(
        tup: IndexTuple,
        tupleDescriptor: TupleDesc,
        values: *mut Datum,
        isnull: *mut bool,
    );
    pub fn index_deform_tuple_internal(
        tupleDescriptor: TupleDesc,
        values: *mut Datum,
        isnull: *mut bool,
        tp: *mut ::core::ffi::c_char,
        bp: *mut bits8,
        hasnulls: ::core::ffi::c_int,
    );
    pub fn CopyIndexTuple(source: IndexTuple) -> IndexTuple;
    pub fn index_truncate_tuple(
        sourceDescriptor: TupleDesc,
        source: IndexTuple,
        leavenatts: ::core::ffi::c_int,
    ) -> IndexTuple;
    pub fn LogicalTapeSetCreate(
        preallocate: bool,
        fileset: *mut SharedFileSet,
        worker: ::core::ffi::c_int,
    ) -> *mut LogicalTapeSet;
    pub fn LogicalTapeClose(lt: *mut LogicalTape);
    pub fn LogicalTapeSetClose(lts: *mut LogicalTapeSet);
    pub fn LogicalTapeCreate(lts: *mut LogicalTapeSet) -> *mut LogicalTape;
    pub fn LogicalTapeImport(
        lts: *mut LogicalTapeSet,
        worker: ::core::ffi::c_int,
        shared: *mut TapeShare,
    ) -> *mut LogicalTape;
    pub fn LogicalTapeSetForgetFreeSpace(lts: *mut LogicalTapeSet);
    pub fn LogicalTapeRead(
        lt: *mut LogicalTape,
        ptr: *mut ::core::ffi::c_void,
        size: usize,
    ) -> usize;
    pub fn LogicalTapeWrite(lt: *mut LogicalTape, ptr: *const ::core::ffi::c_void, size: usize);
    pub fn LogicalTapeRewindForRead(lt: *mut LogicalTape, buffer_size: usize);
    pub fn LogicalTapeFreeze(lt: *mut LogicalTape, share: *mut TapeShare);
    pub fn LogicalTapeBackspace(lt: *mut LogicalTape, size: usize) -> usize;
    pub fn LogicalTapeSeek(lt: *mut LogicalTape, blocknum: int64, offset: ::core::ffi::c_int);
    pub fn LogicalTapeTell(
        lt: *mut LogicalTape,
        blocknum: *mut int64,
        offset: *mut ::core::ffi::c_int,
    );
    pub fn LogicalTapeSetBlocks(lts: *mut LogicalTapeSet) -> int64;
    pub fn tuplesort_begin_common(
        workMem: ::core::ffi::c_int,
        coordinate: SortCoordinate,
        sortopt: ::core::ffi::c_int,
    ) -> *mut Tuplesortstate;
    pub fn tuplesort_set_bound(state: *mut Tuplesortstate, bound: int64);
    pub fn tuplesort_used_bound(state: *mut Tuplesortstate) -> bool;
    pub fn tuplesort_puttuple_common(
        state: *mut Tuplesortstate,
        tuple: *mut SortTuple,
        useAbbrev: bool,
        tuplen: Size,
    );
    pub fn tuplesort_performsort(state: *mut Tuplesortstate);
    pub fn tuplesort_gettuple_common(
        state: *mut Tuplesortstate,
        forward: bool,
        stup: *mut SortTuple,
    ) -> bool;
    pub fn tuplesort_skiptuples(state: *mut Tuplesortstate, ntuples: int64, forward: bool) -> bool;
    pub fn tuplesort_end(state: *mut Tuplesortstate);
    pub fn tuplesort_reset(state: *mut Tuplesortstate);
    pub fn tuplesort_get_stats(state: *mut Tuplesortstate, stats: *mut TuplesortInstrumentation);
    pub fn tuplesort_method_name(m: TuplesortMethod::Type) -> *const ::core::ffi::c_char;
    pub fn tuplesort_space_type_name(t: TuplesortSpaceType::Type) -> *const ::core::ffi::c_char;
    pub fn tuplesort_merge_order(allowedMem: int64) -> ::core::ffi::c_int;
    pub fn tuplesort_estimate_shared(nWorkers: ::core::ffi::c_int) -> Size;
    pub fn tuplesort_initialize_shared(
        shared: *mut Sharedsort,
        nWorkers: ::core::ffi::c_int,
        seg: *mut dsm_segment,
    );
    pub fn tuplesort_attach_shared(shared: *mut Sharedsort, seg: *mut dsm_segment);
    pub fn tuplesort_rescan(state: *mut Tuplesortstate);
    pub fn tuplesort_markpos(state: *mut Tuplesortstate);
    pub fn tuplesort_restorepos(state: *mut Tuplesortstate);
    pub fn tuplesort_readtup_alloc(
        state: *mut Tuplesortstate,
        tuplen: Size,
    ) -> *mut ::core::ffi::c_void;
    pub fn tuplesort_begin_heap(
        tupDesc: TupleDesc,
        nkeys: ::core::ffi::c_int,
        attNums: *mut AttrNumber,
        sortOperators: *mut Oid,
        sortCollations: *mut Oid,
        nullsFirstFlags: *mut bool,
        workMem: ::core::ffi::c_int,
        coordinate: SortCoordinate,
        sortopt: ::core::ffi::c_int,
    ) -> *mut Tuplesortstate;
    pub fn tuplesort_begin_cluster(
        tupDesc: TupleDesc,
        indexRel: Relation,
        workMem: ::core::ffi::c_int,
        coordinate: SortCoordinate,
        sortopt: ::core::ffi::c_int,
    ) -> *mut Tuplesortstate;
    pub fn tuplesort_begin_index_btree(
        heapRel: Relation,
        indexRel: Relation,
        enforceUnique: bool,
        uniqueNullsNotDistinct: bool,
        workMem: ::core::ffi::c_int,
        coordinate: SortCoordinate,
        sortopt: ::core::ffi::c_int,
    ) -> *mut Tuplesortstate;
    pub fn tuplesort_begin_index_hash(
        heapRel: Relation,
        indexRel: Relation,
        high_mask: uint32,
        low_mask: uint32,
        max_buckets: uint32,
        workMem: ::core::ffi::c_int,
        coordinate: SortCoordinate,
        sortopt: ::core::ffi::c_int,
    ) -> *mut Tuplesortstate;
    pub fn tuplesort_begin_index_gist(
        heapRel: Relation,
        indexRel: Relation,
        workMem: ::core::ffi::c_int,
        coordinate: SortCoordinate,
        sortopt: ::core::ffi::c_int,
    ) -> *mut Tuplesortstate;
    pub fn tuplesort_begin_index_brin(
        workMem: ::core::ffi::c_int,
        coordinate: SortCoordinate,
        sortopt: ::core::ffi::c_int,
    ) -> *mut Tuplesortstate;
    pub fn tuplesort_begin_datum(
        datumType: Oid,
        sortOperator: Oid,
        sortCollation: Oid,
        nullsFirstFlag: bool,
        workMem: ::core::ffi::c_int,
        coordinate: SortCoordinate,
        sortopt: ::core::ffi::c_int,
    ) -> *mut Tuplesortstate;
    pub fn tuplesort_puttupleslot(state: *mut Tuplesortstate, slot: *mut TupleTableSlot);
    pub fn tuplesort_putheaptuple(state: *mut Tuplesortstate, tup: HeapTuple);
    pub fn tuplesort_putindextuplevalues(
        state: *mut Tuplesortstate,
        rel: Relation,
        self_: ItemPointer,
        values: *const Datum,
        isnull: *const bool,
    );
    pub fn tuplesort_putbrintuple(state: *mut Tuplesortstate, tuple: *mut BrinTuple, size: Size);
    pub fn tuplesort_putdatum(state: *mut Tuplesortstate, val: Datum, isNull: bool);
    pub fn tuplesort_gettupleslot(
        state: *mut Tuplesortstate,
        forward: bool,
        copy: bool,
        slot: *mut TupleTableSlot,
        abbrev: *mut Datum,
    ) -> bool;
    pub fn tuplesort_getheaptuple(state: *mut Tuplesortstate, forward: bool) -> HeapTuple;
    pub fn tuplesort_getindextuple(state: *mut Tuplesortstate, forward: bool) -> IndexTuple;
    pub fn tuplesort_getbrintuple(
        state: *mut Tuplesortstate,
        len: *mut Size,
        forward: bool,
    ) -> *mut BrinTuple;
    pub fn tuplesort_getdatum(
        state: *mut Tuplesortstate,
        forward: bool,
        copy: bool,
        val: *mut Datum,
        isNull: *mut bool,
        abbrev: *mut Datum,
    ) -> bool;
    pub fn tuplestore_begin_heap(
        randomAccess: bool,
        interXact: bool,
        maxKBytes: ::core::ffi::c_int,
    ) -> *mut Tuplestorestate;
    pub fn tuplestore_set_eflags(state: *mut Tuplestorestate, eflags: ::core::ffi::c_int);
    pub fn tuplestore_puttupleslot(state: *mut Tuplestorestate, slot: *mut TupleTableSlot);
    pub fn tuplestore_puttuple(state: *mut Tuplestorestate, tuple: HeapTuple);
    pub fn tuplestore_putvalues(
        state: *mut Tuplestorestate,
        tdesc: TupleDesc,
        values: *const Datum,
        isnull: *const bool,
    );
    pub fn tuplestore_alloc_read_pointer(
        state: *mut Tuplestorestate,
        eflags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn tuplestore_select_read_pointer(state: *mut Tuplestorestate, ptr: ::core::ffi::c_int);
    pub fn tuplestore_copy_read_pointer(
        state: *mut Tuplestorestate,
        srcptr: ::core::ffi::c_int,
        destptr: ::core::ffi::c_int,
    );
    pub fn tuplestore_trim(state: *mut Tuplestorestate);
    pub fn tuplestore_in_memory(state: *mut Tuplestorestate) -> bool;
    pub fn tuplestore_gettupleslot(
        state: *mut Tuplestorestate,
        forward: bool,
        copy: bool,
        slot: *mut TupleTableSlot,
    ) -> bool;
    pub fn tuplestore_advance(state: *mut Tuplestorestate, forward: bool) -> bool;
    pub fn tuplestore_skiptuples(
        state: *mut Tuplestorestate,
        ntuples: int64,
        forward: bool,
    ) -> bool;
    pub fn tuplestore_tuple_count(state: *mut Tuplestorestate) -> int64;
    pub fn tuplestore_ateof(state: *mut Tuplestorestate) -> bool;
    pub fn tuplestore_rescan(state: *mut Tuplestorestate);
    pub fn tuplestore_clear(state: *mut Tuplestorestate);
    pub fn tuplestore_end(state: *mut Tuplestorestate);
    pub static pg_leftmost_one_pos: [uint8; 256usize];
    pub static pg_rightmost_one_pos: [uint8; 256usize];
    pub static pg_number_of_ones: [uint8; 256usize];
    pub static mut pg_popcount32:
        ::core::option::Option<unsafe extern "C-unwind" fn(word: uint32) -> ::core::ffi::c_int>;
    pub static mut pg_popcount64:
        ::core::option::Option<unsafe extern "C-unwind" fn(word: uint64) -> ::core::ffi::c_int>;
    pub static mut pg_popcount_optimized: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            buf: *const ::core::ffi::c_char,
            bytes: ::core::ffi::c_int,
        ) -> uint64,
    >;
    pub static mut pg_popcount_masked_optimized: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            buf: *const ::core::ffi::c_char,
            bytes: ::core::ffi::c_int,
            mask: bits8,
        ) -> uint64,
    >;
    pub fn pg_popcount_avx512_available() -> bool;
    pub fn pg_popcount_avx512(buf: *const ::core::ffi::c_char, bytes: ::core::ffi::c_int)
        -> uint64;
    pub fn pg_popcount_masked_avx512(
        buf: *const ::core::ffi::c_char,
        bytes: ::core::ffi::c_int,
        mask: bits8,
    ) -> uint64;
    pub fn tuplehash_create(
        ctx: MemoryContext,
        nelements: uint32,
        private_data: *mut ::core::ffi::c_void,
    ) -> *mut tuplehash_hash;
    pub fn tuplehash_destroy(tb: *mut tuplehash_hash);
    pub fn tuplehash_reset(tb: *mut tuplehash_hash);
    pub fn tuplehash_grow(tb: *mut tuplehash_hash, newsize: uint64);
    pub fn tuplehash_insert(
        tb: *mut tuplehash_hash,
        key: MinimalTuple,
        found: *mut bool,
    ) -> *mut TupleHashEntryData;
    pub fn tuplehash_insert_hash(
        tb: *mut tuplehash_hash,
        key: MinimalTuple,
        hash: uint32,
        found: *mut bool,
    ) -> *mut TupleHashEntryData;
    pub fn tuplehash_lookup(tb: *mut tuplehash_hash, key: MinimalTuple) -> *mut TupleHashEntryData;
    pub fn tuplehash_lookup_hash(
        tb: *mut tuplehash_hash,
        key: MinimalTuple,
        hash: uint32,
    ) -> *mut TupleHashEntryData;
    pub fn tuplehash_delete_item(tb: *mut tuplehash_hash, entry: *mut TupleHashEntryData);
    pub fn tuplehash_delete(tb: *mut tuplehash_hash, key: MinimalTuple) -> bool;
    pub fn tuplehash_start_iterate(tb: *mut tuplehash_hash, iter: *mut tuplehash_iterator);
    pub fn tuplehash_start_iterate_at(
        tb: *mut tuplehash_hash,
        iter: *mut tuplehash_iterator,
        at: uint32,
    );
    pub fn tuplehash_iterate(
        tb: *mut tuplehash_hash,
        iter: *mut tuplehash_iterator,
    ) -> *mut TupleHashEntryData;
    pub fn tuplehash_stat(tb: *mut tuplehash_hash);
    pub fn InitializeQueryCompletion(qc: *mut QueryCompletion);
    pub fn GetCommandTagName(commandTag: CommandTag::Type) -> *const ::core::ffi::c_char;
    pub fn GetCommandTagNameAndLen(
        commandTag: CommandTag::Type,
        len: *mut Size,
    ) -> *const ::core::ffi::c_char;
    pub fn command_tag_display_rowcount(commandTag: CommandTag::Type) -> bool;
    pub fn command_tag_event_trigger_ok(commandTag: CommandTag::Type) -> bool;
    pub fn command_tag_table_rewrite_ok(commandTag: CommandTag::Type) -> bool;
    pub fn GetCommandTagEnum(commandname: *const ::core::ffi::c_char) -> CommandTag::Type;
    pub fn BuildQueryCompletionString(
        buff: *mut ::core::ffi::c_char,
        qc: *const QueryCompletion,
        nameonly: bool,
    ) -> Size;
    pub static mut None_Receiver: *mut DestReceiver;
    pub fn BeginCommand(commandTag: CommandTag::Type, dest: CommandDest::Type);
    pub fn CreateDestReceiver(dest: CommandDest::Type) -> *mut DestReceiver;
    pub fn EndCommand(
        qc: *const QueryCompletion,
        dest: CommandDest::Type,
        force_undecorated_output: bool,
    );
    pub fn EndReplicationCommand(commandTag: *const ::core::ffi::c_char);
    pub fn NullCommand(dest: CommandDest::Type);
    pub fn ReadyForQuery(dest: CommandDest::Type);
    pub fn CreateQueryDesc(
        plannedstmt: *mut PlannedStmt,
        sourceText: *const ::core::ffi::c_char,
        snapshot: Snapshot,
        crosscheck_snapshot: Snapshot,
        dest: *mut DestReceiver,
        params: ParamListInfo,
        queryEnv: *mut QueryEnvironment,
        instrument_options: ::core::ffi::c_int,
    ) -> *mut QueryDesc;
    pub fn FreeQueryDesc(qdesc: *mut QueryDesc);
    pub fn makeInteger(i: ::core::ffi::c_int) -> *mut Integer;
    pub fn makeFloat(numericStr: *mut ::core::ffi::c_char) -> *mut Float;
    pub fn makeBoolean(val: bool) -> *mut Boolean;
    pub fn makeString(str_: *mut ::core::ffi::c_char) -> *mut String;
    pub fn makeBitString(str_: *mut ::core::ffi::c_char) -> *mut BitString;
    pub static mut TopMemoryContext: MemoryContext;
    pub static mut ErrorContext: MemoryContext;
    pub static mut PostmasterContext: MemoryContext;
    pub static mut CacheMemoryContext: MemoryContext;
    pub static mut MessageContext: MemoryContext;
    pub static mut TopTransactionContext: MemoryContext;
    pub static mut CurTransactionContext: MemoryContext;
    pub static mut PortalContext: MemoryContext;
    pub fn MemoryContextInit();
    pub fn MemoryContextReset(context: MemoryContext);
    pub fn MemoryContextDelete(context: MemoryContext);
    pub fn MemoryContextResetOnly(context: MemoryContext);
    pub fn MemoryContextResetChildren(context: MemoryContext);
    pub fn MemoryContextDeleteChildren(context: MemoryContext);
    pub fn MemoryContextSetIdentifier(context: MemoryContext, id: *const ::core::ffi::c_char);
    pub fn MemoryContextSetParent(context: MemoryContext, new_parent: MemoryContext);
    pub fn GetMemoryChunkSpace(pointer: *mut ::core::ffi::c_void) -> Size;
    pub fn MemoryContextGetParent(context: MemoryContext) -> MemoryContext;
    pub fn MemoryContextIsEmpty(context: MemoryContext) -> bool;
    pub fn MemoryContextMemAllocated(context: MemoryContext, recurse: bool) -> Size;
    pub fn MemoryContextMemConsumed(context: MemoryContext, consumed: *mut MemoryContextCounters);
    pub fn MemoryContextStats(context: MemoryContext);
    pub fn MemoryContextStatsDetail(
        context: MemoryContext,
        max_level: ::core::ffi::c_int,
        max_children: ::core::ffi::c_int,
        print_to_stderr: bool,
    );
    pub fn MemoryContextAllowInCriticalSection(context: MemoryContext, allow: bool);
    pub fn MemoryContextCheck(context: MemoryContext);
    pub fn HandleLogMemoryContextInterrupt();
    pub fn ProcessLogMemoryContextInterrupt();
    pub fn AllocSetContextCreateInternal(
        parent: MemoryContext,
        name: *const ::core::ffi::c_char,
        minContextSize: Size,
        initBlockSize: Size,
        maxBlockSize: Size,
    ) -> MemoryContext;
    pub fn SlabContextCreate(
        parent: MemoryContext,
        name: *const ::core::ffi::c_char,
        blockSize: Size,
        chunkSize: Size,
    ) -> MemoryContext;
    pub fn GenerationContextCreate(
        parent: MemoryContext,
        name: *const ::core::ffi::c_char,
        minContextSize: Size,
        initBlockSize: Size,
        maxBlockSize: Size,
    ) -> MemoryContext;
    pub fn BumpContextCreate(
        parent: MemoryContext,
        name: *const ::core::ffi::c_char,
        minContextSize: Size,
        initBlockSize: Size,
        maxBlockSize: Size,
    ) -> MemoryContext;
    pub static mut ExecutorStart_hook: ExecutorStart_hook_type;
    pub static mut ExecutorRun_hook: ExecutorRun_hook_type;
    pub static mut ExecutorFinish_hook: ExecutorFinish_hook_type;
    pub static mut ExecutorEnd_hook: ExecutorEnd_hook_type;
    pub static mut ExecutorCheckPerms_hook: ExecutorCheckPerms_hook_type;
    pub fn ExecReScan(node: *mut PlanState);
    pub fn ExecMarkPos(node: *mut PlanState);
    pub fn ExecRestrPos(node: *mut PlanState);
    pub fn ExecSupportsMarkRestore(pathnode: *mut Path) -> bool;
    pub fn ExecSupportsBackwardScan(node: *mut Plan) -> bool;
    pub fn ExecMaterializesOutput(plantype: NodeTag) -> bool;
    pub fn execCurrentOf(
        cexpr: *mut CurrentOfExpr,
        econtext: *mut ExprContext,
        table_oid: Oid,
        current_tid: ItemPointer,
    ) -> bool;
    pub fn execTuplesMatchPrepare(
        desc: TupleDesc,
        numCols: ::core::ffi::c_int,
        keyColIdx: *const AttrNumber,
        eqOperators: *const Oid,
        collations: *const Oid,
        parent: *mut PlanState,
    ) -> *mut ExprState;
    pub fn execTuplesHashPrepare(
        numCols: ::core::ffi::c_int,
        eqOperators: *const Oid,
        eqFuncOids: *mut *mut Oid,
        hashFunctions: *mut *mut FmgrInfo,
    );
    pub fn BuildTupleHashTable(
        parent: *mut PlanState,
        inputDesc: TupleDesc,
        numCols: ::core::ffi::c_int,
        keyColIdx: *mut AttrNumber,
        eqfuncoids: *const Oid,
        hashfunctions: *mut FmgrInfo,
        collations: *mut Oid,
        nbuckets: ::core::ffi::c_long,
        additionalsize: Size,
        tablecxt: MemoryContext,
        tempcxt: MemoryContext,
        use_variable_hash_iv: bool,
    ) -> TupleHashTable;
    pub fn BuildTupleHashTableExt(
        parent: *mut PlanState,
        inputDesc: TupleDesc,
        numCols: ::core::ffi::c_int,
        keyColIdx: *mut AttrNumber,
        eqfuncoids: *const Oid,
        hashfunctions: *mut FmgrInfo,
        collations: *mut Oid,
        nbuckets: ::core::ffi::c_long,
        additionalsize: Size,
        metacxt: MemoryContext,
        tablecxt: MemoryContext,
        tempcxt: MemoryContext,
        use_variable_hash_iv: bool,
    ) -> TupleHashTable;
    pub fn LookupTupleHashEntry(
        hashtable: TupleHashTable,
        slot: *mut TupleTableSlot,
        isnew: *mut bool,
        hash: *mut uint32,
    ) -> TupleHashEntry;
    pub fn TupleHashTableHash(hashtable: TupleHashTable, slot: *mut TupleTableSlot) -> uint32;
    pub fn LookupTupleHashEntryHash(
        hashtable: TupleHashTable,
        slot: *mut TupleTableSlot,
        isnew: *mut bool,
        hash: uint32,
    ) -> TupleHashEntry;
    pub fn FindTupleHashEntry(
        hashtable: TupleHashTable,
        slot: *mut TupleTableSlot,
        eqcomp: *mut ExprState,
        hashfunctions: *mut FmgrInfo,
    ) -> TupleHashEntry;
    pub fn ResetTupleHashTable(hashtable: TupleHashTable);
    pub fn ExecInitJunkFilter(targetList: *mut List, slot: *mut TupleTableSlot) -> *mut JunkFilter;
    pub fn ExecInitJunkFilterConversion(
        targetList: *mut List,
        cleanTupType: TupleDesc,
        slot: *mut TupleTableSlot,
    ) -> *mut JunkFilter;
    pub fn ExecFindJunkAttribute(
        junkfilter: *mut JunkFilter,
        attrName: *const ::core::ffi::c_char,
    ) -> AttrNumber;
    pub fn ExecFindJunkAttributeInTlist(
        targetlist: *mut List,
        attrName: *const ::core::ffi::c_char,
    ) -> AttrNumber;
    pub fn ExecFilterJunk(
        junkfilter: *mut JunkFilter,
        slot: *mut TupleTableSlot,
    ) -> *mut TupleTableSlot;
    pub fn ExecutorStart(queryDesc: *mut QueryDesc, eflags: ::core::ffi::c_int);
    pub fn standard_ExecutorStart(queryDesc: *mut QueryDesc, eflags: ::core::ffi::c_int);
    pub fn ExecutorRun(
        queryDesc: *mut QueryDesc,
        direction: ScanDirection::Type,
        count: uint64,
        execute_once: bool,
    );
    pub fn standard_ExecutorRun(
        queryDesc: *mut QueryDesc,
        direction: ScanDirection::Type,
        count: uint64,
        execute_once: bool,
    );
    pub fn ExecutorFinish(queryDesc: *mut QueryDesc);
    pub fn standard_ExecutorFinish(queryDesc: *mut QueryDesc);
    pub fn ExecutorEnd(queryDesc: *mut QueryDesc);
    pub fn standard_ExecutorEnd(queryDesc: *mut QueryDesc);
    pub fn ExecutorRewind(queryDesc: *mut QueryDesc);
    pub fn ExecCheckPermissions(
        rangeTable: *mut List,
        rteperminfos: *mut List,
        ereport_on_violation: bool,
    ) -> bool;
    pub fn CheckValidResultRel(
        resultRelInfo: *mut ResultRelInfo,
        operation: CmdType::Type,
        mergeActions: *mut List,
    );
    pub fn InitResultRelInfo(
        resultRelInfo: *mut ResultRelInfo,
        resultRelationDesc: Relation,
        resultRelationIndex: Index,
        partition_root_rri: *mut ResultRelInfo,
        instrument_options: ::core::ffi::c_int,
    );
    pub fn ExecGetTriggerResultRel(
        estate: *mut EState,
        relid: Oid,
        rootRelInfo: *mut ResultRelInfo,
    ) -> *mut ResultRelInfo;
    pub fn ExecGetAncestorResultRels(
        estate: *mut EState,
        resultRelInfo: *mut ResultRelInfo,
    ) -> *mut List;
    pub fn ExecConstraints(
        resultRelInfo: *mut ResultRelInfo,
        slot: *mut TupleTableSlot,
        estate: *mut EState,
    );
    pub fn ExecPartitionCheck(
        resultRelInfo: *mut ResultRelInfo,
        slot: *mut TupleTableSlot,
        estate: *mut EState,
        emitError: bool,
    ) -> bool;
    pub fn ExecPartitionCheckEmitError(
        resultRelInfo: *mut ResultRelInfo,
        slot: *mut TupleTableSlot,
        estate: *mut EState,
    );
    pub fn ExecWithCheckOptions(
        kind: WCOKind::Type,
        resultRelInfo: *mut ResultRelInfo,
        slot: *mut TupleTableSlot,
        estate: *mut EState,
    );
    pub fn ExecUpdateLockMode(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
    ) -> LockTupleMode::Type;
    pub fn ExecFindRowMark(estate: *mut EState, rti: Index, missing_ok: bool) -> *mut ExecRowMark;
    pub fn ExecBuildAuxRowMark(erm: *mut ExecRowMark, targetlist: *mut List)
        -> *mut ExecAuxRowMark;
    pub fn EvalPlanQual(
        epqstate: *mut EPQState,
        relation: Relation,
        rti: Index,
        inputslot: *mut TupleTableSlot,
    ) -> *mut TupleTableSlot;
    pub fn EvalPlanQualInit(
        epqstate: *mut EPQState,
        parentestate: *mut EState,
        subplan: *mut Plan,
        auxrowmarks: *mut List,
        epqParam: ::core::ffi::c_int,
        resultRelations: *mut List,
    );
    pub fn EvalPlanQualSetPlan(epqstate: *mut EPQState, subplan: *mut Plan, auxrowmarks: *mut List);
    pub fn EvalPlanQualSlot(
        epqstate: *mut EPQState,
        relation: Relation,
        rti: Index,
    ) -> *mut TupleTableSlot;
    pub fn EvalPlanQualFetchRowMark(
        epqstate: *mut EPQState,
        rti: Index,
        slot: *mut TupleTableSlot,
    ) -> bool;
    pub fn EvalPlanQualNext(epqstate: *mut EPQState) -> *mut TupleTableSlot;
    pub fn EvalPlanQualBegin(epqstate: *mut EPQState);
    pub fn EvalPlanQualEnd(epqstate: *mut EPQState);
    pub fn ExecInitNode(
        node: *mut Plan,
        estate: *mut EState,
        eflags: ::core::ffi::c_int,
    ) -> *mut PlanState;
    pub fn ExecSetExecProcNode(node: *mut PlanState, function: ExecProcNodeMtd);
    pub fn MultiExecProcNode(node: *mut PlanState) -> *mut Node;
    pub fn ExecEndNode(node: *mut PlanState);
    pub fn ExecShutdownNode(node: *mut PlanState);
    pub fn ExecSetTupleBound(tuples_needed: int64, child_node: *mut PlanState);
    pub fn ExecInitExpr(node: *mut Expr, parent: *mut PlanState) -> *mut ExprState;
    pub fn ExecInitExprWithParams(node: *mut Expr, ext_params: ParamListInfo) -> *mut ExprState;
    pub fn ExecInitQual(qual: *mut List, parent: *mut PlanState) -> *mut ExprState;
    pub fn ExecInitCheck(qual: *mut List, parent: *mut PlanState) -> *mut ExprState;
    pub fn ExecInitExprList(nodes: *mut List, parent: *mut PlanState) -> *mut List;
    pub fn ExecBuildAggTrans(
        aggstate: *mut AggState,
        phase: *mut AggStatePerPhaseData,
        doSort: bool,
        doHash: bool,
        nullcheck: bool,
    ) -> *mut ExprState;
    pub fn ExecBuildGroupingEqual(
        ldesc: TupleDesc,
        rdesc: TupleDesc,
        lops: *const TupleTableSlotOps,
        rops: *const TupleTableSlotOps,
        numCols: ::core::ffi::c_int,
        keyColIdx: *const AttrNumber,
        eqfunctions: *const Oid,
        collations: *const Oid,
        parent: *mut PlanState,
    ) -> *mut ExprState;
    pub fn ExecBuildParamSetEqual(
        desc: TupleDesc,
        lops: *const TupleTableSlotOps,
        rops: *const TupleTableSlotOps,
        eqfunctions: *const Oid,
        collations: *const Oid,
        param_exprs: *const List,
        parent: *mut PlanState,
    ) -> *mut ExprState;
    pub fn ExecBuildProjectionInfo(
        targetList: *mut List,
        econtext: *mut ExprContext,
        slot: *mut TupleTableSlot,
        parent: *mut PlanState,
        inputDesc: TupleDesc,
    ) -> *mut ProjectionInfo;
    pub fn ExecBuildUpdateProjection(
        targetList: *mut List,
        evalTargetList: bool,
        targetColnos: *mut List,
        relDesc: TupleDesc,
        econtext: *mut ExprContext,
        slot: *mut TupleTableSlot,
        parent: *mut PlanState,
    ) -> *mut ProjectionInfo;
    pub fn ExecPrepareExpr(node: *mut Expr, estate: *mut EState) -> *mut ExprState;
    pub fn ExecPrepareQual(qual: *mut List, estate: *mut EState) -> *mut ExprState;
    pub fn ExecPrepareCheck(qual: *mut List, estate: *mut EState) -> *mut ExprState;
    pub fn ExecPrepareExprList(nodes: *mut List, estate: *mut EState) -> *mut List;
    pub fn ExecCheck(state: *mut ExprState, econtext: *mut ExprContext) -> bool;
    pub fn ExecInitTableFunctionResult(
        expr: *mut Expr,
        econtext: *mut ExprContext,
        parent: *mut PlanState,
    ) -> *mut SetExprState;
    pub fn ExecMakeTableFunctionResult(
        setexpr: *mut SetExprState,
        econtext: *mut ExprContext,
        argContext: MemoryContext,
        expectedDesc: TupleDesc,
        randomAccess: bool,
    ) -> *mut Tuplestorestate;
    pub fn ExecInitFunctionResultSet(
        expr: *mut Expr,
        econtext: *mut ExprContext,
        parent: *mut PlanState,
    ) -> *mut SetExprState;
    pub fn ExecMakeFunctionResultSet(
        fcache: *mut SetExprState,
        econtext: *mut ExprContext,
        argContext: MemoryContext,
        isNull: *mut bool,
        isDone: *mut ExprDoneCond::Type,
    ) -> Datum;
    pub fn ExecScan(
        node: *mut ScanState,
        accessMtd: ExecScanAccessMtd,
        recheckMtd: ExecScanRecheckMtd,
    ) -> *mut TupleTableSlot;
    pub fn ExecAssignScanProjectionInfo(node: *mut ScanState);
    pub fn ExecAssignScanProjectionInfoWithVarno(node: *mut ScanState, varno: ::core::ffi::c_int);
    pub fn ExecScanReScan(node: *mut ScanState);
    pub fn ExecInitResultTypeTL(planstate: *mut PlanState);
    pub fn ExecInitResultSlot(planstate: *mut PlanState, tts_ops: *const TupleTableSlotOps);
    pub fn ExecInitResultTupleSlotTL(planstate: *mut PlanState, tts_ops: *const TupleTableSlotOps);
    pub fn ExecInitScanTupleSlot(
        estate: *mut EState,
        scanstate: *mut ScanState,
        tupledesc: TupleDesc,
        tts_ops: *const TupleTableSlotOps,
    );
    pub fn ExecInitExtraTupleSlot(
        estate: *mut EState,
        tupledesc: TupleDesc,
        tts_ops: *const TupleTableSlotOps,
    ) -> *mut TupleTableSlot;
    pub fn ExecInitNullTupleSlot(
        estate: *mut EState,
        tupType: TupleDesc,
        tts_ops: *const TupleTableSlotOps,
    ) -> *mut TupleTableSlot;
    pub fn ExecTypeFromTL(targetList: *mut List) -> TupleDesc;
    pub fn ExecCleanTypeFromTL(targetList: *mut List) -> TupleDesc;
    pub fn ExecTypeFromExprList(exprList: *mut List) -> TupleDesc;
    pub fn ExecTypeSetColNames(typeInfo: TupleDesc, namesList: *mut List);
    pub fn UpdateChangedParamSet(node: *mut PlanState, newchg: *mut Bitmapset);
    pub fn begin_tup_output_tupdesc(
        dest: *mut DestReceiver,
        tupdesc: TupleDesc,
        tts_ops: *const TupleTableSlotOps,
    ) -> *mut TupOutputState;
    pub fn do_tup_output(tstate: *mut TupOutputState, values: *const Datum, isnull: *const bool);
    pub fn do_text_output_multiline(tstate: *mut TupOutputState, txt: *const ::core::ffi::c_char);
    pub fn end_tup_output(tstate: *mut TupOutputState);
    pub fn CreateExecutorState() -> *mut EState;
    pub fn FreeExecutorState(estate: *mut EState);
    pub fn CreateExprContext(estate: *mut EState) -> *mut ExprContext;
    pub fn CreateWorkExprContext(estate: *mut EState) -> *mut ExprContext;
    pub fn CreateStandaloneExprContext() -> *mut ExprContext;
    pub fn FreeExprContext(econtext: *mut ExprContext, isCommit: bool);
    pub fn ReScanExprContext(econtext: *mut ExprContext);
    pub fn MakePerTupleExprContext(estate: *mut EState) -> *mut ExprContext;
    pub fn ExecAssignExprContext(estate: *mut EState, planstate: *mut PlanState);
    pub fn ExecGetResultType(planstate: *mut PlanState) -> TupleDesc;
    pub fn ExecGetResultSlotOps(
        planstate: *mut PlanState,
        isfixed: *mut bool,
    ) -> *const TupleTableSlotOps;
    pub fn ExecAssignProjectionInfo(planstate: *mut PlanState, inputDesc: TupleDesc);
    pub fn ExecConditionalAssignProjectionInfo(
        planstate: *mut PlanState,
        inputDesc: TupleDesc,
        varno: ::core::ffi::c_int,
    );
    pub fn ExecAssignScanType(scanstate: *mut ScanState, tupDesc: TupleDesc);
    pub fn ExecCreateScanSlotFromOuterPlan(
        estate: *mut EState,
        scanstate: *mut ScanState,
        tts_ops: *const TupleTableSlotOps,
    );
    pub fn ExecRelationIsTargetRelation(estate: *mut EState, scanrelid: Index) -> bool;
    pub fn ExecOpenScanRelation(
        estate: *mut EState,
        scanrelid: Index,
        eflags: ::core::ffi::c_int,
    ) -> Relation;
    pub fn ExecInitRangeTable(estate: *mut EState, rangeTable: *mut List, permInfos: *mut List);
    pub fn ExecCloseRangeTableRelations(estate: *mut EState);
    pub fn ExecCloseResultRelations(estate: *mut EState);
    pub fn ExecGetRangeTableRelation(estate: *mut EState, rti: Index) -> Relation;
    pub fn ExecInitResultRelation(
        estate: *mut EState,
        resultRelInfo: *mut ResultRelInfo,
        rti: Index,
    );
    pub fn executor_errposition(
        estate: *mut EState,
        location: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn RegisterExprContextCallback(
        econtext: *mut ExprContext,
        function: ExprContextCallbackFunction,
        arg: Datum,
    );
    pub fn UnregisterExprContextCallback(
        econtext: *mut ExprContext,
        function: ExprContextCallbackFunction,
        arg: Datum,
    );
    pub fn GetAttributeByName(
        tuple: HeapTupleHeader,
        attname: *const ::core::ffi::c_char,
        isNull: *mut bool,
    ) -> Datum;
    pub fn GetAttributeByNum(
        tuple: HeapTupleHeader,
        attrno: AttrNumber,
        isNull: *mut bool,
    ) -> Datum;
    pub fn ExecTargetListLength(targetlist: *mut List) -> ::core::ffi::c_int;
    pub fn ExecCleanTargetListLength(targetlist: *mut List) -> ::core::ffi::c_int;
    pub fn ExecGetTriggerOldSlot(
        estate: *mut EState,
        relInfo: *mut ResultRelInfo,
    ) -> *mut TupleTableSlot;
    pub fn ExecGetTriggerNewSlot(
        estate: *mut EState,
        relInfo: *mut ResultRelInfo,
    ) -> *mut TupleTableSlot;
    pub fn ExecGetReturningSlot(
        estate: *mut EState,
        relInfo: *mut ResultRelInfo,
    ) -> *mut TupleTableSlot;
    pub fn ExecGetChildToRootMap(resultRelInfo: *mut ResultRelInfo) -> *mut TupleConversionMap;
    pub fn ExecGetRootToChildMap(
        resultRelInfo: *mut ResultRelInfo,
        estate: *mut EState,
    ) -> *mut TupleConversionMap;
    pub fn ExecGetResultRelCheckAsUser(relInfo: *mut ResultRelInfo, estate: *mut EState) -> Oid;
    pub fn ExecGetInsertedCols(relinfo: *mut ResultRelInfo, estate: *mut EState) -> *mut Bitmapset;
    pub fn ExecGetUpdatedCols(relinfo: *mut ResultRelInfo, estate: *mut EState) -> *mut Bitmapset;
    pub fn ExecGetExtraUpdatedCols(
        relinfo: *mut ResultRelInfo,
        estate: *mut EState,
    ) -> *mut Bitmapset;
    pub fn ExecGetAllUpdatedCols(
        relinfo: *mut ResultRelInfo,
        estate: *mut EState,
    ) -> *mut Bitmapset;
    pub fn ExecOpenIndices(resultRelInfo: *mut ResultRelInfo, speculative: bool);
    pub fn ExecCloseIndices(resultRelInfo: *mut ResultRelInfo);
    pub fn ExecInsertIndexTuples(
        resultRelInfo: *mut ResultRelInfo,
        slot: *mut TupleTableSlot,
        estate: *mut EState,
        update: bool,
        noDupErr: bool,
        specConflict: *mut bool,
        arbiterIndexes: *mut List,
        onlySummarizing: bool,
    ) -> *mut List;
    pub fn ExecCheckIndexConstraints(
        resultRelInfo: *mut ResultRelInfo,
        slot: *mut TupleTableSlot,
        estate: *mut EState,
        conflictTid: ItemPointer,
        arbiterIndexes: *mut List,
    ) -> bool;
    pub fn check_exclusion_constraint(
        heap: Relation,
        index: Relation,
        indexInfo: *mut IndexInfo,
        tupleid: ItemPointer,
        values: *const Datum,
        isnull: *const bool,
        estate: *mut EState,
        newIndex: bool,
    );
    pub fn get_equal_strategy_number_for_am(am: Oid) -> StrategyNumber;
    pub fn RelationFindReplTupleByIndex(
        rel: Relation,
        idxoid: Oid,
        lockmode: LockTupleMode::Type,
        searchslot: *mut TupleTableSlot,
        outslot: *mut TupleTableSlot,
    ) -> bool;
    pub fn RelationFindReplTupleSeq(
        rel: Relation,
        lockmode: LockTupleMode::Type,
        searchslot: *mut TupleTableSlot,
        outslot: *mut TupleTableSlot,
    ) -> bool;
    pub fn ExecSimpleRelationInsert(
        resultRelInfo: *mut ResultRelInfo,
        estate: *mut EState,
        slot: *mut TupleTableSlot,
    );
    pub fn ExecSimpleRelationUpdate(
        resultRelInfo: *mut ResultRelInfo,
        estate: *mut EState,
        epqstate: *mut EPQState,
        searchslot: *mut TupleTableSlot,
        slot: *mut TupleTableSlot,
    );
    pub fn ExecSimpleRelationDelete(
        resultRelInfo: *mut ResultRelInfo,
        estate: *mut EState,
        epqstate: *mut EPQState,
        searchslot: *mut TupleTableSlot,
    );
    pub fn CheckCmdReplicaIdentity(rel: Relation, cmd: CmdType::Type);
    pub fn CheckSubscriptionRelkind(
        relkind: ::core::ffi::c_char,
        nspname: *const ::core::ffi::c_char,
        relname: *const ::core::ffi::c_char,
    );
    pub fn ExecGetUpdateNewTuple(
        relinfo: *mut ResultRelInfo,
        planSlot: *mut TupleTableSlot,
        oldSlot: *mut TupleTableSlot,
    ) -> *mut TupleTableSlot;
    pub fn ExecLookupResultRelByOid(
        node: *mut ModifyTableState,
        resultoid: Oid,
        missing_ok: bool,
        update_cache: bool,
    ) -> *mut ResultRelInfo;
    pub fn get_call_result_type(
        fcinfo: FunctionCallInfo,
        resultTypeId: *mut Oid,
        resultTupleDesc: *mut TupleDesc,
    ) -> TypeFuncClass::Type;
    pub fn get_expr_result_type(
        expr: *mut Node,
        resultTypeId: *mut Oid,
        resultTupleDesc: *mut TupleDesc,
    ) -> TypeFuncClass::Type;
    pub fn get_func_result_type(
        functionId: Oid,
        resultTypeId: *mut Oid,
        resultTupleDesc: *mut TupleDesc,
    ) -> TypeFuncClass::Type;
    pub fn get_expr_result_tupdesc(expr: *mut Node, noError: bool) -> TupleDesc;
    pub fn resolve_polymorphic_argtypes(
        numargs: ::core::ffi::c_int,
        argtypes: *mut Oid,
        argmodes: *mut ::core::ffi::c_char,
        call_expr: *mut Node,
    ) -> bool;
    pub fn get_func_arg_info(
        procTup: HeapTuple,
        p_argtypes: *mut *mut Oid,
        p_argnames: *mut *mut *mut ::core::ffi::c_char,
        p_argmodes: *mut *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn get_func_input_arg_names(
        proargnames: Datum,
        proargmodes: Datum,
        arg_names: *mut *mut *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn get_func_trftypes(procTup: HeapTuple, p_trftypes: *mut *mut Oid) -> ::core::ffi::c_int;
    pub fn get_func_result_name(functionId: Oid) -> *mut ::core::ffi::c_char;
    pub fn build_function_result_tupdesc_d(
        prokind: ::core::ffi::c_char,
        proallargtypes: Datum,
        proargmodes: Datum,
        proargnames: Datum,
    ) -> TupleDesc;
    pub fn build_function_result_tupdesc_t(procTuple: HeapTuple) -> TupleDesc;
    pub fn RelationNameGetTupleDesc(relname: *const ::core::ffi::c_char) -> TupleDesc;
    pub fn TypeGetTupleDesc(typeoid: Oid, colaliases: *mut List) -> TupleDesc;
    pub fn BlessTupleDesc(tupdesc: TupleDesc) -> TupleDesc;
    pub fn TupleDescGetAttInMetadata(tupdesc: TupleDesc) -> *mut AttInMetadata;
    pub fn BuildTupleFromCStrings(
        attinmeta: *mut AttInMetadata,
        values: *mut *mut ::core::ffi::c_char,
    ) -> HeapTuple;
    pub fn HeapTupleHeaderGetDatum(tuple: HeapTupleHeader) -> Datum;
    pub fn InitMaterializedSRF(fcinfo: FunctionCallInfo, flags: bits32);
    pub fn init_MultiFuncCall(fcinfo: FunctionCallInfo) -> *mut FuncCallContext;
    pub fn per_MultiFuncCall(fcinfo: FunctionCallInfo) -> *mut FuncCallContext;
    pub fn end_MultiFuncCall(fcinfo: FunctionCallInfo, funcctx: *mut FuncCallContext);
    pub fn extract_variadic_args(
        fcinfo: FunctionCallInfo,
        variadic_start: ::core::ffi::c_int,
        convert_unknown: bool,
        args: *mut *mut Datum,
        types: *mut *mut Oid,
        nulls: *mut *mut bool,
    ) -> ::core::ffi::c_int;
    pub fn pg_localtime(timep: *const pg_time_t, tz: *const pg_tz) -> *mut pg_tm;
    pub fn pg_gmtime(timep: *const pg_time_t) -> *mut pg_tm;
    pub fn pg_next_dst_boundary(
        timep: *const pg_time_t,
        before_gmtoff: *mut ::core::ffi::c_long,
        before_isdst: *mut ::core::ffi::c_int,
        boundary: *mut pg_time_t,
        after_gmtoff: *mut ::core::ffi::c_long,
        after_isdst: *mut ::core::ffi::c_int,
        tz: *const pg_tz,
    ) -> ::core::ffi::c_int;
    pub fn pg_interpret_timezone_abbrev(
        abbrev: *const ::core::ffi::c_char,
        timep: *const pg_time_t,
        gmtoff: *mut ::core::ffi::c_long,
        isdst: *mut ::core::ffi::c_int,
        tz: *const pg_tz,
    ) -> bool;
    pub fn pg_get_timezone_offset(tz: *const pg_tz, gmtoff: *mut ::core::ffi::c_long) -> bool;
    pub fn pg_get_timezone_name(tz: *mut pg_tz) -> *const ::core::ffi::c_char;
    pub fn pg_tz_acceptable(tz: *mut pg_tz) -> bool;
    pub fn pg_strftime(
        s: *mut ::core::ffi::c_char,
        maxsize: usize,
        format: *const ::core::ffi::c_char,
        t: *const pg_tm,
    ) -> usize;
    pub static mut session_timezone: *mut pg_tz;
    pub static mut log_timezone: *mut pg_tz;
    pub fn pg_timezone_initialize();
    pub fn pg_tzset(tzname: *const ::core::ffi::c_char) -> *mut pg_tz;
    pub fn pg_tzset_offset(gmtoffset: ::core::ffi::c_long) -> *mut pg_tz;
    pub fn pg_tzenumerate_start() -> *mut pg_tzenum;
    pub fn pg_tzenumerate_next(dir: *mut pg_tzenum) -> *mut pg_tz;
    pub fn pg_tzenumerate_end(dir: *mut pg_tzenum);
    #[doc = "\t  System interrupt and critical section handling\n\n There are two types of interrupts that a running backend needs to accept\n without messing up its state: QueryCancel (SIGINT) and ProcDie (SIGTERM).\n In both cases, we need to be able to clean up the current transaction\n gracefully, so we can't respond to the interrupt instantaneously ---\n there's no guarantee that internal data structures would be self-consistent\n if the code is interrupted at an arbitrary instant.  Instead, the signal\n handlers set flags that are checked periodically during execution.\n\n The CHECK_FOR_INTERRUPTS() macro is called at strategically located spots\n where it is normally safe to accept a cancel or die interrupt.  In some\n cases, we invoke CHECK_FOR_INTERRUPTS() inside low-level subroutines that\n might sometimes be called in contexts that do *not* want to allow a cancel\n or die interrupt.  The HOLD_INTERRUPTS() and RESUME_INTERRUPTS() macros\n allow code to ensure that no cancel or die interrupt will be accepted,\n even if CHECK_FOR_INTERRUPTS() gets called in a subroutine.  The interrupt\n will be held off until CHECK_FOR_INTERRUPTS() is done outside any\n HOLD_INTERRUPTS() ... RESUME_INTERRUPTS() section.\n\n There is also a mechanism to prevent query cancel interrupts, while still\n allowing die interrupts: HOLD_CANCEL_INTERRUPTS() and\n RESUME_CANCEL_INTERRUPTS().\n\n Note that ProcessInterrupts() has also acquired a number of tasks that\n do not necessarily cause a query-cancel-or-die response.  Hence, it's\n possible that it will just clear InterruptPending and return.\n\n INTERRUPTS_PENDING_CONDITION() can be checked to see whether an\n interrupt needs to be serviced, without trying to do so immediately.\n Some callers are also interested in INTERRUPTS_CAN_BE_PROCESSED(),\n which tells whether ProcessInterrupts is sure to clear the interrupt.\n\n Special mechanisms are used to let an interrupt be accepted when we are\n waiting for a lock or when we are waiting for command input (but, of\n course, only if the interrupt holdoff counter is zero).  See the\n related code for details.\n\n A lost connection is handled similarly, although the loss of connection\n does not raise a signal, but is detected when we fail to write to the\n socket. If there was a signal for a broken connection, we could make use of\n it by setting ClientConnectionLost in the signal handler.\n\n A related, but conceptually distinct, mechanism is the \"critical section\"\n mechanism.  A critical section not only holds off cancel/die interrupts,\n but causes any ereport(ERROR) or ereport(FATAL) to become ereport(PANIC)\n --- that is, a system-wide reset is forced.  Needless to say, only really\n *critical* code should be marked as a critical section!\tCurrently, this\n mechanism is only used for XLOG-related code.\n"]
    pub static mut InterruptPending: sig_atomic_t;
    pub static mut QueryCancelPending: sig_atomic_t;
    pub static mut ProcDiePending: sig_atomic_t;
    pub static mut IdleInTransactionSessionTimeoutPending: sig_atomic_t;
    pub static mut TransactionTimeoutPending: sig_atomic_t;
    pub static mut IdleSessionTimeoutPending: sig_atomic_t;
    pub static mut ProcSignalBarrierPending: sig_atomic_t;
    pub static mut LogMemoryContextPending: sig_atomic_t;
    pub static mut IdleStatsUpdateTimeoutPending: sig_atomic_t;
    pub static mut CheckClientConnectionPending: sig_atomic_t;
    pub static mut ClientConnectionLost: sig_atomic_t;
    pub static mut InterruptHoldoffCount: uint32;
    pub static mut QueryCancelHoldoffCount: uint32;
    pub static mut CritSectionCount: uint32;
    pub fn ProcessInterrupts();
    #[doc = "\t  globals.h --\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t *"]
    pub static mut PostmasterPid: pid_t;
    pub static mut IsPostmasterEnvironment: bool;
    pub static mut IsUnderPostmaster: bool;
    pub static mut IsBinaryUpgrade: bool;
    pub static mut ExitOnAnyError: bool;
    pub static mut DataDir: *mut ::core::ffi::c_char;
    pub static mut data_directory_mode: ::core::ffi::c_int;
    pub static mut NBuffers: ::core::ffi::c_int;
    pub static mut MaxBackends: ::core::ffi::c_int;
    pub static mut MaxConnections: ::core::ffi::c_int;
    pub static mut max_worker_processes: ::core::ffi::c_int;
    pub static mut max_parallel_workers: ::core::ffi::c_int;
    pub static mut commit_timestamp_buffers: ::core::ffi::c_int;
    pub static mut multixact_member_buffers: ::core::ffi::c_int;
    pub static mut multixact_offset_buffers: ::core::ffi::c_int;
    pub static mut notify_buffers: ::core::ffi::c_int;
    pub static mut serializable_buffers: ::core::ffi::c_int;
    pub static mut subtransaction_buffers: ::core::ffi::c_int;
    pub static mut transaction_buffers: ::core::ffi::c_int;
    pub static mut MyProcPid: ::core::ffi::c_int;
    pub static mut MyStartTime: pg_time_t;
    pub static mut MyStartTimestamp: TimestampTz;
    pub static mut MyProcPort: *mut Port;
    pub static mut MyLatch: *mut Latch;
    pub static mut MyCancelKey: int32;
    pub static mut MyPMChildSlot: ::core::ffi::c_int;
    pub static mut OutputFileName: [::core::ffi::c_char; 0usize];
    pub static mut my_exec_path: [::core::ffi::c_char; 0usize];
    pub static mut pkglib_path: [::core::ffi::c_char; 0usize];
    pub static mut MyDatabaseId: Oid;
    pub static mut MyDatabaseTableSpace: Oid;
    pub static mut MyDatabaseHasLoginEventTriggers: bool;
    pub static mut DateStyle: ::core::ffi::c_int;
    pub static mut DateOrder: ::core::ffi::c_int;
    pub static mut IntervalStyle: ::core::ffi::c_int;
    pub static mut enableFsync: bool;
    pub static mut allowSystemTableMods: bool;
    pub static mut work_mem: ::core::ffi::c_int;
    pub static mut hash_mem_multiplier: f64;
    pub static mut maintenance_work_mem: ::core::ffi::c_int;
    pub static mut max_parallel_maintenance_workers: ::core::ffi::c_int;
    pub static mut VacuumBufferUsageLimit: ::core::ffi::c_int;
    pub static mut VacuumCostPageHit: ::core::ffi::c_int;
    pub static mut VacuumCostPageMiss: ::core::ffi::c_int;
    pub static mut VacuumCostPageDirty: ::core::ffi::c_int;
    pub static mut VacuumCostLimit: ::core::ffi::c_int;
    pub static mut VacuumCostDelay: f64;
    pub static mut VacuumPageHit: int64;
    pub static mut VacuumPageMiss: int64;
    pub static mut VacuumPageDirty: int64;
    pub static mut VacuumCostBalance: ::core::ffi::c_int;
    pub static mut VacuumCostActive: bool;
    pub fn set_stack_base() -> pg_stack_base_t;
    pub fn restore_stack_base(base: pg_stack_base_t);
    pub fn check_stack_depth();
    pub fn stack_is_too_deep() -> bool;
    pub fn PreventCommandIfReadOnly(cmdname: *const ::core::ffi::c_char);
    pub fn PreventCommandIfParallelMode(cmdname: *const ::core::ffi::c_char);
    pub fn PreventCommandDuringRecovery(cmdname: *const ::core::ffi::c_char);
    pub static mut DatabasePath: *mut ::core::ffi::c_char;
    pub fn InitPostmasterChild();
    pub fn InitStandaloneProcess(argv0: *const ::core::ffi::c_char);
    pub fn InitProcessLocalLatch();
    pub fn SwitchToSharedLatch();
    pub fn SwitchBackToLocalLatch();
    pub static mut MyBackendType: BackendType::Type;
    pub fn GetBackendTypeDesc(backendType: BackendType::Type) -> *const ::core::ffi::c_char;
    pub fn SetDatabasePath(path: *const ::core::ffi::c_char);
    pub fn checkDataDir();
    pub fn SetDataDir(dir: *const ::core::ffi::c_char);
    pub fn ChangeToDataDir();
    pub fn GetUserNameFromId(roleid: Oid, noerr: bool) -> *mut ::core::ffi::c_char;
    pub fn GetUserId() -> Oid;
    pub fn GetOuterUserId() -> Oid;
    pub fn GetSessionUserId() -> Oid;
    pub fn GetSessionUserIsSuperuser() -> bool;
    pub fn GetAuthenticatedUserId() -> Oid;
    pub fn SetAuthenticatedUserId(userid: Oid);
    pub fn GetUserIdAndSecContext(userid: *mut Oid, sec_context: *mut ::core::ffi::c_int);
    pub fn SetUserIdAndSecContext(userid: Oid, sec_context: ::core::ffi::c_int);
    pub fn InLocalUserIdChange() -> bool;
    pub fn InSecurityRestrictedOperation() -> bool;
    pub fn InNoForceRLSOperation() -> bool;
    pub fn GetUserIdAndContext(userid: *mut Oid, sec_def_context: *mut bool);
    pub fn SetUserIdAndContext(userid: Oid, sec_def_context: bool);
    pub fn InitializeSessionUserId(
        rolename: *const ::core::ffi::c_char,
        roleid: Oid,
        bypass_login_check: bool,
    );
    pub fn InitializeSessionUserIdStandalone();
    pub fn SetSessionAuthorization(userid: Oid, is_superuser: bool);
    pub fn GetCurrentRoleId() -> Oid;
    pub fn SetCurrentRoleId(roleid: Oid, is_superuser: bool);
    pub fn InitializeSystemUser(
        authn_id: *const ::core::ffi::c_char,
        auth_method: *const ::core::ffi::c_char,
    );
    pub fn GetSystemUser() -> *const ::core::ffi::c_char;
    pub fn superuser() -> bool;
    pub fn superuser_arg(roleid: Oid) -> bool;
    pub static mut Mode: ProcessingMode::Type;
    pub fn pg_split_opts(
        argv: *mut *mut ::core::ffi::c_char,
        argcp: *mut ::core::ffi::c_int,
        optstr: *const ::core::ffi::c_char,
    );
    pub fn InitializeMaxBackends();
    pub fn InitPostgres(
        in_dbname: *const ::core::ffi::c_char,
        dboid: Oid,
        username: *const ::core::ffi::c_char,
        useroid: Oid,
        flags: bits32,
        out_dbname: *mut ::core::ffi::c_char,
    );
    pub fn BaseInit();
    pub static mut IgnoreSystemIndexes: bool;
    pub static mut process_shared_preload_libraries_in_progress: bool;
    pub static mut process_shared_preload_libraries_done: bool;
    pub static mut process_shmem_requests_in_progress: bool;
    pub static mut session_preload_libraries_string: *mut ::core::ffi::c_char;
    pub static mut shared_preload_libraries_string: *mut ::core::ffi::c_char;
    pub static mut local_preload_libraries_string: *mut ::core::ffi::c_char;
    pub fn CreateDataDirLockFile(amPostmaster: bool);
    pub fn CreateSocketLockFile(
        socketfile: *const ::core::ffi::c_char,
        amPostmaster: bool,
        socketDir: *const ::core::ffi::c_char,
    );
    pub fn TouchSocketLockFiles();
    pub fn AddToDataDirLockFile(target_line: ::core::ffi::c_int, str_: *const ::core::ffi::c_char);
    pub fn RecheckDataDirLockFile() -> bool;
    pub fn ValidatePgVersion(path: *const ::core::ffi::c_char);
    pub fn process_shared_preload_libraries();
    pub fn process_session_preload_libraries();
    pub fn process_shmem_requests();
    pub fn pg_bindtextdomain(domain: *const ::core::ffi::c_char);
    pub fn has_rolreplication(roleid: Oid) -> bool;
    pub static mut shmem_request_hook: shmem_request_hook_type;
    pub fn EstimateClientConnectionInfoSpace() -> Size;
    pub fn SerializeClientConnectionInfo(maxsize: Size, start_address: *mut ::core::ffi::c_char);
    pub fn RestoreClientConnectionInfo(conninfo: *mut ::core::ffi::c_char);
    pub fn get_hash_memory_limit() -> usize;
    pub fn PgArchShmemSize() -> Size;
    pub fn PgArchShmemInit();
    pub fn PgArchCanRestart() -> bool;
    pub fn PgArchiverMain(startup_data: *mut ::core::ffi::c_char, startup_data_len: usize) -> !;
    pub fn PgArchWakeup();
    pub fn PgArchForceDirScan();
    pub fn pgstat_progress_start_command(cmdtype: ProgressCommandType::Type, relid: Oid);
    pub fn pgstat_progress_update_param(index: ::core::ffi::c_int, val: int64);
    pub fn pgstat_progress_incr_param(index: ::core::ffi::c_int, incr: int64);
    pub fn pgstat_progress_parallel_incr_param(index: ::core::ffi::c_int, incr: int64);
    pub fn pgstat_progress_update_multi_param(
        nparam: ::core::ffi::c_int,
        index: *const ::core::ffi::c_int,
        val: *const int64,
    );
    pub fn pgstat_progress_end_command();
    pub static mut pgstat_track_activities: bool;
    pub static mut pgstat_track_activity_query_size: ::core::ffi::c_int;
    pub static mut MyBEEntry: *mut PgBackendStatus;
    pub fn BackendStatusShmemSize() -> Size;
    pub fn CreateSharedBackendStatus();
    pub fn pgstat_beinit();
    pub fn pgstat_bestart();
    pub fn pgstat_clear_backend_activity_snapshot();
    pub fn pgstat_report_activity(state: BackendState::Type, cmd_str: *const ::core::ffi::c_char);
    pub fn pgstat_report_query_id(query_id: uint64, force: bool);
    pub fn pgstat_report_tempfile(filesize: usize);
    pub fn pgstat_report_appname(appname: *const ::core::ffi::c_char);
    pub fn pgstat_report_xact_timestamp(tstamp: TimestampTz);
    pub fn pgstat_get_backend_current_activity(
        pid: ::core::ffi::c_int,
        checkUser: bool,
    ) -> *const ::core::ffi::c_char;
    pub fn pgstat_get_crashed_backend_activity(
        pid: ::core::ffi::c_int,
        buffer: *mut ::core::ffi::c_char,
        buflen: ::core::ffi::c_int,
    ) -> *const ::core::ffi::c_char;
    pub fn pgstat_get_my_query_id() -> uint64;
    pub fn pgstat_fetch_stat_numbackends() -> ::core::ffi::c_int;
    pub fn pgstat_get_beentry_by_proc_number(procNumber: ProcNumber) -> *mut PgBackendStatus;
    pub fn pgstat_get_local_beentry_by_proc_number(
        procNumber: ProcNumber,
    ) -> *mut LocalPgBackendStatus;
    pub fn pgstat_get_local_beentry_by_index(idx: ::core::ffi::c_int) -> *mut LocalPgBackendStatus;
    pub fn pgstat_clip_activity(
        raw_activity: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn pgstat_get_wait_event(wait_event_info: uint32) -> *const ::core::ffi::c_char;
    pub fn pgstat_get_wait_event_type(wait_event_info: uint32) -> *const ::core::ffi::c_char;
    pub fn pgstat_set_wait_event_storage(wait_event_info: *mut uint32);
    pub fn pgstat_reset_wait_event_storage();
    pub static mut my_wait_event_info: *mut uint32;
    pub fn WaitEventExtensionNew(wait_event_name: *const ::core::ffi::c_char) -> uint32;
    pub fn WaitEventInjectionPointNew(wait_event_name: *const ::core::ffi::c_char) -> uint32;
    pub fn WaitEventCustomShmemInit();
    pub fn WaitEventCustomShmemSize() -> Size;
    pub fn GetWaitEventCustomNames(
        classId: uint32,
        nwaitevents: *mut ::core::ffi::c_int,
    ) -> *mut *mut ::core::ffi::c_char;
    pub fn StatsShmemSize() -> Size;
    pub fn StatsShmemInit();
    pub fn pgstat_restore_stats();
    pub fn pgstat_discard_stats();
    pub fn pgstat_before_server_shutdown(code: ::core::ffi::c_int, arg: Datum);
    pub fn pgstat_initialize();
    pub fn pgstat_report_stat(force: bool) -> ::core::ffi::c_long;
    pub fn pgstat_force_next_flush();
    pub fn pgstat_reset_counters();
    pub fn pgstat_reset(kind: PgStat_Kind::Type, dboid: Oid, objoid: Oid);
    pub fn pgstat_reset_of_kind(kind: PgStat_Kind::Type);
    pub fn pgstat_clear_snapshot();
    pub fn pgstat_get_stat_snapshot_timestamp(have_snapshot: *mut bool) -> TimestampTz;
    pub fn pgstat_get_kind_from_str(kind_str: *mut ::core::ffi::c_char) -> PgStat_Kind::Type;
    pub fn pgstat_have_entry(kind: PgStat_Kind::Type, dboid: Oid, objoid: Oid) -> bool;
    pub fn pgstat_report_archiver(xlog: *const ::core::ffi::c_char, failed: bool);
    pub fn pgstat_fetch_stat_archiver() -> *mut PgStat_ArchiverStats;
    pub fn pgstat_report_bgwriter();
    pub fn pgstat_fetch_stat_bgwriter() -> *mut PgStat_BgWriterStats;
    pub fn pgstat_report_checkpointer();
    pub fn pgstat_fetch_stat_checkpointer() -> *mut PgStat_CheckpointerStats;
    pub fn pgstat_bktype_io_stats_valid(
        backend_io: *mut PgStat_BktypeIO,
        bktype: BackendType::Type,
    ) -> bool;
    pub fn pgstat_count_io_op(
        io_object: IOObject::Type,
        io_context: IOContext::Type,
        io_op: IOOp::Type,
    );
    pub fn pgstat_count_io_op_n(
        io_object: IOObject::Type,
        io_context: IOContext::Type,
        io_op: IOOp::Type,
        cnt: uint32,
    );
    pub fn pgstat_prepare_io_time(track_io_guc: bool) -> instr_time;
    pub fn pgstat_count_io_op_time(
        io_object: IOObject::Type,
        io_context: IOContext::Type,
        io_op: IOOp::Type,
        start_time: instr_time,
        cnt: uint32,
    );
    pub fn pgstat_fetch_stat_io() -> *mut PgStat_IO;
    pub fn pgstat_get_io_context_name(io_context: IOContext::Type) -> *const ::core::ffi::c_char;
    pub fn pgstat_get_io_object_name(io_object: IOObject::Type) -> *const ::core::ffi::c_char;
    pub fn pgstat_tracks_io_bktype(bktype: BackendType::Type) -> bool;
    pub fn pgstat_tracks_io_object(
        bktype: BackendType::Type,
        io_object: IOObject::Type,
        io_context: IOContext::Type,
    ) -> bool;
    pub fn pgstat_tracks_io_op(
        bktype: BackendType::Type,
        io_object: IOObject::Type,
        io_context: IOContext::Type,
        io_op: IOOp::Type,
    ) -> bool;
    pub fn pgstat_drop_database(databaseid: Oid);
    pub fn pgstat_report_autovac(dboid: Oid);
    pub fn pgstat_report_recovery_conflict(reason: ::core::ffi::c_int);
    pub fn pgstat_report_deadlock();
    pub fn pgstat_report_checksum_failures_in_db(dboid: Oid, failurecount: ::core::ffi::c_int);
    pub fn pgstat_report_checksum_failure();
    pub fn pgstat_report_connect(dboid: Oid);
    pub fn pgstat_fetch_stat_dbentry(dboid: Oid) -> *mut PgStat_StatDBEntry;
    pub fn pgstat_create_function(proid: Oid);
    pub fn pgstat_drop_function(proid: Oid);
    pub fn pgstat_init_function_usage(
        fcinfo: *mut FunctionCallInfoBaseData,
        fcu: *mut PgStat_FunctionCallUsage,
    );
    pub fn pgstat_end_function_usage(fcu: *mut PgStat_FunctionCallUsage, finalize: bool);
    pub fn pgstat_fetch_stat_funcentry(func_id: Oid) -> *mut PgStat_StatFuncEntry;
    pub fn find_funcstat_entry(func_id: Oid) -> *mut PgStat_FunctionCounts;
    pub fn pgstat_create_relation(rel: Relation);
    pub fn pgstat_drop_relation(rel: Relation);
    pub fn pgstat_copy_relation_stats(dst: Relation, src: Relation);
    pub fn pgstat_init_relation(rel: Relation);
    pub fn pgstat_assoc_relation(rel: Relation);
    pub fn pgstat_unlink_relation(rel: Relation);
    pub fn pgstat_report_vacuum(
        tableoid: Oid,
        shared: bool,
        livetuples: PgStat_Counter,
        deadtuples: PgStat_Counter,
    );
    pub fn pgstat_report_analyze(
        rel: Relation,
        livetuples: PgStat_Counter,
        deadtuples: PgStat_Counter,
        resetcounter: bool,
    );
    pub fn pgstat_count_heap_insert(rel: Relation, n: PgStat_Counter);
    pub fn pgstat_count_heap_update(rel: Relation, hot: bool, newpage: bool);
    pub fn pgstat_count_heap_delete(rel: Relation);
    pub fn pgstat_count_truncate(rel: Relation);
    pub fn pgstat_update_heap_dead_tuples(rel: Relation, delta: ::core::ffi::c_int);
    pub fn pgstat_twophase_postcommit(
        xid: TransactionId,
        info: uint16,
        recdata: *mut ::core::ffi::c_void,
        len: uint32,
    );
    pub fn pgstat_twophase_postabort(
        xid: TransactionId,
        info: uint16,
        recdata: *mut ::core::ffi::c_void,
        len: uint32,
    );
    pub fn pgstat_fetch_stat_tabentry(relid: Oid) -> *mut PgStat_StatTabEntry;
    pub fn pgstat_fetch_stat_tabentry_ext(shared: bool, reloid: Oid) -> *mut PgStat_StatTabEntry;
    pub fn find_tabstat_entry(rel_id: Oid) -> *mut PgStat_TableStatus;
    pub fn pgstat_reset_replslot(name: *const ::core::ffi::c_char);
    pub fn pgstat_report_replslot(
        slot: *mut ReplicationSlot,
        repSlotStat: *const PgStat_StatReplSlotEntry,
    );
    pub fn pgstat_create_replslot(slot: *mut ReplicationSlot);
    pub fn pgstat_acquire_replslot(slot: *mut ReplicationSlot);
    pub fn pgstat_drop_replslot(slot: *mut ReplicationSlot);
    pub fn pgstat_fetch_replslot(slotname: NameData) -> *mut PgStat_StatReplSlotEntry;
    pub fn pgstat_reset_slru(arg1: *const ::core::ffi::c_char);
    pub fn pgstat_count_slru_page_zeroed(slru_idx: ::core::ffi::c_int);
    pub fn pgstat_count_slru_page_hit(slru_idx: ::core::ffi::c_int);
    pub fn pgstat_count_slru_page_read(slru_idx: ::core::ffi::c_int);
    pub fn pgstat_count_slru_page_written(slru_idx: ::core::ffi::c_int);
    pub fn pgstat_count_slru_page_exists(slru_idx: ::core::ffi::c_int);
    pub fn pgstat_count_slru_flush(slru_idx: ::core::ffi::c_int);
    pub fn pgstat_count_slru_truncate(slru_idx: ::core::ffi::c_int);
    pub fn pgstat_get_slru_name(slru_idx: ::core::ffi::c_int) -> *const ::core::ffi::c_char;
    pub fn pgstat_get_slru_index(name: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn pgstat_fetch_slru() -> *mut PgStat_SLRUStats;
    pub fn pgstat_report_subscription_error(subid: Oid, is_apply_error: bool);
    pub fn pgstat_create_subscription(subid: Oid);
    pub fn pgstat_drop_subscription(subid: Oid);
    pub fn pgstat_fetch_stat_subscription(subid: Oid) -> *mut PgStat_StatSubEntry;
    pub fn AtEOXact_PgStat(isCommit: bool, parallel: bool);
    pub fn AtEOSubXact_PgStat(isCommit: bool, nestDepth: ::core::ffi::c_int);
    pub fn AtPrepare_PgStat();
    pub fn PostPrepare_PgStat();
    pub fn pgstat_get_transactional_drops(
        isCommit: bool,
        items: *mut *mut xl_xact_stats_item,
    ) -> ::core::ffi::c_int;
    pub fn pgstat_execute_transactional_drops(
        ndrops: ::core::ffi::c_int,
        items: *mut xl_xact_stats_item,
        is_redo: bool,
    );
    pub fn pgstat_report_wal(force: bool);
    pub fn pgstat_fetch_stat_wal() -> *mut PgStat_WalStats;
    pub static mut pgstat_track_counts: bool;
    pub static mut pgstat_track_functions: ::core::ffi::c_int;
    pub static mut pgstat_fetch_consistency: ::core::ffi::c_int;
    pub static mut PendingBgWriterStats: PgStat_BgWriterStats;
    pub static mut PendingCheckpointerStats: PgStat_CheckpointerStats;
    pub static mut pgStatBlockReadTime: PgStat_Counter;
    pub static mut pgStatBlockWriteTime: PgStat_Counter;
    pub static mut pgStatActiveTime: PgStat_Counter;
    pub static mut pgStatTransactionIdleTime: PgStat_Counter;
    pub static mut pgStatSessionEndCause: SessionEndType::Type;
    pub static mut PendingWalStats: PgStat_PendingWalStats;
    pub fn detoast_external_attr(attr: *mut varlena) -> *mut varlena;
    pub fn detoast_attr(attr: *mut varlena) -> *mut varlena;
    pub fn detoast_attr_slice(
        attr: *mut varlena,
        sliceoffset: int32,
        slicelength: int32,
    ) -> *mut varlena;
    pub fn toast_raw_datum_size(value: Datum) -> Size;
    pub fn toast_datum_size(value: Datum) -> Size;
    pub fn build_backup_content(
        state: *mut BackupState,
        ishistoryfile: bool,
    ) -> *mut ::core::ffi::c_char;
    pub static mut wal_sync_method: ::core::ffi::c_int;
    pub static mut ProcLastRecPtr: XLogRecPtr;
    pub static mut XactLastRecEnd: XLogRecPtr;
    pub static mut XactLastCommitEnd: XLogRecPtr;
    pub static mut wal_segment_size: ::core::ffi::c_int;
    pub static mut min_wal_size_mb: ::core::ffi::c_int;
    pub static mut max_wal_size_mb: ::core::ffi::c_int;
    pub static mut wal_keep_size_mb: ::core::ffi::c_int;
    pub static mut max_slot_wal_keep_size_mb: ::core::ffi::c_int;
    pub static mut XLOGbuffers: ::core::ffi::c_int;
    pub static mut XLogArchiveTimeout: ::core::ffi::c_int;
    pub static mut wal_retrieve_retry_interval: ::core::ffi::c_int;
    pub static mut XLogArchiveCommand: *mut ::core::ffi::c_char;
    pub static mut EnableHotStandby: bool;
    pub static mut fullPageWrites: bool;
    pub static mut wal_log_hints: bool;
    pub static mut wal_compression: ::core::ffi::c_int;
    pub static mut wal_init_zero: bool;
    pub static mut wal_recycle: bool;
    pub static mut wal_consistency_checking: *mut bool;
    pub static mut wal_consistency_checking_string: *mut ::core::ffi::c_char;
    pub static mut log_checkpoints: bool;
    pub static mut track_wal_io_timing: bool;
    pub static mut wal_decode_buffer_size: ::core::ffi::c_int;
    pub static mut CheckPointSegments: ::core::ffi::c_int;
    pub static mut XLogArchiveMode: ::core::ffi::c_int;
    pub static mut wal_level: ::core::ffi::c_int;
    pub static mut CheckpointStats: CheckpointStatsData;
    pub fn XLogInsertRecord(
        rdata: *mut XLogRecData,
        fpw_lsn: XLogRecPtr,
        flags: uint8,
        num_fpi: ::core::ffi::c_int,
        topxid_included: bool,
    ) -> XLogRecPtr;
    pub fn XLogFlush(record: XLogRecPtr);
    pub fn XLogBackgroundFlush() -> bool;
    pub fn XLogNeedsFlush(record: XLogRecPtr) -> bool;
    pub fn XLogFileInit(logsegno: XLogSegNo, logtli: TimeLineID) -> ::core::ffi::c_int;
    pub fn XLogFileOpen(segno: XLogSegNo, tli: TimeLineID) -> ::core::ffi::c_int;
    pub fn CheckXLogRemoved(segno: XLogSegNo, tli: TimeLineID);
    pub fn XLogGetLastRemovedSegno() -> XLogSegNo;
    pub fn XLogGetOldestSegno(tli: TimeLineID) -> XLogSegNo;
    pub fn XLogSetAsyncXactLSN(asyncXactLSN: XLogRecPtr);
    pub fn XLogSetReplicationSlotMinimumLSN(lsn: XLogRecPtr);
    pub fn xlog_redo(record: *mut XLogReaderState);
    pub fn xlog_desc(buf: StringInfo, record: *mut XLogReaderState);
    pub fn xlog_identify(info: uint8) -> *const ::core::ffi::c_char;
    pub fn issue_xlog_fsync(fd: ::core::ffi::c_int, segno: XLogSegNo, tli: TimeLineID);
    pub fn RecoveryInProgress() -> bool;
    pub fn GetRecoveryState() -> RecoveryState::Type;
    pub fn XLogInsertAllowed() -> bool;
    pub fn GetXLogInsertRecPtr() -> XLogRecPtr;
    pub fn GetXLogWriteRecPtr() -> XLogRecPtr;
    pub fn GetSystemIdentifier() -> uint64;
    pub fn GetMockAuthenticationNonce() -> *mut ::core::ffi::c_char;
    pub fn DataChecksumsEnabled() -> bool;
    pub fn GetFakeLSNForUnloggedRel() -> XLogRecPtr;
    pub fn XLOGShmemSize() -> Size;
    pub fn XLOGShmemInit();
    pub fn BootStrapXLOG();
    pub fn InitializeWalConsistencyChecking();
    pub fn LocalProcessControlFile(reset: bool);
    pub fn GetActiveWalLevelOnStandby() -> WalLevel::Type;
    pub fn StartupXLOG();
    pub fn ShutdownXLOG(code: ::core::ffi::c_int, arg: Datum);
    pub fn CreateCheckPoint(flags: ::core::ffi::c_int);
    pub fn CreateRestartPoint(flags: ::core::ffi::c_int) -> bool;
    pub fn GetWALAvailability(targetLSN: XLogRecPtr) -> WALAvailability::Type;
    pub fn XLogPutNextOid(nextOid: Oid);
    pub fn XLogRestorePoint(rpName: *const ::core::ffi::c_char) -> XLogRecPtr;
    pub fn UpdateFullPageWrites();
    pub fn GetFullPageWriteInfo(RedoRecPtr_p: *mut XLogRecPtr, doPageWrites_p: *mut bool);
    pub fn GetRedoRecPtr() -> XLogRecPtr;
    pub fn GetInsertRecPtr() -> XLogRecPtr;
    pub fn GetFlushRecPtr(insertTLI: *mut TimeLineID) -> XLogRecPtr;
    pub fn GetWALInsertionTimeLine() -> TimeLineID;
    pub fn GetWALInsertionTimeLineIfSet() -> TimeLineID;
    pub fn GetLastImportantRecPtr() -> XLogRecPtr;
    pub fn SetWalWriterSleeping(sleeping: bool);
    pub fn WALReadFromBuffers(
        dstbuf: *mut ::core::ffi::c_char,
        startptr: XLogRecPtr,
        count: Size,
        tli: TimeLineID,
    ) -> Size;
    pub fn RemoveNonParentXlogFiles(switchpoint: XLogRecPtr, newTLI: TimeLineID);
    pub fn XLogCheckpointNeeded(new_segno: XLogSegNo) -> bool;
    pub fn SwitchIntoArchiveRecovery(EndRecPtr: XLogRecPtr, replayTLI: TimeLineID);
    pub fn ReachedEndOfBackup(EndRecPtr: XLogRecPtr, tli: TimeLineID);
    pub fn SetInstallXLogFileSegmentActive();
    pub fn IsInstallXLogFileSegmentActive() -> bool;
    pub fn XLogShutdownWalRcv();
    pub fn do_pg_backup_start(
        backupidstr: *const ::core::ffi::c_char,
        fast: bool,
        tablespaces: *mut *mut List,
        state: *mut BackupState,
        tblspcmapfile: StringInfo,
    );
    pub fn do_pg_backup_stop(state: *mut BackupState, waitforarchive: bool);
    pub fn do_pg_abort_backup(code: ::core::ffi::c_int, arg: Datum);
    pub fn register_persistent_abort_backup_handler();
    pub fn get_backup_status() -> SessionBackupState::Type;
    pub fn pg_comp_crc32c_sb8(
        crc: pg_crc32c,
        data: *const ::core::ffi::c_void,
        len: usize,
    ) -> pg_crc32c;
    pub static mut pg_comp_crc32c: ::core::option::Option<
        unsafe extern "C-unwind" fn(
            crc: pg_crc32c,
            data: *const ::core::ffi::c_void,
            len: usize,
        ) -> pg_crc32c,
    >;
    pub fn pg_comp_crc32c_sse42(
        crc: pg_crc32c,
        data: *const ::core::ffi::c_void,
        len: usize,
    ) -> pg_crc32c;
    pub fn XLogReaderAllocate(
        wal_segment_size: ::core::ffi::c_int,
        waldir: *const ::core::ffi::c_char,
        routine: *mut XLogReaderRoutine,
        private_data: *mut ::core::ffi::c_void,
    ) -> *mut XLogReaderState;
    pub fn XLogReaderFree(state: *mut XLogReaderState);
    pub fn XLogReaderSetDecodeBuffer(
        state: *mut XLogReaderState,
        buffer: *mut ::core::ffi::c_void,
        size: usize,
    );
    pub fn XLogBeginRead(state: *mut XLogReaderState, RecPtr: XLogRecPtr);
    pub fn XLogFindNextRecord(state: *mut XLogReaderState, RecPtr: XLogRecPtr) -> XLogRecPtr;
    pub fn XLogReadRecord(
        state: *mut XLogReaderState,
        errormsg: *mut *mut ::core::ffi::c_char,
    ) -> *mut XLogRecord;
    pub fn XLogNextRecord(
        state: *mut XLogReaderState,
        errormsg: *mut *mut ::core::ffi::c_char,
    ) -> *mut DecodedXLogRecord;
    pub fn XLogReleasePreviousRecord(state: *mut XLogReaderState) -> XLogRecPtr;
    pub fn XLogReadAhead(state: *mut XLogReaderState, nonblocking: bool) -> *mut DecodedXLogRecord;
    pub fn XLogReaderValidatePageHeader(
        state: *mut XLogReaderState,
        recptr: XLogRecPtr,
        phdr: *mut ::core::ffi::c_char,
    ) -> bool;
    pub fn XLogReaderResetError(state: *mut XLogReaderState);
    pub fn WALRead(
        state: *mut XLogReaderState,
        buf: *mut ::core::ffi::c_char,
        startptr: XLogRecPtr,
        count: Size,
        tli: TimeLineID,
        errinfo: *mut WALReadError,
    ) -> bool;
    pub fn DecodeXLogRecordRequiredSpace(xl_tot_len: usize) -> usize;
    pub fn DecodeXLogRecord(
        state: *mut XLogReaderState,
        decoded: *mut DecodedXLogRecord,
        record: *mut XLogRecord,
        lsn: XLogRecPtr,
        errormsg: *mut *mut ::core::ffi::c_char,
    ) -> bool;
    pub fn XLogRecGetFullXid(record: *mut XLogReaderState) -> FullTransactionId;
    pub fn RestoreBlockImage(
        record: *mut XLogReaderState,
        block_id: uint8,
        page: *mut ::core::ffi::c_char,
    ) -> bool;
    pub fn XLogRecGetBlockData(
        record: *mut XLogReaderState,
        block_id: uint8,
        len: *mut Size,
    ) -> *mut ::core::ffi::c_char;
    pub fn XLogRecGetBlockTag(
        record: *mut XLogReaderState,
        block_id: uint8,
        rlocator: *mut RelFileLocator,
        forknum: *mut ForkNumber::Type,
        blknum: *mut BlockNumber,
    );
    pub fn XLogRecGetBlockTagExtended(
        record: *mut XLogReaderState,
        block_id: uint8,
        rlocator: *mut RelFileLocator,
        forknum: *mut ForkNumber::Type,
        blknum: *mut BlockNumber,
        prefetch_buffer: *mut Buffer,
    ) -> bool;
    pub fn XLogBeginInsert();
    pub fn XLogSetRecordFlags(flags: uint8);
    pub fn XLogInsert(rmid: RmgrId, info: uint8) -> XLogRecPtr;
    pub fn XLogEnsureRecordSpace(max_block_id: ::core::ffi::c_int, ndatas: ::core::ffi::c_int);
    pub fn XLogRegisterData(data: *mut ::core::ffi::c_char, len: uint32);
    pub fn XLogRegisterBuffer(block_id: uint8, buffer: Buffer, flags: uint8);
    pub fn XLogRegisterBlock(
        block_id: uint8,
        rlocator: *mut RelFileLocator,
        forknum: ForkNumber::Type,
        blknum: BlockNumber,
        page: *mut ::core::ffi::c_char,
        flags: uint8,
    );
    pub fn XLogRegisterBufData(block_id: uint8, data: *mut ::core::ffi::c_char, len: uint32);
    pub fn XLogResetInsertion();
    pub fn XLogCheckBufferNeedsBackup(buffer: Buffer) -> bool;
    pub fn log_newpage(
        rlocator: *mut RelFileLocator,
        forknum: ForkNumber::Type,
        blkno: BlockNumber,
        page: *mut ::core::ffi::c_char,
        page_std: bool,
    ) -> XLogRecPtr;
    pub fn log_newpages(
        rlocator: *mut RelFileLocator,
        forknum: ForkNumber::Type,
        num_pages: ::core::ffi::c_int,
        blknos: *mut BlockNumber,
        pages: *mut *mut ::core::ffi::c_char,
        page_std: bool,
    );
    pub fn log_newpage_buffer(buffer: Buffer, page_std: bool) -> XLogRecPtr;
    pub fn log_newpage_range(
        rel: Relation,
        forknum: ForkNumber::Type,
        startblk: BlockNumber,
        endblk: BlockNumber,
        page_std: bool,
    );
    pub fn XLogSaveBufferForHint(buffer: Buffer, buffer_std: bool) -> XLogRecPtr;
    pub fn InitXLogInsert();
    pub fn errdetail_relkind_not_supported(relkind: ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn IsSystemRelation(relation: Relation) -> bool;
    pub fn IsToastRelation(relation: Relation) -> bool;
    pub fn IsCatalogRelation(relation: Relation) -> bool;
    pub fn IsInplaceUpdateRelation(relation: Relation) -> bool;
    pub fn IsSystemClass(relid: Oid, reltuple: Form_pg_class) -> bool;
    pub fn IsToastClass(reltuple: Form_pg_class) -> bool;
    pub fn IsCatalogRelationOid(relid: Oid) -> bool;
    pub fn IsInplaceUpdateOid(relid: Oid) -> bool;
    pub fn IsCatalogNamespace(namespaceId: Oid) -> bool;
    pub fn IsToastNamespace(namespaceId: Oid) -> bool;
    pub fn IsReservedName(name: *const ::core::ffi::c_char) -> bool;
    pub fn IsSharedRelation(relationId: Oid) -> bool;
    pub fn IsPinnedObject(classId: Oid, objectId: Oid) -> bool;
    pub fn GetNewOidWithIndex(relation: Relation, indexId: Oid, oidcolumn: AttrNumber) -> Oid;
    pub fn GetNewRelFileNumber(
        reltablespace: Oid,
        pg_class: Relation,
        relpersistence: ::core::ffi::c_char,
    ) -> RelFileNumber;
    pub static InvalidObjectAddress: ObjectAddress;
    pub fn get_object_address(
        objtype: ObjectType::Type,
        object: *mut Node,
        relp: *mut Relation,
        lockmode: LOCKMODE,
        missing_ok: bool,
    ) -> ObjectAddress;
    pub fn get_object_address_rv(
        objtype: ObjectType::Type,
        rel: *mut RangeVar,
        object: *mut List,
        relp: *mut Relation,
        lockmode: LOCKMODE,
        missing_ok: bool,
    ) -> ObjectAddress;
    pub fn check_object_ownership(
        roleid: Oid,
        objtype: ObjectType::Type,
        address: ObjectAddress,
        object: *mut Node,
        relation: Relation,
    );
    pub fn get_object_namespace(address: *const ObjectAddress) -> Oid;
    pub fn is_objectclass_supported(class_id: Oid) -> bool;
    pub fn get_object_class_descr(class_id: Oid) -> *const ::core::ffi::c_char;
    pub fn get_object_oid_index(class_id: Oid) -> Oid;
    pub fn get_object_catcache_oid(class_id: Oid) -> ::core::ffi::c_int;
    pub fn get_object_catcache_name(class_id: Oid) -> ::core::ffi::c_int;
    pub fn get_object_attnum_oid(class_id: Oid) -> AttrNumber;
    pub fn get_object_attnum_name(class_id: Oid) -> AttrNumber;
    pub fn get_object_attnum_namespace(class_id: Oid) -> AttrNumber;
    pub fn get_object_attnum_owner(class_id: Oid) -> AttrNumber;
    pub fn get_object_attnum_acl(class_id: Oid) -> AttrNumber;
    pub fn get_object_type(class_id: Oid, object_id: Oid) -> ObjectType::Type;
    pub fn get_object_namensp_unique(class_id: Oid) -> bool;
    pub fn get_catalog_object_by_oid(
        catalog: Relation,
        oidcol: AttrNumber,
        objectId: Oid,
    ) -> HeapTuple;
    pub fn get_catalog_object_by_oid_extended(
        catalog: Relation,
        oidcol: AttrNumber,
        objectId: Oid,
        locktup: bool,
    ) -> HeapTuple;
    pub fn getObjectDescription(
        object: *const ObjectAddress,
        missing_ok: bool,
    ) -> *mut ::core::ffi::c_char;
    pub fn getObjectDescriptionOids(classid: Oid, objid: Oid) -> *mut ::core::ffi::c_char;
    pub fn read_objtype_from_string(objtype: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn getObjectTypeDescription(
        object: *const ObjectAddress,
        missing_ok: bool,
    ) -> *mut ::core::ffi::c_char;
    pub fn getObjectIdentity(
        object: *const ObjectAddress,
        missing_ok: bool,
    ) -> *mut ::core::ffi::c_char;
    pub fn getObjectIdentityParts(
        object: *const ObjectAddress,
        objname: *mut *mut List,
        objargs: *mut *mut List,
        missing_ok: bool,
    ) -> *mut ::core::ffi::c_char;
    pub fn strlist_to_textarray(list: *mut List) -> *mut ArrayType;
    pub fn get_relkind_objtype(relkind: ::core::ffi::c_char) -> ObjectType::Type;
    pub fn GetPublication(pubid: Oid) -> *mut Publication;
    pub fn GetPublicationByName(
        pubname: *const ::core::ffi::c_char,
        missing_ok: bool,
    ) -> *mut Publication;
    pub fn GetRelationPublications(relid: Oid) -> *mut List;
    pub fn GetPublicationRelations(pubid: Oid, pub_partopt: PublicationPartOpt::Type) -> *mut List;
    pub fn GetAllTablesPublications() -> *mut List;
    pub fn GetAllTablesPublicationRelations(pubviaroot: bool) -> *mut List;
    pub fn GetPublicationSchemas(pubid: Oid) -> *mut List;
    pub fn GetSchemaPublications(schemaid: Oid) -> *mut List;
    pub fn GetSchemaPublicationRelations(
        schemaid: Oid,
        pub_partopt: PublicationPartOpt::Type,
    ) -> *mut List;
    pub fn GetAllSchemaPublicationRelations(
        pubid: Oid,
        pub_partopt: PublicationPartOpt::Type,
    ) -> *mut List;
    pub fn GetPubPartitionOptionRelations(
        result: *mut List,
        pub_partopt: PublicationPartOpt::Type,
        relid: Oid,
    ) -> *mut List;
    pub fn GetTopMostAncestorInPublication(
        puboid: Oid,
        ancestors: *mut List,
        ancestor_level: *mut ::core::ffi::c_int,
    ) -> Oid;
    pub fn is_publishable_relation(rel: Relation) -> bool;
    pub fn is_schema_publication(pubid: Oid) -> bool;
    pub fn publication_add_relation(
        pubid: Oid,
        pri: *mut PublicationRelInfo,
        if_not_exists: bool,
    ) -> ObjectAddress;
    pub fn publication_add_schema(pubid: Oid, schemaid: Oid, if_not_exists: bool) -> ObjectAddress;
    pub fn pub_collist_to_bitmapset(
        columns: *mut Bitmapset,
        pubcols: Datum,
        mcxt: MemoryContext,
    ) -> *mut Bitmapset;
    pub fn smgrinit();
    pub fn smgropen(rlocator: RelFileLocator, backend: ProcNumber) -> SMgrRelation;
    pub fn smgrexists(reln: SMgrRelation, forknum: ForkNumber::Type) -> bool;
    pub fn smgrpin(reln: SMgrRelation);
    pub fn smgrunpin(reln: SMgrRelation);
    pub fn smgrclose(reln: SMgrRelation);
    pub fn smgrdestroyall();
    pub fn smgrrelease(reln: SMgrRelation);
    pub fn smgrreleaseall();
    pub fn smgrreleaserellocator(rlocator: RelFileLocatorBackend);
    pub fn smgrcreate(reln: SMgrRelation, forknum: ForkNumber::Type, isRedo: bool);
    pub fn smgrdosyncall(rels: *mut SMgrRelation, nrels: ::core::ffi::c_int);
    pub fn smgrdounlinkall(rels: *mut SMgrRelation, nrels: ::core::ffi::c_int, isRedo: bool);
    pub fn smgrextend(
        reln: SMgrRelation,
        forknum: ForkNumber::Type,
        blocknum: BlockNumber,
        buffer: *const ::core::ffi::c_void,
        skipFsync: bool,
    );
    pub fn smgrzeroextend(
        reln: SMgrRelation,
        forknum: ForkNumber::Type,
        blocknum: BlockNumber,
        nblocks: ::core::ffi::c_int,
        skipFsync: bool,
    );
    pub fn smgrprefetch(
        reln: SMgrRelation,
        forknum: ForkNumber::Type,
        blocknum: BlockNumber,
        nblocks: ::core::ffi::c_int,
    ) -> bool;
    pub fn smgrreadv(
        reln: SMgrRelation,
        forknum: ForkNumber::Type,
        blocknum: BlockNumber,
        buffers: *mut *mut ::core::ffi::c_void,
        nblocks: BlockNumber,
    );
    pub fn smgrwritev(
        reln: SMgrRelation,
        forknum: ForkNumber::Type,
        blocknum: BlockNumber,
        buffers: *mut *const ::core::ffi::c_void,
        nblocks: BlockNumber,
        skipFsync: bool,
    );
    pub fn smgrwriteback(
        reln: SMgrRelation,
        forknum: ForkNumber::Type,
        blocknum: BlockNumber,
        nblocks: BlockNumber,
    );
    pub fn smgrnblocks(reln: SMgrRelation, forknum: ForkNumber::Type) -> BlockNumber;
    pub fn smgrnblocks_cached(reln: SMgrRelation, forknum: ForkNumber::Type) -> BlockNumber;
    pub fn smgrtruncate(
        reln: SMgrRelation,
        forknum: *mut ForkNumber::Type,
        nforks: ::core::ffi::c_int,
        nblocks: *mut BlockNumber,
    );
    pub fn smgrtruncate2(
        reln: SMgrRelation,
        forknum: *mut ForkNumber::Type,
        nforks: ::core::ffi::c_int,
        old_nblocks: *mut BlockNumber,
        nblocks: *mut BlockNumber,
    );
    pub fn smgrimmedsync(reln: SMgrRelation, forknum: ForkNumber::Type);
    pub fn smgrregistersync(reln: SMgrRelation, forknum: ForkNumber::Type);
    pub fn AtEOXact_SMgr();
    pub fn ProcessBarrierSmgrRelease() -> bool;
    pub fn RelationIncrementReferenceCount(rel: Relation);
    pub fn RelationDecrementReferenceCount(rel: Relation);
    pub fn GenericXLogStart(relation: Relation) -> *mut GenericXLogState;
    pub fn GenericXLogRegisterBuffer(
        state: *mut GenericXLogState,
        buffer: Buffer,
        flags: ::core::ffi::c_int,
    ) -> Page;
    pub fn GenericXLogFinish(state: *mut GenericXLogState) -> XLogRecPtr;
    pub fn GenericXLogAbort(state: *mut GenericXLogState);
    pub fn generic_redo(record: *mut XLogReaderState);
    pub fn generic_identify(info: uint8) -> *const ::core::ffi::c_char;
    pub fn generic_desc(buf: StringInfo, record: *mut XLogReaderState);
    pub fn generic_mask(page: *mut ::core::ffi::c_char, blkno: BlockNumber);
    pub static mut GinFuzzySearchLimit: ::core::ffi::c_int;
    pub static mut gin_pending_list_limit: ::core::ffi::c_int;
    pub fn ginGetStats(index: Relation, stats: *mut GinStatsData);
    pub fn ginUpdateStats(index: Relation, stats: *const GinStatsData, is_build: bool);
    pub fn relation_open(relationId: Oid, lockmode: LOCKMODE) -> Relation;
    pub fn try_relation_open(relationId: Oid, lockmode: LOCKMODE) -> Relation;
    pub fn relation_openrv(relation: *const RangeVar, lockmode: LOCKMODE) -> Relation;
    pub fn relation_openrv_extended(
        relation: *const RangeVar,
        lockmode: LOCKMODE,
        missing_ok: bool,
    ) -> Relation;
    pub fn relation_close(relation: Relation, lockmode: LOCKMODE);
    pub fn table_open(relationId: Oid, lockmode: LOCKMODE) -> Relation;
    pub fn table_openrv(relation: *const RangeVar, lockmode: LOCKMODE) -> Relation;
    pub fn table_openrv_extended(
        relation: *const RangeVar,
        lockmode: LOCKMODE,
        missing_ok: bool,
    ) -> Relation;
    pub fn try_table_open(relationId: Oid, lockmode: LOCKMODE) -> Relation;
    pub fn table_close(relation: Relation, lockmode: LOCKMODE);
    pub static mut SharedInvalidMessageCounter: uint64;
    pub static mut catchupInterruptPending: sig_atomic_t;
    pub fn SendSharedInvalidMessages(msgs: *const SharedInvalidationMessage, n: ::core::ffi::c_int);
    pub fn ReceiveSharedInvalidMessages(
        invalFunction: ::core::option::Option<
            unsafe extern "C-unwind" fn(msg: *mut SharedInvalidationMessage),
        >,
        resetFunction: ::core::option::Option<unsafe extern "C-unwind" fn()>,
    );
    pub fn HandleCatchupInterrupt();
    pub fn ProcessCatchupInterrupt();
    pub fn xactGetCommittedInvalidationMessages(
        msgs: *mut *mut SharedInvalidationMessage,
        RelcacheInitFileInval: *mut bool,
    ) -> ::core::ffi::c_int;
    pub fn ProcessCommittedInvalidationMessages(
        msgs: *mut SharedInvalidationMessage,
        nmsgs: ::core::ffi::c_int,
        RelcacheInitFileInval: bool,
        dbid: Oid,
        tsid: Oid,
    );
    pub fn LocalExecuteInvalidationMessage(msg: *mut SharedInvalidationMessage);
    pub static mut DefaultXactIsoLevel: ::core::ffi::c_int;
    pub static mut XactIsoLevel: ::core::ffi::c_int;
    pub static mut DefaultXactReadOnly: bool;
    pub static mut XactReadOnly: bool;
    pub static mut xact_is_sampled: bool;
    pub static mut DefaultXactDeferrable: bool;
    pub static mut XactDeferrable: bool;
    pub static mut synchronous_commit: ::core::ffi::c_int;
    pub static mut CheckXidAlive: TransactionId;
    pub static mut bsysscan: bool;
    pub static mut MyXactFlags: ::core::ffi::c_int;
    pub fn IsTransactionState() -> bool;
    pub fn IsAbortedTransactionBlockState() -> bool;
    pub fn GetTopTransactionId() -> TransactionId;
    pub fn GetTopTransactionIdIfAny() -> TransactionId;
    pub fn GetCurrentTransactionId() -> TransactionId;
    pub fn GetCurrentTransactionIdIfAny() -> TransactionId;
    pub fn GetStableLatestTransactionId() -> TransactionId;
    pub fn GetCurrentSubTransactionId() -> SubTransactionId;
    pub fn GetTopFullTransactionId() -> FullTransactionId;
    pub fn GetTopFullTransactionIdIfAny() -> FullTransactionId;
    pub fn GetCurrentFullTransactionId() -> FullTransactionId;
    pub fn GetCurrentFullTransactionIdIfAny() -> FullTransactionId;
    pub fn MarkCurrentTransactionIdLoggedIfAny();
    pub fn SubTransactionIsActive(subxid: SubTransactionId) -> bool;
    pub fn GetCurrentCommandId(used: bool) -> CommandId;
    pub fn SetParallelStartTimestamps(xact_ts: TimestampTz, stmt_ts: TimestampTz);
    pub fn GetCurrentTransactionStartTimestamp() -> TimestampTz;
    pub fn GetCurrentStatementStartTimestamp() -> TimestampTz;
    pub fn GetCurrentTransactionStopTimestamp() -> TimestampTz;
    pub fn SetCurrentStatementStartTimestamp();
    pub fn GetCurrentTransactionNestLevel() -> ::core::ffi::c_int;
    pub fn TransactionIdIsCurrentTransactionId(xid: TransactionId) -> bool;
    pub fn CommandCounterIncrement();
    pub fn ForceSyncCommit();
    pub fn StartTransactionCommand();
    pub fn SaveTransactionCharacteristics(s: *mut SavedTransactionCharacteristics);
    pub fn RestoreTransactionCharacteristics(s: *const SavedTransactionCharacteristics);
    pub fn CommitTransactionCommand();
    pub fn AbortCurrentTransaction();
    pub fn BeginTransactionBlock();
    pub fn EndTransactionBlock(chain: bool) -> bool;
    pub fn PrepareTransactionBlock(gid: *const ::core::ffi::c_char) -> bool;
    pub fn UserAbortTransactionBlock(chain: bool);
    pub fn BeginImplicitTransactionBlock();
    pub fn EndImplicitTransactionBlock();
    pub fn ReleaseSavepoint(name: *const ::core::ffi::c_char);
    pub fn DefineSavepoint(name: *const ::core::ffi::c_char);
    pub fn RollbackToSavepoint(name: *const ::core::ffi::c_char);
    pub fn BeginInternalSubTransaction(name: *const ::core::ffi::c_char);
    pub fn ReleaseCurrentSubTransaction();
    pub fn RollbackAndReleaseCurrentSubTransaction();
    pub fn IsSubTransaction() -> bool;
    pub fn EstimateTransactionStateSpace() -> Size;
    pub fn SerializeTransactionState(maxsize: Size, start_address: *mut ::core::ffi::c_char);
    pub fn StartParallelWorkerTransaction(tstatespace: *mut ::core::ffi::c_char);
    pub fn EndParallelWorkerTransaction();
    pub fn IsTransactionBlock() -> bool;
    pub fn IsTransactionOrTransactionBlock() -> bool;
    pub fn TransactionBlockStatusCode() -> ::core::ffi::c_char;
    pub fn AbortOutOfAnyTransaction();
    pub fn PreventInTransactionBlock(isTopLevel: bool, stmtType: *const ::core::ffi::c_char);
    pub fn RequireTransactionBlock(isTopLevel: bool, stmtType: *const ::core::ffi::c_char);
    pub fn WarnNoTransactionBlock(isTopLevel: bool, stmtType: *const ::core::ffi::c_char);
    pub fn IsInTransactionBlock(isTopLevel: bool) -> bool;
    pub fn RegisterXactCallback(callback: XactCallback, arg: *mut ::core::ffi::c_void);
    pub fn UnregisterXactCallback(callback: XactCallback, arg: *mut ::core::ffi::c_void);
    pub fn RegisterSubXactCallback(callback: SubXactCallback, arg: *mut ::core::ffi::c_void);
    pub fn UnregisterSubXactCallback(callback: SubXactCallback, arg: *mut ::core::ffi::c_void);
    pub fn IsSubxactTopXidLogPending() -> bool;
    pub fn MarkSubxactTopXidLogged();
    pub fn xactGetCommittedChildren(ptr: *mut *mut TransactionId) -> ::core::ffi::c_int;
    pub fn XactLogCommitRecord(
        commit_time: TimestampTz,
        nsubxacts: ::core::ffi::c_int,
        subxacts: *mut TransactionId,
        nrels: ::core::ffi::c_int,
        rels: *mut RelFileLocator,
        ndroppedstats: ::core::ffi::c_int,
        droppedstats: *mut xl_xact_stats_item,
        nmsgs: ::core::ffi::c_int,
        msgs: *mut SharedInvalidationMessage,
        relcacheInval: bool,
        xactflags: ::core::ffi::c_int,
        twophase_xid: TransactionId,
        twophase_gid: *const ::core::ffi::c_char,
    ) -> XLogRecPtr;
    pub fn XactLogAbortRecord(
        abort_time: TimestampTz,
        nsubxacts: ::core::ffi::c_int,
        subxacts: *mut TransactionId,
        nrels: ::core::ffi::c_int,
        rels: *mut RelFileLocator,
        ndroppedstats: ::core::ffi::c_int,
        droppedstats: *mut xl_xact_stats_item,
        xactflags: ::core::ffi::c_int,
        twophase_xid: TransactionId,
        twophase_gid: *const ::core::ffi::c_char,
    ) -> XLogRecPtr;
    pub fn xact_redo(record: *mut XLogReaderState);
    pub fn xact_desc(buf: StringInfo, record: *mut XLogReaderState);
    pub fn xact_identify(info: uint8) -> *const ::core::ffi::c_char;
    pub fn ParseCommitRecord(
        info: uint8,
        xlrec: *mut xl_xact_commit,
        parsed: *mut xl_xact_parsed_commit,
    );
    pub fn ParseAbortRecord(
        info: uint8,
        xlrec: *mut xl_xact_abort,
        parsed: *mut xl_xact_parsed_abort,
    );
    pub fn ParsePrepareRecord(
        info: uint8,
        xlrec: *mut xl_xact_prepare,
        parsed: *mut xl_xact_parsed_prepare,
    );
    pub fn EnterParallelMode();
    pub fn ExitParallelMode();
    pub fn IsInParallelMode() -> bool;
    pub static mut CurrentResourceOwner: ResourceOwner;
    pub static mut CurTransactionResourceOwner: ResourceOwner;
    pub static mut TopTransactionResourceOwner: ResourceOwner;
    pub static mut AuxProcessResourceOwner: ResourceOwner;
    pub fn ResourceOwnerCreate(
        parent: ResourceOwner,
        name: *const ::core::ffi::c_char,
    ) -> ResourceOwner;
    pub fn ResourceOwnerRelease(
        owner: ResourceOwner,
        phase: ResourceReleasePhase::Type,
        isCommit: bool,
        isTopLevel: bool,
    );
    pub fn ResourceOwnerDelete(owner: ResourceOwner);
    pub fn ResourceOwnerGetParent(owner: ResourceOwner) -> ResourceOwner;
    pub fn ResourceOwnerNewParent(owner: ResourceOwner, newparent: ResourceOwner);
    pub fn ResourceOwnerEnlarge(owner: ResourceOwner);
    pub fn ResourceOwnerRemember(
        owner: ResourceOwner,
        value: Datum,
        kind: *const ResourceOwnerDesc,
    );
    pub fn ResourceOwnerForget(owner: ResourceOwner, value: Datum, kind: *const ResourceOwnerDesc);
    pub fn ResourceOwnerReleaseAllOfKind(owner: ResourceOwner, kind: *const ResourceOwnerDesc);
    pub fn RegisterResourceReleaseCallback(
        callback: ResourceReleaseCallback,
        arg: *mut ::core::ffi::c_void,
    );
    pub fn UnregisterResourceReleaseCallback(
        callback: ResourceReleaseCallback,
        arg: *mut ::core::ffi::c_void,
    );
    pub fn CreateAuxProcessResourceOwner();
    pub fn ReleaseAuxProcessResources(isCommit: bool);
    pub fn ResourceOwnerRememberLock(owner: ResourceOwner, locallock: *mut LOCALLOCK);
    pub fn ResourceOwnerForgetLock(owner: ResourceOwner, locallock: *mut LOCALLOCK);
    pub static mut FirstSnapshotSet: bool;
    pub static mut TransactionXmin: TransactionId;
    pub static mut RecentXmin: TransactionId;
    pub static mut SnapshotSelfData: SnapshotData;
    pub static mut SnapshotAnyData: SnapshotData;
    pub static mut CatalogSnapshotData: SnapshotData;
    pub fn GetTransactionSnapshot() -> Snapshot;
    pub fn GetLatestSnapshot() -> Snapshot;
    pub fn SnapshotSetCommandId(curcid: CommandId);
    pub fn GetOldestSnapshot() -> Snapshot;
    pub fn GetCatalogSnapshot(relid: Oid) -> Snapshot;
    pub fn GetNonHistoricCatalogSnapshot(relid: Oid) -> Snapshot;
    pub fn InvalidateCatalogSnapshot();
    pub fn InvalidateCatalogSnapshotConditionally();
    pub fn PushActiveSnapshot(snapshot: Snapshot);
    pub fn PushActiveSnapshotWithLevel(snapshot: Snapshot, snap_level: ::core::ffi::c_int);
    pub fn PushCopiedSnapshot(snapshot: Snapshot);
    pub fn UpdateActiveSnapshotCommandId();
    pub fn PopActiveSnapshot();
    pub fn GetActiveSnapshot() -> Snapshot;
    pub fn ActiveSnapshotSet() -> bool;
    pub fn RegisterSnapshot(snapshot: Snapshot) -> Snapshot;
    pub fn UnregisterSnapshot(snapshot: Snapshot);
    pub fn RegisterSnapshotOnOwner(snapshot: Snapshot, owner: ResourceOwner) -> Snapshot;
    pub fn UnregisterSnapshotFromOwner(snapshot: Snapshot, owner: ResourceOwner);
    pub fn AtSubCommit_Snapshot(level: ::core::ffi::c_int);
    pub fn AtSubAbort_Snapshot(level: ::core::ffi::c_int);
    pub fn AtEOXact_Snapshot(isCommit: bool, resetXmin: bool);
    pub fn ImportSnapshot(idstr: *const ::core::ffi::c_char);
    pub fn XactHasExportedSnapshots() -> bool;
    pub fn DeleteAllExportedSnapshotFiles();
    pub fn WaitForOlderSnapshots(limitXmin: TransactionId, progress: bool);
    pub fn ThereAreNoPriorRegisteredSnapshots() -> bool;
    pub fn HaveRegisteredOrActiveSnapshot() -> bool;
    pub fn ExportSnapshot(snapshot: Snapshot) -> *mut ::core::ffi::c_char;
    pub fn GlobalVisTestFor(rel: Relation) -> *mut GlobalVisState;
    pub fn GlobalVisTestIsRemovableXid(state: *mut GlobalVisState, xid: TransactionId) -> bool;
    pub fn GlobalVisTestIsRemovableFullXid(
        state: *mut GlobalVisState,
        fxid: FullTransactionId,
    ) -> bool;
    pub fn GlobalVisCheckRemovableXid(rel: Relation, xid: TransactionId) -> bool;
    pub fn GlobalVisCheckRemovableFullXid(rel: Relation, fxid: FullTransactionId) -> bool;
    pub fn XidInMVCCSnapshot(xid: TransactionId, snapshot: Snapshot) -> bool;
    pub fn HistoricSnapshotGetTupleCids() -> *mut HTAB;
    pub fn SetupHistoricSnapshot(historic_snapshot: Snapshot, tuplecids: *mut HTAB);
    pub fn TeardownHistoricSnapshot(is_error: bool);
    pub fn HistoricSnapshotActive() -> bool;
    pub fn EstimateSnapshotSpace(snapshot: Snapshot) -> Size;
    pub fn SerializeSnapshot(snapshot: Snapshot, start_address: *mut ::core::ffi::c_char);
    pub fn RestoreSnapshot(start_address: *mut ::core::ffi::c_char) -> Snapshot;
    pub fn RestoreTransactionSnapshot(snapshot: Snapshot, source_pgproc: *mut ::core::ffi::c_void);
    pub static mut zero_damaged_pages: bool;
    pub static mut bgwriter_lru_maxpages: ::core::ffi::c_int;
    pub static mut bgwriter_lru_multiplier: f64;
    pub static mut track_io_timing: bool;
    pub static mut effective_io_concurrency: ::core::ffi::c_int;
    pub static mut maintenance_io_concurrency: ::core::ffi::c_int;
    pub static mut io_combine_limit: ::core::ffi::c_int;
    pub static mut checkpoint_flush_after: ::core::ffi::c_int;
    pub static mut backend_flush_after: ::core::ffi::c_int;
    pub static mut bgwriter_flush_after: ::core::ffi::c_int;
    pub static mut BufferBlocks: *mut ::core::ffi::c_char;
    pub static mut NLocBuffer: ::core::ffi::c_int;
    pub static mut LocalBufferBlockPointers: *mut Block;
    pub static mut LocalRefCount: *mut int32;
    pub fn PrefetchSharedBuffer(
        smgr_reln: *mut SMgrRelationData,
        forkNum: ForkNumber::Type,
        blockNum: BlockNumber,
    ) -> PrefetchBufferResult;
    pub fn PrefetchBuffer(
        reln: Relation,
        forkNum: ForkNumber::Type,
        blockNum: BlockNumber,
    ) -> PrefetchBufferResult;
    pub fn ReadRecentBuffer(
        rlocator: RelFileLocator,
        forkNum: ForkNumber::Type,
        blockNum: BlockNumber,
        recent_buffer: Buffer,
    ) -> bool;
    pub fn ReadBuffer(reln: Relation, blockNum: BlockNumber) -> Buffer;
    pub fn ReadBufferExtended(
        reln: Relation,
        forkNum: ForkNumber::Type,
        blockNum: BlockNumber,
        mode: ReadBufferMode::Type,
        strategy: BufferAccessStrategy,
    ) -> Buffer;
    pub fn ReadBufferWithoutRelcache(
        rlocator: RelFileLocator,
        forkNum: ForkNumber::Type,
        blockNum: BlockNumber,
        mode: ReadBufferMode::Type,
        strategy: BufferAccessStrategy,
        permanent: bool,
    ) -> Buffer;
    pub fn StartReadBuffer(
        operation: *mut ReadBuffersOperation,
        buffer: *mut Buffer,
        blocknum: BlockNumber,
        flags: ::core::ffi::c_int,
    ) -> bool;
    pub fn StartReadBuffers(
        operation: *mut ReadBuffersOperation,
        buffers: *mut Buffer,
        blockNum: BlockNumber,
        nblocks: *mut ::core::ffi::c_int,
        flags: ::core::ffi::c_int,
    ) -> bool;
    pub fn WaitReadBuffers(operation: *mut ReadBuffersOperation);
    pub fn ReleaseBuffer(buffer: Buffer);
    pub fn UnlockReleaseBuffer(buffer: Buffer);
    pub fn BufferIsExclusiveLocked(buffer: Buffer) -> bool;
    pub fn BufferIsDirty(buffer: Buffer) -> bool;
    pub fn MarkBufferDirty(buffer: Buffer);
    pub fn IncrBufferRefCount(buffer: Buffer);
    pub fn CheckBufferIsPinnedOnce(buffer: Buffer);
    pub fn ReleaseAndReadBuffer(
        buffer: Buffer,
        relation: Relation,
        blockNum: BlockNumber,
    ) -> Buffer;
    pub fn ExtendBufferedRel(
        bmr: BufferManagerRelation,
        forkNum: ForkNumber::Type,
        strategy: BufferAccessStrategy,
        flags: uint32,
    ) -> Buffer;
    pub fn ExtendBufferedRelBy(
        bmr: BufferManagerRelation,
        fork: ForkNumber::Type,
        strategy: BufferAccessStrategy,
        flags: uint32,
        extend_by: uint32,
        buffers: *mut Buffer,
        extended_by: *mut uint32,
    ) -> BlockNumber;
    pub fn ExtendBufferedRelTo(
        bmr: BufferManagerRelation,
        fork: ForkNumber::Type,
        strategy: BufferAccessStrategy,
        flags: uint32,
        extend_to: BlockNumber,
        mode: ReadBufferMode::Type,
    ) -> Buffer;
    pub fn InitBufferPoolAccess();
    pub fn AtEOXact_Buffers(isCommit: bool);
    pub fn DebugPrintBufferRefcount(buffer: Buffer) -> *mut ::core::ffi::c_char;
    pub fn CheckPointBuffers(flags: ::core::ffi::c_int);
    pub fn BufferGetBlockNumber(buffer: Buffer) -> BlockNumber;
    pub fn RelationGetNumberOfBlocksInFork(
        relation: Relation,
        forkNum: ForkNumber::Type,
    ) -> BlockNumber;
    pub fn FlushOneBuffer(buffer: Buffer);
    pub fn FlushRelationBuffers(rel: Relation);
    pub fn FlushRelationsAllBuffers(smgrs: *mut *mut SMgrRelationData, nrels: ::core::ffi::c_int);
    pub fn CreateAndCopyRelationData(
        src_rlocator: RelFileLocator,
        dst_rlocator: RelFileLocator,
        permanent: bool,
    );
    pub fn FlushDatabaseBuffers(dbid: Oid);
    pub fn DropRelationBuffers(
        smgr_reln: *mut SMgrRelationData,
        forkNum: *mut ForkNumber::Type,
        nforks: ::core::ffi::c_int,
        firstDelBlock: *mut BlockNumber,
    );
    pub fn DropRelationsAllBuffers(
        smgr_reln: *mut *mut SMgrRelationData,
        nlocators: ::core::ffi::c_int,
    );
    pub fn DropDatabaseBuffers(dbid: Oid);
    pub fn BufferIsPermanent(buffer: Buffer) -> bool;
    pub fn BufferGetLSNAtomic(buffer: Buffer) -> XLogRecPtr;
    pub fn BufferGetTag(
        buffer: Buffer,
        rlocator: *mut RelFileLocator,
        forknum: *mut ForkNumber::Type,
        blknum: *mut BlockNumber,
    );
    pub fn MarkBufferDirtyHint(buffer: Buffer, buffer_std: bool);
    pub fn UnlockBuffers();
    pub fn LockBuffer(buffer: Buffer, mode: ::core::ffi::c_int);
    pub fn ConditionalLockBuffer(buffer: Buffer) -> bool;
    pub fn LockBufferForCleanup(buffer: Buffer);
    pub fn ConditionalLockBufferForCleanup(buffer: Buffer) -> bool;
    pub fn IsBufferCleanupOK(buffer: Buffer) -> bool;
    pub fn HoldingBufferPinThatDelaysRecovery() -> bool;
    pub fn BgBufferSync(wb_context: *mut WritebackContext) -> bool;
    pub fn LimitAdditionalPins(additional_pins: *mut uint32);
    pub fn LimitAdditionalLocalPins(additional_pins: *mut uint32);
    pub fn EvictUnpinnedBuffer(buf: Buffer) -> bool;
    pub fn InitBufferPool();
    pub fn BufferShmemSize() -> Size;
    pub fn AtProcExit_LocalBuffers();
    pub fn GetAccessStrategy(btype: BufferAccessStrategyType::Type) -> BufferAccessStrategy;
    pub fn GetAccessStrategyWithSize(
        btype: BufferAccessStrategyType::Type,
        ring_size_kb: ::core::ffi::c_int,
    ) -> BufferAccessStrategy;
    pub fn GetAccessStrategyBufferCount(strategy: BufferAccessStrategy) -> ::core::ffi::c_int;
    pub fn GetAccessStrategyPinLimit(strategy: BufferAccessStrategy) -> ::core::ffi::c_int;
    pub fn FreeAccessStrategy(strategy: BufferAccessStrategy);
    pub fn read_stream_begin_relation(
        flags: ::core::ffi::c_int,
        strategy: BufferAccessStrategy,
        rel: Relation,
        forknum: ForkNumber::Type,
        callback: ReadStreamBlockNumberCB,
        callback_private_data: *mut ::core::ffi::c_void,
        per_buffer_data_size: usize,
    ) -> *mut ReadStream;
    pub fn read_stream_next_buffer(
        stream: *mut ReadStream,
        per_buffer_data: *mut *mut ::core::ffi::c_void,
    ) -> Buffer;
    pub fn read_stream_next_block(
        stream: *mut ReadStream,
        strategy: *mut BufferAccessStrategy,
    ) -> BlockNumber;
    pub fn read_stream_reset(stream: *mut ReadStream);
    pub fn read_stream_end(stream: *mut ReadStream);
    pub static mut default_table_access_method: *mut ::core::ffi::c_char;
    pub static mut synchronize_seqscans: bool;
    pub fn table_slot_callbacks(relation: Relation) -> *const TupleTableSlotOps;
    pub fn table_slot_create(relation: Relation, reglist: *mut *mut List) -> *mut TupleTableSlot;
    pub fn table_beginscan_catalog(
        relation: Relation,
        nkeys: ::core::ffi::c_int,
        key: *mut ScanKeyData,
    ) -> TableScanDesc;
    pub fn table_parallelscan_estimate(rel: Relation, snapshot: Snapshot) -> Size;
    pub fn table_parallelscan_initialize(
        rel: Relation,
        pscan: ParallelTableScanDesc,
        snapshot: Snapshot,
    );
    pub fn table_beginscan_parallel(
        relation: Relation,
        pscan: ParallelTableScanDesc,
    ) -> TableScanDesc;
    pub fn table_index_fetch_tuple_check(
        rel: Relation,
        tid: ItemPointer,
        snapshot: Snapshot,
        all_dead: *mut bool,
    ) -> bool;
    pub fn table_tuple_get_latest_tid(scan: TableScanDesc, tid: ItemPointer);
    pub fn simple_table_tuple_insert(rel: Relation, slot: *mut TupleTableSlot);
    pub fn simple_table_tuple_delete(rel: Relation, tid: ItemPointer, snapshot: Snapshot);
    pub fn simple_table_tuple_update(
        rel: Relation,
        otid: ItemPointer,
        slot: *mut TupleTableSlot,
        snapshot: Snapshot,
        update_indexes: *mut TU_UpdateIndexes::Type,
    );
    pub fn table_block_parallelscan_estimate(rel: Relation) -> Size;
    pub fn table_block_parallelscan_initialize(rel: Relation, pscan: ParallelTableScanDesc)
        -> Size;
    pub fn table_block_parallelscan_reinitialize(rel: Relation, pscan: ParallelTableScanDesc);
    pub fn table_block_parallelscan_nextpage(
        rel: Relation,
        pbscanwork: ParallelBlockTableScanWorker,
        pbscan: ParallelBlockTableScanDesc,
    ) -> BlockNumber;
    pub fn table_block_parallelscan_startblock_init(
        rel: Relation,
        pbscanwork: ParallelBlockTableScanWorker,
        pbscan: ParallelBlockTableScanDesc,
    );
    pub fn table_block_relation_size(rel: Relation, forkNumber: ForkNumber::Type) -> uint64;
    pub fn table_block_relation_estimate_size(
        rel: Relation,
        attr_widths: *mut int32,
        pages: *mut BlockNumber,
        tuples: *mut f64,
        allvisfrac: *mut f64,
        overhead_bytes_per_tuple: Size,
        usable_bytes_per_page: Size,
    );
    pub fn GetTableAmRoutine(amhandler: Oid) -> *const TableAmRoutine;
    pub fn GetHeapamTableAmRoutine() -> *const TableAmRoutine;
    pub fn InitShmemAccess(seghdr: *mut ::core::ffi::c_void);
    pub fn InitShmemAllocation();
    pub fn ShmemAlloc(size: Size) -> *mut ::core::ffi::c_void;
    pub fn ShmemAllocNoError(size: Size) -> *mut ::core::ffi::c_void;
    pub fn ShmemAllocUnlocked(size: Size) -> *mut ::core::ffi::c_void;
    pub fn ShmemAddrIsValid(addr: *const ::core::ffi::c_void) -> bool;
    pub fn InitShmemIndex();
    pub fn ShmemInitHash(
        name: *const ::core::ffi::c_char,
        init_size: ::core::ffi::c_long,
        max_size: ::core::ffi::c_long,
        infoP: *mut HASHCTL,
        hash_flags: ::core::ffi::c_int,
    ) -> *mut HTAB;
    pub fn ShmemInitStruct(
        name: *const ::core::ffi::c_char,
        size: Size,
        foundPtr: *mut bool,
    ) -> *mut ::core::ffi::c_void;
    pub fn add_size(s1: Size, s2: Size) -> Size;
    pub fn mul_size(s1: Size, s2: Size) -> Size;
    pub fn RequestAddinShmemSpace(size: Size);
    pub fn shm_toc_create(
        magic: uint64,
        address: *mut ::core::ffi::c_void,
        nbytes: Size,
    ) -> *mut shm_toc;
    pub fn shm_toc_attach(magic: uint64, address: *mut ::core::ffi::c_void) -> *mut shm_toc;
    pub fn shm_toc_allocate(toc: *mut shm_toc, nbytes: Size) -> *mut ::core::ffi::c_void;
    pub fn shm_toc_freespace(toc: *mut shm_toc) -> Size;
    pub fn shm_toc_insert(toc: *mut shm_toc, key: uint64, address: *mut ::core::ffi::c_void);
    pub fn shm_toc_lookup(
        toc: *mut shm_toc,
        key: uint64,
        noError: bool,
    ) -> *mut ::core::ffi::c_void;
    pub fn shm_toc_estimate(e: *mut shm_toc_estimator) -> Size;
    pub fn heap_beginscan(
        relation: Relation,
        snapshot: Snapshot,
        nkeys: ::core::ffi::c_int,
        key: ScanKey,
        parallel_scan: ParallelTableScanDesc,
        flags: uint32,
    ) -> TableScanDesc;
    pub fn heap_setscanlimits(sscan: TableScanDesc, startBlk: BlockNumber, numBlks: BlockNumber);
    pub fn heap_prepare_pagescan(sscan: TableScanDesc);
    pub fn heap_rescan(
        sscan: TableScanDesc,
        key: ScanKey,
        set_params: bool,
        allow_strat: bool,
        allow_sync: bool,
        allow_pagemode: bool,
    );
    pub fn heap_endscan(sscan: TableScanDesc);
    pub fn heap_getnext(sscan: TableScanDesc, direction: ScanDirection::Type) -> HeapTuple;
    pub fn heap_getnextslot(
        sscan: TableScanDesc,
        direction: ScanDirection::Type,
        slot: *mut TupleTableSlot,
    ) -> bool;
    pub fn heap_set_tidrange(sscan: TableScanDesc, mintid: ItemPointer, maxtid: ItemPointer);
    pub fn heap_getnextslot_tidrange(
        sscan: TableScanDesc,
        direction: ScanDirection::Type,
        slot: *mut TupleTableSlot,
    ) -> bool;
    pub fn heap_fetch(
        relation: Relation,
        snapshot: Snapshot,
        tuple: HeapTuple,
        userbuf: *mut Buffer,
        keep_buf: bool,
    ) -> bool;
    pub fn heap_hot_search_buffer(
        tid: ItemPointer,
        relation: Relation,
        buffer: Buffer,
        snapshot: Snapshot,
        heapTuple: HeapTuple,
        all_dead: *mut bool,
        first_call: bool,
    ) -> bool;
    pub fn heap_get_latest_tid(sscan: TableScanDesc, tid: ItemPointer);
    pub fn GetBulkInsertState() -> BulkInsertState;
    pub fn FreeBulkInsertState(arg1: BulkInsertState);
    pub fn ReleaseBulkInsertStatePin(bistate: BulkInsertState);
    pub fn heap_insert(
        relation: Relation,
        tup: HeapTuple,
        cid: CommandId,
        options: ::core::ffi::c_int,
        bistate: BulkInsertState,
    );
    pub fn heap_multi_insert(
        relation: Relation,
        slots: *mut *mut TupleTableSlot,
        ntuples: ::core::ffi::c_int,
        cid: CommandId,
        options: ::core::ffi::c_int,
        bistate: BulkInsertState,
    );
    pub fn heap_delete(
        relation: Relation,
        tid: ItemPointer,
        cid: CommandId,
        crosscheck: Snapshot,
        wait: bool,
        tmfd: *mut TM_FailureData,
        changingPart: bool,
    ) -> TM_Result::Type;
    pub fn heap_finish_speculative(relation: Relation, tid: ItemPointer);
    pub fn heap_abort_speculative(relation: Relation, tid: ItemPointer);
    pub fn heap_update(
        relation: Relation,
        otid: ItemPointer,
        newtup: HeapTuple,
        cid: CommandId,
        crosscheck: Snapshot,
        wait: bool,
        tmfd: *mut TM_FailureData,
        lockmode: *mut LockTupleMode::Type,
        update_indexes: *mut TU_UpdateIndexes::Type,
    ) -> TM_Result::Type;
    pub fn heap_lock_tuple(
        relation: Relation,
        tuple: HeapTuple,
        cid: CommandId,
        mode: LockTupleMode::Type,
        wait_policy: LockWaitPolicy::Type,
        follow_updates: bool,
        buffer: *mut Buffer,
        tmfd: *mut TM_FailureData,
    ) -> TM_Result::Type;
    pub fn heap_inplace_lock(
        relation: Relation,
        oldtup_ptr: HeapTuple,
        buffer: Buffer,
        release_callback: ::core::option::Option<
            unsafe extern "C-unwind" fn(arg1: *mut ::core::ffi::c_void),
        >,
        arg: *mut ::core::ffi::c_void,
    ) -> bool;
    pub fn heap_inplace_update_and_unlock(
        relation: Relation,
        oldtup: HeapTuple,
        tuple: HeapTuple,
        buffer: Buffer,
    );
    pub fn heap_inplace_unlock(relation: Relation, oldtup: HeapTuple, buffer: Buffer);
    pub fn heap_inplace_update(relation: Relation, tuple: HeapTuple);
    pub fn heap_prepare_freeze_tuple(
        tuple: HeapTupleHeader,
        cutoffs: *const VacuumCutoffs,
        pagefrz: *mut HeapPageFreeze,
        frz: *mut HeapTupleFreeze,
        totally_frozen: *mut bool,
    ) -> bool;
    pub fn heap_pre_freeze_checks(
        buffer: Buffer,
        tuples: *mut HeapTupleFreeze,
        ntuples: ::core::ffi::c_int,
    );
    pub fn heap_freeze_prepared_tuples(
        buffer: Buffer,
        tuples: *mut HeapTupleFreeze,
        ntuples: ::core::ffi::c_int,
    );
    pub fn heap_freeze_tuple(
        tuple: HeapTupleHeader,
        relfrozenxid: TransactionId,
        relminmxid: TransactionId,
        FreezeLimit: TransactionId,
        MultiXactCutoff: TransactionId,
    ) -> bool;
    pub fn heap_tuple_should_freeze(
        tuple: HeapTupleHeader,
        cutoffs: *const VacuumCutoffs,
        NoFreezePageRelfrozenXid: *mut TransactionId,
        NoFreezePageRelminMxid: *mut MultiXactId,
    ) -> bool;
    pub fn heap_tuple_needs_eventual_freeze(tuple: HeapTupleHeader) -> bool;
    pub fn simple_heap_insert(relation: Relation, tup: HeapTuple);
    pub fn simple_heap_delete(relation: Relation, tid: ItemPointer);
    pub fn simple_heap_update(
        relation: Relation,
        otid: ItemPointer,
        tup: HeapTuple,
        update_indexes: *mut TU_UpdateIndexes::Type,
    );
    pub fn heap_index_delete_tuples(
        rel: Relation,
        delstate: *mut TM_IndexDeleteOp,
    ) -> TransactionId;
    pub fn heap_page_prune_opt(relation: Relation, buffer: Buffer);
    pub fn heap_page_prune_and_freeze(
        relation: Relation,
        buffer: Buffer,
        vistest: *mut GlobalVisState,
        options: ::core::ffi::c_int,
        cutoffs: *mut VacuumCutoffs,
        presult: *mut PruneFreezeResult,
        reason: PruneReason::Type,
        off_loc: *mut OffsetNumber,
        new_relfrozen_xid: *mut TransactionId,
        new_relmin_mxid: *mut MultiXactId,
    );
    pub fn heap_page_prune_execute(
        buffer: Buffer,
        lp_truncate_only: bool,
        redirected: *mut OffsetNumber,
        nredirected: ::core::ffi::c_int,
        nowdead: *mut OffsetNumber,
        ndead: ::core::ffi::c_int,
        nowunused: *mut OffsetNumber,
        nunused: ::core::ffi::c_int,
    );
    pub fn heap_get_root_tuples(page: Page, root_offsets: *mut OffsetNumber);
    pub fn log_heap_prune_and_freeze(
        relation: Relation,
        buffer: Buffer,
        conflict_xid: TransactionId,
        cleanup_lock: bool,
        reason: PruneReason::Type,
        frozen: *mut HeapTupleFreeze,
        nfrozen: ::core::ffi::c_int,
        redirected: *mut OffsetNumber,
        nredirected: ::core::ffi::c_int,
        dead: *mut OffsetNumber,
        ndead: ::core::ffi::c_int,
        unused: *mut OffsetNumber,
        nunused: ::core::ffi::c_int,
    );
    pub fn heap_vacuum_rel(
        rel: Relation,
        params: *mut VacuumParams,
        bstrategy: BufferAccessStrategy,
    );
    pub fn HeapTupleSatisfiesVisibility(
        htup: HeapTuple,
        snapshot: Snapshot,
        buffer: Buffer,
    ) -> bool;
    pub fn HeapTupleSatisfiesUpdate(
        htup: HeapTuple,
        curcid: CommandId,
        buffer: Buffer,
    ) -> TM_Result::Type;
    pub fn HeapTupleSatisfiesVacuum(
        htup: HeapTuple,
        OldestXmin: TransactionId,
        buffer: Buffer,
    ) -> HTSV_Result::Type;
    pub fn HeapTupleSatisfiesVacuumHorizon(
        htup: HeapTuple,
        buffer: Buffer,
        dead_after: *mut TransactionId,
    ) -> HTSV_Result::Type;
    pub fn HeapTupleSetHintBits(
        tuple: HeapTupleHeader,
        buffer: Buffer,
        infomask: uint16,
        xid: TransactionId,
    );
    pub fn HeapTupleHeaderIsOnlyLocked(tuple: HeapTupleHeader) -> bool;
    pub fn HeapTupleIsSurelyDead(htup: HeapTuple, vistest: *mut GlobalVisState) -> bool;
    pub fn ResolveCminCmaxDuringDecoding(
        tuplecid_data: *mut HTAB,
        snapshot: Snapshot,
        htup: HeapTuple,
        buffer: Buffer,
        cmin: *mut CommandId,
        cmax: *mut CommandId,
    ) -> bool;
    pub fn HeapCheckForSerializableConflictOut(
        visible: bool,
        relation: Relation,
        tuple: HeapTuple,
        buffer: Buffer,
        snapshot: Snapshot,
    );
    pub fn InitSync();
    pub fn SyncPreCheckpoint();
    pub fn SyncPostCheckpoint();
    pub fn ProcessSyncRequests();
    pub fn RememberSyncRequest(ftag: *const FileTag, type_: SyncRequestType::Type);
    pub fn RegisterSyncRequest(
        ftag: *const FileTag,
        type_: SyncRequestType::Type,
        retryOnError: bool,
    ) -> bool;
    pub fn MultiXactIdCreate(
        xid1: TransactionId,
        status1: MultiXactStatus::Type,
        xid2: TransactionId,
        status2: MultiXactStatus::Type,
    ) -> MultiXactId;
    pub fn MultiXactIdExpand(
        multi: MultiXactId,
        xid: TransactionId,
        status: MultiXactStatus::Type,
    ) -> MultiXactId;
    pub fn MultiXactIdCreateFromMembers(
        nmembers: ::core::ffi::c_int,
        members: *mut MultiXactMember,
    ) -> MultiXactId;
    pub fn ReadNextMultiXactId() -> MultiXactId;
    pub fn ReadMultiXactIdRange(oldest: *mut MultiXactId, next: *mut MultiXactId);
    pub fn MultiXactIdIsRunning(multi: MultiXactId, isLockOnly: bool) -> bool;
    pub fn MultiXactIdSetOldestMember();
    pub fn GetMultiXactIdMembers(
        multi: MultiXactId,
        members: *mut *mut MultiXactMember,
        from_pgupgrade: bool,
        isLockOnly: bool,
    ) -> ::core::ffi::c_int;
    pub fn MultiXactIdPrecedes(multi1: MultiXactId, multi2: MultiXactId) -> bool;
    pub fn MultiXactIdPrecedesOrEquals(multi1: MultiXactId, multi2: MultiXactId) -> bool;
    pub fn multixactoffsetssyncfiletag(
        ftag: *const FileTag,
        path: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn multixactmemberssyncfiletag(
        ftag: *const FileTag,
        path: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn AtEOXact_MultiXact();
    pub fn AtPrepare_MultiXact();
    pub fn PostPrepare_MultiXact(xid: TransactionId);
    pub fn MultiXactShmemSize() -> Size;
    pub fn MultiXactShmemInit();
    pub fn BootStrapMultiXact();
    pub fn StartupMultiXact();
    pub fn TrimMultiXact();
    pub fn SetMultiXactIdLimit(
        oldest_datminmxid: MultiXactId,
        oldest_datoid: Oid,
        is_startup: bool,
    );
    pub fn MultiXactGetCheckptMulti(
        is_shutdown: bool,
        nextMulti: *mut MultiXactId,
        nextMultiOffset: *mut MultiXactOffset,
        oldestMulti: *mut MultiXactId,
        oldestMultiDB: *mut Oid,
    );
    pub fn CheckPointMultiXact();
    pub fn GetOldestMultiXactId() -> MultiXactId;
    pub fn TruncateMultiXact(newOldestMulti: MultiXactId, newOldestMultiDB: Oid);
    pub fn MultiXactSetNextMXact(nextMulti: MultiXactId, nextMultiOffset: MultiXactOffset);
    pub fn MultiXactAdvanceNextMXact(minMulti: MultiXactId, minMultiOffset: MultiXactOffset);
    pub fn MultiXactAdvanceOldest(oldestMulti: MultiXactId, oldestMultiDB: Oid);
    pub fn MultiXactMemberFreezeThreshold() -> ::core::ffi::c_int;
    pub fn multixact_twophase_recover(
        xid: TransactionId,
        info: uint16,
        recdata: *mut ::core::ffi::c_void,
        len: uint32,
    );
    pub fn multixact_twophase_postcommit(
        xid: TransactionId,
        info: uint16,
        recdata: *mut ::core::ffi::c_void,
        len: uint32,
    );
    pub fn multixact_twophase_postabort(
        xid: TransactionId,
        info: uint16,
        recdata: *mut ::core::ffi::c_void,
        len: uint32,
    );
    pub fn multixact_redo(record: *mut XLogReaderState);
    pub fn multixact_desc(buf: StringInfo, record: *mut XLogReaderState);
    pub fn multixact_identify(info: uint8) -> *const ::core::ffi::c_char;
    pub fn mxid_to_string(
        multi: MultiXactId,
        nmembers: ::core::ffi::c_int,
        members: *mut MultiXactMember,
    ) -> *mut ::core::ffi::c_char;
    pub static mut MainLWLockArray: *mut LWLockPadded;
    pub static mut NamedLWLockTrancheArray: *mut NamedLWLockTranche;
    pub static mut NamedLWLockTrancheRequests: ::core::ffi::c_int;
    pub fn LWLockAcquire(lock: *mut LWLock, mode: LWLockMode::Type) -> bool;
    pub fn LWLockConditionalAcquire(lock: *mut LWLock, mode: LWLockMode::Type) -> bool;
    pub fn LWLockAcquireOrWait(lock: *mut LWLock, mode: LWLockMode::Type) -> bool;
    pub fn LWLockRelease(lock: *mut LWLock);
    pub fn LWLockReleaseClearVar(lock: *mut LWLock, valptr: *mut pg_atomic_uint64, val: uint64);
    pub fn LWLockReleaseAll();
    pub fn LWLockHeldByMe(lock: *mut LWLock) -> bool;
    pub fn LWLockAnyHeldByMe(lock: *mut LWLock, nlocks: ::core::ffi::c_int, stride: usize) -> bool;
    pub fn LWLockHeldByMeInMode(lock: *mut LWLock, mode: LWLockMode::Type) -> bool;
    pub fn LWLockWaitForVar(
        lock: *mut LWLock,
        valptr: *mut pg_atomic_uint64,
        oldval: uint64,
        newval: *mut uint64,
    ) -> bool;
    pub fn LWLockUpdateVar(lock: *mut LWLock, valptr: *mut pg_atomic_uint64, val: uint64);
    pub fn LWLockShmemSize() -> Size;
    pub fn CreateLWLocks();
    pub fn InitLWLockAccess();
    pub fn GetLWLockIdentifier(classId: uint32, eventId: uint16) -> *const ::core::ffi::c_char;
    pub fn RequestNamedLWLockTranche(
        tranche_name: *const ::core::ffi::c_char,
        num_lwlocks: ::core::ffi::c_int,
    );
    pub fn GetNamedLWLockTranche(tranche_name: *const ::core::ffi::c_char) -> *mut LWLockPadded;
    pub fn LWLockNewTrancheId() -> ::core::ffi::c_int;
    pub fn LWLockRegisterTranche(
        tranche_id: ::core::ffi::c_int,
        tranche_name: *const ::core::ffi::c_char,
    );
    pub fn LWLockInitialize(lock: *mut LWLock, tranche_id: ::core::ffi::c_int);
    pub static mut PgStartTime: TimestampTz;
    pub static mut PgReloadTime: TimestampTz;
    pub fn anytimestamp_typmod_check(istz: bool, typmod: int32) -> int32;
    pub fn GetCurrentTimestamp() -> TimestampTz;
    pub fn GetSQLCurrentTimestamp(typmod: int32) -> TimestampTz;
    pub fn GetSQLLocalTimestamp(typmod: int32) -> Timestamp;
    pub fn TimestampDifference(
        start_time: TimestampTz,
        stop_time: TimestampTz,
        secs: *mut ::core::ffi::c_long,
        microsecs: *mut ::core::ffi::c_int,
    );
    pub fn TimestampDifferenceMilliseconds(
        start_time: TimestampTz,
        stop_time: TimestampTz,
    ) -> ::core::ffi::c_long;
    pub fn TimestampDifferenceExceeds(
        start_time: TimestampTz,
        stop_time: TimestampTz,
        msec: ::core::ffi::c_int,
    ) -> bool;
    pub fn time_t_to_timestamptz(tm: pg_time_t) -> TimestampTz;
    pub fn timestamptz_to_time_t(t: TimestampTz) -> pg_time_t;
    pub fn timestamptz_to_str(t: TimestampTz) -> *const ::core::ffi::c_char;
    pub fn tm2timestamp(
        tm: *mut pg_tm,
        fsec: fsec_t,
        tzp: *mut ::core::ffi::c_int,
        result: *mut Timestamp,
    ) -> ::core::ffi::c_int;
    pub fn timestamp2tm(
        dt: Timestamp,
        tzp: *mut ::core::ffi::c_int,
        tm: *mut pg_tm,
        fsec: *mut fsec_t,
        tzn: *mut *const ::core::ffi::c_char,
        attimezone: *mut pg_tz,
    ) -> ::core::ffi::c_int;
    pub fn dt2time(
        jd: Timestamp,
        hour: *mut ::core::ffi::c_int,
        min: *mut ::core::ffi::c_int,
        sec: *mut ::core::ffi::c_int,
        fsec: *mut fsec_t,
    );
    pub fn interval2itm(span: Interval, itm: *mut pg_itm);
    pub fn itm2interval(itm: *mut pg_itm, span: *mut Interval) -> ::core::ffi::c_int;
    pub fn itmin2interval(itm_in: *mut pg_itm_in, span: *mut Interval) -> ::core::ffi::c_int;
    pub fn SetEpochTimestamp() -> Timestamp;
    pub fn GetEpochTime(tm: *mut pg_tm);
    pub fn timestamp_cmp_internal(dt1: Timestamp, dt2: Timestamp) -> ::core::ffi::c_int;
    pub fn timestamp2timestamptz_opt_overflow(
        timestamp: Timestamp,
        overflow: *mut ::core::ffi::c_int,
    ) -> TimestampTz;
    pub fn timestamp_cmp_timestamptz_internal(timestampVal: Timestamp, dt2: TimestampTz) -> int32;
    pub fn isoweek2j(year: ::core::ffi::c_int, week: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn isoweek2date(
        woy: ::core::ffi::c_int,
        year: *mut ::core::ffi::c_int,
        mon: *mut ::core::ffi::c_int,
        mday: *mut ::core::ffi::c_int,
    );
    pub fn isoweekdate2date(
        isoweek: ::core::ffi::c_int,
        wday: ::core::ffi::c_int,
        year: *mut ::core::ffi::c_int,
        mon: *mut ::core::ffi::c_int,
        mday: *mut ::core::ffi::c_int,
    );
    pub fn date2isoweek(
        year: ::core::ffi::c_int,
        mon: ::core::ffi::c_int,
        mday: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn date2isoyear(
        year: ::core::ffi::c_int,
        mon: ::core::ffi::c_int,
        mday: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn date2isoyearday(
        year: ::core::ffi::c_int,
        mon: ::core::ffi::c_int,
        mday: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn TimestampTimestampTzRequiresRewrite() -> bool;
    pub static mut max_locks_per_xact: ::core::ffi::c_int;
    pub static LockTagTypeNames: [*const ::core::ffi::c_char; 0usize];
    pub fn InitLocks();
    pub fn GetLocksMethodTable(lock: *const LOCK) -> LockMethod;
    pub fn GetLockTagsMethodTable(locktag: *const LOCKTAG) -> LockMethod;
    pub fn LockTagHashCode(locktag: *const LOCKTAG) -> uint32;
    pub fn DoLockModesConflict(mode1: LOCKMODE, mode2: LOCKMODE) -> bool;
    pub fn LockAcquire(
        locktag: *const LOCKTAG,
        lockmode: LOCKMODE,
        sessionLock: bool,
        dontWait: bool,
    ) -> LockAcquireResult::Type;
    pub fn LockAcquireExtended(
        locktag: *const LOCKTAG,
        lockmode: LOCKMODE,
        sessionLock: bool,
        dontWait: bool,
        reportMemoryError: bool,
        locallockp: *mut *mut LOCALLOCK,
    ) -> LockAcquireResult::Type;
    pub fn AbortStrongLockAcquire();
    pub fn MarkLockClear(locallock: *mut LOCALLOCK);
    pub fn LockRelease(locktag: *const LOCKTAG, lockmode: LOCKMODE, sessionLock: bool) -> bool;
    pub fn LockReleaseAll(lockmethodid: LOCKMETHODID, allLocks: bool);
    pub fn LockReleaseSession(lockmethodid: LOCKMETHODID);
    pub fn LockReleaseCurrentOwner(locallocks: *mut *mut LOCALLOCK, nlocks: ::core::ffi::c_int);
    pub fn LockReassignCurrentOwner(locallocks: *mut *mut LOCALLOCK, nlocks: ::core::ffi::c_int);
    pub fn LockHeldByMe(locktag: *const LOCKTAG, lockmode: LOCKMODE, orstronger: bool) -> bool;
    pub fn GetLockMethodLocalHash() -> *mut HTAB;
    pub fn LockHasWaiters(locktag: *const LOCKTAG, lockmode: LOCKMODE, sessionLock: bool) -> bool;
    pub fn GetLockConflicts(
        locktag: *const LOCKTAG,
        lockmode: LOCKMODE,
        countp: *mut ::core::ffi::c_int,
    ) -> *mut VirtualTransactionId;
    pub fn AtPrepare_Locks();
    pub fn PostPrepare_Locks(xid: TransactionId);
    pub fn LockCheckConflicts(
        lockMethodTable: LockMethod,
        lockmode: LOCKMODE,
        lock: *mut LOCK,
        proclock: *mut PROCLOCK,
    ) -> bool;
    pub fn GrantLock(lock: *mut LOCK, proclock: *mut PROCLOCK, lockmode: LOCKMODE);
    pub fn GrantAwaitedLock();
    pub fn RemoveFromWaitQueue(proc_: *mut PGPROC, hashcode: uint32);
    pub fn LockShmemSize() -> Size;
    pub fn GetLockStatusData() -> *mut LockData;
    pub fn GetBlockerStatusData(blocked_pid: ::core::ffi::c_int) -> *mut BlockedProcsData;
    pub fn GetRunningTransactionLocks(nlocks: *mut ::core::ffi::c_int) -> *mut xl_standby_lock;
    pub fn GetLockmodeName(
        lockmethodid: LOCKMETHODID,
        mode: LOCKMODE,
    ) -> *const ::core::ffi::c_char;
    pub fn lock_twophase_recover(
        xid: TransactionId,
        info: uint16,
        recdata: *mut ::core::ffi::c_void,
        len: uint32,
    );
    pub fn lock_twophase_postcommit(
        xid: TransactionId,
        info: uint16,
        recdata: *mut ::core::ffi::c_void,
        len: uint32,
    );
    pub fn lock_twophase_postabort(
        xid: TransactionId,
        info: uint16,
        recdata: *mut ::core::ffi::c_void,
        len: uint32,
    );
    pub fn lock_twophase_standby_recover(
        xid: TransactionId,
        info: uint16,
        recdata: *mut ::core::ffi::c_void,
        len: uint32,
    );
    pub fn DeadLockCheck(proc_: *mut PGPROC) -> DeadLockState::Type;
    pub fn GetBlockingAutoVacuumPgproc() -> *mut PGPROC;
    pub fn DeadLockReport() -> !;
    pub fn RememberSimpleDeadLock(
        proc1: *mut PGPROC,
        lockmode: LOCKMODE,
        lock: *mut LOCK,
        proc2: *mut PGPROC,
    );
    pub fn InitDeadLockChecking();
    pub fn LockWaiterCount(locktag: *const LOCKTAG) -> ::core::ffi::c_int;
    pub fn VirtualXactLockTableInsert(vxid: VirtualTransactionId);
    pub fn VirtualXactLockTableCleanup();
    pub fn VirtualXactLock(vxid: VirtualTransactionId, wait: bool) -> bool;
    pub fn add_reloption_kind() -> relopt_kind::Type;
    pub fn add_bool_reloption(
        kinds: bits32,
        name: *const ::core::ffi::c_char,
        desc: *const ::core::ffi::c_char,
        default_val: bool,
        lockmode: LOCKMODE,
    );
    pub fn add_int_reloption(
        kinds: bits32,
        name: *const ::core::ffi::c_char,
        desc: *const ::core::ffi::c_char,
        default_val: ::core::ffi::c_int,
        min_val: ::core::ffi::c_int,
        max_val: ::core::ffi::c_int,
        lockmode: LOCKMODE,
    );
    pub fn add_real_reloption(
        kinds: bits32,
        name: *const ::core::ffi::c_char,
        desc: *const ::core::ffi::c_char,
        default_val: f64,
        min_val: f64,
        max_val: f64,
        lockmode: LOCKMODE,
    );
    pub fn add_enum_reloption(
        kinds: bits32,
        name: *const ::core::ffi::c_char,
        desc: *const ::core::ffi::c_char,
        members: *mut relopt_enum_elt_def,
        default_val: ::core::ffi::c_int,
        detailmsg: *const ::core::ffi::c_char,
        lockmode: LOCKMODE,
    );
    pub fn add_string_reloption(
        kinds: bits32,
        name: *const ::core::ffi::c_char,
        desc: *const ::core::ffi::c_char,
        default_val: *const ::core::ffi::c_char,
        validator: validate_string_relopt,
        lockmode: LOCKMODE,
    );
    pub fn init_local_reloptions(relopts: *mut local_relopts, relopt_struct_size: Size);
    pub fn register_reloptions_validator(relopts: *mut local_relopts, validator: relopts_validator);
    pub fn add_local_bool_reloption(
        relopts: *mut local_relopts,
        name: *const ::core::ffi::c_char,
        desc: *const ::core::ffi::c_char,
        default_val: bool,
        offset: ::core::ffi::c_int,
    );
    pub fn add_local_int_reloption(
        relopts: *mut local_relopts,
        name: *const ::core::ffi::c_char,
        desc: *const ::core::ffi::c_char,
        default_val: ::core::ffi::c_int,
        min_val: ::core::ffi::c_int,
        max_val: ::core::ffi::c_int,
        offset: ::core::ffi::c_int,
    );
    pub fn add_local_real_reloption(
        relopts: *mut local_relopts,
        name: *const ::core::ffi::c_char,
        desc: *const ::core::ffi::c_char,
        default_val: f64,
        min_val: f64,
        max_val: f64,
        offset: ::core::ffi::c_int,
    );
    pub fn add_local_enum_reloption(
        relopts: *mut local_relopts,
        name: *const ::core::ffi::c_char,
        desc: *const ::core::ffi::c_char,
        members: *mut relopt_enum_elt_def,
        default_val: ::core::ffi::c_int,
        detailmsg: *const ::core::ffi::c_char,
        offset: ::core::ffi::c_int,
    );
    pub fn add_local_string_reloption(
        relopts: *mut local_relopts,
        name: *const ::core::ffi::c_char,
        desc: *const ::core::ffi::c_char,
        default_val: *const ::core::ffi::c_char,
        validator: validate_string_relopt,
        filler: fill_string_relopt,
        offset: ::core::ffi::c_int,
    );
    pub fn transformRelOptions(
        oldOptions: Datum,
        defList: *mut List,
        namspace: *const ::core::ffi::c_char,
        validnsps: *mut *mut ::core::ffi::c_char,
        acceptOidsOff: bool,
        isReset: bool,
    ) -> Datum;
    pub fn untransformRelOptions(options: Datum) -> *mut List;
    pub fn extractRelOptions(
        tuple: HeapTuple,
        tupdesc: TupleDesc,
        amoptions: amoptions_function,
    ) -> *mut bytea;
    pub fn build_reloptions(
        reloptions: Datum,
        validate: bool,
        kind: relopt_kind::Type,
        relopt_struct_size: Size,
        relopt_elems: *const relopt_parse_elt,
        num_relopt_elems: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn build_local_reloptions(
        relopts: *mut local_relopts,
        options: Datum,
        validate: bool,
    ) -> *mut ::core::ffi::c_void;
    pub fn default_reloptions(
        reloptions: Datum,
        validate: bool,
        kind: relopt_kind::Type,
    ) -> *mut bytea;
    pub fn heap_reloptions(
        relkind: ::core::ffi::c_char,
        reloptions: Datum,
        validate: bool,
    ) -> *mut bytea;
    pub fn view_reloptions(reloptions: Datum, validate: bool) -> *mut bytea;
    pub fn partitioned_table_reloptions(reloptions: Datum, validate: bool) -> *mut bytea;
    pub fn index_reloptions(
        amoptions: amoptions_function,
        reloptions: Datum,
        validate: bool,
    ) -> *mut bytea;
    pub fn attribute_reloptions(reloptions: Datum, validate: bool) -> *mut bytea;
    pub fn tablespace_reloptions(reloptions: Datum, validate: bool) -> *mut bytea;
    pub fn AlterTableGetRelOptionsLockLevel(defList: *mut List) -> LOCKMODE;
    pub fn visibilitymap_clear(
        rel: Relation,
        heapBlk: BlockNumber,
        vmbuf: Buffer,
        flags: uint8,
    ) -> bool;
    pub fn visibilitymap_pin(rel: Relation, heapBlk: BlockNumber, vmbuf: *mut Buffer);
    pub fn visibilitymap_pin_ok(heapBlk: BlockNumber, vmbuf: Buffer) -> bool;
    pub fn visibilitymap_set(
        rel: Relation,
        heapBlk: BlockNumber,
        heapBuf: Buffer,
        recptr: XLogRecPtr,
        vmBuf: Buffer,
        cutoff_xid: TransactionId,
        flags: uint8,
    );
    pub fn visibilitymap_get_status(
        rel: Relation,
        heapBlk: BlockNumber,
        vmbuf: *mut Buffer,
    ) -> uint8;
    pub fn visibilitymap_count(
        rel: Relation,
        all_visible: *mut BlockNumber,
        all_frozen: *mut BlockNumber,
    );
    pub fn visibilitymap_prepare_truncate(rel: Relation, nheapblocks: BlockNumber) -> BlockNumber;
    pub static mut RmgrTable: [RmgrData; 0usize];
    pub fn RmgrStartup();
    pub fn RmgrCleanup();
    pub fn RmgrNotFound(rmid: RmgrId);
    pub fn RegisterCustomRmgr(rmid: RmgrId, rmgr: *const RmgrData);
    pub fn GetLastSegSwitchData(lastSwitchLSN: *mut XLogRecPtr) -> pg_time_t;
    pub fn RequestXLogSwitch(mark_unimportant: bool) -> XLogRecPtr;
    pub fn GetOldestRestartPoint(oldrecptr: *mut XLogRecPtr, oldtli: *mut TimeLineID);
    pub fn XLogRecGetBlockRefInfo(
        record: *mut XLogReaderState,
        pretty: bool,
        detailed_format: bool,
        buf: StringInfo,
        fpi_len: *mut uint32,
    );
    pub static mut ArchiveRecoveryRequested: bool;
    pub static mut InArchiveRecovery: bool;
    pub static mut StandbyMode: bool;
    pub static mut recoveryRestoreCommand: *mut ::core::ffi::c_char;
    pub static mut recoveryTargetInclusive: bool;
    pub static mut recoveryTargetAction: ::core::ffi::c_int;
    pub static mut recovery_min_apply_delay: ::core::ffi::c_int;
    pub static mut PrimaryConnInfo: *mut ::core::ffi::c_char;
    pub static mut PrimarySlotName: *mut ::core::ffi::c_char;
    pub static mut recoveryEndCommand: *mut ::core::ffi::c_char;
    pub static mut archiveCleanupCommand: *mut ::core::ffi::c_char;
    pub static mut recoveryTargetXid: TransactionId;
    pub static mut recovery_target_time_string: *mut ::core::ffi::c_char;
    pub static mut recoveryTargetTime: TimestampTz;
    pub static mut recoveryTargetName: *const ::core::ffi::c_char;
    pub static mut recoveryTargetLSN: XLogRecPtr;
    pub static mut recoveryTarget: RecoveryTargetType::Type;
    pub static mut wal_receiver_create_temp_slot: bool;
    pub static mut recoveryTargetTimeLineGoal: RecoveryTargetTimeLineGoal::Type;
    pub static mut recoveryTargetTLIRequested: TimeLineID;
    pub static mut recoveryTargetTLI: TimeLineID;
    pub static mut reachedConsistency: bool;
    pub fn XLogRecoveryShmemSize() -> Size;
    pub fn XLogRecoveryShmemInit();
    pub fn InitWalRecovery(
        ControlFile: *mut ControlFileData,
        wasShutdown_ptr: *mut bool,
        haveBackupLabel_ptr: *mut bool,
        haveTblspcMap_ptr: *mut bool,
    );
    pub fn PerformWalRecovery();
    pub fn FinishWalRecovery() -> *mut EndOfWalRecoveryInfo;
    pub fn ShutdownWalRecovery();
    pub fn RemovePromoteSignalFiles();
    pub fn HotStandbyActive() -> bool;
    pub fn GetXLogReplayRecPtr(replayTLI: *mut TimeLineID) -> XLogRecPtr;
    pub fn GetRecoveryPauseState() -> RecoveryPauseState::Type;
    pub fn SetRecoveryPause(recoveryPause: bool);
    pub fn GetXLogReceiptTime(rtime: *mut TimestampTz, fromStream: *mut bool);
    pub fn GetLatestXTime() -> TimestampTz;
    pub fn GetCurrentChunkReplayStartTime() -> TimestampTz;
    pub fn GetCurrentReplayRecPtr(replayEndTLI: *mut TimeLineID) -> XLogRecPtr;
    pub fn PromoteIsTriggered() -> bool;
    pub fn CheckPromoteSignal() -> bool;
    pub fn WakeupRecovery();
    pub fn StartupRequestWalReceiverRestart();
    pub fn XLogRequestWalReceiverReply();
    pub fn RecoveryRequiresIntParameter(
        param_name: *const ::core::ffi::c_char,
        currValue: ::core::ffi::c_int,
        minValue: ::core::ffi::c_int,
    );
    pub fn xlog_outdesc(buf: StringInfo, record: *mut XLogReaderState);
    pub static mut InRecovery: bool;
    pub static mut standbyState: HotStandbyState::Type;
    pub fn XLogHaveInvalidPages() -> bool;
    pub fn XLogCheckInvalidPages();
    pub fn XLogDropRelation(rlocator: RelFileLocator, forknum: ForkNumber::Type);
    pub fn XLogDropDatabase(dbid: Oid);
    pub fn XLogTruncateRelation(
        rlocator: RelFileLocator,
        forkNum: ForkNumber::Type,
        nblocks: BlockNumber,
    );
    pub fn XLogReadBufferForRedo(
        record: *mut XLogReaderState,
        block_id: uint8,
        buf: *mut Buffer,
    ) -> XLogRedoAction::Type;
    pub fn XLogInitBufferForRedo(record: *mut XLogReaderState, block_id: uint8) -> Buffer;
    pub fn XLogReadBufferForRedoExtended(
        record: *mut XLogReaderState,
        block_id: uint8,
        mode: ReadBufferMode::Type,
        get_cleanup_lock: bool,
        buf: *mut Buffer,
    ) -> XLogRedoAction::Type;
    pub fn XLogReadBufferExtended(
        rlocator: RelFileLocator,
        forknum: ForkNumber::Type,
        blkno: BlockNumber,
        mode: ReadBufferMode::Type,
        recent_buffer: Buffer,
    ) -> Buffer;
    pub fn CreateFakeRelcacheEntry(rlocator: RelFileLocator) -> Relation;
    pub fn FreeFakeRelcacheEntry(fakerel: Relation);
    pub fn read_local_xlog_page(
        state: *mut XLogReaderState,
        targetPagePtr: XLogRecPtr,
        reqLen: ::core::ffi::c_int,
        targetRecPtr: XLogRecPtr,
        cur_page: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn read_local_xlog_page_no_wait(
        state: *mut XLogReaderState,
        targetPagePtr: XLogRecPtr,
        reqLen: ::core::ffi::c_int,
        targetRecPtr: XLogRecPtr,
        cur_page: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn wal_segment_open(
        state: *mut XLogReaderState,
        nextSegNo: XLogSegNo,
        tli_p: *mut TimeLineID,
    );
    pub fn wal_segment_close(state: *mut XLogReaderState);
    pub fn XLogReadDetermineTimeline(
        state: *mut XLogReaderState,
        wantPage: XLogRecPtr,
        wantLength: uint32,
        currTLI: TimeLineID,
    );
    pub fn WALReadRaiseError(errinfo: *mut WALReadError);
    pub fn AcquireDeletionLock(object: *const ObjectAddress, flags: ::core::ffi::c_int);
    pub fn ReleaseDeletionLock(object: *const ObjectAddress);
    pub fn performDeletion(
        object: *const ObjectAddress,
        behavior: DropBehavior::Type,
        flags: ::core::ffi::c_int,
    );
    pub fn performMultipleDeletions(
        objects: *const ObjectAddresses,
        behavior: DropBehavior::Type,
        flags: ::core::ffi::c_int,
    );
    pub fn recordDependencyOnExpr(
        depender: *const ObjectAddress,
        expr: *mut Node,
        rtable: *mut List,
        behavior: DependencyType::Type,
    );
    pub fn recordDependencyOnSingleRelExpr(
        depender: *const ObjectAddress,
        expr: *mut Node,
        relId: Oid,
        behavior: DependencyType::Type,
        self_behavior: DependencyType::Type,
        reverse_self: bool,
    );
    pub fn new_object_addresses() -> *mut ObjectAddresses;
    pub fn add_exact_object_address(object: *const ObjectAddress, addrs: *mut ObjectAddresses);
    pub fn object_address_present(
        object: *const ObjectAddress,
        addrs: *const ObjectAddresses,
    ) -> bool;
    pub fn record_object_address_dependencies(
        depender: *const ObjectAddress,
        referenced: *mut ObjectAddresses,
        behavior: DependencyType::Type,
    );
    pub fn sort_object_addresses(addrs: *mut ObjectAddresses);
    pub fn free_object_addresses(addrs: *mut ObjectAddresses);
    pub fn recordDependencyOn(
        depender: *const ObjectAddress,
        referenced: *const ObjectAddress,
        behavior: DependencyType::Type,
    );
    pub fn recordMultipleDependencies(
        depender: *const ObjectAddress,
        referenced: *const ObjectAddress,
        nreferenced: ::core::ffi::c_int,
        behavior: DependencyType::Type,
    );
    pub fn recordDependencyOnCurrentExtension(object: *const ObjectAddress, isReplace: bool);
    pub fn checkMembershipInCurrentExtension(object: *const ObjectAddress);
    pub fn deleteDependencyRecordsFor(
        classId: Oid,
        objectId: Oid,
        skipExtensionDeps: bool,
    ) -> ::core::ffi::c_long;
    pub fn deleteDependencyRecordsForClass(
        classId: Oid,
        objectId: Oid,
        refclassId: Oid,
        deptype: ::core::ffi::c_char,
    ) -> ::core::ffi::c_long;
    pub fn deleteDependencyRecordsForSpecific(
        classId: Oid,
        objectId: Oid,
        deptype: ::core::ffi::c_char,
        refclassId: Oid,
        refobjectId: Oid,
    ) -> ::core::ffi::c_long;
    pub fn changeDependencyFor(
        classId: Oid,
        objectId: Oid,
        refClassId: Oid,
        oldRefObjectId: Oid,
        newRefObjectId: Oid,
    ) -> ::core::ffi::c_long;
    pub fn changeDependenciesOf(
        classId: Oid,
        oldObjectId: Oid,
        newObjectId: Oid,
    ) -> ::core::ffi::c_long;
    pub fn changeDependenciesOn(
        refClassId: Oid,
        oldRefObjectId: Oid,
        newRefObjectId: Oid,
    ) -> ::core::ffi::c_long;
    pub fn getExtensionOfObject(classId: Oid, objectId: Oid) -> Oid;
    pub fn getAutoExtensionsOfObject(classId: Oid, objectId: Oid) -> *mut List;
    pub fn sequenceIsOwned(
        seqId: Oid,
        deptype: ::core::ffi::c_char,
        tableId: *mut Oid,
        colId: *mut int32,
    ) -> bool;
    pub fn getOwnedSequences(relid: Oid) -> *mut List;
    pub fn getIdentitySequence(rel: Relation, attnum: AttrNumber, missing_ok: bool) -> Oid;
    pub fn get_index_constraint(indexId: Oid) -> Oid;
    pub fn get_index_ref_constraints(indexId: Oid) -> *mut List;
    pub fn recordSharedDependencyOn(
        depender: *mut ObjectAddress,
        referenced: *mut ObjectAddress,
        deptype: SharedDependencyType::Type,
    );
    pub fn deleteSharedDependencyRecordsFor(classId: Oid, objectId: Oid, objectSubId: int32);
    pub fn recordDependencyOnOwner(classId: Oid, objectId: Oid, owner: Oid);
    pub fn changeDependencyOnOwner(classId: Oid, objectId: Oid, newOwnerId: Oid);
    pub fn recordDependencyOnTablespace(classId: Oid, objectId: Oid, tablespace: Oid);
    pub fn changeDependencyOnTablespace(classId: Oid, objectId: Oid, newTablespaceId: Oid);
    pub fn updateAclDependencies(
        classId: Oid,
        objectId: Oid,
        objsubId: int32,
        ownerId: Oid,
        noldmembers: ::core::ffi::c_int,
        oldmembers: *mut Oid,
        nnewmembers: ::core::ffi::c_int,
        newmembers: *mut Oid,
    );
    pub fn updateInitAclDependencies(
        classId: Oid,
        objectId: Oid,
        objsubId: int32,
        noldmembers: ::core::ffi::c_int,
        oldmembers: *mut Oid,
        nnewmembers: ::core::ffi::c_int,
        newmembers: *mut Oid,
    );
    pub fn checkSharedDependencies(
        classId: Oid,
        objectId: Oid,
        detail_msg: *mut *mut ::core::ffi::c_char,
        detail_log_msg: *mut *mut ::core::ffi::c_char,
    ) -> bool;
    pub fn shdepLockAndCheckObject(classId: Oid, objectId: Oid);
    pub fn copyTemplateDependencies(templateDbId: Oid, newDbId: Oid);
    pub fn dropDatabaseDependencies(databaseId: Oid);
    pub fn shdepDropOwned(roleids: *mut List, behavior: DropBehavior::Type);
    pub fn shdepReassignOwned(roleids: *mut List, newrole: Oid);
    pub fn index_check_primary_key(
        heapRel: Relation,
        indexInfo: *const IndexInfo,
        is_alter_table: bool,
        stmt: *const IndexStmt,
    );
    pub fn index_create(
        heapRelation: Relation,
        indexRelationName: *const ::core::ffi::c_char,
        indexRelationId: Oid,
        parentIndexRelid: Oid,
        parentConstraintId: Oid,
        relFileNumber: RelFileNumber,
        indexInfo: *mut IndexInfo,
        indexColNames: *const List,
        accessMethodId: Oid,
        tableSpaceId: Oid,
        collationIds: *const Oid,
        opclassIds: *const Oid,
        opclassOptions: *const Datum,
        coloptions: *const int16,
        stattargets: *const NullableDatum,
        reloptions: Datum,
        flags: bits16,
        constr_flags: bits16,
        allow_system_table_mods: bool,
        is_internal: bool,
        constraintId: *mut Oid,
    ) -> Oid;
    pub fn index_concurrently_create_copy(
        heapRelation: Relation,
        oldIndexId: Oid,
        tablespaceOid: Oid,
        newName: *const ::core::ffi::c_char,
    ) -> Oid;
    pub fn index_concurrently_build(heapRelationId: Oid, indexRelationId: Oid);
    pub fn index_concurrently_swap(
        newIndexId: Oid,
        oldIndexId: Oid,
        oldName: *const ::core::ffi::c_char,
    );
    pub fn index_concurrently_set_dead(heapId: Oid, indexId: Oid);
    pub fn index_constraint_create(
        heapRelation: Relation,
        indexRelationId: Oid,
        parentConstraintId: Oid,
        indexInfo: *const IndexInfo,
        constraintName: *const ::core::ffi::c_char,
        constraintType: ::core::ffi::c_char,
        constr_flags: bits16,
        allow_system_table_mods: bool,
        is_internal: bool,
    ) -> ObjectAddress;
    pub fn index_drop(indexId: Oid, concurrent: bool, concurrent_lock_mode: bool);
    pub fn BuildIndexInfo(index: Relation) -> *mut IndexInfo;
    pub fn BuildDummyIndexInfo(index: Relation) -> *mut IndexInfo;
    pub fn CompareIndexInfo(
        info1: *const IndexInfo,
        info2: *const IndexInfo,
        collations1: *const Oid,
        collations2: *const Oid,
        opfamilies1: *const Oid,
        opfamilies2: *const Oid,
        attmap: *const AttrMap,
    ) -> bool;
    pub fn BuildSpeculativeIndexInfo(index: Relation, ii: *mut IndexInfo);
    pub fn FormIndexDatum(
        indexInfo: *mut IndexInfo,
        slot: *mut TupleTableSlot,
        estate: *mut EState,
        values: *mut Datum,
        isnull: *mut bool,
    );
    pub fn index_build(
        heapRelation: Relation,
        indexRelation: Relation,
        indexInfo: *mut IndexInfo,
        isreindex: bool,
        parallel: bool,
    );
    pub fn validate_index(heapId: Oid, indexId: Oid, snapshot: Snapshot);
    pub fn index_set_state_flags(indexId: Oid, action: IndexStateFlagsAction::Type);
    pub fn IndexGetRelation(indexId: Oid, missing_ok: bool) -> Oid;
    pub fn reindex_index(
        stmt: *const ReindexStmt,
        indexId: Oid,
        skip_constraint_checks: bool,
        persistence: ::core::ffi::c_char,
        params: *const ReindexParams,
    );
    pub fn reindex_relation(
        stmt: *const ReindexStmt,
        relid: Oid,
        flags: ::core::ffi::c_int,
        params: *const ReindexParams,
    ) -> bool;
    pub fn ReindexIsProcessingHeap(heapOid: Oid) -> bool;
    pub fn ReindexIsProcessingIndex(indexOid: Oid) -> bool;
    pub fn ResetReindexState(nestLevel: ::core::ffi::c_int);
    pub fn EstimateReindexStateSpace() -> Size;
    pub fn SerializeReindexState(maxsize: Size, start_address: *mut ::core::ffi::c_char);
    pub fn RestoreReindexState(reindexstate: *const ::core::ffi::c_void);
    pub fn IndexSetParentIndex(partitionIdx: Relation, parentOid: Oid);
    pub fn CatalogOpenIndexes(heapRel: Relation) -> CatalogIndexState;
    pub fn CatalogCloseIndexes(indstate: CatalogIndexState);
    pub fn CatalogTupleInsert(heapRel: Relation, tup: HeapTuple);
    pub fn CatalogTupleInsertWithInfo(
        heapRel: Relation,
        tup: HeapTuple,
        indstate: CatalogIndexState,
    );
    pub fn CatalogTuplesMultiInsertWithInfo(
        heapRel: Relation,
        slot: *mut *mut TupleTableSlot,
        ntuples: ::core::ffi::c_int,
        indstate: CatalogIndexState,
    );
    pub fn CatalogTupleUpdate(heapRel: Relation, otid: ItemPointer, tup: HeapTuple);
    pub fn CatalogTupleUpdateWithInfo(
        heapRel: Relation,
        otid: ItemPointer,
        tup: HeapTuple,
        indstate: CatalogIndexState,
    );
    pub fn CatalogTupleDelete(heapRel: Relation, tid: ItemPointer);
    pub fn RangeVarGetRelidExtended(
        relation: *const RangeVar,
        lockmode: LOCKMODE,
        flags: uint32,
        callback: RangeVarGetRelidCallback,
        callback_arg: *mut ::core::ffi::c_void,
    ) -> Oid;
    pub fn RangeVarGetCreationNamespace(newRelation: *const RangeVar) -> Oid;
    pub fn RangeVarGetAndCheckCreationNamespace(
        relation: *mut RangeVar,
        lockmode: LOCKMODE,
        existing_relation_id: *mut Oid,
    ) -> Oid;
    pub fn RangeVarAdjustRelationPersistence(newRelation: *mut RangeVar, nspid: Oid);
    pub fn RelnameGetRelid(relname: *const ::core::ffi::c_char) -> Oid;
    pub fn RelationIsVisible(relid: Oid) -> bool;
    pub fn TypenameGetTypid(typname: *const ::core::ffi::c_char) -> Oid;
    pub fn TypenameGetTypidExtended(typname: *const ::core::ffi::c_char, temp_ok: bool) -> Oid;
    pub fn TypeIsVisible(typid: Oid) -> bool;
    pub fn FuncnameGetCandidates(
        names: *mut List,
        nargs: ::core::ffi::c_int,
        argnames: *mut List,
        expand_variadic: bool,
        expand_defaults: bool,
        include_out_arguments: bool,
        missing_ok: bool,
    ) -> FuncCandidateList;
    pub fn FunctionIsVisible(funcid: Oid) -> bool;
    pub fn OpernameGetOprid(names: *mut List, oprleft: Oid, oprright: Oid) -> Oid;
    pub fn OpernameGetCandidates(
        names: *mut List,
        oprkind: ::core::ffi::c_char,
        missing_schema_ok: bool,
    ) -> FuncCandidateList;
    pub fn OperatorIsVisible(oprid: Oid) -> bool;
    pub fn OpclassnameGetOpcid(amid: Oid, opcname: *const ::core::ffi::c_char) -> Oid;
    pub fn OpclassIsVisible(opcid: Oid) -> bool;
    pub fn OpfamilynameGetOpfid(amid: Oid, opfname: *const ::core::ffi::c_char) -> Oid;
    pub fn OpfamilyIsVisible(opfid: Oid) -> bool;
    pub fn CollationGetCollid(collname: *const ::core::ffi::c_char) -> Oid;
    pub fn CollationIsVisible(collid: Oid) -> bool;
    pub fn ConversionGetConid(conname: *const ::core::ffi::c_char) -> Oid;
    pub fn ConversionIsVisible(conid: Oid) -> bool;
    pub fn get_statistics_object_oid(names: *mut List, missing_ok: bool) -> Oid;
    pub fn StatisticsObjIsVisible(stxid: Oid) -> bool;
    pub fn get_ts_parser_oid(names: *mut List, missing_ok: bool) -> Oid;
    pub fn TSParserIsVisible(prsId: Oid) -> bool;
    pub fn get_ts_dict_oid(names: *mut List, missing_ok: bool) -> Oid;
    pub fn TSDictionaryIsVisible(dictId: Oid) -> bool;
    pub fn get_ts_template_oid(names: *mut List, missing_ok: bool) -> Oid;
    pub fn TSTemplateIsVisible(tmplId: Oid) -> bool;
    pub fn get_ts_config_oid(names: *mut List, missing_ok: bool) -> Oid;
    pub fn TSConfigIsVisible(cfgid: Oid) -> bool;
    pub fn DeconstructQualifiedName(
        names: *const List,
        nspname_p: *mut *mut ::core::ffi::c_char,
        objname_p: *mut *mut ::core::ffi::c_char,
    );
    pub fn LookupNamespaceNoError(nspname: *const ::core::ffi::c_char) -> Oid;
    pub fn LookupExplicitNamespace(nspname: *const ::core::ffi::c_char, missing_ok: bool) -> Oid;
    pub fn get_namespace_oid(nspname: *const ::core::ffi::c_char, missing_ok: bool) -> Oid;
    pub fn LookupCreationNamespace(nspname: *const ::core::ffi::c_char) -> Oid;
    pub fn CheckSetNamespace(oldNspOid: Oid, nspOid: Oid);
    pub fn QualifiedNameGetCreationNamespace(
        names: *const List,
        objname_p: *mut *mut ::core::ffi::c_char,
    ) -> Oid;
    pub fn makeRangeVarFromNameList(names: *const List) -> *mut RangeVar;
    pub fn NameListToString(names: *const List) -> *mut ::core::ffi::c_char;
    pub fn NameListToQuotedString(names: *const List) -> *mut ::core::ffi::c_char;
    pub fn isTempNamespace(namespaceId: Oid) -> bool;
    pub fn isTempToastNamespace(namespaceId: Oid) -> bool;
    pub fn isTempOrTempToastNamespace(namespaceId: Oid) -> bool;
    pub fn isAnyTempNamespace(namespaceId: Oid) -> bool;
    pub fn isOtherTempNamespace(namespaceId: Oid) -> bool;
    pub fn checkTempNamespaceStatus(namespaceId: Oid) -> TempNamespaceStatus::Type;
    pub fn GetTempNamespaceProcNumber(namespaceId: Oid) -> ProcNumber;
    pub fn GetTempToastNamespace() -> Oid;
    pub fn GetTempNamespaceState(tempNamespaceId: *mut Oid, tempToastNamespaceId: *mut Oid);
    pub fn SetTempNamespaceState(tempNamespaceId: Oid, tempToastNamespaceId: Oid);
    pub fn ResetTempTableNamespace();
    pub fn GetSearchPathMatcher(context: MemoryContext) -> *mut SearchPathMatcher;
    pub fn CopySearchPathMatcher(path: *mut SearchPathMatcher) -> *mut SearchPathMatcher;
    pub fn SearchPathMatchesCurrentEnvironment(path: *mut SearchPathMatcher) -> bool;
    pub fn get_collation_oid(collname: *mut List, missing_ok: bool) -> Oid;
    pub fn get_conversion_oid(conname: *mut List, missing_ok: bool) -> Oid;
    pub fn FindDefaultConversionProc(for_encoding: int32, to_encoding: int32) -> Oid;
    pub fn InitializeSearchPath();
    pub fn AtEOXact_Namespace(isCommit: bool, parallel: bool);
    pub fn AtEOSubXact_Namespace(
        isCommit: bool,
        mySubid: SubTransactionId,
        parentSubid: SubTransactionId,
    );
    pub static mut namespace_search_path: *mut ::core::ffi::c_char;
    pub fn fetch_search_path(includeImplicit: bool) -> *mut List;
    pub fn fetch_search_path_array(
        sarray: *mut Oid,
        sarray_len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub static mut object_access_hook: object_access_hook_type;
    pub static mut object_access_hook_str: object_access_hook_type_str;
    pub fn RunObjectPostCreateHook(
        classId: Oid,
        objectId: Oid,
        subId: ::core::ffi::c_int,
        is_internal: bool,
    );
    pub fn RunObjectDropHook(
        classId: Oid,
        objectId: Oid,
        subId: ::core::ffi::c_int,
        dropflags: ::core::ffi::c_int,
    );
    pub fn RunObjectTruncateHook(objectId: Oid);
    pub fn RunObjectPostAlterHook(
        classId: Oid,
        objectId: Oid,
        subId: ::core::ffi::c_int,
        auxiliaryId: Oid,
        is_internal: bool,
    );
    pub fn RunNamespaceSearchHook(objectId: Oid, ereport_on_violation: bool) -> bool;
    pub fn RunFunctionExecuteHook(objectId: Oid);
    pub fn RunObjectPostCreateHookStr(
        classId: Oid,
        objectName: *const ::core::ffi::c_char,
        subId: ::core::ffi::c_int,
        is_internal: bool,
    );
    pub fn RunObjectDropHookStr(
        classId: Oid,
        objectName: *const ::core::ffi::c_char,
        subId: ::core::ffi::c_int,
        dropflags: ::core::ffi::c_int,
    );
    pub fn RunObjectTruncateHookStr(objectName: *const ::core::ffi::c_char);
    pub fn RunObjectPostAlterHookStr(
        classId: Oid,
        objectName: *const ::core::ffi::c_char,
        subId: ::core::ffi::c_int,
        auxiliaryId: Oid,
        is_internal: bool,
    );
    pub fn RunNamespaceSearchHookStr(
        objectName: *const ::core::ffi::c_char,
        ereport_on_violation: bool,
    ) -> bool;
    pub fn RunFunctionExecuteHookStr(objectName: *const ::core::ffi::c_char);
    pub fn CollationCreate(
        collname: *const ::core::ffi::c_char,
        collnamespace: Oid,
        collowner: Oid,
        collprovider: ::core::ffi::c_char,
        collisdeterministic: bool,
        collencoding: int32,
        collcollate: *const ::core::ffi::c_char,
        collctype: *const ::core::ffi::c_char,
        colllocale: *const ::core::ffi::c_char,
        collicurules: *const ::core::ffi::c_char,
        collversion: *const ::core::ffi::c_char,
        if_not_exists: bool,
        quiet: bool,
    ) -> Oid;
    pub fn database_is_invalid_form(datform: Form_pg_database) -> bool;
    pub fn database_is_invalid_oid(dboid: Oid) -> bool;
    pub fn EnumValuesCreate(enumTypeOid: Oid, vals: *mut List);
    pub fn EnumValuesDelete(enumTypeOid: Oid);
    pub fn AddEnumLabel(
        enumTypeOid: Oid,
        newVal: *const ::core::ffi::c_char,
        neighbor: *const ::core::ffi::c_char,
        newValIsAfter: bool,
        skipIfExists: bool,
    );
    pub fn RenameEnumLabel(
        enumTypeOid: Oid,
        oldVal: *const ::core::ffi::c_char,
        newVal: *const ::core::ffi::c_char,
    );
    pub fn EnumUncommitted(enum_id: Oid) -> bool;
    pub fn EstimateUncommittedEnumsSpace() -> Size;
    pub fn SerializeUncommittedEnums(space: *mut ::core::ffi::c_void, size: Size);
    pub fn RestoreUncommittedEnums(space: *mut ::core::ffi::c_void);
    pub fn AtEOXact_Enum();
    pub fn OperatorLookup(
        operatorName: *mut List,
        leftObjectId: Oid,
        rightObjectId: Oid,
        defined: *mut bool,
    ) -> Oid;
    pub fn OperatorCreate(
        operatorName: *const ::core::ffi::c_char,
        operatorNamespace: Oid,
        leftTypeId: Oid,
        rightTypeId: Oid,
        procedureId: Oid,
        commutatorName: *mut List,
        negatorName: *mut List,
        restrictionId: Oid,
        joinId: Oid,
        canMerge: bool,
        canHash: bool,
    ) -> ObjectAddress;
    pub fn makeOperatorDependencies(
        tuple: HeapTuple,
        makeExtensionDep: bool,
        isUpdate: bool,
    ) -> ObjectAddress;
    pub fn OperatorValidateParams(
        leftTypeId: Oid,
        rightTypeId: Oid,
        operResultType: Oid,
        hasCommutator: bool,
        hasNegator: bool,
        hasRestrictionSelectivity: bool,
        hasJoinSelectivity: bool,
        canMerge: bool,
        canHash: bool,
    );
    pub fn OperatorUpd(baseId: Oid, commId: Oid, negId: Oid, isDelete: bool);
    pub fn ProcedureCreate(
        procedureName: *const ::core::ffi::c_char,
        procNamespace: Oid,
        replace: bool,
        returnsSet: bool,
        returnType: Oid,
        proowner: Oid,
        languageObjectId: Oid,
        languageValidator: Oid,
        prosrc: *const ::core::ffi::c_char,
        probin: *const ::core::ffi::c_char,
        prosqlbody: *mut Node,
        prokind: ::core::ffi::c_char,
        security_definer: bool,
        isLeakProof: bool,
        isStrict: bool,
        volatility: ::core::ffi::c_char,
        parallel: ::core::ffi::c_char,
        parameterTypes: *mut oidvector,
        allParameterTypes: Datum,
        parameterModes: Datum,
        parameterNames: Datum,
        parameterDefaults: *mut List,
        trftypes: Datum,
        proconfig: Datum,
        prosupport: Oid,
        procost: float4,
        prorows: float4,
    ) -> ObjectAddress;
    pub fn function_parse_error_transpose(prosrc: *const ::core::ffi::c_char) -> bool;
    pub fn oid_array_to_list(datum: Datum) -> *mut List;
    pub fn make_parsestate(parentParseState: *mut ParseState) -> *mut ParseState;
    pub fn free_parsestate(pstate: *mut ParseState);
    pub fn parser_errposition(
        pstate: *mut ParseState,
        location: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn setup_parser_errposition_callback(
        pcbstate: *mut ParseCallbackState,
        pstate: *mut ParseState,
        location: ::core::ffi::c_int,
    );
    pub fn cancel_parser_errposition_callback(pcbstate: *mut ParseCallbackState);
    pub fn transformContainerType(containerType: *mut Oid, containerTypmod: *mut int32);
    pub fn transformContainerSubscripts(
        pstate: *mut ParseState,
        containerBase: *mut Node,
        containerType: Oid,
        containerTypMod: int32,
        indirection: *mut List,
        isAssignment: bool,
    ) -> *mut SubscriptingRef;
    pub fn make_const(pstate: *mut ParseState, aconst: *mut A_Const) -> *mut Const;
    pub fn acldefault(objtype: ObjectType::Type, ownerId: Oid) -> *mut Acl;
    pub fn get_user_default_acl(objtype: ObjectType::Type, ownerId: Oid, nsp_oid: Oid) -> *mut Acl;
    pub fn recordDependencyOnNewAcl(
        classId: Oid,
        objectId: Oid,
        objsubId: int32,
        ownerId: Oid,
        acl: *mut Acl,
    );
    pub fn aclupdate(
        old_acl: *const Acl,
        mod_aip: *const AclItem,
        modechg: ::core::ffi::c_int,
        ownerId: Oid,
        behavior: DropBehavior::Type,
    ) -> *mut Acl;
    pub fn aclnewowner(old_acl: *const Acl, oldOwnerId: Oid, newOwnerId: Oid) -> *mut Acl;
    pub fn make_empty_acl() -> *mut Acl;
    pub fn aclcopy(orig_acl: *const Acl) -> *mut Acl;
    pub fn aclconcat(left_acl: *const Acl, right_acl: *const Acl) -> *mut Acl;
    pub fn aclmerge(left_acl: *const Acl, right_acl: *const Acl, ownerId: Oid) -> *mut Acl;
    pub fn aclitemsort(acl: *mut Acl);
    pub fn aclequal(left_acl: *const Acl, right_acl: *const Acl) -> bool;
    pub fn aclmask(
        acl: *const Acl,
        roleid: Oid,
        ownerId: Oid,
        mask: AclMode,
        how: AclMaskHow::Type,
    ) -> AclMode;
    pub fn aclmembers(acl: *const Acl, roleids: *mut *mut Oid) -> ::core::ffi::c_int;
    pub fn has_privs_of_role(member: Oid, role: Oid) -> bool;
    pub fn member_can_set_role(member: Oid, role: Oid) -> bool;
    pub fn check_can_set_role(member: Oid, role: Oid);
    pub fn is_member_of_role(member: Oid, role: Oid) -> bool;
    pub fn is_member_of_role_nosuper(member: Oid, role: Oid) -> bool;
    pub fn is_admin_of_role(member: Oid, role: Oid) -> bool;
    pub fn select_best_admin(member: Oid, role: Oid) -> Oid;
    pub fn get_role_oid(rolname: *const ::core::ffi::c_char, missing_ok: bool) -> Oid;
    pub fn get_role_oid_or_public(rolname: *const ::core::ffi::c_char) -> Oid;
    pub fn get_rolespec_oid(role: *const RoleSpec, missing_ok: bool) -> Oid;
    pub fn check_rolespec_name(role: *const RoleSpec, detail_msg: *const ::core::ffi::c_char);
    pub fn get_rolespec_tuple(role: *const RoleSpec) -> HeapTuple;
    pub fn get_rolespec_name(role: *const RoleSpec) -> *mut ::core::ffi::c_char;
    pub fn select_best_grantor(
        roleId: Oid,
        privileges: AclMode,
        acl: *const Acl,
        ownerId: Oid,
        grantorId: *mut Oid,
        grantOptions: *mut AclMode,
    );
    pub fn initialize_acl();
    pub fn ExecuteGrantStmt(stmt: *mut GrantStmt);
    pub fn ExecAlterDefaultPrivilegesStmt(
        pstate: *mut ParseState,
        stmt: *mut AlterDefaultPrivilegesStmt,
    );
    pub fn RemoveRoleFromObjectACL(roleid: Oid, classid: Oid, objid: Oid);
    pub fn pg_class_aclmask(
        table_oid: Oid,
        roleid: Oid,
        mask: AclMode,
        how: AclMaskHow::Type,
    ) -> AclMode;
    pub fn object_aclcheck(
        classid: Oid,
        objectid: Oid,
        roleid: Oid,
        mode: AclMode,
    ) -> AclResult::Type;
    pub fn object_aclcheck_ext(
        classid: Oid,
        objectid: Oid,
        roleid: Oid,
        mode: AclMode,
        is_missing: *mut bool,
    ) -> AclResult::Type;
    pub fn pg_attribute_aclcheck(
        table_oid: Oid,
        attnum: AttrNumber,
        roleid: Oid,
        mode: AclMode,
    ) -> AclResult::Type;
    pub fn pg_attribute_aclcheck_ext(
        table_oid: Oid,
        attnum: AttrNumber,
        roleid: Oid,
        mode: AclMode,
        is_missing: *mut bool,
    ) -> AclResult::Type;
    pub fn pg_attribute_aclcheck_all(
        table_oid: Oid,
        roleid: Oid,
        mode: AclMode,
        how: AclMaskHow::Type,
    ) -> AclResult::Type;
    pub fn pg_attribute_aclcheck_all_ext(
        table_oid: Oid,
        roleid: Oid,
        mode: AclMode,
        how: AclMaskHow::Type,
        is_missing: *mut bool,
    ) -> AclResult::Type;
    pub fn pg_class_aclcheck(table_oid: Oid, roleid: Oid, mode: AclMode) -> AclResult::Type;
    pub fn pg_class_aclcheck_ext(
        table_oid: Oid,
        roleid: Oid,
        mode: AclMode,
        is_missing: *mut bool,
    ) -> AclResult::Type;
    pub fn pg_parameter_aclcheck(
        name: *const ::core::ffi::c_char,
        roleid: Oid,
        mode: AclMode,
    ) -> AclResult::Type;
    pub fn pg_largeobject_aclcheck_snapshot(
        lobj_oid: Oid,
        roleid: Oid,
        mode: AclMode,
        snapshot: Snapshot,
    ) -> AclResult::Type;
    pub fn aclcheck_error(
        aclerr: AclResult::Type,
        objtype: ObjectType::Type,
        objectname: *const ::core::ffi::c_char,
    );
    pub fn aclcheck_error_col(
        aclerr: AclResult::Type,
        objtype: ObjectType::Type,
        objectname: *const ::core::ffi::c_char,
        colname: *const ::core::ffi::c_char,
    );
    pub fn aclcheck_error_type(aclerr: AclResult::Type, typeOid: Oid);
    pub fn recordExtObjInitPriv(objoid: Oid, classoid: Oid);
    pub fn removeExtObjInitPriv(objoid: Oid, classoid: Oid);
    pub fn ReplaceRoleInInitPriv(
        oldroleid: Oid,
        newroleid: Oid,
        classid: Oid,
        objid: Oid,
        objsubid: int32,
    );
    pub fn RemoveRoleFromInitPriv(roleid: Oid, classid: Oid, objid: Oid, objsubid: int32);
    pub fn object_ownercheck(classid: Oid, objectid: Oid, roleid: Oid) -> bool;
    pub fn has_createrole_privilege(roleid: Oid) -> bool;
    pub fn has_bypassrls_privilege(roleid: Oid) -> bool;
    pub fn NamespaceCreate(nspName: *const ::core::ffi::c_char, ownerId: Oid, isTemp: bool) -> Oid;
    pub fn TypeShellMake(
        typeName: *const ::core::ffi::c_char,
        typeNamespace: Oid,
        ownerId: Oid,
    ) -> ObjectAddress;
    pub fn TypeCreate(
        newTypeOid: Oid,
        typeName: *const ::core::ffi::c_char,
        typeNamespace: Oid,
        relationOid: Oid,
        relationKind: ::core::ffi::c_char,
        ownerId: Oid,
        internalSize: int16,
        typeType: ::core::ffi::c_char,
        typeCategory: ::core::ffi::c_char,
        typePreferred: bool,
        typDelim: ::core::ffi::c_char,
        inputProcedure: Oid,
        outputProcedure: Oid,
        receiveProcedure: Oid,
        sendProcedure: Oid,
        typmodinProcedure: Oid,
        typmodoutProcedure: Oid,
        analyzeProcedure: Oid,
        subscriptProcedure: Oid,
        elementType: Oid,
        isImplicitArray: bool,
        arrayType: Oid,
        baseType: Oid,
        defaultTypeValue: *const ::core::ffi::c_char,
        defaultTypeBin: *mut ::core::ffi::c_char,
        passedByValue: bool,
        alignment: ::core::ffi::c_char,
        storage: ::core::ffi::c_char,
        typeMod: int32,
        typNDims: int32,
        typeNotNull: bool,
        typeCollation: Oid,
    ) -> ObjectAddress;
    pub fn GenerateTypeDependencies(
        typeTuple: HeapTuple,
        typeCatalog: Relation,
        defaultExpr: *mut Node,
        typacl: *mut ::core::ffi::c_void,
        relationKind: ::core::ffi::c_char,
        isImplicitArray: bool,
        isDependentType: bool,
        makeExtensionDep: bool,
        rebuild: bool,
    );
    pub fn RenameTypeInternal(
        typeOid: Oid,
        newTypeName: *const ::core::ffi::c_char,
        typeNamespace: Oid,
    );
    pub fn makeArrayTypeName(
        typeName: *const ::core::ffi::c_char,
        typeNamespace: Oid,
    ) -> *mut ::core::ffi::c_char;
    pub fn moveArrayTypeName(
        typeOid: Oid,
        typeName: *const ::core::ffi::c_char,
        typeNamespace: Oid,
    ) -> bool;
    pub fn makeMultirangeTypeName(
        rangeTypeName: *const ::core::ffi::c_char,
        typeNamespace: Oid,
    ) -> *mut ::core::ffi::c_char;
    pub static mut wal_skip_threshold: ::core::ffi::c_int;
    pub fn RelationCreateStorage(
        rlocator: RelFileLocator,
        relpersistence: ::core::ffi::c_char,
        register_delete: bool,
    ) -> SMgrRelation;
    pub fn RelationDropStorage(rel: Relation);
    pub fn RelationPreserveStorage(rlocator: RelFileLocator, atCommit: bool);
    pub fn RelationPreTruncate(rel: Relation);
    pub fn RelationTruncate(rel: Relation, nblocks: BlockNumber);
    pub fn RelationCopyStorage(
        src: SMgrRelation,
        dst: SMgrRelation,
        forkNum: ForkNumber::Type,
        relpersistence: ::core::ffi::c_char,
    );
    pub fn RelFileLocatorSkippingWAL(rlocator: RelFileLocator) -> bool;
    pub fn EstimatePendingSyncsSpace() -> Size;
    pub fn SerializePendingSyncs(maxSize: Size, startAddress: *mut ::core::ffi::c_char);
    pub fn RestorePendingSyncs(startAddress: *mut ::core::ffi::c_char);
    pub fn smgrDoPendingDeletes(isCommit: bool);
    pub fn smgrDoPendingSyncs(isCommit: bool, isParallelWorker: bool);
    pub fn smgrGetPendingDeletes(
        forCommit: bool,
        ptr: *mut *mut RelFileLocator,
    ) -> ::core::ffi::c_int;
    pub fn AtSubCommit_smgr();
    pub fn AtSubAbort_smgr();
    pub fn PostPrepare_smgr();
    pub fn CommentObject(stmt: *mut CommentStmt) -> ObjectAddress;
    pub fn DeleteComments(oid: Oid, classoid: Oid, subid: int32);
    pub fn CreateComments(
        oid: Oid,
        classoid: Oid,
        subid: int32,
        comment: *const ::core::ffi::c_char,
    );
    pub fn DeleteSharedComments(oid: Oid, classoid: Oid);
    pub fn CreateSharedComments(oid: Oid, classoid: Oid, comment: *const ::core::ffi::c_char);
    pub fn GetComment(oid: Oid, classoid: Oid, subid: int32) -> *mut ::core::ffi::c_char;
    pub fn DoCopy(
        pstate: *mut ParseState,
        stmt: *const CopyStmt,
        stmt_location: ::core::ffi::c_int,
        stmt_len: ::core::ffi::c_int,
        processed: *mut uint64,
    );
    pub fn ProcessCopyOptions(
        pstate: *mut ParseState,
        opts_out: *mut CopyFormatOptions,
        is_from: bool,
        options: *mut List,
    );
    pub fn BeginCopyFrom(
        pstate: *mut ParseState,
        rel: Relation,
        whereClause: *mut Node,
        filename: *const ::core::ffi::c_char,
        is_program: bool,
        data_source_cb: copy_data_source_cb,
        attnamelist: *mut List,
        options: *mut List,
    ) -> CopyFromState;
    pub fn EndCopyFrom(cstate: CopyFromState);
    pub fn NextCopyFrom(
        cstate: CopyFromState,
        econtext: *mut ExprContext,
        values: *mut Datum,
        nulls: *mut bool,
    ) -> bool;
    pub fn NextCopyFromRawFields(
        cstate: CopyFromState,
        fields: *mut *mut *mut ::core::ffi::c_char,
        nfields: *mut ::core::ffi::c_int,
    ) -> bool;
    pub fn CopyFromErrorCallback(arg: *mut ::core::ffi::c_void);
    pub fn CopyLimitPrintoutLength(str_: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn CopyFrom(cstate: CopyFromState) -> uint64;
    pub fn CreateCopyDestReceiver() -> *mut DestReceiver;
    pub fn BeginCopyTo(
        pstate: *mut ParseState,
        rel: Relation,
        raw_query: *mut RawStmt,
        queryRelId: Oid,
        filename: *const ::core::ffi::c_char,
        is_program: bool,
        data_dest_cb: copy_data_dest_cb,
        attnamelist: *mut List,
        options: *mut List,
    ) -> CopyToState;
    pub fn EndCopyTo(cstate: CopyToState);
    pub fn DoCopyTo(cstate: CopyToState) -> uint64;
    pub fn CopyGetAttnums(tupDesc: TupleDesc, rel: Relation, attnamelist: *mut List) -> *mut List;
    pub fn createdb(pstate: *mut ParseState, stmt: *const CreatedbStmt) -> Oid;
    pub fn dropdb(dbname: *const ::core::ffi::c_char, missing_ok: bool, force: bool);
    pub fn DropDatabase(pstate: *mut ParseState, stmt: *mut DropdbStmt);
    pub fn RenameDatabase(
        oldname: *const ::core::ffi::c_char,
        newname: *const ::core::ffi::c_char,
    ) -> ObjectAddress;
    pub fn AlterDatabase(
        pstate: *mut ParseState,
        stmt: *mut AlterDatabaseStmt,
        isTopLevel: bool,
    ) -> Oid;
    pub fn AlterDatabaseRefreshColl(stmt: *mut AlterDatabaseRefreshCollStmt) -> ObjectAddress;
    pub fn AlterDatabaseSet(stmt: *mut AlterDatabaseSetStmt) -> Oid;
    pub fn AlterDatabaseOwner(dbname: *const ::core::ffi::c_char, newOwnerId: Oid)
        -> ObjectAddress;
    pub fn get_database_oid(dbname: *const ::core::ffi::c_char, missing_ok: bool) -> Oid;
    pub fn get_database_name(dbid: Oid) -> *mut ::core::ffi::c_char;
    pub fn have_createdb_privilege() -> bool;
    pub fn check_encoding_locale_matches(
        encoding: ::core::ffi::c_int,
        collate: *const ::core::ffi::c_char,
        ctype: *const ::core::ffi::c_char,
    );
    pub fn DatumGetEOHP(d: Datum) -> *mut ExpandedObjectHeader;
    pub fn EOH_init_header(
        eohptr: *mut ExpandedObjectHeader,
        methods: *const ExpandedObjectMethods,
        obj_context: MemoryContext,
    );
    pub fn EOH_get_flat_size(eohptr: *mut ExpandedObjectHeader) -> Size;
    pub fn EOH_flatten_into(
        eohptr: *mut ExpandedObjectHeader,
        result: *mut ::core::ffi::c_void,
        allocated_size: Size,
    );
    pub fn MakeExpandedObjectReadOnlyInternal(d: Datum) -> Datum;
    pub fn TransferExpandedObject(d: Datum, new_parent: MemoryContext) -> Datum;
    pub fn DeleteExpandedObject(d: Datum);
    pub static mut Array_nulls: bool;
    pub fn CopyArrayEls(
        array: *mut ArrayType,
        values: *mut Datum,
        nulls: *mut bool,
        nitems: ::core::ffi::c_int,
        typlen: ::core::ffi::c_int,
        typbyval: bool,
        typalign: ::core::ffi::c_char,
        freedata: bool,
    );
    pub fn array_get_element(
        arraydatum: Datum,
        nSubscripts: ::core::ffi::c_int,
        indx: *mut ::core::ffi::c_int,
        arraytyplen: ::core::ffi::c_int,
        elmlen: ::core::ffi::c_int,
        elmbyval: bool,
        elmalign: ::core::ffi::c_char,
        isNull: *mut bool,
    ) -> Datum;
    pub fn array_set_element(
        arraydatum: Datum,
        nSubscripts: ::core::ffi::c_int,
        indx: *mut ::core::ffi::c_int,
        dataValue: Datum,
        isNull: bool,
        arraytyplen: ::core::ffi::c_int,
        elmlen: ::core::ffi::c_int,
        elmbyval: bool,
        elmalign: ::core::ffi::c_char,
    ) -> Datum;
    pub fn array_get_slice(
        arraydatum: Datum,
        nSubscripts: ::core::ffi::c_int,
        upperIndx: *mut ::core::ffi::c_int,
        lowerIndx: *mut ::core::ffi::c_int,
        upperProvided: *mut bool,
        lowerProvided: *mut bool,
        arraytyplen: ::core::ffi::c_int,
        elmlen: ::core::ffi::c_int,
        elmbyval: bool,
        elmalign: ::core::ffi::c_char,
    ) -> Datum;
    pub fn array_set_slice(
        arraydatum: Datum,
        nSubscripts: ::core::ffi::c_int,
        upperIndx: *mut ::core::ffi::c_int,
        lowerIndx: *mut ::core::ffi::c_int,
        upperProvided: *mut bool,
        lowerProvided: *mut bool,
        srcArrayDatum: Datum,
        isNull: bool,
        arraytyplen: ::core::ffi::c_int,
        elmlen: ::core::ffi::c_int,
        elmbyval: bool,
        elmalign: ::core::ffi::c_char,
    ) -> Datum;
    pub fn array_ref(
        array: *mut ArrayType,
        nSubscripts: ::core::ffi::c_int,
        indx: *mut ::core::ffi::c_int,
        arraytyplen: ::core::ffi::c_int,
        elmlen: ::core::ffi::c_int,
        elmbyval: bool,
        elmalign: ::core::ffi::c_char,
        isNull: *mut bool,
    ) -> Datum;
    pub fn array_set(
        array: *mut ArrayType,
        nSubscripts: ::core::ffi::c_int,
        indx: *mut ::core::ffi::c_int,
        dataValue: Datum,
        isNull: bool,
        arraytyplen: ::core::ffi::c_int,
        elmlen: ::core::ffi::c_int,
        elmbyval: bool,
        elmalign: ::core::ffi::c_char,
    ) -> *mut ArrayType;
    pub fn array_map(
        arrayd: Datum,
        exprstate: *mut ExprState,
        econtext: *mut ExprContext,
        retType: Oid,
        amstate: *mut ArrayMapState,
    ) -> Datum;
    pub fn array_bitmap_copy(
        destbitmap: *mut bits8,
        destoffset: ::core::ffi::c_int,
        srcbitmap: *const bits8,
        srcoffset: ::core::ffi::c_int,
        nitems: ::core::ffi::c_int,
    );
    pub fn construct_array(
        elems: *mut Datum,
        nelems: ::core::ffi::c_int,
        elmtype: Oid,
        elmlen: ::core::ffi::c_int,
        elmbyval: bool,
        elmalign: ::core::ffi::c_char,
    ) -> *mut ArrayType;
    pub fn construct_array_builtin(
        elems: *mut Datum,
        nelems: ::core::ffi::c_int,
        elmtype: Oid,
    ) -> *mut ArrayType;
    pub fn construct_md_array(
        elems: *mut Datum,
        nulls: *mut bool,
        ndims: ::core::ffi::c_int,
        dims: *mut ::core::ffi::c_int,
        lbs: *mut ::core::ffi::c_int,
        elmtype: Oid,
        elmlen: ::core::ffi::c_int,
        elmbyval: bool,
        elmalign: ::core::ffi::c_char,
    ) -> *mut ArrayType;
    pub fn construct_empty_array(elmtype: Oid) -> *mut ArrayType;
    pub fn construct_empty_expanded_array(
        element_type: Oid,
        parentcontext: MemoryContext,
        metacache: *mut ArrayMetaState,
    ) -> *mut ExpandedArrayHeader;
    pub fn deconstruct_array(
        array: *mut ArrayType,
        elmtype: Oid,
        elmlen: ::core::ffi::c_int,
        elmbyval: bool,
        elmalign: ::core::ffi::c_char,
        elemsp: *mut *mut Datum,
        nullsp: *mut *mut bool,
        nelemsp: *mut ::core::ffi::c_int,
    );
    pub fn deconstruct_array_builtin(
        array: *mut ArrayType,
        elmtype: Oid,
        elemsp: *mut *mut Datum,
        nullsp: *mut *mut bool,
        nelemsp: *mut ::core::ffi::c_int,
    );
    pub fn array_contains_nulls(array: *mut ArrayType) -> bool;
    pub fn initArrayResult(
        element_type: Oid,
        rcontext: MemoryContext,
        subcontext: bool,
    ) -> *mut ArrayBuildState;
    pub fn initArrayResultWithSize(
        element_type: Oid,
        rcontext: MemoryContext,
        subcontext: bool,
        initsize: ::core::ffi::c_int,
    ) -> *mut ArrayBuildState;
    pub fn accumArrayResult(
        astate: *mut ArrayBuildState,
        dvalue: Datum,
        disnull: bool,
        element_type: Oid,
        rcontext: MemoryContext,
    ) -> *mut ArrayBuildState;
    pub fn makeArrayResult(astate: *mut ArrayBuildState, rcontext: MemoryContext) -> Datum;
    pub fn makeMdArrayResult(
        astate: *mut ArrayBuildState,
        ndims: ::core::ffi::c_int,
        dims: *mut ::core::ffi::c_int,
        lbs: *mut ::core::ffi::c_int,
        rcontext: MemoryContext,
        release: bool,
    ) -> Datum;
    pub fn initArrayResultArr(
        array_type: Oid,
        element_type: Oid,
        rcontext: MemoryContext,
        subcontext: bool,
    ) -> *mut ArrayBuildStateArr;
    pub fn accumArrayResultArr(
        astate: *mut ArrayBuildStateArr,
        dvalue: Datum,
        disnull: bool,
        array_type: Oid,
        rcontext: MemoryContext,
    ) -> *mut ArrayBuildStateArr;
    pub fn makeArrayResultArr(
        astate: *mut ArrayBuildStateArr,
        rcontext: MemoryContext,
        release: bool,
    ) -> Datum;
    pub fn initArrayResultAny(
        input_type: Oid,
        rcontext: MemoryContext,
        subcontext: bool,
    ) -> *mut ArrayBuildStateAny;
    pub fn accumArrayResultAny(
        astate: *mut ArrayBuildStateAny,
        dvalue: Datum,
        disnull: bool,
        input_type: Oid,
        rcontext: MemoryContext,
    ) -> *mut ArrayBuildStateAny;
    pub fn makeArrayResultAny(
        astate: *mut ArrayBuildStateAny,
        rcontext: MemoryContext,
        release: bool,
    ) -> Datum;
    pub fn array_create_iterator(
        arr: *mut ArrayType,
        slice_ndim: ::core::ffi::c_int,
        mstate: *mut ArrayMetaState,
    ) -> ArrayIterator;
    pub fn array_iterate(iterator: ArrayIterator, value: *mut Datum, isnull: *mut bool) -> bool;
    pub fn array_free_iterator(iterator: ArrayIterator);
    pub fn ArrayGetOffset(
        n: ::core::ffi::c_int,
        dim: *const ::core::ffi::c_int,
        lb: *const ::core::ffi::c_int,
        indx: *const ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn ArrayGetNItems(
        ndim: ::core::ffi::c_int,
        dims: *const ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn ArrayGetNItemsSafe(
        ndim: ::core::ffi::c_int,
        dims: *const ::core::ffi::c_int,
        escontext: *mut Node,
    ) -> ::core::ffi::c_int;
    pub fn ArrayCheckBounds(
        ndim: ::core::ffi::c_int,
        dims: *const ::core::ffi::c_int,
        lb: *const ::core::ffi::c_int,
    );
    pub fn ArrayCheckBoundsSafe(
        ndim: ::core::ffi::c_int,
        dims: *const ::core::ffi::c_int,
        lb: *const ::core::ffi::c_int,
        escontext: *mut Node,
    ) -> bool;
    pub fn mda_get_range(
        n: ::core::ffi::c_int,
        span: *mut ::core::ffi::c_int,
        st: *const ::core::ffi::c_int,
        endp: *const ::core::ffi::c_int,
    );
    pub fn mda_get_prod(
        n: ::core::ffi::c_int,
        range: *const ::core::ffi::c_int,
        prod: *mut ::core::ffi::c_int,
    );
    pub fn mda_get_offset_values(
        n: ::core::ffi::c_int,
        dist: *mut ::core::ffi::c_int,
        prod: *const ::core::ffi::c_int,
        span: *const ::core::ffi::c_int,
    );
    pub fn mda_next_tuple(
        n: ::core::ffi::c_int,
        curr: *mut ::core::ffi::c_int,
        span: *const ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn ArrayGetIntegerTypmods(arr: *mut ArrayType, n: *mut ::core::ffi::c_int) -> *mut int32;
    pub fn expand_array(
        arraydatum: Datum,
        parentcontext: MemoryContext,
        metacache: *mut ArrayMetaState,
    ) -> Datum;
    pub fn DatumGetExpandedArray(d: Datum) -> *mut ExpandedArrayHeader;
    pub fn DatumGetExpandedArrayX(
        d: Datum,
        metacache: *mut ArrayMetaState,
    ) -> *mut ExpandedArrayHeader;
    pub fn DatumGetAnyArrayP(d: Datum) -> *mut AnyArrayType;
    pub fn deconstruct_expanded_array(eah: *mut ExpandedArrayHeader);
    pub fn RemoveObjects(stmt: *mut DropStmt);
    pub fn DefineIndex(
        tableId: Oid,
        stmt: *mut IndexStmt,
        indexRelationId: Oid,
        parentIndexId: Oid,
        parentConstraintId: Oid,
        total_parts: ::core::ffi::c_int,
        is_alter_table: bool,
        check_rights: bool,
        check_not_in_use: bool,
        skip_build: bool,
        quiet: bool,
    ) -> ObjectAddress;
    pub fn ExecReindex(pstate: *mut ParseState, stmt: *const ReindexStmt, isTopLevel: bool);
    pub fn makeObjectName(
        name1: *const ::core::ffi::c_char,
        name2: *const ::core::ffi::c_char,
        label: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn ChooseRelationName(
        name1: *const ::core::ffi::c_char,
        name2: *const ::core::ffi::c_char,
        label: *const ::core::ffi::c_char,
        namespaceid: Oid,
        isconstraint: bool,
    ) -> *mut ::core::ffi::c_char;
    pub fn CheckIndexCompatible(
        oldId: Oid,
        accessMethodName: *const ::core::ffi::c_char,
        attributeList: *const List,
        exclusionOpNames: *const List,
    ) -> bool;
    pub fn GetDefaultOpClass(type_id: Oid, am_id: Oid) -> Oid;
    pub fn ResolveOpClass(
        opclass: *const List,
        attrType: Oid,
        accessMethodName: *const ::core::ffi::c_char,
        accessMethodId: Oid,
    ) -> Oid;
    pub fn CreateFunction(pstate: *mut ParseState, stmt: *mut CreateFunctionStmt) -> ObjectAddress;
    pub fn RemoveFunctionById(funcOid: Oid);
    pub fn AlterFunction(pstate: *mut ParseState, stmt: *mut AlterFunctionStmt) -> ObjectAddress;
    pub fn CreateCast(stmt: *mut CreateCastStmt) -> ObjectAddress;
    pub fn CreateTransform(stmt: *mut CreateTransformStmt) -> ObjectAddress;
    pub fn IsThereFunctionInNamespace(
        proname: *const ::core::ffi::c_char,
        pronargs: ::core::ffi::c_int,
        proargtypes: *mut oidvector,
        nspOid: Oid,
    );
    pub fn ExecuteDoStmt(pstate: *mut ParseState, stmt: *mut DoStmt, atomic: bool);
    pub fn ExecuteCallStmt(
        stmt: *mut CallStmt,
        params: ParamListInfo,
        atomic: bool,
        dest: *mut DestReceiver,
    );
    pub fn CallStmtResultDesc(stmt: *mut CallStmt) -> TupleDesc;
    pub fn get_transform_oid(type_id: Oid, lang_id: Oid, missing_ok: bool) -> Oid;
    pub fn interpret_function_parameter_list(
        pstate: *mut ParseState,
        parameters: *mut List,
        languageOid: Oid,
        objtype: ObjectType::Type,
        parameterTypes: *mut *mut oidvector,
        parameterTypes_list: *mut *mut List,
        allParameterTypes: *mut *mut ArrayType,
        parameterModes: *mut *mut ArrayType,
        parameterNames: *mut *mut ArrayType,
        inParameterNames_list: *mut *mut List,
        parameterDefaults: *mut *mut List,
        variadicArgType: *mut Oid,
        requiredResultType: *mut Oid,
    );
    pub fn DefineOperator(names: *mut List, parameters: *mut List) -> ObjectAddress;
    pub fn RemoveOperatorById(operOid: Oid);
    pub fn AlterOperator(stmt: *mut AlterOperatorStmt) -> ObjectAddress;
    pub fn CreateStatistics(stmt: *mut CreateStatsStmt) -> ObjectAddress;
    pub fn AlterStatistics(stmt: *mut AlterStatsStmt) -> ObjectAddress;
    pub fn RemoveStatisticsById(statsOid: Oid);
    pub fn RemoveStatisticsDataById(statsOid: Oid, inh: bool);
    pub fn StatisticsGetRelation(statId: Oid, missing_ok: bool) -> Oid;
    pub fn DefineAggregate(
        pstate: *mut ParseState,
        name: *mut List,
        args: *mut List,
        oldstyle: bool,
        parameters: *mut List,
        replace: bool,
    ) -> ObjectAddress;
    pub fn DefineOpClass(stmt: *mut CreateOpClassStmt) -> ObjectAddress;
    pub fn DefineOpFamily(stmt: *mut CreateOpFamilyStmt) -> ObjectAddress;
    pub fn AlterOpFamily(stmt: *mut AlterOpFamilyStmt) -> Oid;
    pub fn IsThereOpClassInNamespace(
        opcname: *const ::core::ffi::c_char,
        opcmethod: Oid,
        opcnamespace: Oid,
    );
    pub fn IsThereOpFamilyInNamespace(
        opfname: *const ::core::ffi::c_char,
        opfmethod: Oid,
        opfnamespace: Oid,
    );
    pub fn get_opclass_oid(amID: Oid, opclassname: *mut List, missing_ok: bool) -> Oid;
    pub fn get_opfamily_oid(amID: Oid, opfamilyname: *mut List, missing_ok: bool) -> Oid;
    pub fn DefineTSParser(names: *mut List, parameters: *mut List) -> ObjectAddress;
    pub fn DefineTSDictionary(names: *mut List, parameters: *mut List) -> ObjectAddress;
    pub fn AlterTSDictionary(stmt: *mut AlterTSDictionaryStmt) -> ObjectAddress;
    pub fn DefineTSTemplate(names: *mut List, parameters: *mut List) -> ObjectAddress;
    pub fn DefineTSConfiguration(
        names: *mut List,
        parameters: *mut List,
        copied: *mut ObjectAddress,
    ) -> ObjectAddress;
    pub fn RemoveTSConfigurationById(cfgId: Oid);
    pub fn AlterTSConfiguration(stmt: *mut AlterTSConfigurationStmt) -> ObjectAddress;
    pub fn serialize_deflist(deflist: *mut List) -> *mut text;
    pub fn deserialize_deflist(txt: Datum) -> *mut List;
    pub fn AlterForeignServerOwner(
        name: *const ::core::ffi::c_char,
        newOwnerId: Oid,
    ) -> ObjectAddress;
    pub fn AlterForeignServerOwner_oid(arg1: Oid, newOwnerId: Oid);
    pub fn AlterForeignDataWrapperOwner(
        name: *const ::core::ffi::c_char,
        newOwnerId: Oid,
    ) -> ObjectAddress;
    pub fn AlterForeignDataWrapperOwner_oid(fwdId: Oid, newOwnerId: Oid);
    pub fn CreateForeignDataWrapper(
        pstate: *mut ParseState,
        stmt: *mut CreateFdwStmt,
    ) -> ObjectAddress;
    pub fn AlterForeignDataWrapper(
        pstate: *mut ParseState,
        stmt: *mut AlterFdwStmt,
    ) -> ObjectAddress;
    pub fn CreateForeignServer(stmt: *mut CreateForeignServerStmt) -> ObjectAddress;
    pub fn AlterForeignServer(stmt: *mut AlterForeignServerStmt) -> ObjectAddress;
    pub fn CreateUserMapping(stmt: *mut CreateUserMappingStmt) -> ObjectAddress;
    pub fn AlterUserMapping(stmt: *mut AlterUserMappingStmt) -> ObjectAddress;
    pub fn RemoveUserMapping(stmt: *mut DropUserMappingStmt) -> Oid;
    pub fn CreateForeignTable(stmt: *mut CreateForeignTableStmt, relid: Oid);
    pub fn ImportForeignSchema(stmt: *mut ImportForeignSchemaStmt);
    pub fn transformGenericOptions(
        catalogId: Oid,
        oldOptions: Datum,
        options: *mut List,
        fdwvalidator: Oid,
    ) -> Datum;
    pub fn CreateAccessMethod(stmt: *mut CreateAmStmt) -> ObjectAddress;
    pub fn get_index_am_oid(amname: *const ::core::ffi::c_char, missing_ok: bool) -> Oid;
    pub fn get_table_am_oid(amname: *const ::core::ffi::c_char, missing_ok: bool) -> Oid;
    pub fn get_am_oid(amname: *const ::core::ffi::c_char, missing_ok: bool) -> Oid;
    pub fn get_am_name(amOid: Oid) -> *mut ::core::ffi::c_char;
    pub fn defGetString(def: *mut DefElem) -> *mut ::core::ffi::c_char;
    pub fn defGetNumeric(def: *mut DefElem) -> f64;
    pub fn defGetBoolean(def: *mut DefElem) -> bool;
    pub fn defGetInt32(def: *mut DefElem) -> int32;
    pub fn defGetInt64(def: *mut DefElem) -> int64;
    pub fn defGetObjectId(def: *mut DefElem) -> Oid;
    pub fn defGetQualifiedName(def: *mut DefElem) -> *mut List;
    pub fn defGetTypeName(def: *mut DefElem) -> *mut TypeName;
    pub fn defGetTypeLength(def: *mut DefElem) -> ::core::ffi::c_int;
    pub fn defGetStringList(def: *mut DefElem) -> *mut List;
    pub fn errorConflictingDefElem(defel: *mut DefElem, pstate: *mut ParseState) -> !;
    pub static mut event_triggers: bool;
    pub fn CreateEventTrigger(stmt: *mut CreateEventTrigStmt) -> Oid;
    pub fn get_event_trigger_oid(trigname: *const ::core::ffi::c_char, missing_ok: bool) -> Oid;
    pub fn AlterEventTrigger(stmt: *mut AlterEventTrigStmt) -> Oid;
    pub fn AlterEventTriggerOwner(
        name: *const ::core::ffi::c_char,
        newOwnerId: Oid,
    ) -> ObjectAddress;
    pub fn AlterEventTriggerOwner_oid(arg1: Oid, newOwnerId: Oid);
    pub fn EventTriggerSupportsObjectType(obtype: ObjectType::Type) -> bool;
    pub fn EventTriggerSupportsObject(object: *const ObjectAddress) -> bool;
    pub fn EventTriggerDDLCommandStart(parsetree: *mut Node);
    pub fn EventTriggerDDLCommandEnd(parsetree: *mut Node);
    pub fn EventTriggerSQLDrop(parsetree: *mut Node);
    pub fn EventTriggerTableRewrite(
        parsetree: *mut Node,
        tableOid: Oid,
        reason: ::core::ffi::c_int,
    );
    pub fn EventTriggerOnLogin();
    pub fn EventTriggerBeginCompleteQuery() -> bool;
    pub fn EventTriggerEndCompleteQuery();
    pub fn trackDroppedObjectsNeeded() -> bool;
    pub fn EventTriggerSQLDropAddObject(object: *const ObjectAddress, original: bool, normal: bool);
    pub fn EventTriggerInhibitCommandCollection();
    pub fn EventTriggerUndoInhibitCommandCollection();
    pub fn EventTriggerCollectSimpleCommand(
        address: ObjectAddress,
        secondaryObject: ObjectAddress,
        parsetree: *mut Node,
    );
    pub fn EventTriggerAlterTableStart(parsetree: *mut Node);
    pub fn EventTriggerAlterTableRelid(objectId: Oid);
    pub fn EventTriggerCollectAlterTableSubcmd(subcmd: *mut Node, address: ObjectAddress);
    pub fn EventTriggerAlterTableEnd();
    pub fn EventTriggerCollectGrant(istmt: *mut InternalGrant);
    pub fn EventTriggerCollectAlterOpFam(
        stmt: *mut AlterOpFamilyStmt,
        opfamoid: Oid,
        operators: *mut List,
        procedures: *mut List,
    );
    pub fn EventTriggerCollectCreateOpClass(
        stmt: *mut CreateOpClassStmt,
        opcoid: Oid,
        operators: *mut List,
        procedures: *mut List,
    );
    pub fn EventTriggerCollectAlterTSConfig(
        stmt: *mut AlterTSConfigurationStmt,
        cfgId: Oid,
        dictIds: *mut Oid,
        ndicts: ::core::ffi::c_int,
    );
    pub fn EventTriggerCollectAlterDefPrivs(stmt: *mut AlterDefaultPrivilegesStmt);
    pub static mut ExplainOneQuery_hook: ExplainOneQuery_hook_type;
    pub static mut explain_get_index_name_hook: explain_get_index_name_hook_type;
    pub fn ExplainQuery(
        pstate: *mut ParseState,
        stmt: *mut ExplainStmt,
        params: ParamListInfo,
        dest: *mut DestReceiver,
    );
    pub fn standard_ExplainOneQuery(
        query: *mut Query,
        cursorOptions: ::core::ffi::c_int,
        into: *mut IntoClause,
        es: *mut ExplainState,
        queryString: *const ::core::ffi::c_char,
        params: ParamListInfo,
        queryEnv: *mut QueryEnvironment,
    );
    pub fn NewExplainState() -> *mut ExplainState;
    pub fn ExplainResultDesc(stmt: *mut ExplainStmt) -> TupleDesc;
    pub fn ExplainOneUtility(
        utilityStmt: *mut Node,
        into: *mut IntoClause,
        es: *mut ExplainState,
        queryString: *const ::core::ffi::c_char,
        params: ParamListInfo,
        queryEnv: *mut QueryEnvironment,
    );
    pub fn ExplainOnePlan(
        plannedstmt: *mut PlannedStmt,
        into: *mut IntoClause,
        es: *mut ExplainState,
        queryString: *const ::core::ffi::c_char,
        params: ParamListInfo,
        queryEnv: *mut QueryEnvironment,
        planduration: *const instr_time,
        bufusage: *const BufferUsage,
        mem_counters: *const MemoryContextCounters,
    );
    pub fn ExplainPrintPlan(es: *mut ExplainState, queryDesc: *mut QueryDesc);
    pub fn ExplainPrintTriggers(es: *mut ExplainState, queryDesc: *mut QueryDesc);
    pub fn ExplainPrintJITSummary(es: *mut ExplainState, queryDesc: *mut QueryDesc);
    pub fn ExplainQueryText(es: *mut ExplainState, queryDesc: *mut QueryDesc);
    pub fn ExplainQueryParameters(
        es: *mut ExplainState,
        params: ParamListInfo,
        maxlen: ::core::ffi::c_int,
    );
    pub fn ExplainBeginOutput(es: *mut ExplainState);
    pub fn ExplainEndOutput(es: *mut ExplainState);
    pub fn ExplainSeparatePlans(es: *mut ExplainState);
    pub fn ExplainPropertyList(
        qlabel: *const ::core::ffi::c_char,
        data: *mut List,
        es: *mut ExplainState,
    );
    pub fn ExplainPropertyListNested(
        qlabel: *const ::core::ffi::c_char,
        data: *mut List,
        es: *mut ExplainState,
    );
    pub fn ExplainPropertyText(
        qlabel: *const ::core::ffi::c_char,
        value: *const ::core::ffi::c_char,
        es: *mut ExplainState,
    );
    pub fn ExplainPropertyInteger(
        qlabel: *const ::core::ffi::c_char,
        unit: *const ::core::ffi::c_char,
        value: int64,
        es: *mut ExplainState,
    );
    pub fn ExplainPropertyUInteger(
        qlabel: *const ::core::ffi::c_char,
        unit: *const ::core::ffi::c_char,
        value: uint64,
        es: *mut ExplainState,
    );
    pub fn ExplainPropertyFloat(
        qlabel: *const ::core::ffi::c_char,
        unit: *const ::core::ffi::c_char,
        value: f64,
        ndigits: ::core::ffi::c_int,
        es: *mut ExplainState,
    );
    pub fn ExplainPropertyBool(
        qlabel: *const ::core::ffi::c_char,
        value: bool,
        es: *mut ExplainState,
    );
    pub fn ExplainOpenGroup(
        objtype: *const ::core::ffi::c_char,
        labelname: *const ::core::ffi::c_char,
        labeled: bool,
        es: *mut ExplainState,
    );
    pub fn ExplainCloseGroup(
        objtype: *const ::core::ffi::c_char,
        labelname: *const ::core::ffi::c_char,
        labeled: bool,
        es: *mut ExplainState,
    );
    pub fn CreateExplainSerializeDestReceiver(es: *mut ExplainState) -> *mut DestReceiver;
    pub static mut creating_extension: bool;
    pub static mut CurrentExtensionObject: Oid;
    pub fn CreateExtension(
        pstate: *mut ParseState,
        stmt: *mut CreateExtensionStmt,
    ) -> ObjectAddress;
    pub fn RemoveExtensionById(extId: Oid);
    pub fn InsertExtensionTuple(
        extName: *const ::core::ffi::c_char,
        extOwner: Oid,
        schemaOid: Oid,
        relocatable: bool,
        extVersion: *const ::core::ffi::c_char,
        extConfig: Datum,
        extCondition: Datum,
        requiredExtensions: *mut List,
    ) -> ObjectAddress;
    pub fn ExecAlterExtensionStmt(
        pstate: *mut ParseState,
        stmt: *mut AlterExtensionStmt,
    ) -> ObjectAddress;
    pub fn ExecAlterExtensionContentsStmt(
        stmt: *mut AlterExtensionContentsStmt,
        objAddr: *mut ObjectAddress,
    ) -> ObjectAddress;
    pub fn get_extension_oid(extname: *const ::core::ffi::c_char, missing_ok: bool) -> Oid;
    pub fn get_extension_name(ext_oid: Oid) -> *mut ::core::ffi::c_char;
    pub fn get_extension_schema(ext_oid: Oid) -> Oid;
    pub fn extension_file_exists(extensionName: *const ::core::ffi::c_char) -> bool;
    pub fn AlterExtensionNamespace(
        extensionName: *const ::core::ffi::c_char,
        newschema: *const ::core::ffi::c_char,
        oldschema: *mut Oid,
    ) -> ObjectAddress;
    pub static mut plan_cache_mode: ::core::ffi::c_int;
    pub fn InitPlanCache();
    pub fn ResetPlanCache();
    pub fn ReleaseAllPlanCacheRefsInOwner(owner: ResourceOwner);
    pub fn CreateCachedPlan(
        raw_parse_tree: *mut RawStmt,
        query_string: *const ::core::ffi::c_char,
        commandTag: CommandTag::Type,
    ) -> *mut CachedPlanSource;
    pub fn CreateOneShotCachedPlan(
        raw_parse_tree: *mut RawStmt,
        query_string: *const ::core::ffi::c_char,
        commandTag: CommandTag::Type,
    ) -> *mut CachedPlanSource;
    pub fn CompleteCachedPlan(
        plansource: *mut CachedPlanSource,
        querytree_list: *mut List,
        querytree_context: MemoryContext,
        param_types: *mut Oid,
        num_params: ::core::ffi::c_int,
        parserSetup: ParserSetupHook,
        parserSetupArg: *mut ::core::ffi::c_void,
        cursor_options: ::core::ffi::c_int,
        fixed_result: bool,
    );
    pub fn SaveCachedPlan(plansource: *mut CachedPlanSource);
    pub fn DropCachedPlan(plansource: *mut CachedPlanSource);
    pub fn CachedPlanSetParentContext(plansource: *mut CachedPlanSource, newcontext: MemoryContext);
    pub fn CopyCachedPlan(plansource: *mut CachedPlanSource) -> *mut CachedPlanSource;
    pub fn CachedPlanIsValid(plansource: *mut CachedPlanSource) -> bool;
    pub fn CachedPlanGetTargetList(
        plansource: *mut CachedPlanSource,
        queryEnv: *mut QueryEnvironment,
    ) -> *mut List;
    pub fn GetCachedPlan(
        plansource: *mut CachedPlanSource,
        boundParams: ParamListInfo,
        owner: ResourceOwner,
        queryEnv: *mut QueryEnvironment,
    ) -> *mut CachedPlan;
    pub fn ReleaseCachedPlan(plan: *mut CachedPlan, owner: ResourceOwner);
    pub fn CachedPlanAllowsSimpleValidityCheck(
        plansource: *mut CachedPlanSource,
        plan: *mut CachedPlan,
        owner: ResourceOwner,
    ) -> bool;
    pub fn CachedPlanIsSimplyValid(
        plansource: *mut CachedPlanSource,
        plan: *mut CachedPlan,
        owner: ResourceOwner,
    ) -> bool;
    pub fn GetCachedExpression(expr: *mut Node) -> *mut CachedExpression;
    pub fn FreeCachedExpression(cexpr: *mut CachedExpression);
    pub fn PrepareQuery(
        pstate: *mut ParseState,
        stmt: *mut PrepareStmt,
        stmt_location: ::core::ffi::c_int,
        stmt_len: ::core::ffi::c_int,
    );
    pub fn ExecuteQuery(
        pstate: *mut ParseState,
        stmt: *mut ExecuteStmt,
        intoClause: *mut IntoClause,
        params: ParamListInfo,
        dest: *mut DestReceiver,
        qc: *mut QueryCompletion,
    );
    pub fn DeallocateQuery(stmt: *mut DeallocateStmt);
    pub fn ExplainExecuteQuery(
        execstmt: *mut ExecuteStmt,
        into: *mut IntoClause,
        es: *mut ExplainState,
        queryString: *const ::core::ffi::c_char,
        params: ParamListInfo,
        queryEnv: *mut QueryEnvironment,
    );
    pub fn StorePreparedStatement(
        stmt_name: *const ::core::ffi::c_char,
        plansource: *mut CachedPlanSource,
        from_sql: bool,
    );
    pub fn FetchPreparedStatement(
        stmt_name: *const ::core::ffi::c_char,
        throwError: bool,
    ) -> *mut PreparedStatement;
    pub fn DropPreparedStatement(stmt_name: *const ::core::ffi::c_char, showError: bool);
    pub fn FetchPreparedStatementResultDesc(stmt: *mut PreparedStatement) -> TupleDesc;
    pub fn FetchPreparedStatementTargetList(stmt: *mut PreparedStatement) -> *mut List;
    pub fn DropAllPreparedStatements();
    pub fn CreateProceduralLanguage(stmt: *mut CreatePLangStmt) -> ObjectAddress;
    pub fn get_language_oid(langname: *const ::core::ffi::c_char, missing_ok: bool) -> Oid;
    pub fn GetSecurityLabel(
        object: *const ObjectAddress,
        provider: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn SetSecurityLabel(
        object: *const ObjectAddress,
        provider: *const ::core::ffi::c_char,
        label: *const ::core::ffi::c_char,
    );
    pub fn DeleteSecurityLabel(object: *const ObjectAddress);
    pub fn DeleteSharedSecurityLabel(objectId: Oid, classId: Oid);
    pub fn ExecSecLabelStmt(stmt: *mut SecLabelStmt) -> ObjectAddress;
    pub fn register_label_provider(
        provider_name: *const ::core::ffi::c_char,
        hook: check_object_relabel_type,
    );
    pub static mut allow_in_place_tablespaces: bool;
    pub fn CreateTableSpace(stmt: *mut CreateTableSpaceStmt) -> Oid;
    pub fn DropTableSpace(stmt: *mut DropTableSpaceStmt);
    pub fn RenameTableSpace(
        oldname: *const ::core::ffi::c_char,
        newname: *const ::core::ffi::c_char,
    ) -> ObjectAddress;
    pub fn AlterTableSpaceOptions(stmt: *mut AlterTableSpaceOptionsStmt) -> Oid;
    pub fn TablespaceCreateDbspace(spcOid: Oid, dbOid: Oid, isRedo: bool);
    pub fn GetDefaultTablespace(relpersistence: ::core::ffi::c_char, partitioned: bool) -> Oid;
    pub fn PrepareTempTablespaces();
    pub fn get_tablespace_oid(tablespacename: *const ::core::ffi::c_char, missing_ok: bool) -> Oid;
    pub fn get_tablespace_name(spc_oid: Oid) -> *mut ::core::ffi::c_char;
    pub fn directory_is_empty(path: *const ::core::ffi::c_char) -> bool;
    pub fn remove_tablespace_symlink(linkloc: *const ::core::ffi::c_char);
    pub fn tblspc_redo(record: *mut XLogReaderState);
    pub fn tblspc_desc(buf: StringInfo, record: *mut XLogReaderState);
    pub fn tblspc_identify(info: uint8) -> *const ::core::ffi::c_char;
    pub fn DefineRelation(
        stmt: *mut CreateStmt,
        relkind: ::core::ffi::c_char,
        ownerId: Oid,
        typaddress: *mut ObjectAddress,
        queryString: *const ::core::ffi::c_char,
    ) -> ObjectAddress;
    pub fn BuildDescForRelation(columns: *const List) -> TupleDesc;
    pub fn RemoveRelations(drop: *mut DropStmt);
    pub fn AlterTableLookupRelation(stmt: *mut AlterTableStmt, lockmode: LOCKMODE) -> Oid;
    pub fn AlterTable(
        stmt: *mut AlterTableStmt,
        lockmode: LOCKMODE,
        context: *mut AlterTableUtilityContext,
    );
    pub fn AlterTableGetLockLevel(cmds: *mut List) -> LOCKMODE;
    pub fn ATExecChangeOwner(
        relationOid: Oid,
        newOwnerId: Oid,
        recursing: bool,
        lockmode: LOCKMODE,
    );
    pub fn AlterTableInternal(relid: Oid, cmds: *mut List, recurse: bool);
    pub fn AlterTableMoveAll(stmt: *mut AlterTableMoveAllStmt) -> Oid;
    pub fn AlterTableNamespace(
        stmt: *mut AlterObjectSchemaStmt,
        oldschema: *mut Oid,
    ) -> ObjectAddress;
    pub fn AlterTableNamespaceInternal(
        rel: Relation,
        oldNspOid: Oid,
        nspOid: Oid,
        objsMoved: *mut ObjectAddresses,
    );
    pub fn AlterRelationNamespaceInternal(
        classRel: Relation,
        relOid: Oid,
        oldNspOid: Oid,
        newNspOid: Oid,
        hasDependEntry: bool,
        objsMoved: *mut ObjectAddresses,
    );
    pub fn CheckTableNotInUse(rel: Relation, stmt: *const ::core::ffi::c_char);
    pub fn ExecuteTruncate(stmt: *mut TruncateStmt);
    pub fn ExecuteTruncateGuts(
        explicit_rels: *mut List,
        relids: *mut List,
        relids_logged: *mut List,
        behavior: DropBehavior::Type,
        restart_seqs: bool,
        run_as_table_owner: bool,
    );
    pub fn SetRelationHasSubclass(relationId: Oid, relhassubclass: bool);
    pub fn CheckRelationTableSpaceMove(rel: Relation, newTableSpaceId: Oid) -> bool;
    pub fn SetRelationTableSpace(
        rel: Relation,
        newTableSpaceId: Oid,
        newRelFilenumber: RelFileNumber,
    );
    pub fn renameatt(stmt: *mut RenameStmt) -> ObjectAddress;
    pub fn RenameConstraint(stmt: *mut RenameStmt) -> ObjectAddress;
    pub fn RenameRelation(stmt: *mut RenameStmt) -> ObjectAddress;
    pub fn RenameRelationInternal(
        myrelid: Oid,
        newrelname: *const ::core::ffi::c_char,
        is_internal: bool,
        is_index: bool,
    );
    pub fn ResetRelRewrite(myrelid: Oid);
    pub fn find_composite_type_dependencies(
        typeOid: Oid,
        origRelation: Relation,
        origTypeName: *const ::core::ffi::c_char,
    );
    pub fn check_of_type(typetuple: HeapTuple);
    pub fn register_on_commit_action(relid: Oid, action: OnCommitAction::Type);
    pub fn remove_on_commit_action(relid: Oid);
    pub fn PreCommit_on_commit_actions();
    pub fn AtEOXact_on_commit_actions(isCommit: bool);
    pub fn AtEOSubXact_on_commit_actions(
        isCommit: bool,
        mySubid: SubTransactionId,
        parentSubid: SubTransactionId,
    );
    pub fn RangeVarCallbackMaintainsTable(
        relation: *const RangeVar,
        relId: Oid,
        oldRelId: Oid,
        arg: *mut ::core::ffi::c_void,
    );
    pub fn RangeVarCallbackOwnsRelation(
        relation: *const RangeVar,
        relId: Oid,
        oldRelId: Oid,
        arg: *mut ::core::ffi::c_void,
    );
    pub fn PartConstraintImpliedByRelConstraint(
        scanrel: Relation,
        partConstraint: *mut List,
    ) -> bool;
    pub static mut SessionReplicationRole: ::core::ffi::c_int;
    pub fn CreateTrigger(
        stmt: *mut CreateTrigStmt,
        queryString: *const ::core::ffi::c_char,
        relOid: Oid,
        refRelOid: Oid,
        constraintOid: Oid,
        indexOid: Oid,
        funcoid: Oid,
        parentTriggerOid: Oid,
        whenClause: *mut Node,
        isInternal: bool,
        in_partition: bool,
    ) -> ObjectAddress;
    pub fn CreateTriggerFiringOn(
        stmt: *mut CreateTrigStmt,
        queryString: *const ::core::ffi::c_char,
        relOid: Oid,
        refRelOid: Oid,
        constraintOid: Oid,
        indexOid: Oid,
        funcoid: Oid,
        parentTriggerOid: Oid,
        whenClause: *mut Node,
        isInternal: bool,
        in_partition: bool,
        trigger_fires_when: ::core::ffi::c_char,
    ) -> ObjectAddress;
    pub fn TriggerSetParentTrigger(
        trigRel: Relation,
        childTrigId: Oid,
        parentTrigId: Oid,
        childTableId: Oid,
    );
    pub fn RemoveTriggerById(trigOid: Oid);
    pub fn get_trigger_oid(
        relid: Oid,
        trigname: *const ::core::ffi::c_char,
        missing_ok: bool,
    ) -> Oid;
    pub fn renametrig(stmt: *mut RenameStmt) -> ObjectAddress;
    pub fn EnableDisableTrigger(
        rel: Relation,
        tgname: *const ::core::ffi::c_char,
        tgparent: Oid,
        fires_when: ::core::ffi::c_char,
        skip_system: bool,
        recurse: bool,
        lockmode: LOCKMODE,
    );
    pub fn RelationBuildTriggers(relation: Relation);
    pub fn CopyTriggerDesc(trigdesc: *mut TriggerDesc) -> *mut TriggerDesc;
    pub fn FindTriggerIncompatibleWithInheritance(
        trigdesc: *mut TriggerDesc,
    ) -> *const ::core::ffi::c_char;
    pub fn MakeTransitionCaptureState(
        trigdesc: *mut TriggerDesc,
        relid: Oid,
        cmdType: CmdType::Type,
    ) -> *mut TransitionCaptureState;
    pub fn FreeTriggerDesc(trigdesc: *mut TriggerDesc);
    pub fn ExecBSInsertTriggers(estate: *mut EState, relinfo: *mut ResultRelInfo);
    pub fn ExecASInsertTriggers(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
        transition_capture: *mut TransitionCaptureState,
    );
    pub fn ExecBRInsertTriggers(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
        slot: *mut TupleTableSlot,
    ) -> bool;
    pub fn ExecARInsertTriggers(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
        slot: *mut TupleTableSlot,
        recheckIndexes: *mut List,
        transition_capture: *mut TransitionCaptureState,
    );
    pub fn ExecIRInsertTriggers(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
        slot: *mut TupleTableSlot,
    ) -> bool;
    pub fn ExecBSDeleteTriggers(estate: *mut EState, relinfo: *mut ResultRelInfo);
    pub fn ExecASDeleteTriggers(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
        transition_capture: *mut TransitionCaptureState,
    );
    pub fn ExecBRDeleteTriggers(
        estate: *mut EState,
        epqstate: *mut EPQState,
        relinfo: *mut ResultRelInfo,
        tupleid: ItemPointer,
        fdw_trigtuple: HeapTuple,
        epqslot: *mut *mut TupleTableSlot,
        tmresult: *mut TM_Result::Type,
        tmfd: *mut TM_FailureData,
    ) -> bool;
    pub fn ExecARDeleteTriggers(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
        tupleid: ItemPointer,
        fdw_trigtuple: HeapTuple,
        transition_capture: *mut TransitionCaptureState,
        is_crosspart_update: bool,
    );
    pub fn ExecIRDeleteTriggers(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
        trigtuple: HeapTuple,
    ) -> bool;
    pub fn ExecBSUpdateTriggers(estate: *mut EState, relinfo: *mut ResultRelInfo);
    pub fn ExecASUpdateTriggers(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
        transition_capture: *mut TransitionCaptureState,
    );
    pub fn ExecBRUpdateTriggers(
        estate: *mut EState,
        epqstate: *mut EPQState,
        relinfo: *mut ResultRelInfo,
        tupleid: ItemPointer,
        fdw_trigtuple: HeapTuple,
        newslot: *mut TupleTableSlot,
        tmresult: *mut TM_Result::Type,
        tmfd: *mut TM_FailureData,
    ) -> bool;
    pub fn ExecARUpdateTriggers(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
        src_partinfo: *mut ResultRelInfo,
        dst_partinfo: *mut ResultRelInfo,
        tupleid: ItemPointer,
        fdw_trigtuple: HeapTuple,
        newslot: *mut TupleTableSlot,
        recheckIndexes: *mut List,
        transition_capture: *mut TransitionCaptureState,
        is_crosspart_update: bool,
    );
    pub fn ExecIRUpdateTriggers(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
        trigtuple: HeapTuple,
        newslot: *mut TupleTableSlot,
    ) -> bool;
    pub fn ExecBSTruncateTriggers(estate: *mut EState, relinfo: *mut ResultRelInfo);
    pub fn ExecASTruncateTriggers(estate: *mut EState, relinfo: *mut ResultRelInfo);
    pub fn AfterTriggerBeginXact();
    pub fn AfterTriggerBeginQuery();
    pub fn AfterTriggerEndQuery(estate: *mut EState);
    pub fn AfterTriggerFireDeferred();
    pub fn AfterTriggerEndXact(isCommit: bool);
    pub fn AfterTriggerBeginSubXact();
    pub fn AfterTriggerEndSubXact(isCommit: bool);
    pub fn AfterTriggerSetState(stmt: *mut ConstraintsSetStmt);
    pub fn AfterTriggerPendingOnRel(relid: Oid) -> bool;
    pub fn RI_FKey_pk_upd_check_required(
        trigger: *mut Trigger,
        pk_rel: Relation,
        oldslot: *mut TupleTableSlot,
        newslot: *mut TupleTableSlot,
    ) -> bool;
    pub fn RI_FKey_fk_upd_check_required(
        trigger: *mut Trigger,
        fk_rel: Relation,
        oldslot: *mut TupleTableSlot,
        newslot: *mut TupleTableSlot,
    ) -> bool;
    pub fn RI_Initial_Check(trigger: *mut Trigger, fk_rel: Relation, pk_rel: Relation) -> bool;
    pub fn RI_PartitionRemove_Check(trigger: *mut Trigger, fk_rel: Relation, pk_rel: Relation);
    pub fn RI_FKey_trigger_type(tgfoid: Oid) -> ::core::ffi::c_int;
    pub fn get_password_type(shadow_pass: *const ::core::ffi::c_char) -> PasswordType::Type;
    pub fn encrypt_password(
        target_type: PasswordType::Type,
        role: *const ::core::ffi::c_char,
        password: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn get_role_password(
        role: *const ::core::ffi::c_char,
        logdetail: *mut *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn md5_crypt_verify(
        role: *const ::core::ffi::c_char,
        shadow_pass: *const ::core::ffi::c_char,
        client_pass: *const ::core::ffi::c_char,
        md5_salt: *const ::core::ffi::c_char,
        md5_salt_len: ::core::ffi::c_int,
        logdetail: *mut *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn plain_crypt_verify(
        role: *const ::core::ffi::c_char,
        shadow_pass: *const ::core::ffi::c_char,
        client_pass: *const ::core::ffi::c_char,
        logdetail: *mut *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn ParseConfigFile(
        config_file: *const ::core::ffi::c_char,
        strict: bool,
        calling_file: *const ::core::ffi::c_char,
        calling_lineno: ::core::ffi::c_int,
        depth: ::core::ffi::c_int,
        elevel: ::core::ffi::c_int,
        head_p: *mut *mut ConfigVariable,
        tail_p: *mut *mut ConfigVariable,
    ) -> bool;
    pub fn ParseConfigFp(
        fp: *mut FILE,
        config_file: *const ::core::ffi::c_char,
        depth: ::core::ffi::c_int,
        elevel: ::core::ffi::c_int,
        head_p: *mut *mut ConfigVariable,
        tail_p: *mut *mut ConfigVariable,
    ) -> bool;
    pub fn ParseConfigDirectory(
        includedir: *const ::core::ffi::c_char,
        calling_file: *const ::core::ffi::c_char,
        calling_lineno: ::core::ffi::c_int,
        depth: ::core::ffi::c_int,
        elevel: ::core::ffi::c_int,
        head_p: *mut *mut ConfigVariable,
        tail_p: *mut *mut ConfigVariable,
    ) -> bool;
    pub fn FreeConfigVariables(list: *mut ConfigVariable);
    pub fn DeescapeQuotedString(s: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub static mut Debug_print_plan: bool;
    pub static mut Debug_print_parse: bool;
    pub static mut Debug_print_rewritten: bool;
    pub static mut Debug_pretty_print: bool;
    pub static mut log_parser_stats: bool;
    pub static mut log_planner_stats: bool;
    pub static mut log_executor_stats: bool;
    pub static mut log_statement_stats: bool;
    pub static mut log_btree_build_stats: bool;
    pub static mut check_function_bodies: bool;
    pub static mut current_role_is_superuser: bool;
    pub static mut AllowAlterSystem: bool;
    pub static mut log_duration: bool;
    pub static mut log_parameter_max_length: ::core::ffi::c_int;
    pub static mut log_parameter_max_length_on_error: ::core::ffi::c_int;
    pub static mut log_min_error_statement: ::core::ffi::c_int;
    pub static mut log_min_messages: ::core::ffi::c_int;
    pub static mut client_min_messages: ::core::ffi::c_int;
    pub static mut log_min_duration_sample: ::core::ffi::c_int;
    pub static mut log_min_duration_statement: ::core::ffi::c_int;
    pub static mut log_temp_files: ::core::ffi::c_int;
    pub static mut log_statement_sample_rate: f64;
    pub static mut log_xact_sample_rate: f64;
    pub static mut backtrace_functions: *mut ::core::ffi::c_char;
    pub static mut temp_file_limit: ::core::ffi::c_int;
    pub static mut num_temp_buffers: ::core::ffi::c_int;
    pub static mut cluster_name: *mut ::core::ffi::c_char;
    pub static mut ConfigFileName: *mut ::core::ffi::c_char;
    pub static mut HbaFileName: *mut ::core::ffi::c_char;
    pub static mut IdentFileName: *mut ::core::ffi::c_char;
    pub static mut external_pid_file: *mut ::core::ffi::c_char;
    pub static mut application_name: *mut ::core::ffi::c_char;
    pub static mut tcp_keepalives_idle: ::core::ffi::c_int;
    pub static mut tcp_keepalives_interval: ::core::ffi::c_int;
    pub static mut tcp_keepalives_count: ::core::ffi::c_int;
    pub static mut tcp_user_timeout: ::core::ffi::c_int;
    pub static mut trace_sort: bool;
    pub fn SetConfigOption(
        name: *const ::core::ffi::c_char,
        value: *const ::core::ffi::c_char,
        context: GucContext::Type,
        source: GucSource::Type,
    );
    pub fn DefineCustomBoolVariable(
        name: *const ::core::ffi::c_char,
        short_desc: *const ::core::ffi::c_char,
        long_desc: *const ::core::ffi::c_char,
        valueAddr: *mut bool,
        bootValue: bool,
        context: GucContext::Type,
        flags: ::core::ffi::c_int,
        check_hook: GucBoolCheckHook,
        assign_hook: GucBoolAssignHook,
        show_hook: GucShowHook,
    );
    pub fn DefineCustomIntVariable(
        name: *const ::core::ffi::c_char,
        short_desc: *const ::core::ffi::c_char,
        long_desc: *const ::core::ffi::c_char,
        valueAddr: *mut ::core::ffi::c_int,
        bootValue: ::core::ffi::c_int,
        minValue: ::core::ffi::c_int,
        maxValue: ::core::ffi::c_int,
        context: GucContext::Type,
        flags: ::core::ffi::c_int,
        check_hook: GucIntCheckHook,
        assign_hook: GucIntAssignHook,
        show_hook: GucShowHook,
    );
    pub fn DefineCustomRealVariable(
        name: *const ::core::ffi::c_char,
        short_desc: *const ::core::ffi::c_char,
        long_desc: *const ::core::ffi::c_char,
        valueAddr: *mut f64,
        bootValue: f64,
        minValue: f64,
        maxValue: f64,
        context: GucContext::Type,
        flags: ::core::ffi::c_int,
        check_hook: GucRealCheckHook,
        assign_hook: GucRealAssignHook,
        show_hook: GucShowHook,
    );
    pub fn DefineCustomStringVariable(
        name: *const ::core::ffi::c_char,
        short_desc: *const ::core::ffi::c_char,
        long_desc: *const ::core::ffi::c_char,
        valueAddr: *mut *mut ::core::ffi::c_char,
        bootValue: *const ::core::ffi::c_char,
        context: GucContext::Type,
        flags: ::core::ffi::c_int,
        check_hook: GucStringCheckHook,
        assign_hook: GucStringAssignHook,
        show_hook: GucShowHook,
    );
    pub fn DefineCustomEnumVariable(
        name: *const ::core::ffi::c_char,
        short_desc: *const ::core::ffi::c_char,
        long_desc: *const ::core::ffi::c_char,
        valueAddr: *mut ::core::ffi::c_int,
        bootValue: ::core::ffi::c_int,
        options: *const config_enum_entry,
        context: GucContext::Type,
        flags: ::core::ffi::c_int,
        check_hook: GucEnumCheckHook,
        assign_hook: GucEnumAssignHook,
        show_hook: GucShowHook,
    );
    pub fn MarkGUCPrefixReserved(className: *const ::core::ffi::c_char);
    pub fn GetConfigOption(
        name: *const ::core::ffi::c_char,
        missing_ok: bool,
        restrict_privileged: bool,
    ) -> *const ::core::ffi::c_char;
    pub fn GetConfigOptionResetString(
        name: *const ::core::ffi::c_char,
    ) -> *const ::core::ffi::c_char;
    pub fn GetConfigOptionFlags(
        name: *const ::core::ffi::c_char,
        missing_ok: bool,
    ) -> ::core::ffi::c_int;
    pub fn ProcessConfigFile(context: GucContext::Type);
    pub fn convert_GUC_name_for_parameter_acl(
        name: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn check_GUC_name_for_parameter_acl(name: *const ::core::ffi::c_char);
    pub fn InitializeGUCOptions();
    pub fn SelectConfigFiles(
        userDoption: *const ::core::ffi::c_char,
        progname: *const ::core::ffi::c_char,
    ) -> bool;
    pub fn ResetAllOptions();
    pub fn AtStart_GUC();
    pub fn NewGUCNestLevel() -> ::core::ffi::c_int;
    pub fn RestrictSearchPath();
    pub fn AtEOXact_GUC(isCommit: bool, nestLevel: ::core::ffi::c_int);
    pub fn BeginReportingGUCOptions();
    pub fn ReportChangedGUCOptions();
    pub fn ParseLongOption(
        string: *const ::core::ffi::c_char,
        name: *mut *mut ::core::ffi::c_char,
        value: *mut *mut ::core::ffi::c_char,
    );
    pub fn get_config_unit_name(flags: ::core::ffi::c_int) -> *const ::core::ffi::c_char;
    pub fn parse_int(
        value: *const ::core::ffi::c_char,
        result: *mut ::core::ffi::c_int,
        flags: ::core::ffi::c_int,
        hintmsg: *mut *const ::core::ffi::c_char,
    ) -> bool;
    pub fn parse_real(
        value: *const ::core::ffi::c_char,
        result: *mut f64,
        flags: ::core::ffi::c_int,
        hintmsg: *mut *const ::core::ffi::c_char,
    ) -> bool;
    pub fn set_config_option(
        name: *const ::core::ffi::c_char,
        value: *const ::core::ffi::c_char,
        context: GucContext::Type,
        source: GucSource::Type,
        action: GucAction::Type,
        changeVal: bool,
        elevel: ::core::ffi::c_int,
        is_reload: bool,
    ) -> ::core::ffi::c_int;
    pub fn set_config_option_ext(
        name: *const ::core::ffi::c_char,
        value: *const ::core::ffi::c_char,
        context: GucContext::Type,
        source: GucSource::Type,
        srole: Oid,
        action: GucAction::Type,
        changeVal: bool,
        elevel: ::core::ffi::c_int,
        is_reload: bool,
    ) -> ::core::ffi::c_int;
    pub fn set_config_with_handle(
        name: *const ::core::ffi::c_char,
        handle: *mut config_handle,
        value: *const ::core::ffi::c_char,
        context: GucContext::Type,
        source: GucSource::Type,
        srole: Oid,
        action: GucAction::Type,
        changeVal: bool,
        elevel: ::core::ffi::c_int,
        is_reload: bool,
    ) -> ::core::ffi::c_int;
    pub fn get_config_handle(name: *const ::core::ffi::c_char) -> *mut config_handle;
    pub fn AlterSystemSetConfigFile(altersysstmt: *mut AlterSystemStmt);
    pub fn GetConfigOptionByName(
        name: *const ::core::ffi::c_char,
        varname: *mut *const ::core::ffi::c_char,
        missing_ok: bool,
    ) -> *mut ::core::ffi::c_char;
    pub fn TransformGUCArray(array: *mut ArrayType, names: *mut *mut List, values: *mut *mut List);
    pub fn ProcessGUCArray(
        array: *mut ArrayType,
        context: GucContext::Type,
        source: GucSource::Type,
        action: GucAction::Type,
    );
    pub fn GUCArrayAdd(
        array: *mut ArrayType,
        name: *const ::core::ffi::c_char,
        value: *const ::core::ffi::c_char,
    ) -> *mut ArrayType;
    pub fn GUCArrayDelete(
        array: *mut ArrayType,
        name: *const ::core::ffi::c_char,
    ) -> *mut ArrayType;
    pub fn GUCArrayReset(array: *mut ArrayType) -> *mut ArrayType;
    pub fn guc_malloc(elevel: ::core::ffi::c_int, size: usize) -> *mut ::core::ffi::c_void;
    pub fn guc_realloc(
        elevel: ::core::ffi::c_int,
        old: *mut ::core::ffi::c_void,
        size: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn guc_strdup(
        elevel: ::core::ffi::c_int,
        src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn guc_free(ptr: *mut ::core::ffi::c_void);
    pub fn EstimateGUCStateSpace() -> Size;
    pub fn SerializeGUCState(maxsize: Size, start_address: *mut ::core::ffi::c_char);
    pub fn RestoreGUCState(gucstate: *mut ::core::ffi::c_void);
    pub fn ExecSetVariableStmt(stmt: *mut VariableSetStmt, isTopLevel: bool);
    pub fn ExtractSetVariableArgs(stmt: *mut VariableSetStmt) -> *mut ::core::ffi::c_char;
    pub fn SetPGVariable(name: *const ::core::ffi::c_char, args: *mut List, is_local: bool);
    pub fn GetPGVariable(name: *const ::core::ffi::c_char, dest: *mut DestReceiver);
    pub fn GetPGVariableResultDesc(name: *const ::core::ffi::c_char) -> TupleDesc;
    pub static mut GUC_check_errmsg_string: *mut ::core::ffi::c_char;
    pub static mut GUC_check_errdetail_string: *mut ::core::ffi::c_char;
    pub static mut GUC_check_errhint_string: *mut ::core::ffi::c_char;
    pub fn GUC_check_errcode(sqlerrcode: ::core::ffi::c_int);
    pub static mut Password_encryption: ::core::ffi::c_int;
    pub static mut createrole_self_grant: *mut ::core::ffi::c_char;
    pub static mut check_password_hook: check_password_hook_type;
    pub fn CreateRole(pstate: *mut ParseState, stmt: *mut CreateRoleStmt) -> Oid;
    pub fn AlterRole(pstate: *mut ParseState, stmt: *mut AlterRoleStmt) -> Oid;
    pub fn AlterRoleSet(stmt: *mut AlterRoleSetStmt) -> Oid;
    pub fn DropRole(stmt: *mut DropRoleStmt);
    pub fn GrantRole(pstate: *mut ParseState, stmt: *mut GrantRoleStmt);
    pub fn RenameRole(
        oldname: *const ::core::ffi::c_char,
        newname: *const ::core::ffi::c_char,
    ) -> ObjectAddress;
    pub fn DropOwnedObjects(stmt: *mut DropOwnedStmt);
    pub fn ReassignOwnedObjects(stmt: *mut ReassignOwnedStmt);
    pub fn roleSpecsToIds(memberNames: *mut List) -> *mut List;
    pub fn check_createrole_self_grant(
        newval: *mut *mut ::core::ffi::c_char,
        extra: *mut *mut ::core::ffi::c_void,
        source: GucSource::Type,
    ) -> bool;
    pub fn assign_createrole_self_grant(
        newval: *const ::core::ffi::c_char,
        extra: *mut ::core::ffi::c_void,
    );
    pub fn RegisterBackgroundWorker(worker: *mut BackgroundWorker);
    pub fn RegisterDynamicBackgroundWorker(
        worker: *mut BackgroundWorker,
        handle: *mut *mut BackgroundWorkerHandle,
    ) -> bool;
    pub fn GetBackgroundWorkerPid(
        handle: *mut BackgroundWorkerHandle,
        pidp: *mut pid_t,
    ) -> BgwHandleStatus::Type;
    pub fn WaitForBackgroundWorkerStartup(
        handle: *mut BackgroundWorkerHandle,
        pidp: *mut pid_t,
    ) -> BgwHandleStatus::Type;
    pub fn WaitForBackgroundWorkerShutdown(
        arg1: *mut BackgroundWorkerHandle,
    ) -> BgwHandleStatus::Type;
    pub fn GetBackgroundWorkerTypeByPid(pid: pid_t) -> *const ::core::ffi::c_char;
    pub fn TerminateBackgroundWorker(handle: *mut BackgroundWorkerHandle);
    pub static mut MyBgworkerEntry: *mut BackgroundWorker;
    pub fn BackgroundWorkerInitializeConnection(
        dbname: *const ::core::ffi::c_char,
        username: *const ::core::ffi::c_char,
        flags: uint32,
    );
    pub fn BackgroundWorkerInitializeConnectionByOid(dboid: Oid, useroid: Oid, flags: uint32);
    pub fn BackgroundWorkerBlockSignals();
    pub fn BackgroundWorkerUnblockSignals();
    pub fn TransactionIdSetTreeStatus(
        xid: TransactionId,
        nsubxids: ::core::ffi::c_int,
        subxids: *mut TransactionId,
        status: XidStatus,
        lsn: XLogRecPtr,
    );
    pub fn TransactionIdGetStatus(xid: TransactionId, lsn: *mut XLogRecPtr) -> XidStatus;
    pub fn CLOGShmemSize() -> Size;
    pub fn CLOGShmemInit();
    pub fn BootStrapCLOG();
    pub fn StartupCLOG();
    pub fn TrimCLOG();
    pub fn CheckPointCLOG();
    pub fn ExtendCLOG(newestXact: TransactionId);
    pub fn TruncateCLOG(oldestXact: TransactionId, oldestxid_datoid: Oid);
    pub fn clogsyncfiletag(
        ftag: *const FileTag,
        path: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn clog_redo(record: *mut XLogReaderState);
    pub fn clog_desc(buf: StringInfo, record: *mut XLogReaderState);
    pub fn clog_identify(info: uint8) -> *const ::core::ffi::c_char;
    pub fn InitializeLatchSupport();
    pub fn InitLatch(latch: *mut Latch);
    pub fn InitSharedLatch(latch: *mut Latch);
    pub fn OwnLatch(latch: *mut Latch);
    pub fn DisownLatch(latch: *mut Latch);
    pub fn SetLatch(latch: *mut Latch);
    pub fn ResetLatch(latch: *mut Latch);
    pub fn ShutdownLatchSupport();
    pub fn CreateWaitEventSet(
        resowner: ResourceOwner,
        nevents: ::core::ffi::c_int,
    ) -> *mut WaitEventSet;
    pub fn FreeWaitEventSet(set: *mut WaitEventSet);
    pub fn FreeWaitEventSetAfterFork(set: *mut WaitEventSet);
    pub fn AddWaitEventToSet(
        set: *mut WaitEventSet,
        events: uint32,
        fd: pgsocket,
        latch: *mut Latch,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn ModifyWaitEvent(
        set: *mut WaitEventSet,
        pos: ::core::ffi::c_int,
        events: uint32,
        latch: *mut Latch,
    );
    pub fn WaitEventSetWait(
        set: *mut WaitEventSet,
        timeout: ::core::ffi::c_long,
        occurred_events: *mut WaitEvent,
        nevents: ::core::ffi::c_int,
        wait_event_info: uint32,
    ) -> ::core::ffi::c_int;
    pub fn WaitLatch(
        latch: *mut Latch,
        wakeEvents: ::core::ffi::c_int,
        timeout: ::core::ffi::c_long,
        wait_event_info: uint32,
    ) -> ::core::ffi::c_int;
    pub fn WaitLatchOrSocket(
        latch: *mut Latch,
        wakeEvents: ::core::ffi::c_int,
        sock: pgsocket,
        timeout: ::core::ffi::c_long,
        wait_event_info: uint32,
    ) -> ::core::ffi::c_int;
    pub fn InitializeLatchWaitSet();
    pub fn GetNumRegisteredWaitEvents(set: *mut WaitEventSet) -> ::core::ffi::c_int;
    pub fn WaitEventSetCanReportClosed() -> bool;
    pub fn PGSemaphoreShmemSize(maxSemas: ::core::ffi::c_int) -> Size;
    pub fn PGReserveSemaphores(maxSemas: ::core::ffi::c_int);
    pub fn PGSemaphoreCreate() -> PGSemaphore;
    pub fn PGSemaphoreReset(sema: PGSemaphore);
    pub fn PGSemaphoreLock(sema: PGSemaphore);
    pub fn PGSemaphoreUnlock(sema: PGSemaphore);
    pub fn PGSemaphoreTryLock(sema: PGSemaphore) -> bool;
    pub static mut MyProc: *mut PGPROC;
    pub static mut ProcGlobal: *mut PROC_HDR;
    pub static mut PreparedXactProcs: *mut PGPROC;
    pub static mut DeadlockTimeout: ::core::ffi::c_int;
    pub static mut StatementTimeout: ::core::ffi::c_int;
    pub static mut LockTimeout: ::core::ffi::c_int;
    pub static mut IdleInTransactionSessionTimeout: ::core::ffi::c_int;
    pub static mut TransactionTimeout: ::core::ffi::c_int;
    pub static mut IdleSessionTimeout: ::core::ffi::c_int;
    pub static mut log_lock_waits: bool;
    pub fn ProcGlobalSemas() -> ::core::ffi::c_int;
    pub fn ProcGlobalShmemSize() -> Size;
    pub fn InitProcGlobal();
    pub fn InitProcess();
    pub fn InitProcessPhase2();
    pub fn InitAuxiliaryProcess();
    pub fn SetStartupBufferPinWaitBufId(bufid: ::core::ffi::c_int);
    pub fn GetStartupBufferPinWaitBufId() -> ::core::ffi::c_int;
    pub fn HaveNFreeProcs(n: ::core::ffi::c_int, nfree: *mut ::core::ffi::c_int) -> bool;
    pub fn ProcReleaseLocks(isCommit: bool);
    pub fn ProcSleep(
        locallock: *mut LOCALLOCK,
        lockMethodTable: LockMethod,
        dontWait: bool,
    ) -> ProcWaitStatus::Type;
    pub fn ProcWakeup(proc_: *mut PGPROC, waitStatus: ProcWaitStatus::Type);
    pub fn ProcLockWakeup(lockMethodTable: LockMethod, lock: *mut LOCK);
    pub fn CheckDeadLockAlert();
    pub fn IsWaitingForLock() -> bool;
    pub fn LockErrorCleanup();
    pub fn ProcWaitForSignal(wait_event_info: uint32);
    pub fn ProcSendSignal(procNumber: ProcNumber);
    pub fn AuxiliaryPidGetProc(pid: ::core::ffi::c_int) -> *mut PGPROC;
    pub fn BecomeLockGroupLeader();
    pub fn BecomeLockGroupMember(leader: *mut PGPROC, pid: ::core::ffi::c_int) -> bool;
    pub fn shm_mq_create(address: *mut ::core::ffi::c_void, size: Size) -> *mut shm_mq;
    pub fn shm_mq_set_receiver(mq: *mut shm_mq, arg1: *mut PGPROC);
    pub fn shm_mq_set_sender(mq: *mut shm_mq, arg1: *mut PGPROC);
    pub fn shm_mq_get_receiver(arg1: *mut shm_mq) -> *mut PGPROC;
    pub fn shm_mq_get_sender(arg1: *mut shm_mq) -> *mut PGPROC;
    pub fn shm_mq_attach(
        mq: *mut shm_mq,
        seg: *mut dsm_segment,
        handle: *mut BackgroundWorkerHandle,
    ) -> *mut shm_mq_handle;
    pub fn shm_mq_set_handle(arg1: *mut shm_mq_handle, arg2: *mut BackgroundWorkerHandle);
    pub fn shm_mq_detach(mqh: *mut shm_mq_handle);
    pub fn shm_mq_get_queue(mqh: *mut shm_mq_handle) -> *mut shm_mq;
    pub fn shm_mq_send(
        mqh: *mut shm_mq_handle,
        nbytes: Size,
        data: *const ::core::ffi::c_void,
        nowait: bool,
        force_flush: bool,
    ) -> shm_mq_result::Type;
    pub fn shm_mq_sendv(
        mqh: *mut shm_mq_handle,
        iov: *mut shm_mq_iovec,
        iovcnt: ::core::ffi::c_int,
        nowait: bool,
        force_flush: bool,
    ) -> shm_mq_result::Type;
    pub fn shm_mq_receive(
        mqh: *mut shm_mq_handle,
        nbytesp: *mut Size,
        datap: *mut *mut ::core::ffi::c_void,
        nowait: bool,
    ) -> shm_mq_result::Type;
    pub fn shm_mq_wait_for_attach(mqh: *mut shm_mq_handle) -> shm_mq_result::Type;
    pub static shm_mq_minimum_size: Size;
    pub static mut ParallelMessagePending: sig_atomic_t;
    pub static mut ParallelWorkerNumber: ::core::ffi::c_int;
    pub static mut InitializingParallelWorker: bool;
    pub fn CreateParallelContext(
        library_name: *const ::core::ffi::c_char,
        function_name: *const ::core::ffi::c_char,
        nworkers: ::core::ffi::c_int,
    ) -> *mut ParallelContext;
    pub fn InitializeParallelDSM(pcxt: *mut ParallelContext);
    pub fn ReinitializeParallelDSM(pcxt: *mut ParallelContext);
    pub fn ReinitializeParallelWorkers(
        pcxt: *mut ParallelContext,
        nworkers_to_launch: ::core::ffi::c_int,
    );
    pub fn LaunchParallelWorkers(pcxt: *mut ParallelContext);
    pub fn WaitForParallelWorkersToAttach(pcxt: *mut ParallelContext);
    pub fn WaitForParallelWorkersToFinish(pcxt: *mut ParallelContext);
    pub fn DestroyParallelContext(pcxt: *mut ParallelContext);
    pub fn ParallelContextActive() -> bool;
    pub fn HandleParallelMessageInterrupt();
    pub fn HandleParallelMessages();
    pub fn AtEOXact_Parallel(isCommit: bool);
    pub fn AtEOSubXact_Parallel(isCommit: bool, mySubId: SubTransactionId);
    pub fn ParallelWorkerReportLastRecEnd(last_xlog_end: XLogRecPtr);
    pub fn ParallelWorkerMain(main_arg: Datum);
    pub fn TidStoreCreateLocal(max_bytes: usize, insert_only: bool) -> *mut TidStore;
    pub fn TidStoreCreateShared(max_bytes: usize, tranche_id: ::core::ffi::c_int) -> *mut TidStore;
    pub fn TidStoreAttach(area_handle: dsa_handle, handle: dsa_pointer) -> *mut TidStore;
    pub fn TidStoreDetach(ts: *mut TidStore);
    pub fn TidStoreLockExclusive(ts: *mut TidStore);
    pub fn TidStoreLockShare(ts: *mut TidStore);
    pub fn TidStoreUnlock(ts: *mut TidStore);
    pub fn TidStoreDestroy(ts: *mut TidStore);
    pub fn TidStoreSetBlockOffsets(
        ts: *mut TidStore,
        blkno: BlockNumber,
        offsets: *mut OffsetNumber,
        num_offsets: ::core::ffi::c_int,
    );
    pub fn TidStoreIsMember(ts: *mut TidStore, tid: ItemPointer) -> bool;
    pub fn TidStoreBeginIterate(ts: *mut TidStore) -> *mut TidStoreIter;
    pub fn TidStoreIterateNext(iter: *mut TidStoreIter) -> *mut TidStoreIterResult;
    pub fn TidStoreEndIterate(iter: *mut TidStoreIter);
    pub fn TidStoreMemoryUsage(ts: *mut TidStore) -> usize;
    pub fn TidStoreGetHandle(ts: *mut TidStore) -> dsa_pointer;
    pub fn TidStoreGetDSA(ts: *mut TidStore) -> *mut dsa_area;
    pub static mut default_statistics_target: ::core::ffi::c_int;
    pub static mut vacuum_freeze_min_age: ::core::ffi::c_int;
    pub static mut vacuum_freeze_table_age: ::core::ffi::c_int;
    pub static mut vacuum_multixact_freeze_min_age: ::core::ffi::c_int;
    pub static mut vacuum_multixact_freeze_table_age: ::core::ffi::c_int;
    pub static mut vacuum_failsafe_age: ::core::ffi::c_int;
    pub static mut vacuum_multixact_failsafe_age: ::core::ffi::c_int;
    pub static mut VacuumSharedCostBalance: *mut pg_atomic_uint32;
    pub static mut VacuumActiveNWorkers: *mut pg_atomic_uint32;
    pub static mut VacuumCostBalanceLocal: ::core::ffi::c_int;
    pub static mut VacuumFailsafeActive: bool;
    pub static mut vacuum_cost_delay: f64;
    pub static mut vacuum_cost_limit: ::core::ffi::c_int;
    pub fn ExecVacuum(pstate: *mut ParseState, vacstmt: *mut VacuumStmt, isTopLevel: bool);
    pub fn vacuum(
        relations: *mut List,
        params: *mut VacuumParams,
        bstrategy: BufferAccessStrategy,
        vac_context: MemoryContext,
        isTopLevel: bool,
    );
    pub fn vac_open_indexes(
        relation: Relation,
        lockmode: LOCKMODE,
        nindexes: *mut ::core::ffi::c_int,
        Irel: *mut *mut Relation,
    );
    pub fn vac_close_indexes(nindexes: ::core::ffi::c_int, Irel: *mut Relation, lockmode: LOCKMODE);
    pub fn vac_estimate_reltuples(
        relation: Relation,
        total_pages: BlockNumber,
        scanned_pages: BlockNumber,
        scanned_tuples: f64,
    ) -> f64;
    pub fn vac_update_relstats(
        relation: Relation,
        num_pages: BlockNumber,
        num_tuples: f64,
        num_all_visible_pages: BlockNumber,
        hasindex: bool,
        frozenxid: TransactionId,
        minmulti: MultiXactId,
        frozenxid_updated: *mut bool,
        minmulti_updated: *mut bool,
        in_outer_xact: bool,
    );
    pub fn vacuum_get_cutoffs(
        rel: Relation,
        params: *const VacuumParams,
        cutoffs: *mut VacuumCutoffs,
    ) -> bool;
    pub fn vacuum_xid_failsafe_check(cutoffs: *const VacuumCutoffs) -> bool;
    pub fn vac_update_datfrozenxid();
    pub fn vacuum_delay_point();
    pub fn vacuum_is_permitted_for_relation(
        relid: Oid,
        reltuple: Form_pg_class,
        options: bits32,
    ) -> bool;
    pub fn vacuum_open_relation(
        relid: Oid,
        relation: *mut RangeVar,
        options: bits32,
        verbose: bool,
        lmode: LOCKMODE,
    ) -> Relation;
    pub fn vac_bulkdel_one_index(
        ivinfo: *mut IndexVacuumInfo,
        istat: *mut IndexBulkDeleteResult,
        dead_items: *mut TidStore,
        dead_items_info: *mut VacDeadItemsInfo,
    ) -> *mut IndexBulkDeleteResult;
    pub fn vac_cleanup_one_index(
        ivinfo: *mut IndexVacuumInfo,
        istat: *mut IndexBulkDeleteResult,
    ) -> *mut IndexBulkDeleteResult;
    pub fn AutoVacuumUpdateCostLimit();
    pub fn VacuumUpdateCosts();
    pub fn parallel_vacuum_init(
        rel: Relation,
        indrels: *mut Relation,
        nindexes: ::core::ffi::c_int,
        nrequested_workers: ::core::ffi::c_int,
        vac_work_mem: ::core::ffi::c_int,
        elevel: ::core::ffi::c_int,
        bstrategy: BufferAccessStrategy,
    ) -> *mut ParallelVacuumState;
    pub fn parallel_vacuum_end(
        pvs: *mut ParallelVacuumState,
        istats: *mut *mut IndexBulkDeleteResult,
    );
    pub fn parallel_vacuum_get_dead_items(
        pvs: *mut ParallelVacuumState,
        dead_items_info_p: *mut *mut VacDeadItemsInfo,
    ) -> *mut TidStore;
    pub fn parallel_vacuum_reset_dead_items(pvs: *mut ParallelVacuumState);
    pub fn parallel_vacuum_bulkdel_all_indexes(
        pvs: *mut ParallelVacuumState,
        num_table_tuples: ::core::ffi::c_long,
        num_index_scans: ::core::ffi::c_int,
    );
    pub fn parallel_vacuum_cleanup_all_indexes(
        pvs: *mut ParallelVacuumState,
        num_table_tuples: ::core::ffi::c_long,
        num_index_scans: ::core::ffi::c_int,
        estimated_count: bool,
    );
    pub fn parallel_vacuum_main(seg: *mut dsm_segment, toc: *mut shm_toc);
    pub fn analyze_rel(
        relid: Oid,
        relation: *mut RangeVar,
        params: *mut VacuumParams,
        va_cols: *mut List,
        in_outer_xact: bool,
        bstrategy: BufferAccessStrategy,
    );
    pub fn std_typanalyze(stats: *mut VacAttrStats) -> bool;
    pub fn anl_random_fract() -> f64;
    pub fn anl_init_selection_state(n: ::core::ffi::c_int) -> f64;
    pub fn anl_get_next_S(t: f64, n: ::core::ffi::c_int, stateptr: *mut f64) -> f64;
    pub fn get_configdata(
        my_exec_path: *const ::core::ffi::c_char,
        configdata_len: *mut usize,
    ) -> *mut ConfigData;
    pub fn get_controlfile(
        DataDir: *const ::core::ffi::c_char,
        crc_ok_p: *mut bool,
    ) -> *mut ControlFileData;
    pub fn get_controlfile_by_exact_path(
        ControlFilePath: *const ::core::ffi::c_char,
        crc_ok_p: *mut bool,
    ) -> *mut ControlFileData;
    pub fn update_controlfile(
        DataDir: *const ::core::ffi::c_char,
        ControlFile: *mut ControlFileData,
        do_sync: bool,
    );
    pub fn ExecInitAgg(
        node: *mut Agg,
        estate: *mut EState,
        eflags: ::core::ffi::c_int,
    ) -> *mut AggState;
    pub fn ExecEndAgg(node: *mut AggState);
    pub fn ExecReScanAgg(node: *mut AggState);
    pub fn hash_agg_entry_size(
        numTrans: ::core::ffi::c_int,
        tupleWidth: Size,
        transitionSpace: Size,
    ) -> Size;
    pub fn hash_agg_set_limits(
        hashentrysize: f64,
        input_groups: f64,
        used_bits: ::core::ffi::c_int,
        mem_limit: *mut Size,
        ngroups_limit: *mut uint64,
        num_partitions: *mut ::core::ffi::c_int,
    );
    pub fn ExecAggEstimate(node: *mut AggState, pcxt: *mut ParallelContext);
    pub fn ExecAggInitializeDSM(node: *mut AggState, pcxt: *mut ParallelContext);
    pub fn ExecAggInitializeWorker(node: *mut AggState, pwcxt: *mut ParallelWorkerContext);
    pub fn ExecAggRetrieveInstrumentation(node: *mut AggState);
    pub fn ExprEvalPushStep(es: *mut ExprState, s: *const ExprEvalStep);
    pub fn ExecReadyInterpretedExpr(state: *mut ExprState);
    pub fn ExecEvalStepOp(state: *mut ExprState, op: *mut ExprEvalStep) -> ExprEvalOp::Type;
    pub fn ExecInterpExprStillValid(
        state: *mut ExprState,
        econtext: *mut ExprContext,
        isNull: *mut bool,
    ) -> Datum;
    pub fn CheckExprStillValid(state: *mut ExprState, econtext: *mut ExprContext);
    pub fn ExecEvalFuncExprFusage(
        state: *mut ExprState,
        op: *mut ExprEvalStep,
        econtext: *mut ExprContext,
    );
    pub fn ExecEvalFuncExprStrictFusage(
        state: *mut ExprState,
        op: *mut ExprEvalStep,
        econtext: *mut ExprContext,
    );
    pub fn ExecEvalParamExec(
        state: *mut ExprState,
        op: *mut ExprEvalStep,
        econtext: *mut ExprContext,
    );
    pub fn ExecEvalParamExtern(
        state: *mut ExprState,
        op: *mut ExprEvalStep,
        econtext: *mut ExprContext,
    );
    pub fn ExecEvalCoerceViaIOSafe(state: *mut ExprState, op: *mut ExprEvalStep);
    pub fn ExecEvalSQLValueFunction(state: *mut ExprState, op: *mut ExprEvalStep);
    pub fn ExecEvalCurrentOfExpr(state: *mut ExprState, op: *mut ExprEvalStep);
    pub fn ExecEvalNextValueExpr(state: *mut ExprState, op: *mut ExprEvalStep);
    pub fn ExecEvalRowNull(
        state: *mut ExprState,
        op: *mut ExprEvalStep,
        econtext: *mut ExprContext,
    );
    pub fn ExecEvalRowNotNull(
        state: *mut ExprState,
        op: *mut ExprEvalStep,
        econtext: *mut ExprContext,
    );
    pub fn ExecEvalArrayExpr(state: *mut ExprState, op: *mut ExprEvalStep);
    pub fn ExecEvalArrayCoerce(
        state: *mut ExprState,
        op: *mut ExprEvalStep,
        econtext: *mut ExprContext,
    );
    pub fn ExecEvalRow(state: *mut ExprState, op: *mut ExprEvalStep);
    pub fn ExecEvalMinMax(state: *mut ExprState, op: *mut ExprEvalStep);
    pub fn ExecEvalFieldSelect(
        state: *mut ExprState,
        op: *mut ExprEvalStep,
        econtext: *mut ExprContext,
    );
    pub fn ExecEvalFieldStoreDeForm(
        state: *mut ExprState,
        op: *mut ExprEvalStep,
        econtext: *mut ExprContext,
    );
    pub fn ExecEvalFieldStoreForm(
        state: *mut ExprState,
        op: *mut ExprEvalStep,
        econtext: *mut ExprContext,
    );
    pub fn ExecEvalConvertRowtype(
        state: *mut ExprState,
        op: *mut ExprEvalStep,
        econtext: *mut ExprContext,
    );
    pub fn ExecEvalScalarArrayOp(state: *mut ExprState, op: *mut ExprEvalStep);
    pub fn ExecEvalHashedScalarArrayOp(
        state: *mut ExprState,
        op: *mut ExprEvalStep,
        econtext: *mut ExprContext,
    );
    pub fn ExecEvalConstraintNotNull(state: *mut ExprState, op: *mut ExprEvalStep);
    pub fn ExecEvalConstraintCheck(state: *mut ExprState, op: *mut ExprEvalStep);
    pub fn ExecEvalXmlExpr(state: *mut ExprState, op: *mut ExprEvalStep);
    pub fn ExecEvalJsonConstructor(
        state: *mut ExprState,
        op: *mut ExprEvalStep,
        econtext: *mut ExprContext,
    );
    pub fn ExecEvalJsonIsPredicate(state: *mut ExprState, op: *mut ExprEvalStep);
    pub fn ExecEvalJsonExprPath(
        state: *mut ExprState,
        op: *mut ExprEvalStep,
        econtext: *mut ExprContext,
    ) -> ::core::ffi::c_int;
    pub fn ExecEvalJsonCoercion(
        state: *mut ExprState,
        op: *mut ExprEvalStep,
        econtext: *mut ExprContext,
    );
    pub fn ExecEvalJsonCoercionFinish(state: *mut ExprState, op: *mut ExprEvalStep);
    pub fn ExecEvalGroupingFunc(state: *mut ExprState, op: *mut ExprEvalStep);
    pub fn ExecEvalMergeSupportFunc(
        state: *mut ExprState,
        op: *mut ExprEvalStep,
        econtext: *mut ExprContext,
    );
    pub fn ExecEvalSubPlan(
        state: *mut ExprState,
        op: *mut ExprEvalStep,
        econtext: *mut ExprContext,
    );
    pub fn ExecEvalWholeRowVar(
        state: *mut ExprState,
        op: *mut ExprEvalStep,
        econtext: *mut ExprContext,
    );
    pub fn ExecEvalSysVar(
        state: *mut ExprState,
        op: *mut ExprEvalStep,
        econtext: *mut ExprContext,
        slot: *mut TupleTableSlot,
    );
    pub fn ExecAggInitGroup(
        aggstate: *mut AggState,
        pertrans: AggStatePerTrans,
        pergroup: AggStatePerGroup,
        aggcontext: *mut ExprContext,
    );
    pub fn ExecAggCopyTransValue(
        aggstate: *mut AggState,
        pertrans: AggStatePerTrans,
        newValue: Datum,
        newValueIsNull: bool,
        oldValue: Datum,
        oldValueIsNull: bool,
    ) -> Datum;
    pub fn ExecEvalPreOrderedDistinctSingle(
        aggstate: *mut AggState,
        pertrans: AggStatePerTrans,
    ) -> bool;
    pub fn ExecEvalPreOrderedDistinctMulti(
        aggstate: *mut AggState,
        pertrans: AggStatePerTrans,
    ) -> bool;
    pub fn ExecEvalAggOrderedTransDatum(
        state: *mut ExprState,
        op: *mut ExprEvalStep,
        econtext: *mut ExprContext,
    );
    pub fn ExecEvalAggOrderedTransTuple(
        state: *mut ExprState,
        op: *mut ExprEvalStep,
        econtext: *mut ExprContext,
    );
    pub static mut backslash_quote: ::core::ffi::c_int;
    pub static mut escape_string_warning: bool;
    pub static mut standard_conforming_strings: bool;
    pub fn raw_parser(str_: *const ::core::ffi::c_char, mode: RawParseMode::Type) -> *mut List;
    pub fn SystemFuncName(name: *mut ::core::ffi::c_char) -> *mut List;
    pub fn SystemTypeName(name: *mut ::core::ffi::c_char) -> *mut TypeName;
    pub fn EnablePortalManager();
    pub fn PreCommit_Portals(isPrepare: bool) -> bool;
    pub fn AtAbort_Portals();
    pub fn AtCleanup_Portals();
    pub fn PortalErrorCleanup();
    pub fn AtSubCommit_Portals(
        mySubid: SubTransactionId,
        parentSubid: SubTransactionId,
        parentLevel: ::core::ffi::c_int,
        parentXactOwner: ResourceOwner,
    );
    pub fn AtSubAbort_Portals(
        mySubid: SubTransactionId,
        parentSubid: SubTransactionId,
        myXactOwner: ResourceOwner,
        parentXactOwner: ResourceOwner,
    );
    pub fn AtSubCleanup_Portals(mySubid: SubTransactionId);
    pub fn CreatePortal(
        name: *const ::core::ffi::c_char,
        allowDup: bool,
        dupSilent: bool,
    ) -> Portal;
    pub fn CreateNewPortal() -> Portal;
    pub fn PinPortal(portal: Portal);
    pub fn UnpinPortal(portal: Portal);
    pub fn MarkPortalActive(portal: Portal);
    pub fn MarkPortalDone(portal: Portal);
    pub fn MarkPortalFailed(portal: Portal);
    pub fn PortalDrop(portal: Portal, isTopCommit: bool);
    pub fn GetPortalByName(name: *const ::core::ffi::c_char) -> Portal;
    pub fn PortalDefineQuery(
        portal: Portal,
        prepStmtName: *const ::core::ffi::c_char,
        sourceText: *const ::core::ffi::c_char,
        commandTag: CommandTag::Type,
        stmts: *mut List,
        cplan: *mut CachedPlan,
    );
    pub fn PortalGetPrimaryStmt(portal: Portal) -> *mut PlannedStmt;
    pub fn PortalCreateHoldStore(portal: Portal);
    pub fn PortalHashTableDeleteAll();
    pub fn ThereAreNoReadyPortals() -> bool;
    pub fn HoldPinnedPortals();
    pub fn ForgetPortalSnapshots();
    pub static mut SPI_processed: uint64;
    pub static mut SPI_tuptable: *mut SPITupleTable;
    pub static mut SPI_result: ::core::ffi::c_int;
    pub fn SPI_connect() -> ::core::ffi::c_int;
    pub fn SPI_connect_ext(options: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn SPI_finish() -> ::core::ffi::c_int;
    pub fn SPI_execute(
        src: *const ::core::ffi::c_char,
        read_only: bool,
        tcount: ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
    pub fn SPI_execute_extended(
        src: *const ::core::ffi::c_char,
        options: *const SPIExecuteOptions,
    ) -> ::core::ffi::c_int;
    pub fn SPI_execute_plan(
        plan: SPIPlanPtr,
        Values: *mut Datum,
        Nulls: *const ::core::ffi::c_char,
        read_only: bool,
        tcount: ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
    pub fn SPI_execute_plan_extended(
        plan: SPIPlanPtr,
        options: *const SPIExecuteOptions,
    ) -> ::core::ffi::c_int;
    pub fn SPI_execute_plan_with_paramlist(
        plan: SPIPlanPtr,
        params: ParamListInfo,
        read_only: bool,
        tcount: ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
    pub fn SPI_exec(
        src: *const ::core::ffi::c_char,
        tcount: ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
    pub fn SPI_execp(
        plan: SPIPlanPtr,
        Values: *mut Datum,
        Nulls: *const ::core::ffi::c_char,
        tcount: ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
    pub fn SPI_execute_snapshot(
        plan: SPIPlanPtr,
        Values: *mut Datum,
        Nulls: *const ::core::ffi::c_char,
        snapshot: Snapshot,
        crosscheck_snapshot: Snapshot,
        read_only: bool,
        fire_triggers: bool,
        tcount: ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
    pub fn SPI_execute_with_args(
        src: *const ::core::ffi::c_char,
        nargs: ::core::ffi::c_int,
        argtypes: *mut Oid,
        Values: *mut Datum,
        Nulls: *const ::core::ffi::c_char,
        read_only: bool,
        tcount: ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
    pub fn SPI_prepare(
        src: *const ::core::ffi::c_char,
        nargs: ::core::ffi::c_int,
        argtypes: *mut Oid,
    ) -> SPIPlanPtr;
    pub fn SPI_prepare_cursor(
        src: *const ::core::ffi::c_char,
        nargs: ::core::ffi::c_int,
        argtypes: *mut Oid,
        cursorOptions: ::core::ffi::c_int,
    ) -> SPIPlanPtr;
    pub fn SPI_prepare_extended(
        src: *const ::core::ffi::c_char,
        options: *const SPIPrepareOptions,
    ) -> SPIPlanPtr;
    pub fn SPI_prepare_params(
        src: *const ::core::ffi::c_char,
        parserSetup: ParserSetupHook,
        parserSetupArg: *mut ::core::ffi::c_void,
        cursorOptions: ::core::ffi::c_int,
    ) -> SPIPlanPtr;
    pub fn SPI_keepplan(plan: SPIPlanPtr) -> ::core::ffi::c_int;
    pub fn SPI_saveplan(plan: SPIPlanPtr) -> SPIPlanPtr;
    pub fn SPI_freeplan(plan: SPIPlanPtr) -> ::core::ffi::c_int;
    pub fn SPI_getargtypeid(plan: SPIPlanPtr, argIndex: ::core::ffi::c_int) -> Oid;
    pub fn SPI_getargcount(plan: SPIPlanPtr) -> ::core::ffi::c_int;
    pub fn SPI_is_cursor_plan(plan: SPIPlanPtr) -> bool;
    pub fn SPI_plan_is_valid(plan: SPIPlanPtr) -> bool;
    pub fn SPI_result_code_string(code: ::core::ffi::c_int) -> *const ::core::ffi::c_char;
    pub fn SPI_plan_get_plan_sources(plan: SPIPlanPtr) -> *mut List;
    pub fn SPI_plan_get_cached_plan(plan: SPIPlanPtr) -> *mut CachedPlan;
    pub fn SPI_copytuple(tuple: HeapTuple) -> HeapTuple;
    pub fn SPI_returntuple(tuple: HeapTuple, tupdesc: TupleDesc) -> HeapTupleHeader;
    pub fn SPI_modifytuple(
        rel: Relation,
        tuple: HeapTuple,
        natts: ::core::ffi::c_int,
        attnum: *mut ::core::ffi::c_int,
        Values: *mut Datum,
        Nulls: *const ::core::ffi::c_char,
    ) -> HeapTuple;
    pub fn SPI_fnumber(tupdesc: TupleDesc, fname: *const ::core::ffi::c_char)
        -> ::core::ffi::c_int;
    pub fn SPI_fname(tupdesc: TupleDesc, fnumber: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
    pub fn SPI_getvalue(
        tuple: HeapTuple,
        tupdesc: TupleDesc,
        fnumber: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn SPI_getbinval(
        tuple: HeapTuple,
        tupdesc: TupleDesc,
        fnumber: ::core::ffi::c_int,
        isnull: *mut bool,
    ) -> Datum;
    pub fn SPI_gettype(tupdesc: TupleDesc, fnumber: ::core::ffi::c_int)
        -> *mut ::core::ffi::c_char;
    pub fn SPI_gettypeid(tupdesc: TupleDesc, fnumber: ::core::ffi::c_int) -> Oid;
    pub fn SPI_getrelname(rel: Relation) -> *mut ::core::ffi::c_char;
    pub fn SPI_getnspname(rel: Relation) -> *mut ::core::ffi::c_char;
    pub fn SPI_palloc(size: Size) -> *mut ::core::ffi::c_void;
    pub fn SPI_repalloc(pointer: *mut ::core::ffi::c_void, size: Size) -> *mut ::core::ffi::c_void;
    pub fn SPI_pfree(pointer: *mut ::core::ffi::c_void);
    pub fn SPI_datumTransfer(value: Datum, typByVal: bool, typLen: ::core::ffi::c_int) -> Datum;
    pub fn SPI_freetuple(tuple: HeapTuple);
    pub fn SPI_freetuptable(tuptable: *mut SPITupleTable);
    pub fn SPI_cursor_open(
        name: *const ::core::ffi::c_char,
        plan: SPIPlanPtr,
        Values: *mut Datum,
        Nulls: *const ::core::ffi::c_char,
        read_only: bool,
    ) -> Portal;
    pub fn SPI_cursor_open_with_args(
        name: *const ::core::ffi::c_char,
        src: *const ::core::ffi::c_char,
        nargs: ::core::ffi::c_int,
        argtypes: *mut Oid,
        Values: *mut Datum,
        Nulls: *const ::core::ffi::c_char,
        read_only: bool,
        cursorOptions: ::core::ffi::c_int,
    ) -> Portal;
    pub fn SPI_cursor_open_with_paramlist(
        name: *const ::core::ffi::c_char,
        plan: SPIPlanPtr,
        params: ParamListInfo,
        read_only: bool,
    ) -> Portal;
    pub fn SPI_cursor_parse_open(
        name: *const ::core::ffi::c_char,
        src: *const ::core::ffi::c_char,
        options: *const SPIParseOpenOptions,
    ) -> Portal;
    pub fn SPI_cursor_find(name: *const ::core::ffi::c_char) -> Portal;
    pub fn SPI_cursor_fetch(portal: Portal, forward: bool, count: ::core::ffi::c_long);
    pub fn SPI_cursor_move(portal: Portal, forward: bool, count: ::core::ffi::c_long);
    pub fn SPI_scroll_cursor_fetch(
        arg1: Portal,
        direction: FetchDirection::Type,
        count: ::core::ffi::c_long,
    );
    pub fn SPI_scroll_cursor_move(
        arg1: Portal,
        direction: FetchDirection::Type,
        count: ::core::ffi::c_long,
    );
    pub fn SPI_cursor_close(portal: Portal);
    pub fn SPI_register_relation(enr: EphemeralNamedRelation) -> ::core::ffi::c_int;
    pub fn SPI_unregister_relation(name: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn SPI_register_trigger_data(tdata: *mut TriggerData) -> ::core::ffi::c_int;
    pub fn SPI_start_transaction();
    pub fn SPI_commit();
    pub fn SPI_commit_and_chain();
    pub fn SPI_rollback();
    pub fn SPI_rollback_and_chain();
    pub fn AtEOXact_SPI(isCommit: bool);
    pub fn AtEOSubXact_SPI(isCommit: bool, mySubid: SubTransactionId);
    pub fn SPI_inside_nonatomic_context() -> bool;
    pub fn is_dummy_rel(rel: *mut RelOptInfo) -> bool;
    pub fn GetFdwRoutine(fdwhandler: Oid) -> *mut FdwRoutine;
    pub fn GetForeignServerIdByRelId(relid: Oid) -> Oid;
    pub fn GetFdwRoutineByServerId(serverid: Oid) -> *mut FdwRoutine;
    pub fn GetFdwRoutineByRelId(relid: Oid) -> *mut FdwRoutine;
    pub fn GetFdwRoutineForRelation(relation: Relation, makecopy: bool) -> *mut FdwRoutine;
    pub fn IsImportableForeignTable(
        tablename: *const ::core::ffi::c_char,
        stmt: *mut ImportForeignSchemaStmt,
    ) -> bool;
    pub fn GetExistingLocalJoinPath(joinrel: *mut RelOptInfo) -> *mut Path;
    pub fn GetForeignServer(serverid: Oid) -> *mut ForeignServer;
    pub fn GetForeignServerExtended(serverid: Oid, flags: bits16) -> *mut ForeignServer;
    pub fn GetForeignServerByName(
        srvname: *const ::core::ffi::c_char,
        missing_ok: bool,
    ) -> *mut ForeignServer;
    pub fn GetUserMapping(userid: Oid, serverid: Oid) -> *mut UserMapping;
    pub fn GetForeignDataWrapper(fdwid: Oid) -> *mut ForeignDataWrapper;
    pub fn GetForeignDataWrapperExtended(fdwid: Oid, flags: bits16) -> *mut ForeignDataWrapper;
    pub fn GetForeignDataWrapperByName(
        fdwname: *const ::core::ffi::c_char,
        missing_ok: bool,
    ) -> *mut ForeignDataWrapper;
    pub fn GetForeignTable(relid: Oid) -> *mut ForeignTable;
    pub fn GetForeignColumnOptions(relid: Oid, attnum: AttrNumber) -> *mut List;
    pub fn get_foreign_data_wrapper_oid(
        fdwname: *const ::core::ffi::c_char,
        missing_ok: bool,
    ) -> Oid;
    pub fn get_foreign_server_oid(servername: *const ::core::ffi::c_char, missing_ok: bool) -> Oid;
    pub fn _PG_jit_provider_init(cb: *mut JitProviderCallbacks);
    pub static mut jit_enabled: bool;
    pub static mut jit_provider: *mut ::core::ffi::c_char;
    pub static mut jit_debugging_support: bool;
    pub static mut jit_dump_bitcode: bool;
    pub static mut jit_expressions: bool;
    pub static mut jit_profiling_support: bool;
    pub static mut jit_tuple_deforming: bool;
    pub static mut jit_above_cost: f64;
    pub static mut jit_inline_above_cost: f64;
    pub static mut jit_optimize_above_cost: f64;
    pub fn jit_reset_after_error();
    pub fn jit_release_context(context: *mut JitContext);
    pub fn jit_compile_expr(state: *mut ExprState) -> bool;
    pub fn InstrJitAgg(dst: *mut JitInstrumentation, add: *mut JitInstrumentation);
    pub static pg_enc2name_tbl: [pg_enc2name; 0usize];
    pub static mut pg_enc2gettext_tbl: [*const ::core::ffi::c_char; 0usize];
    pub static pg_wchar_table: [pg_wchar_tbl; 0usize];
    pub fn pg_char_to_encoding_private(name: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn pg_encoding_to_char_private(encoding: ::core::ffi::c_int) -> *const ::core::ffi::c_char;
    pub fn pg_valid_server_encoding_id_private(encoding: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn pg_encoding_set_invalid(encoding: ::core::ffi::c_int, dst: *mut ::core::ffi::c_char);
    pub fn pg_encoding_mblen(
        encoding: ::core::ffi::c_int,
        mbstr: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn pg_encoding_mblen_bounded(
        encoding: ::core::ffi::c_int,
        mbstr: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn pg_encoding_dsplen(
        encoding: ::core::ffi::c_int,
        mbstr: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn pg_encoding_verifymbchar(
        encoding: ::core::ffi::c_int,
        mbstr: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn pg_encoding_verifymbstr(
        encoding: ::core::ffi::c_int,
        mbstr: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn pg_encoding_max_length(encoding: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn pg_valid_client_encoding(name: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn pg_valid_server_encoding_private(name: *const ::core::ffi::c_char)
        -> ::core::ffi::c_int;
    pub fn is_encoding_supported_by_icu(encoding: ::core::ffi::c_int) -> bool;
    pub fn get_encoding_name_for_icu(encoding: ::core::ffi::c_int) -> *const ::core::ffi::c_char;
    pub fn pg_utf8_islegal(source: *const ::core::ffi::c_uchar, length: ::core::ffi::c_int)
        -> bool;
    pub fn pg_utf_mblen_private(s: *const ::core::ffi::c_uchar) -> ::core::ffi::c_int;
    pub fn pg_mule_mblen(s: *const ::core::ffi::c_uchar) -> ::core::ffi::c_int;
    pub fn pg_mb2wchar(from: *const ::core::ffi::c_char, to: *mut pg_wchar) -> ::core::ffi::c_int;
    pub fn pg_mb2wchar_with_len(
        from: *const ::core::ffi::c_char,
        to: *mut pg_wchar,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn pg_encoding_mb2wchar_with_len(
        encoding: ::core::ffi::c_int,
        from: *const ::core::ffi::c_char,
        to: *mut pg_wchar,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn pg_wchar2mb(from: *const pg_wchar, to: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn pg_wchar2mb_with_len(
        from: *const pg_wchar,
        to: *mut ::core::ffi::c_char,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn pg_encoding_wchar2mb_with_len(
        encoding: ::core::ffi::c_int,
        from: *const pg_wchar,
        to: *mut ::core::ffi::c_char,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn pg_char_and_wchar_strcmp(
        s1: *const ::core::ffi::c_char,
        s2: *const pg_wchar,
    ) -> ::core::ffi::c_int;
    pub fn pg_wchar_strncmp(
        s1: *const pg_wchar,
        s2: *const pg_wchar,
        n: usize,
    ) -> ::core::ffi::c_int;
    pub fn pg_char_and_wchar_strncmp(
        s1: *const ::core::ffi::c_char,
        s2: *const pg_wchar,
        n: usize,
    ) -> ::core::ffi::c_int;
    pub fn pg_wchar_strlen(str_: *const pg_wchar) -> usize;
    pub fn pg_mblen(mbstr: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn pg_dsplen(mbstr: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn pg_mbstrlen(mbstr: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn pg_mbstrlen_with_len(
        mbstr: *const ::core::ffi::c_char,
        limit: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn pg_mbcliplen(
        mbstr: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
        limit: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn pg_encoding_mbcliplen(
        encoding: ::core::ffi::c_int,
        mbstr: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
        limit: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn pg_mbcharcliplen(
        mbstr: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
        limit: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn pg_database_encoding_max_length() -> ::core::ffi::c_int;
    pub fn pg_database_encoding_character_incrementer() -> mbcharacter_incrementer;
    pub fn PrepareClientEncoding(encoding: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn SetClientEncoding(encoding: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn InitializeClientEncoding();
    pub fn pg_get_client_encoding() -> ::core::ffi::c_int;
    pub fn pg_get_client_encoding_name() -> *const ::core::ffi::c_char;
    pub fn SetDatabaseEncoding(encoding: ::core::ffi::c_int);
    pub fn GetDatabaseEncoding() -> ::core::ffi::c_int;
    pub fn GetDatabaseEncodingName() -> *const ::core::ffi::c_char;
    pub fn SetMessageEncoding(encoding: ::core::ffi::c_int);
    pub fn GetMessageEncoding() -> ::core::ffi::c_int;
    pub fn pg_do_encoding_conversion(
        src: *mut ::core::ffi::c_uchar,
        len: ::core::ffi::c_int,
        src_encoding: ::core::ffi::c_int,
        dest_encoding: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_uchar;
    pub fn pg_do_encoding_conversion_buf(
        proc_: Oid,
        src_encoding: ::core::ffi::c_int,
        dest_encoding: ::core::ffi::c_int,
        src: *mut ::core::ffi::c_uchar,
        srclen: ::core::ffi::c_int,
        dest: *mut ::core::ffi::c_uchar,
        destlen: ::core::ffi::c_int,
        noError: bool,
    ) -> ::core::ffi::c_int;
    pub fn pg_client_to_server(
        s: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn pg_server_to_client(
        s: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn pg_any_to_server(
        s: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
        encoding: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn pg_server_to_any(
        s: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
        encoding: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn pg_unicode_to_server(c: pg_wchar, s: *mut ::core::ffi::c_uchar);
    pub fn pg_unicode_to_server_noerror(c: pg_wchar, s: *mut ::core::ffi::c_uchar) -> bool;
    pub fn BIG5toCNS(
        big5: ::core::ffi::c_ushort,
        lc: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_ushort;
    pub fn CNStoBIG5(cns: ::core::ffi::c_ushort, lc: ::core::ffi::c_uchar)
        -> ::core::ffi::c_ushort;
    pub fn UtfToLocal(
        utf: *const ::core::ffi::c_uchar,
        len: ::core::ffi::c_int,
        iso: *mut ::core::ffi::c_uchar,
        map: *const pg_mb_radix_tree,
        cmap: *const pg_utf_to_local_combined,
        cmapsize: ::core::ffi::c_int,
        conv_func: utf_local_conversion_func,
        encoding: ::core::ffi::c_int,
        noError: bool,
    ) -> ::core::ffi::c_int;
    pub fn LocalToUtf(
        iso: *const ::core::ffi::c_uchar,
        len: ::core::ffi::c_int,
        utf: *mut ::core::ffi::c_uchar,
        map: *const pg_mb_radix_tree,
        cmap: *const pg_local_to_utf_combined,
        cmapsize: ::core::ffi::c_int,
        conv_func: utf_local_conversion_func,
        encoding: ::core::ffi::c_int,
        noError: bool,
    ) -> ::core::ffi::c_int;
    pub fn pg_verifymbstr(
        mbstr: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
        noError: bool,
    ) -> bool;
    pub fn pg_verify_mbstr(
        encoding: ::core::ffi::c_int,
        mbstr: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
        noError: bool,
    ) -> bool;
    pub fn pg_verify_mbstr_len(
        encoding: ::core::ffi::c_int,
        mbstr: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
        noError: bool,
    ) -> ::core::ffi::c_int;
    pub fn check_encoding_conversion_args(
        src_encoding: ::core::ffi::c_int,
        dest_encoding: ::core::ffi::c_int,
        len: ::core::ffi::c_int,
        expected_src_encoding: ::core::ffi::c_int,
        expected_dest_encoding: ::core::ffi::c_int,
    );
    pub fn report_invalid_encoding(
        encoding: ::core::ffi::c_int,
        mbstr: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
    ) -> !;
    pub fn report_untranslatable_char(
        src_encoding: ::core::ffi::c_int,
        dest_encoding: ::core::ffi::c_int,
        mbstr: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
    ) -> !;
    pub fn local2local(
        l: *const ::core::ffi::c_uchar,
        p: *mut ::core::ffi::c_uchar,
        len: ::core::ffi::c_int,
        src_encoding: ::core::ffi::c_int,
        dest_encoding: ::core::ffi::c_int,
        tab: *const ::core::ffi::c_uchar,
        noError: bool,
    ) -> ::core::ffi::c_int;
    pub fn latin2mic(
        l: *const ::core::ffi::c_uchar,
        p: *mut ::core::ffi::c_uchar,
        len: ::core::ffi::c_int,
        lc: ::core::ffi::c_int,
        encoding: ::core::ffi::c_int,
        noError: bool,
    ) -> ::core::ffi::c_int;
    pub fn mic2latin(
        mic: *const ::core::ffi::c_uchar,
        p: *mut ::core::ffi::c_uchar,
        len: ::core::ffi::c_int,
        lc: ::core::ffi::c_int,
        encoding: ::core::ffi::c_int,
        noError: bool,
    ) -> ::core::ffi::c_int;
    pub fn latin2mic_with_table(
        l: *const ::core::ffi::c_uchar,
        p: *mut ::core::ffi::c_uchar,
        len: ::core::ffi::c_int,
        lc: ::core::ffi::c_int,
        encoding: ::core::ffi::c_int,
        tab: *const ::core::ffi::c_uchar,
        noError: bool,
    ) -> ::core::ffi::c_int;
    pub fn mic2latin_with_table(
        mic: *const ::core::ffi::c_uchar,
        p: *mut ::core::ffi::c_uchar,
        len: ::core::ffi::c_int,
        lc: ::core::ffi::c_int,
        encoding: ::core::ffi::c_int,
        tab: *const ::core::ffi::c_uchar,
        noError: bool,
    ) -> ::core::ffi::c_int;
    pub fn pq_beginmessage(buf: StringInfo, msgtype: ::core::ffi::c_char);
    pub fn pq_beginmessage_reuse(buf: StringInfo, msgtype: ::core::ffi::c_char);
    pub fn pq_endmessage(buf: StringInfo);
    pub fn pq_endmessage_reuse(buf: StringInfo);
    pub fn pq_sendbytes(
        buf: StringInfo,
        data: *const ::core::ffi::c_void,
        datalen: ::core::ffi::c_int,
    );
    pub fn pq_sendcountedtext(
        buf: StringInfo,
        str_: *const ::core::ffi::c_char,
        slen: ::core::ffi::c_int,
    );
    pub fn pq_sendtext(buf: StringInfo, str_: *const ::core::ffi::c_char, slen: ::core::ffi::c_int);
    pub fn pq_sendstring(buf: StringInfo, str_: *const ::core::ffi::c_char);
    pub fn pq_send_ascii_string(buf: StringInfo, str_: *const ::core::ffi::c_char);
    pub fn pq_sendfloat4(buf: StringInfo, f: float4);
    pub fn pq_sendfloat8(buf: StringInfo, f: float8);
    pub fn pq_begintypsend(buf: StringInfo);
    pub fn pq_endtypsend(buf: StringInfo) -> *mut bytea;
    pub fn pq_puttextmessage(msgtype: ::core::ffi::c_char, str_: *const ::core::ffi::c_char);
    pub fn pq_putemptymessage(msgtype: ::core::ffi::c_char);
    pub fn pq_getmsgbyte(msg: StringInfo) -> ::core::ffi::c_int;
    pub fn pq_getmsgint(msg: StringInfo, b: ::core::ffi::c_int) -> ::core::ffi::c_uint;
    pub fn pq_getmsgint64(msg: StringInfo) -> int64;
    pub fn pq_getmsgfloat4(msg: StringInfo) -> float4;
    pub fn pq_getmsgfloat8(msg: StringInfo) -> float8;
    pub fn pq_getmsgbytes(
        msg: StringInfo,
        datalen: ::core::ffi::c_int,
    ) -> *const ::core::ffi::c_char;
    pub fn pq_copymsgbytes(
        msg: StringInfo,
        buf: *mut ::core::ffi::c_char,
        datalen: ::core::ffi::c_int,
    );
    pub fn pq_getmsgtext(
        msg: StringInfo,
        rawbytes: ::core::ffi::c_int,
        nbytes: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn pq_getmsgstring(msg: StringInfo) -> *const ::core::ffi::c_char;
    pub fn pq_getmsgrawstring(msg: StringInfo) -> *const ::core::ffi::c_char;
    pub fn pq_getmsgend(msg: StringInfo);
    pub fn RegisterExtensibleNodeMethods(methods: *const ExtensibleNodeMethods);
    pub fn GetExtensibleNodeMethods(
        extnodename: *const ::core::ffi::c_char,
        missing_ok: bool,
    ) -> *const ExtensibleNodeMethods;
    pub fn RegisterCustomScanMethods(methods: *const CustomScanMethods);
    pub fn GetCustomScanMethods(
        CustomName: *const ::core::ffi::c_char,
        missing_ok: bool,
    ) -> *const CustomScanMethods;
    pub fn makeA_Expr(
        kind: A_Expr_Kind::Type,
        name: *mut List,
        lexpr: *mut Node,
        rexpr: *mut Node,
        location: ::core::ffi::c_int,
    ) -> *mut A_Expr;
    pub fn makeSimpleA_Expr(
        kind: A_Expr_Kind::Type,
        name: *mut ::core::ffi::c_char,
        lexpr: *mut Node,
        rexpr: *mut Node,
        location: ::core::ffi::c_int,
    ) -> *mut A_Expr;
    pub fn makeVar(
        varno: ::core::ffi::c_int,
        varattno: AttrNumber,
        vartype: Oid,
        vartypmod: int32,
        varcollid: Oid,
        varlevelsup: Index,
    ) -> *mut Var;
    pub fn makeVarFromTargetEntry(varno: ::core::ffi::c_int, tle: *mut TargetEntry) -> *mut Var;
    pub fn makeWholeRowVar(
        rte: *mut RangeTblEntry,
        varno: ::core::ffi::c_int,
        varlevelsup: Index,
        allowScalar: bool,
    ) -> *mut Var;
    pub fn makeTargetEntry(
        expr: *mut Expr,
        resno: AttrNumber,
        resname: *mut ::core::ffi::c_char,
        resjunk: bool,
    ) -> *mut TargetEntry;
    pub fn flatCopyTargetEntry(src_tle: *mut TargetEntry) -> *mut TargetEntry;
    pub fn makeFromExpr(fromlist: *mut List, quals: *mut Node) -> *mut FromExpr;
    pub fn makeConst(
        consttype: Oid,
        consttypmod: int32,
        constcollid: Oid,
        constlen: ::core::ffi::c_int,
        constvalue: Datum,
        constisnull: bool,
        constbyval: bool,
    ) -> *mut Const;
    pub fn makeNullConst(consttype: Oid, consttypmod: int32, constcollid: Oid) -> *mut Const;
    pub fn makeBoolConst(value: bool, isnull: bool) -> *mut Node;
    pub fn makeBoolExpr(
        boolop: BoolExprType::Type,
        args: *mut List,
        location: ::core::ffi::c_int,
    ) -> *mut Expr;
    pub fn makeAlias(aliasname: *const ::core::ffi::c_char, colnames: *mut List) -> *mut Alias;
    pub fn makeRelabelType(
        arg: *mut Expr,
        rtype: Oid,
        rtypmod: int32,
        rcollid: Oid,
        rformat: CoercionForm::Type,
    ) -> *mut RelabelType;
    pub fn makeRangeVar(
        schemaname: *mut ::core::ffi::c_char,
        relname: *mut ::core::ffi::c_char,
        location: ::core::ffi::c_int,
    ) -> *mut RangeVar;
    pub fn makeTypeName(typnam: *mut ::core::ffi::c_char) -> *mut TypeName;
    pub fn makeTypeNameFromNameList(names: *mut List) -> *mut TypeName;
    pub fn makeTypeNameFromOid(typeOid: Oid, typmod: int32) -> *mut TypeName;
    pub fn makeColumnDef(
        colname: *const ::core::ffi::c_char,
        typeOid: Oid,
        typmod: int32,
        collOid: Oid,
    ) -> *mut ColumnDef;
    pub fn makeFuncExpr(
        funcid: Oid,
        rettype: Oid,
        args: *mut List,
        funccollid: Oid,
        inputcollid: Oid,
        fformat: CoercionForm::Type,
    ) -> *mut FuncExpr;
    pub fn makeFuncCall(
        name: *mut List,
        args: *mut List,
        funcformat: CoercionForm::Type,
        location: ::core::ffi::c_int,
    ) -> *mut FuncCall;
    pub fn make_opclause(
        opno: Oid,
        opresulttype: Oid,
        opretset: bool,
        leftop: *mut Expr,
        rightop: *mut Expr,
        opcollid: Oid,
        inputcollid: Oid,
    ) -> *mut Expr;
    pub fn make_andclause(andclauses: *mut List) -> *mut Expr;
    pub fn make_orclause(orclauses: *mut List) -> *mut Expr;
    pub fn make_notclause(notclause: *mut Expr) -> *mut Expr;
    pub fn make_and_qual(qual1: *mut Node, qual2: *mut Node) -> *mut Node;
    pub fn make_ands_explicit(andclauses: *mut List) -> *mut Expr;
    pub fn make_ands_implicit(clause: *mut Expr) -> *mut List;
    pub fn makeIndexInfo(
        numattrs: ::core::ffi::c_int,
        numkeyattrs: ::core::ffi::c_int,
        amoid: Oid,
        expressions: *mut List,
        predicates: *mut List,
        unique: bool,
        nulls_not_distinct: bool,
        isready: bool,
        concurrent: bool,
        summarizing: bool,
    ) -> *mut IndexInfo;
    pub fn makeStringConst(
        str_: *mut ::core::ffi::c_char,
        location: ::core::ffi::c_int,
    ) -> *mut Node;
    pub fn makeDefElem(
        name: *mut ::core::ffi::c_char,
        arg: *mut Node,
        location: ::core::ffi::c_int,
    ) -> *mut DefElem;
    pub fn makeDefElemExtended(
        nameSpace: *mut ::core::ffi::c_char,
        name: *mut ::core::ffi::c_char,
        arg: *mut Node,
        defaction: DefElemAction::Type,
        location: ::core::ffi::c_int,
    ) -> *mut DefElem;
    pub fn makeGroupingSet(
        kind: GroupingSetKind::Type,
        content: *mut List,
        location: ::core::ffi::c_int,
    ) -> *mut GroupingSet;
    pub fn makeVacuumRelation(
        relation: *mut RangeVar,
        oid: Oid,
        va_cols: *mut List,
    ) -> *mut VacuumRelation;
    pub fn makeJsonFormat(
        type_: JsonFormatType::Type,
        encoding: JsonEncoding::Type,
        location: ::core::ffi::c_int,
    ) -> *mut JsonFormat;
    pub fn makeJsonValueExpr(
        raw_expr: *mut Expr,
        formatted_expr: *mut Expr,
        format: *mut JsonFormat,
    ) -> *mut JsonValueExpr;
    pub fn makeJsonKeyValue(key: *mut Node, value: *mut Node) -> *mut Node;
    pub fn makeJsonIsPredicate(
        expr: *mut Node,
        format: *mut JsonFormat,
        item_type: JsonValueType::Type,
        unique_keys: bool,
        location: ::core::ffi::c_int,
    ) -> *mut Node;
    pub fn makeJsonBehavior(
        btype: JsonBehaviorType::Type,
        expr: *mut Node,
        location: ::core::ffi::c_int,
    ) -> *mut JsonBehavior;
    pub fn makeJsonTablePath(
        pathvalue: *mut Const,
        pathname: *mut ::core::ffi::c_char,
    ) -> *mut JsonTablePath;
    pub fn makeJsonTablePathSpec(
        string: *mut ::core::ffi::c_char,
        name: *mut ::core::ffi::c_char,
        string_location: ::core::ffi::c_int,
        name_location: ::core::ffi::c_int,
    ) -> *mut JsonTablePathSpec;
    pub fn exprType(expr: *const Node) -> Oid;
    pub fn exprTypmod(expr: *const Node) -> int32;
    pub fn exprIsLengthCoercion(expr: *const Node, coercedTypmod: *mut int32) -> bool;
    pub fn applyRelabelType(
        arg: *mut Node,
        rtype: Oid,
        rtypmod: int32,
        rcollid: Oid,
        rformat: CoercionForm::Type,
        rlocation: ::core::ffi::c_int,
        overwrite_ok: bool,
    ) -> *mut Node;
    pub fn relabel_to_typmod(expr: *mut Node, typmod: int32) -> *mut Node;
    pub fn strip_implicit_coercions(node: *mut Node) -> *mut Node;
    pub fn expression_returns_set(clause: *mut Node) -> bool;
    pub fn exprCollation(expr: *const Node) -> Oid;
    pub fn exprInputCollation(expr: *const Node) -> Oid;
    pub fn exprSetCollation(expr: *mut Node, collation: Oid);
    pub fn exprSetInputCollation(expr: *mut Node, inputcollation: Oid);
    pub fn exprLocation(expr: *const Node) -> ::core::ffi::c_int;
    pub fn fix_opfuncids(node: *mut Node);
    pub fn set_opfuncid(opexpr: *mut OpExpr);
    pub fn set_sa_opfuncid(opexpr: *mut ScalarArrayOpExpr);
    pub fn check_functions_in_node(
        node: *mut Node,
        checker: check_function_callback,
        context: *mut ::core::ffi::c_void,
    ) -> bool;
    pub fn expression_tree_walker_impl(
        node: *mut Node,
        walker: tree_walker_callback,
        context: *mut ::core::ffi::c_void,
    ) -> bool;
    pub fn expression_tree_mutator_impl(
        node: *mut Node,
        mutator: tree_mutator_callback,
        context: *mut ::core::ffi::c_void,
    ) -> *mut Node;
    pub fn query_tree_walker_impl(
        query: *mut Query,
        walker: tree_walker_callback,
        context: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> bool;
    pub fn query_tree_mutator_impl(
        query: *mut Query,
        mutator: tree_mutator_callback,
        context: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> *mut Query;
    pub fn range_table_walker_impl(
        rtable: *mut List,
        walker: tree_walker_callback,
        context: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> bool;
    pub fn range_table_mutator_impl(
        rtable: *mut List,
        mutator: tree_mutator_callback,
        context: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> *mut List;
    pub fn range_table_entry_walker_impl(
        rte: *mut RangeTblEntry,
        walker: tree_walker_callback,
        context: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> bool;
    pub fn query_or_expression_tree_walker_impl(
        node: *mut Node,
        walker: tree_walker_callback,
        context: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> bool;
    pub fn query_or_expression_tree_mutator_impl(
        node: *mut Node,
        mutator: tree_mutator_callback,
        context: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> *mut Node;
    pub fn raw_expression_tree_walker_impl(
        node: *mut Node,
        walker: tree_walker_callback,
        context: *mut ::core::ffi::c_void,
    ) -> bool;
    pub fn planstate_tree_walker_impl(
        planstate: *mut PlanState,
        walker: planstate_tree_walker_callback,
        context: *mut ::core::ffi::c_void,
    ) -> bool;
    pub fn print(obj: *const ::core::ffi::c_void);
    pub fn pprint(obj: *const ::core::ffi::c_void);
    pub fn elog_node_display(
        lev: ::core::ffi::c_int,
        title: *const ::core::ffi::c_char,
        obj: *const ::core::ffi::c_void,
        pretty: bool,
    );
    pub fn format_node_dump(dump: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn pretty_format_node_dump(dump: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn print_rt(rtable: *const List);
    pub fn print_expr(expr: *const Node, rtable: *const List);
    pub fn print_pathkeys(pathkeys: *const List, rtable: *const List);
    pub fn print_tl(tlist: *const List, rtable: *const List);
    pub fn print_slot(slot: *mut TupleTableSlot);
    pub fn make_append_rel_info(
        parentrel: Relation,
        childrel: Relation,
        parentRTindex: Index,
        childRTindex: Index,
    ) -> *mut AppendRelInfo;
    pub fn adjust_appendrel_attrs(
        root: *mut PlannerInfo,
        node: *mut Node,
        nappinfos: ::core::ffi::c_int,
        appinfos: *mut *mut AppendRelInfo,
    ) -> *mut Node;
    pub fn adjust_appendrel_attrs_multilevel(
        root: *mut PlannerInfo,
        node: *mut Node,
        childrel: *mut RelOptInfo,
        parentrel: *mut RelOptInfo,
    ) -> *mut Node;
    pub fn adjust_child_relids(
        relids: Relids,
        nappinfos: ::core::ffi::c_int,
        appinfos: *mut *mut AppendRelInfo,
    ) -> Relids;
    pub fn adjust_child_relids_multilevel(
        root: *mut PlannerInfo,
        relids: Relids,
        childrel: *mut RelOptInfo,
        parentrel: *mut RelOptInfo,
    ) -> Relids;
    pub fn adjust_inherited_attnums(attnums: *mut List, context: *mut AppendRelInfo) -> *mut List;
    pub fn adjust_inherited_attnums_multilevel(
        root: *mut PlannerInfo,
        attnums: *mut List,
        child_relid: Index,
        top_parent_relid: Index,
    ) -> *mut List;
    pub fn get_translated_update_targetlist(
        root: *mut PlannerInfo,
        relid: Index,
        processed_tlist: *mut *mut List,
        update_colnos: *mut *mut List,
    );
    pub fn find_appinfos_by_relids(
        root: *mut PlannerInfo,
        relids: Relids,
        nappinfos: *mut ::core::ffi::c_int,
    ) -> *mut *mut AppendRelInfo;
    pub fn add_row_identity_var(
        root: *mut PlannerInfo,
        orig_var: *mut Var,
        rtindex: Index,
        rowid_name: *const ::core::ffi::c_char,
    );
    pub fn add_row_identity_columns(
        root: *mut PlannerInfo,
        rtindex: Index,
        target_rte: *mut RangeTblEntry,
        target_relation: Relation,
    );
    pub fn distribute_row_identity_vars(root: *mut PlannerInfo);
    pub fn contain_agg_clause(clause: *mut Node) -> bool;
    pub fn contain_window_function(clause: *mut Node) -> bool;
    pub fn find_window_functions(clause: *mut Node, maxWinRef: Index) -> *mut WindowFuncLists;
    pub fn expression_returns_set_rows(root: *mut PlannerInfo, clause: *mut Node) -> f64;
    pub fn contain_subplans(clause: *mut Node) -> bool;
    pub fn max_parallel_hazard(parse: *mut Query) -> ::core::ffi::c_char;
    pub fn is_parallel_safe(root: *mut PlannerInfo, node: *mut Node) -> bool;
    pub fn contain_nonstrict_functions(clause: *mut Node) -> bool;
    pub fn contain_exec_param(clause: *mut Node, param_ids: *mut List) -> bool;
    pub fn contain_leaked_vars(clause: *mut Node) -> bool;
    pub fn find_nonnullable_rels(clause: *mut Node) -> Relids;
    pub fn find_nonnullable_vars(clause: *mut Node) -> *mut List;
    pub fn find_forced_null_vars(node: *mut Node) -> *mut List;
    pub fn find_forced_null_var(node: *mut Node) -> *mut Var;
    pub fn is_pseudo_constant_clause(clause: *mut Node) -> bool;
    pub fn is_pseudo_constant_clause_relids(clause: *mut Node, relids: Relids) -> bool;
    pub fn NumRelids(root: *mut PlannerInfo, clause: *mut Node) -> ::core::ffi::c_int;
    pub fn CommuteOpExpr(clause: *mut OpExpr);
    pub fn inline_set_returning_function(
        root: *mut PlannerInfo,
        rte: *mut RangeTblEntry,
    ) -> *mut Query;
    pub fn pull_paramids(expr: *mut Expr) -> *mut Bitmapset;
    pub static mut disable_cost: Cost;
    pub static mut max_parallel_workers_per_gather: ::core::ffi::c_int;
    pub static mut enable_seqscan: bool;
    pub static mut enable_indexscan: bool;
    pub static mut enable_indexonlyscan: bool;
    pub static mut enable_bitmapscan: bool;
    pub static mut enable_tidscan: bool;
    pub static mut enable_sort: bool;
    pub static mut enable_incremental_sort: bool;
    pub static mut enable_hashagg: bool;
    pub static mut enable_nestloop: bool;
    pub static mut enable_material: bool;
    pub static mut enable_memoize: bool;
    pub static mut enable_mergejoin: bool;
    pub static mut enable_hashjoin: bool;
    pub static mut enable_gathermerge: bool;
    pub static mut enable_partitionwise_join: bool;
    pub static mut enable_partitionwise_aggregate: bool;
    pub static mut enable_parallel_append: bool;
    pub static mut enable_parallel_hash: bool;
    pub static mut enable_partition_pruning: bool;
    pub static mut enable_presorted_aggregate: bool;
    pub static mut enable_async_append: bool;
    pub static mut constraint_exclusion: ::core::ffi::c_int;
    pub fn index_pages_fetched(
        tuples_fetched: f64,
        pages: BlockNumber,
        index_pages: f64,
        root: *mut PlannerInfo,
    ) -> f64;
    pub fn cost_seqscan(
        path: *mut Path,
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        param_info: *mut ParamPathInfo,
    );
    pub fn cost_samplescan(
        path: *mut Path,
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        param_info: *mut ParamPathInfo,
    );
    pub fn cost_index(
        path: *mut IndexPath,
        root: *mut PlannerInfo,
        loop_count: f64,
        partial_path: bool,
    );
    pub fn cost_bitmap_heap_scan(
        path: *mut Path,
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        param_info: *mut ParamPathInfo,
        bitmapqual: *mut Path,
        loop_count: f64,
    );
    pub fn cost_bitmap_and_node(path: *mut BitmapAndPath, root: *mut PlannerInfo);
    pub fn cost_bitmap_or_node(path: *mut BitmapOrPath, root: *mut PlannerInfo);
    pub fn cost_bitmap_tree_node(path: *mut Path, cost: *mut Cost, selec: *mut Selectivity);
    pub fn cost_tidscan(
        path: *mut Path,
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        tidquals: *mut List,
        param_info: *mut ParamPathInfo,
    );
    pub fn cost_tidrangescan(
        path: *mut Path,
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        tidrangequals: *mut List,
        param_info: *mut ParamPathInfo,
    );
    pub fn cost_subqueryscan(
        path: *mut SubqueryScanPath,
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        param_info: *mut ParamPathInfo,
        trivial_pathtarget: bool,
    );
    pub fn cost_functionscan(
        path: *mut Path,
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        param_info: *mut ParamPathInfo,
    );
    pub fn cost_valuesscan(
        path: *mut Path,
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        param_info: *mut ParamPathInfo,
    );
    pub fn cost_tablefuncscan(
        path: *mut Path,
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        param_info: *mut ParamPathInfo,
    );
    pub fn cost_ctescan(
        path: *mut Path,
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        param_info: *mut ParamPathInfo,
    );
    pub fn cost_namedtuplestorescan(
        path: *mut Path,
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        param_info: *mut ParamPathInfo,
    );
    pub fn cost_resultscan(
        path: *mut Path,
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        param_info: *mut ParamPathInfo,
    );
    pub fn cost_recursive_union(runion: *mut Path, nrterm: *mut Path, rterm: *mut Path);
    pub fn cost_sort(
        path: *mut Path,
        root: *mut PlannerInfo,
        pathkeys: *mut List,
        input_cost: Cost,
        tuples: f64,
        width: ::core::ffi::c_int,
        comparison_cost: Cost,
        sort_mem: ::core::ffi::c_int,
        limit_tuples: f64,
    );
    pub fn cost_incremental_sort(
        path: *mut Path,
        root: *mut PlannerInfo,
        pathkeys: *mut List,
        presorted_keys: ::core::ffi::c_int,
        input_startup_cost: Cost,
        input_total_cost: Cost,
        input_tuples: f64,
        width: ::core::ffi::c_int,
        comparison_cost: Cost,
        sort_mem: ::core::ffi::c_int,
        limit_tuples: f64,
    );
    pub fn cost_append(apath: *mut AppendPath);
    pub fn cost_merge_append(
        path: *mut Path,
        root: *mut PlannerInfo,
        pathkeys: *mut List,
        n_streams: ::core::ffi::c_int,
        input_startup_cost: Cost,
        input_total_cost: Cost,
        tuples: f64,
    );
    pub fn cost_material(
        path: *mut Path,
        input_startup_cost: Cost,
        input_total_cost: Cost,
        tuples: f64,
        width: ::core::ffi::c_int,
    );
    pub fn cost_agg(
        path: *mut Path,
        root: *mut PlannerInfo,
        aggstrategy: AggStrategy::Type,
        aggcosts: *const AggClauseCosts,
        numGroupCols: ::core::ffi::c_int,
        numGroups: f64,
        quals: *mut List,
        input_startup_cost: Cost,
        input_total_cost: Cost,
        input_tuples: f64,
        input_width: f64,
    );
    pub fn cost_windowagg(
        path: *mut Path,
        root: *mut PlannerInfo,
        windowFuncs: *mut List,
        winclause: *mut WindowClause,
        input_startup_cost: Cost,
        input_total_cost: Cost,
        input_tuples: f64,
    );
    pub fn cost_group(
        path: *mut Path,
        root: *mut PlannerInfo,
        numGroupCols: ::core::ffi::c_int,
        numGroups: f64,
        quals: *mut List,
        input_startup_cost: Cost,
        input_total_cost: Cost,
        input_tuples: f64,
    );
    pub fn initial_cost_nestloop(
        root: *mut PlannerInfo,
        workspace: *mut JoinCostWorkspace,
        jointype: JoinType::Type,
        outer_path: *mut Path,
        inner_path: *mut Path,
        extra: *mut JoinPathExtraData,
    );
    pub fn final_cost_nestloop(
        root: *mut PlannerInfo,
        path: *mut NestPath,
        workspace: *mut JoinCostWorkspace,
        extra: *mut JoinPathExtraData,
    );
    pub fn initial_cost_mergejoin(
        root: *mut PlannerInfo,
        workspace: *mut JoinCostWorkspace,
        jointype: JoinType::Type,
        mergeclauses: *mut List,
        outer_path: *mut Path,
        inner_path: *mut Path,
        outersortkeys: *mut List,
        innersortkeys: *mut List,
        extra: *mut JoinPathExtraData,
    );
    pub fn final_cost_mergejoin(
        root: *mut PlannerInfo,
        path: *mut MergePath,
        workspace: *mut JoinCostWorkspace,
        extra: *mut JoinPathExtraData,
    );
    pub fn initial_cost_hashjoin(
        root: *mut PlannerInfo,
        workspace: *mut JoinCostWorkspace,
        jointype: JoinType::Type,
        hashclauses: *mut List,
        outer_path: *mut Path,
        inner_path: *mut Path,
        extra: *mut JoinPathExtraData,
        parallel_hash: bool,
    );
    pub fn final_cost_hashjoin(
        root: *mut PlannerInfo,
        path: *mut HashPath,
        workspace: *mut JoinCostWorkspace,
        extra: *mut JoinPathExtraData,
    );
    pub fn cost_gather(
        path: *mut GatherPath,
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        param_info: *mut ParamPathInfo,
        rows: *mut f64,
    );
    pub fn cost_gather_merge(
        path: *mut GatherMergePath,
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        param_info: *mut ParamPathInfo,
        input_startup_cost: Cost,
        input_total_cost: Cost,
        rows: *mut f64,
    );
    pub fn cost_subplan(root: *mut PlannerInfo, subplan: *mut SubPlan, plan: *mut Plan);
    pub fn cost_qual_eval(cost: *mut QualCost, quals: *mut List, root: *mut PlannerInfo);
    pub fn cost_qual_eval_node(cost: *mut QualCost, qual: *mut Node, root: *mut PlannerInfo);
    pub fn compute_semi_anti_join_factors(
        root: *mut PlannerInfo,
        joinrel: *mut RelOptInfo,
        outerrel: *mut RelOptInfo,
        innerrel: *mut RelOptInfo,
        jointype: JoinType::Type,
        sjinfo: *mut SpecialJoinInfo,
        restrictlist: *mut List,
        semifactors: *mut SemiAntiJoinFactors,
    );
    pub fn set_baserel_size_estimates(root: *mut PlannerInfo, rel: *mut RelOptInfo);
    pub fn get_parameterized_baserel_size(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        param_clauses: *mut List,
    ) -> f64;
    pub fn get_parameterized_joinrel_size(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        outer_path: *mut Path,
        inner_path: *mut Path,
        sjinfo: *mut SpecialJoinInfo,
        restrict_clauses: *mut List,
    ) -> f64;
    pub fn set_joinrel_size_estimates(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        outer_rel: *mut RelOptInfo,
        inner_rel: *mut RelOptInfo,
        sjinfo: *mut SpecialJoinInfo,
        restrictlist: *mut List,
    );
    pub fn set_subquery_size_estimates(root: *mut PlannerInfo, rel: *mut RelOptInfo);
    pub fn set_function_size_estimates(root: *mut PlannerInfo, rel: *mut RelOptInfo);
    pub fn set_values_size_estimates(root: *mut PlannerInfo, rel: *mut RelOptInfo);
    pub fn set_cte_size_estimates(root: *mut PlannerInfo, rel: *mut RelOptInfo, cte_rows: f64);
    pub fn set_tablefunc_size_estimates(root: *mut PlannerInfo, rel: *mut RelOptInfo);
    pub fn set_namedtuplestore_size_estimates(root: *mut PlannerInfo, rel: *mut RelOptInfo);
    pub fn set_result_size_estimates(root: *mut PlannerInfo, rel: *mut RelOptInfo);
    pub fn set_foreign_size_estimates(root: *mut PlannerInfo, rel: *mut RelOptInfo);
    pub fn set_pathtarget_cost_width(
        root: *mut PlannerInfo,
        target: *mut PathTarget,
    ) -> *mut PathTarget;
    pub fn compute_bitmap_pages(
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        bitmapqual: *mut Path,
        loop_count: f64,
        cost_p: *mut Cost,
        tuples_p: *mut f64,
    ) -> f64;
    pub fn clause_selectivity(
        root: *mut PlannerInfo,
        clause: *mut Node,
        varRelid: ::core::ffi::c_int,
        jointype: JoinType::Type,
        sjinfo: *mut SpecialJoinInfo,
    ) -> Selectivity;
    pub fn clause_selectivity_ext(
        root: *mut PlannerInfo,
        clause: *mut Node,
        varRelid: ::core::ffi::c_int,
        jointype: JoinType::Type,
        sjinfo: *mut SpecialJoinInfo,
        use_extended_stats: bool,
    ) -> Selectivity;
    pub fn clauselist_selectivity(
        root: *mut PlannerInfo,
        clauses: *mut List,
        varRelid: ::core::ffi::c_int,
        jointype: JoinType::Type,
        sjinfo: *mut SpecialJoinInfo,
    ) -> Selectivity;
    pub fn clauselist_selectivity_ext(
        root: *mut PlannerInfo,
        clauses: *mut List,
        varRelid: ::core::ffi::c_int,
        jointype: JoinType::Type,
        sjinfo: *mut SpecialJoinInfo,
        use_extended_stats: bool,
    ) -> Selectivity;
    pub static mut seq_page_cost: f64;
    pub static mut random_page_cost: f64;
    pub static mut cpu_tuple_cost: f64;
    pub static mut cpu_index_tuple_cost: f64;
    pub static mut cpu_operator_cost: f64;
    pub static mut parallel_tuple_cost: f64;
    pub static mut parallel_setup_cost: f64;
    pub static mut recursive_worktable_factor: f64;
    pub static mut effective_cache_size: ::core::ffi::c_int;
    pub fn clamp_row_est(nrows: f64) -> f64;
    pub fn clamp_width_est(tuple_width: int64) -> int32;
    pub fn clamp_cardinality_to_long(x: Cardinality) -> ::core::ffi::c_long;
    pub fn is_pseudo_constant_for_index(
        root: *mut PlannerInfo,
        expr: *mut Node,
        index: *mut IndexOptInfo,
    ) -> bool;
    pub static mut debug_parallel_query: ::core::ffi::c_int;
    pub static mut parallel_leader_participation: bool;
    pub fn planner(
        parse: *mut Query,
        query_string: *const ::core::ffi::c_char,
        cursorOptions: ::core::ffi::c_int,
        boundParams: *mut ParamListInfoData,
    ) -> *mut PlannedStmt;
    pub fn expression_planner(expr: *mut Expr) -> *mut Expr;
    pub fn expression_planner_with_deps(
        expr: *mut Expr,
        relationOids: *mut *mut List,
        invalItems: *mut *mut List,
    ) -> *mut Expr;
    pub fn plan_cluster_use_sort(tableOid: Oid, indexOid: Oid) -> bool;
    pub fn plan_create_index_workers(tableOid: Oid, indexOid: Oid) -> ::core::ffi::c_int;
    pub fn extract_query_dependencies(
        query: *mut Node,
        relationOids: *mut *mut List,
        invalItems: *mut *mut List,
        hasRowSecurity: *mut bool,
    );
    pub fn negate_clause(node: *mut Node) -> *mut Node;
    pub fn canonicalize_qual(qual: *mut Expr, is_check: bool) -> *mut Expr;
    pub fn contain_mutable_functions(clause: *mut Node) -> bool;
    pub fn contain_mutable_functions_after_planning(expr: *mut Expr) -> bool;
    pub fn contain_volatile_functions(clause: *mut Node) -> bool;
    pub fn contain_volatile_functions_after_planning(expr: *mut Expr) -> bool;
    pub fn contain_volatile_functions_not_nextval(clause: *mut Node) -> bool;
    pub fn eval_const_expressions(root: *mut PlannerInfo, node: *mut Node) -> *mut Node;
    pub fn convert_saop_to_hashed_saop(node: *mut Node);
    pub fn estimate_expression_value(root: *mut PlannerInfo, node: *mut Node) -> *mut Node;
    pub fn evaluate_expr(
        expr: *mut Expr,
        result_type: Oid,
        result_typmod: int32,
        result_collation: Oid,
    ) -> *mut Expr;
    pub fn expand_function_arguments(
        args: *mut List,
        include_out_arguments: bool,
        result_type: Oid,
        func_tuple: *mut HeapTupleData,
    ) -> *mut List;
    pub fn predicate_implied_by(
        predicate_list: *mut List,
        clause_list: *mut List,
        weak: bool,
    ) -> bool;
    pub fn predicate_refuted_by(
        predicate_list: *mut List,
        clause_list: *mut List,
        weak: bool,
    ) -> bool;
    pub fn count_nonjunk_tlist_entries(tlist: *mut List) -> ::core::ffi::c_int;
    pub fn get_sortgroupref_tle(sortref: Index, targetList: *mut List) -> *mut TargetEntry;
    pub fn get_sortgroupclause_tle(
        sgClause: *mut SortGroupClause,
        targetList: *mut List,
    ) -> *mut TargetEntry;
    pub fn get_sortgroupclause_expr(
        sgClause: *mut SortGroupClause,
        targetList: *mut List,
    ) -> *mut Node;
    pub fn get_sortgrouplist_exprs(sgClauses: *mut List, targetList: *mut List) -> *mut List;
    pub fn get_sortgroupref_clause(sortref: Index, clauses: *mut List) -> *mut SortGroupClause;
    pub fn get_sortgroupref_clause_noerr(
        sortref: Index,
        clauses: *mut List,
    ) -> *mut SortGroupClause;
    pub fn pull_varnos(root: *mut PlannerInfo, node: *mut Node) -> *mut Bitmapset;
    pub fn pull_varnos_of_level(
        root: *mut PlannerInfo,
        node: *mut Node,
        levelsup: ::core::ffi::c_int,
    ) -> *mut Bitmapset;
    pub fn pull_varattnos(node: *mut Node, varno: Index, varattnos: *mut *mut Bitmapset);
    pub fn pull_vars_of_level(node: *mut Node, levelsup: ::core::ffi::c_int) -> *mut List;
    pub fn contain_var_clause(node: *mut Node) -> bool;
    pub fn contain_vars_of_level(node: *mut Node, levelsup: ::core::ffi::c_int) -> bool;
    pub fn locate_var_of_level(node: *mut Node, levelsup: ::core::ffi::c_int)
        -> ::core::ffi::c_int;
    pub fn pull_var_clause(node: *mut Node, flags: ::core::ffi::c_int) -> *mut List;
    pub fn flatten_join_alias_vars(
        root: *mut PlannerInfo,
        query: *mut Query,
        node: *mut Node,
    ) -> *mut Node;
    pub fn compare_path_costs(
        path1: *mut Path,
        path2: *mut Path,
        criterion: CostSelector::Type,
    ) -> ::core::ffi::c_int;
    pub fn compare_fractional_path_costs(
        path1: *mut Path,
        path2: *mut Path,
        fraction: f64,
    ) -> ::core::ffi::c_int;
    pub fn set_cheapest(parent_rel: *mut RelOptInfo);
    pub fn add_path(parent_rel: *mut RelOptInfo, new_path: *mut Path);
    pub fn add_path_precheck(
        parent_rel: *mut RelOptInfo,
        startup_cost: Cost,
        total_cost: Cost,
        pathkeys: *mut List,
        required_outer: Relids,
    ) -> bool;
    pub fn add_partial_path(parent_rel: *mut RelOptInfo, new_path: *mut Path);
    pub fn add_partial_path_precheck(
        parent_rel: *mut RelOptInfo,
        total_cost: Cost,
        pathkeys: *mut List,
    ) -> bool;
    pub fn create_seqscan_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        required_outer: Relids,
        parallel_workers: ::core::ffi::c_int,
    ) -> *mut Path;
    pub fn create_samplescan_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        required_outer: Relids,
    ) -> *mut Path;
    pub fn create_index_path(
        root: *mut PlannerInfo,
        index: *mut IndexOptInfo,
        indexclauses: *mut List,
        indexorderbys: *mut List,
        indexorderbycols: *mut List,
        pathkeys: *mut List,
        indexscandir: ScanDirection::Type,
        indexonly: bool,
        required_outer: Relids,
        loop_count: f64,
        partial_path: bool,
    ) -> *mut IndexPath;
    pub fn create_bitmap_heap_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        bitmapqual: *mut Path,
        required_outer: Relids,
        loop_count: f64,
        parallel_degree: ::core::ffi::c_int,
    ) -> *mut BitmapHeapPath;
    pub fn create_bitmap_and_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        bitmapquals: *mut List,
    ) -> *mut BitmapAndPath;
    pub fn create_bitmap_or_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        bitmapquals: *mut List,
    ) -> *mut BitmapOrPath;
    pub fn create_tidscan_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        tidquals: *mut List,
        required_outer: Relids,
    ) -> *mut TidPath;
    pub fn create_tidrangescan_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        tidrangequals: *mut List,
        required_outer: Relids,
    ) -> *mut TidRangePath;
    pub fn create_append_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpaths: *mut List,
        partial_subpaths: *mut List,
        pathkeys: *mut List,
        required_outer: Relids,
        parallel_workers: ::core::ffi::c_int,
        parallel_aware: bool,
        rows: f64,
    ) -> *mut AppendPath;
    pub fn create_merge_append_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpaths: *mut List,
        pathkeys: *mut List,
        required_outer: Relids,
    ) -> *mut MergeAppendPath;
    pub fn create_group_result_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        target: *mut PathTarget,
        havingqual: *mut List,
    ) -> *mut GroupResultPath;
    pub fn create_material_path(rel: *mut RelOptInfo, subpath: *mut Path) -> *mut MaterialPath;
    pub fn create_memoize_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        param_exprs: *mut List,
        hash_operators: *mut List,
        singlerow: bool,
        binary_mode: bool,
        calls: f64,
    ) -> *mut MemoizePath;
    pub fn create_unique_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        sjinfo: *mut SpecialJoinInfo,
    ) -> *mut UniquePath;
    pub fn create_gather_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        target: *mut PathTarget,
        required_outer: Relids,
        rows: *mut f64,
    ) -> *mut GatherPath;
    pub fn create_gather_merge_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        target: *mut PathTarget,
        pathkeys: *mut List,
        required_outer: Relids,
        rows: *mut f64,
    ) -> *mut GatherMergePath;
    pub fn create_subqueryscan_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        trivial_pathtarget: bool,
        pathkeys: *mut List,
        required_outer: Relids,
    ) -> *mut SubqueryScanPath;
    pub fn create_functionscan_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        pathkeys: *mut List,
        required_outer: Relids,
    ) -> *mut Path;
    pub fn create_valuesscan_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        required_outer: Relids,
    ) -> *mut Path;
    pub fn create_tablefuncscan_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        required_outer: Relids,
    ) -> *mut Path;
    pub fn create_ctescan_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        pathkeys: *mut List,
        required_outer: Relids,
    ) -> *mut Path;
    pub fn create_namedtuplestorescan_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        required_outer: Relids,
    ) -> *mut Path;
    pub fn create_resultscan_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        required_outer: Relids,
    ) -> *mut Path;
    pub fn create_worktablescan_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        required_outer: Relids,
    ) -> *mut Path;
    pub fn create_foreignscan_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        target: *mut PathTarget,
        rows: f64,
        startup_cost: Cost,
        total_cost: Cost,
        pathkeys: *mut List,
        required_outer: Relids,
        fdw_outerpath: *mut Path,
        fdw_restrictinfo: *mut List,
        fdw_private: *mut List,
    ) -> *mut ForeignPath;
    pub fn create_foreign_join_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        target: *mut PathTarget,
        rows: f64,
        startup_cost: Cost,
        total_cost: Cost,
        pathkeys: *mut List,
        required_outer: Relids,
        fdw_outerpath: *mut Path,
        fdw_restrictinfo: *mut List,
        fdw_private: *mut List,
    ) -> *mut ForeignPath;
    pub fn create_foreign_upper_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        target: *mut PathTarget,
        rows: f64,
        startup_cost: Cost,
        total_cost: Cost,
        pathkeys: *mut List,
        fdw_outerpath: *mut Path,
        fdw_restrictinfo: *mut List,
        fdw_private: *mut List,
    ) -> *mut ForeignPath;
    pub fn calc_nestloop_required_outer(
        outerrelids: Relids,
        outer_paramrels: Relids,
        innerrelids: Relids,
        inner_paramrels: Relids,
    ) -> Relids;
    pub fn calc_non_nestloop_required_outer(outer_path: *mut Path, inner_path: *mut Path)
        -> Relids;
    pub fn create_nestloop_path(
        root: *mut PlannerInfo,
        joinrel: *mut RelOptInfo,
        jointype: JoinType::Type,
        workspace: *mut JoinCostWorkspace,
        extra: *mut JoinPathExtraData,
        outer_path: *mut Path,
        inner_path: *mut Path,
        restrict_clauses: *mut List,
        pathkeys: *mut List,
        required_outer: Relids,
    ) -> *mut NestPath;
    pub fn create_mergejoin_path(
        root: *mut PlannerInfo,
        joinrel: *mut RelOptInfo,
        jointype: JoinType::Type,
        workspace: *mut JoinCostWorkspace,
        extra: *mut JoinPathExtraData,
        outer_path: *mut Path,
        inner_path: *mut Path,
        restrict_clauses: *mut List,
        pathkeys: *mut List,
        required_outer: Relids,
        mergeclauses: *mut List,
        outersortkeys: *mut List,
        innersortkeys: *mut List,
    ) -> *mut MergePath;
    pub fn create_hashjoin_path(
        root: *mut PlannerInfo,
        joinrel: *mut RelOptInfo,
        jointype: JoinType::Type,
        workspace: *mut JoinCostWorkspace,
        extra: *mut JoinPathExtraData,
        outer_path: *mut Path,
        inner_path: *mut Path,
        parallel_hash: bool,
        restrict_clauses: *mut List,
        required_outer: Relids,
        hashclauses: *mut List,
    ) -> *mut HashPath;
    pub fn create_projection_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        target: *mut PathTarget,
    ) -> *mut ProjectionPath;
    pub fn apply_projection_to_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        path: *mut Path,
        target: *mut PathTarget,
    ) -> *mut Path;
    pub fn create_set_projection_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        target: *mut PathTarget,
    ) -> *mut ProjectSetPath;
    pub fn create_sort_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        pathkeys: *mut List,
        limit_tuples: f64,
    ) -> *mut SortPath;
    pub fn create_incremental_sort_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        pathkeys: *mut List,
        presorted_keys: ::core::ffi::c_int,
        limit_tuples: f64,
    ) -> *mut IncrementalSortPath;
    pub fn create_group_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        groupClause: *mut List,
        qual: *mut List,
        numGroups: f64,
    ) -> *mut GroupPath;
    pub fn create_upper_unique_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        numCols: ::core::ffi::c_int,
        numGroups: f64,
    ) -> *mut UpperUniquePath;
    pub fn create_agg_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        target: *mut PathTarget,
        aggstrategy: AggStrategy::Type,
        aggsplit: AggSplit::Type,
        groupClause: *mut List,
        qual: *mut List,
        aggcosts: *const AggClauseCosts,
        numGroups: f64,
    ) -> *mut AggPath;
    pub fn create_groupingsets_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        having_qual: *mut List,
        aggstrategy: AggStrategy::Type,
        rollups: *mut List,
        agg_costs: *const AggClauseCosts,
    ) -> *mut GroupingSetsPath;
    pub fn create_minmaxagg_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        target: *mut PathTarget,
        mmaggregates: *mut List,
        quals: *mut List,
    ) -> *mut MinMaxAggPath;
    pub fn create_windowagg_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        target: *mut PathTarget,
        windowFuncs: *mut List,
        runCondition: *mut List,
        winclause: *mut WindowClause,
        qual: *mut List,
        topwindow: bool,
    ) -> *mut WindowAggPath;
    pub fn create_setop_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        cmd: SetOpCmd::Type,
        strategy: SetOpStrategy::Type,
        distinctList: *mut List,
        flagColIdx: AttrNumber,
        firstFlag: ::core::ffi::c_int,
        numGroups: f64,
        outputRows: f64,
    ) -> *mut SetOpPath;
    pub fn create_recursiveunion_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        leftpath: *mut Path,
        rightpath: *mut Path,
        target: *mut PathTarget,
        distinctList: *mut List,
        wtParam: ::core::ffi::c_int,
        numGroups: f64,
    ) -> *mut RecursiveUnionPath;
    pub fn create_lockrows_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        rowMarks: *mut List,
        epqParam: ::core::ffi::c_int,
    ) -> *mut LockRowsPath;
    pub fn create_modifytable_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        operation: CmdType::Type,
        canSetTag: bool,
        nominalRelation: Index,
        rootRelation: Index,
        partColsUpdated: bool,
        resultRelations: *mut List,
        updateColnosLists: *mut List,
        withCheckOptionLists: *mut List,
        returningLists: *mut List,
        rowMarks: *mut List,
        onconflict: *mut OnConflictExpr,
        mergeActionLists: *mut List,
        mergeJoinConditions: *mut List,
        epqParam: ::core::ffi::c_int,
    ) -> *mut ModifyTablePath;
    pub fn create_limit_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        limitOffset: *mut Node,
        limitCount: *mut Node,
        limitOption: LimitOption::Type,
        offset_est: int64,
        count_est: int64,
    ) -> *mut LimitPath;
    pub fn adjust_limit_rows_costs(
        rows: *mut f64,
        startup_cost: *mut Cost,
        total_cost: *mut Cost,
        offset_est: int64,
        count_est: int64,
    );
    pub fn reparameterize_path(
        root: *mut PlannerInfo,
        path: *mut Path,
        required_outer: Relids,
        loop_count: f64,
    ) -> *mut Path;
    pub fn reparameterize_path_by_child(
        root: *mut PlannerInfo,
        path: *mut Path,
        child_rel: *mut RelOptInfo,
    ) -> *mut Path;
    pub fn path_is_reparameterizable_by_child(path: *mut Path, child_rel: *mut RelOptInfo) -> bool;
    pub fn setup_simple_rel_arrays(root: *mut PlannerInfo);
    pub fn expand_planner_arrays(root: *mut PlannerInfo, add_size: ::core::ffi::c_int);
    pub fn build_simple_rel(
        root: *mut PlannerInfo,
        relid: ::core::ffi::c_int,
        parent: *mut RelOptInfo,
    ) -> *mut RelOptInfo;
    pub fn find_base_rel(root: *mut PlannerInfo, relid: ::core::ffi::c_int) -> *mut RelOptInfo;
    pub fn find_base_rel_noerr(
        root: *mut PlannerInfo,
        relid: ::core::ffi::c_int,
    ) -> *mut RelOptInfo;
    pub fn find_base_rel_ignore_join(
        root: *mut PlannerInfo,
        relid: ::core::ffi::c_int,
    ) -> *mut RelOptInfo;
    pub fn find_join_rel(root: *mut PlannerInfo, relids: Relids) -> *mut RelOptInfo;
    pub fn build_join_rel(
        root: *mut PlannerInfo,
        joinrelids: Relids,
        outer_rel: *mut RelOptInfo,
        inner_rel: *mut RelOptInfo,
        sjinfo: *mut SpecialJoinInfo,
        pushed_down_joins: *mut List,
        restrictlist_ptr: *mut *mut List,
    ) -> *mut RelOptInfo;
    pub fn min_join_parameterization(
        root: *mut PlannerInfo,
        joinrelids: Relids,
        outer_rel: *mut RelOptInfo,
        inner_rel: *mut RelOptInfo,
    ) -> Relids;
    pub fn fetch_upper_rel(
        root: *mut PlannerInfo,
        kind: UpperRelationKind::Type,
        relids: Relids,
    ) -> *mut RelOptInfo;
    pub fn find_childrel_parents(root: *mut PlannerInfo, rel: *mut RelOptInfo) -> Relids;
    pub fn get_baserel_parampathinfo(
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        required_outer: Relids,
    ) -> *mut ParamPathInfo;
    pub fn get_joinrel_parampathinfo(
        root: *mut PlannerInfo,
        joinrel: *mut RelOptInfo,
        outer_path: *mut Path,
        inner_path: *mut Path,
        sjinfo: *mut SpecialJoinInfo,
        required_outer: Relids,
        restrict_clauses: *mut *mut List,
    ) -> *mut ParamPathInfo;
    pub fn get_appendrel_parampathinfo(
        appendrel: *mut RelOptInfo,
        required_outer: Relids,
    ) -> *mut ParamPathInfo;
    pub fn find_param_path_info(rel: *mut RelOptInfo, required_outer: Relids)
        -> *mut ParamPathInfo;
    pub fn get_param_path_clause_serials(path: *mut Path) -> *mut Bitmapset;
    pub fn build_child_join_rel(
        root: *mut PlannerInfo,
        outer_rel: *mut RelOptInfo,
        inner_rel: *mut RelOptInfo,
        parent_joinrel: *mut RelOptInfo,
        restrictlist: *mut List,
        sjinfo: *mut SpecialJoinInfo,
    ) -> *mut RelOptInfo;
    pub static mut enable_geqo: bool;
    pub static mut geqo_threshold: ::core::ffi::c_int;
    pub static mut min_parallel_table_scan_size: ::core::ffi::c_int;
    pub static mut min_parallel_index_scan_size: ::core::ffi::c_int;
    pub static mut enable_group_by_reordering: bool;
    pub static mut set_rel_pathlist_hook: set_rel_pathlist_hook_type;
    pub static mut set_join_pathlist_hook: set_join_pathlist_hook_type;
    pub static mut join_search_hook: join_search_hook_type;
    pub fn make_one_rel(root: *mut PlannerInfo, joinlist: *mut List) -> *mut RelOptInfo;
    pub fn standard_join_search(
        root: *mut PlannerInfo,
        levels_needed: ::core::ffi::c_int,
        initial_rels: *mut List,
    ) -> *mut RelOptInfo;
    pub fn generate_gather_paths(root: *mut PlannerInfo, rel: *mut RelOptInfo, override_rows: bool);
    pub fn generate_useful_gather_paths(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        override_rows: bool,
    );
    pub fn compute_parallel_worker(
        rel: *mut RelOptInfo,
        heap_pages: f64,
        index_pages: f64,
        max_workers: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn create_partial_bitmap_paths(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        bitmapqual: *mut Path,
    );
    pub fn generate_partitionwise_join_paths(root: *mut PlannerInfo, rel: *mut RelOptInfo);
    pub fn create_index_paths(root: *mut PlannerInfo, rel: *mut RelOptInfo);
    pub fn relation_has_unique_index_for(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        restrictlist: *mut List,
        exprlist: *mut List,
        oprlist: *mut List,
    ) -> bool;
    pub fn indexcol_is_bool_constant_for_query(
        root: *mut PlannerInfo,
        index: *mut IndexOptInfo,
        indexcol: ::core::ffi::c_int,
    ) -> bool;
    pub fn match_index_to_operand(
        operand: *mut Node,
        indexcol: ::core::ffi::c_int,
        index: *mut IndexOptInfo,
    ) -> bool;
    pub fn check_index_predicates(root: *mut PlannerInfo, rel: *mut RelOptInfo);
    pub fn create_tidscan_paths(root: *mut PlannerInfo, rel: *mut RelOptInfo);
    pub fn add_paths_to_joinrel(
        root: *mut PlannerInfo,
        joinrel: *mut RelOptInfo,
        outerrel: *mut RelOptInfo,
        innerrel: *mut RelOptInfo,
        jointype: JoinType::Type,
        sjinfo: *mut SpecialJoinInfo,
        restrictlist: *mut List,
    );
    pub fn join_search_one_level(root: *mut PlannerInfo, level: ::core::ffi::c_int);
    pub fn make_join_rel(
        root: *mut PlannerInfo,
        rel1: *mut RelOptInfo,
        rel2: *mut RelOptInfo,
    ) -> *mut RelOptInfo;
    pub fn add_outer_joins_to_relids(
        root: *mut PlannerInfo,
        input_relids: Relids,
        sjinfo: *mut SpecialJoinInfo,
        pushed_down_joins: *mut *mut List,
    ) -> Relids;
    pub fn have_join_order_restriction(
        root: *mut PlannerInfo,
        rel1: *mut RelOptInfo,
        rel2: *mut RelOptInfo,
    ) -> bool;
    pub fn have_dangerous_phv(
        root: *mut PlannerInfo,
        outer_relids: Relids,
        inner_params: Relids,
    ) -> bool;
    pub fn mark_dummy_rel(rel: *mut RelOptInfo);
    pub fn init_dummy_sjinfo(
        sjinfo: *mut SpecialJoinInfo,
        left_relids: Relids,
        right_relids: Relids,
    );
    pub fn process_equivalence(
        root: *mut PlannerInfo,
        p_restrictinfo: *mut *mut RestrictInfo,
        jdomain: *mut JoinDomain,
    ) -> bool;
    pub fn canonicalize_ec_expression(
        expr: *mut Expr,
        req_type: Oid,
        req_collation: Oid,
    ) -> *mut Expr;
    pub fn reconsider_outer_join_clauses(root: *mut PlannerInfo);
    pub fn get_eclass_for_sort_expr(
        root: *mut PlannerInfo,
        expr: *mut Expr,
        opfamilies: *mut List,
        opcintype: Oid,
        collation: Oid,
        sortref: Index,
        rel: Relids,
        create_it: bool,
    ) -> *mut EquivalenceClass;
    pub fn find_ec_member_matching_expr(
        ec: *mut EquivalenceClass,
        expr: *mut Expr,
        relids: Relids,
    ) -> *mut EquivalenceMember;
    pub fn find_computable_ec_member(
        root: *mut PlannerInfo,
        ec: *mut EquivalenceClass,
        exprs: *mut List,
        relids: Relids,
        require_parallel_safe: bool,
    ) -> *mut EquivalenceMember;
    pub fn relation_can_be_sorted_early(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        ec: *mut EquivalenceClass,
        require_parallel_safe: bool,
    ) -> bool;
    pub fn generate_base_implied_equalities(root: *mut PlannerInfo);
    pub fn generate_join_implied_equalities(
        root: *mut PlannerInfo,
        join_relids: Relids,
        outer_relids: Relids,
        inner_rel: *mut RelOptInfo,
        sjinfo: *mut SpecialJoinInfo,
    ) -> *mut List;
    pub fn generate_join_implied_equalities_for_ecs(
        root: *mut PlannerInfo,
        eclasses: *mut List,
        join_relids: Relids,
        outer_relids: Relids,
        inner_rel: *mut RelOptInfo,
    ) -> *mut List;
    pub fn exprs_known_equal(root: *mut PlannerInfo, item1: *mut Node, item2: *mut Node) -> bool;
    pub fn match_eclasses_to_foreign_key_col(
        root: *mut PlannerInfo,
        fkinfo: *mut ForeignKeyOptInfo,
        colno: ::core::ffi::c_int,
    ) -> *mut EquivalenceClass;
    pub fn find_derived_clause_for_ec_member(
        ec: *mut EquivalenceClass,
        em: *mut EquivalenceMember,
    ) -> *mut RestrictInfo;
    pub fn add_child_rel_equivalences(
        root: *mut PlannerInfo,
        appinfo: *mut AppendRelInfo,
        parent_rel: *mut RelOptInfo,
        child_rel: *mut RelOptInfo,
    );
    pub fn add_child_join_rel_equivalences(
        root: *mut PlannerInfo,
        nappinfos: ::core::ffi::c_int,
        appinfos: *mut *mut AppendRelInfo,
        parent_joinrel: *mut RelOptInfo,
        child_joinrel: *mut RelOptInfo,
    );
    pub fn add_setop_child_rel_equivalences(
        root: *mut PlannerInfo,
        child_rel: *mut RelOptInfo,
        child_tlist: *mut List,
        setop_pathkeys: *mut List,
    );
    pub fn generate_implied_equalities_for_column(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        callback: ec_matches_callback_type,
        callback_arg: *mut ::core::ffi::c_void,
        prohibited_rels: Relids,
    ) -> *mut List;
    pub fn have_relevant_eclass_joinclause(
        root: *mut PlannerInfo,
        rel1: *mut RelOptInfo,
        rel2: *mut RelOptInfo,
    ) -> bool;
    pub fn has_relevant_eclass_joinclause(root: *mut PlannerInfo, rel1: *mut RelOptInfo) -> bool;
    pub fn eclass_useful_for_merging(
        root: *mut PlannerInfo,
        eclass: *mut EquivalenceClass,
        rel: *mut RelOptInfo,
    ) -> bool;
    pub fn is_redundant_derived_clause(rinfo: *mut RestrictInfo, clauselist: *mut List) -> bool;
    pub fn is_redundant_with_indexclauses(
        rinfo: *mut RestrictInfo,
        indexclauses: *mut List,
    ) -> bool;
    pub fn compare_pathkeys(keys1: *mut List, keys2: *mut List) -> PathKeysComparison::Type;
    pub fn pathkeys_contained_in(keys1: *mut List, keys2: *mut List) -> bool;
    pub fn pathkeys_count_contained_in(
        keys1: *mut List,
        keys2: *mut List,
        n_common: *mut ::core::ffi::c_int,
    ) -> bool;
    pub fn get_useful_group_keys_orderings(root: *mut PlannerInfo, path: *mut Path) -> *mut List;
    pub fn get_cheapest_path_for_pathkeys(
        paths: *mut List,
        pathkeys: *mut List,
        required_outer: Relids,
        cost_criterion: CostSelector::Type,
        require_parallel_safe: bool,
    ) -> *mut Path;
    pub fn get_cheapest_fractional_path_for_pathkeys(
        paths: *mut List,
        pathkeys: *mut List,
        required_outer: Relids,
        fraction: f64,
    ) -> *mut Path;
    pub fn get_cheapest_parallel_safe_total_inner(paths: *mut List) -> *mut Path;
    pub fn build_index_pathkeys(
        root: *mut PlannerInfo,
        index: *mut IndexOptInfo,
        scandir: ScanDirection::Type,
    ) -> *mut List;
    pub fn build_partition_pathkeys(
        root: *mut PlannerInfo,
        partrel: *mut RelOptInfo,
        scandir: ScanDirection::Type,
        partialkeys: *mut bool,
    ) -> *mut List;
    pub fn build_expression_pathkey(
        root: *mut PlannerInfo,
        expr: *mut Expr,
        opno: Oid,
        rel: Relids,
        create_it: bool,
    ) -> *mut List;
    pub fn convert_subquery_pathkeys(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subquery_pathkeys: *mut List,
        subquery_tlist: *mut List,
    ) -> *mut List;
    pub fn build_join_pathkeys(
        root: *mut PlannerInfo,
        joinrel: *mut RelOptInfo,
        jointype: JoinType::Type,
        outer_pathkeys: *mut List,
    ) -> *mut List;
    pub fn make_pathkeys_for_sortclauses(
        root: *mut PlannerInfo,
        sortclauses: *mut List,
        tlist: *mut List,
    ) -> *mut List;
    pub fn make_pathkeys_for_sortclauses_extended(
        root: *mut PlannerInfo,
        sortclauses: *mut *mut List,
        tlist: *mut List,
        remove_redundant: bool,
        sortable: *mut bool,
        set_ec_sortref: bool,
    ) -> *mut List;
    pub fn initialize_mergeclause_eclasses(root: *mut PlannerInfo, restrictinfo: *mut RestrictInfo);
    pub fn update_mergeclause_eclasses(root: *mut PlannerInfo, restrictinfo: *mut RestrictInfo);
    pub fn find_mergeclauses_for_outer_pathkeys(
        root: *mut PlannerInfo,
        pathkeys: *mut List,
        restrictinfos: *mut List,
    ) -> *mut List;
    pub fn select_outer_pathkeys_for_merge(
        root: *mut PlannerInfo,
        mergeclauses: *mut List,
        joinrel: *mut RelOptInfo,
    ) -> *mut List;
    pub fn make_inner_pathkeys_for_merge(
        root: *mut PlannerInfo,
        mergeclauses: *mut List,
        outer_pathkeys: *mut List,
    ) -> *mut List;
    pub fn trim_mergeclauses_for_inner_pathkeys(
        root: *mut PlannerInfo,
        mergeclauses: *mut List,
        pathkeys: *mut List,
    ) -> *mut List;
    pub fn truncate_useless_pathkeys(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        pathkeys: *mut List,
    ) -> *mut List;
    pub fn has_useful_pathkeys(root: *mut PlannerInfo, rel: *mut RelOptInfo) -> bool;
    pub fn append_pathkeys(target: *mut List, source: *mut List) -> *mut List;
    pub fn make_canonical_pathkey(
        root: *mut PlannerInfo,
        eclass: *mut EquivalenceClass,
        opfamily: Oid,
        strategy: ::core::ffi::c_int,
        nulls_first: bool,
    ) -> *mut PathKey;
    pub fn add_paths_to_append_rel(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        live_childrels: *mut List,
    );
    pub static mut get_relation_info_hook: get_relation_info_hook_type;
    pub fn get_relation_info(
        root: *mut PlannerInfo,
        relationObjectId: Oid,
        inhparent: bool,
        rel: *mut RelOptInfo,
    );
    pub fn infer_arbiter_indexes(root: *mut PlannerInfo) -> *mut List;
    pub fn estimate_rel_size(
        rel: Relation,
        attr_widths: *mut int32,
        pages: *mut BlockNumber,
        tuples: *mut f64,
        allvisfrac: *mut f64,
    );
    pub fn get_rel_data_width(rel: Relation, attr_widths: *mut int32) -> int32;
    pub fn get_relation_data_width(relid: Oid, attr_widths: *mut int32) -> int32;
    pub fn relation_excluded_by_constraints(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        rte: *mut RangeTblEntry,
    ) -> bool;
    pub fn build_physical_tlist(root: *mut PlannerInfo, rel: *mut RelOptInfo) -> *mut List;
    pub fn has_unique_index(rel: *mut RelOptInfo, attno: AttrNumber) -> bool;
    pub fn restriction_selectivity(
        root: *mut PlannerInfo,
        operatorid: Oid,
        args: *mut List,
        inputcollid: Oid,
        varRelid: ::core::ffi::c_int,
    ) -> Selectivity;
    pub fn join_selectivity(
        root: *mut PlannerInfo,
        operatorid: Oid,
        args: *mut List,
        inputcollid: Oid,
        jointype: JoinType::Type,
        sjinfo: *mut SpecialJoinInfo,
    ) -> Selectivity;
    pub fn function_selectivity(
        root: *mut PlannerInfo,
        funcid: Oid,
        args: *mut List,
        inputcollid: Oid,
        is_join: bool,
        varRelid: ::core::ffi::c_int,
        jointype: JoinType::Type,
        sjinfo: *mut SpecialJoinInfo,
    ) -> Selectivity;
    pub fn add_function_cost(
        root: *mut PlannerInfo,
        funcid: Oid,
        node: *mut Node,
        cost: *mut QualCost,
    );
    pub fn get_function_rows(root: *mut PlannerInfo, funcid: Oid, node: *mut Node) -> f64;
    pub fn has_row_triggers(root: *mut PlannerInfo, rti: Index, event: CmdType::Type) -> bool;
    pub fn has_stored_generated_columns(root: *mut PlannerInfo, rti: Index) -> bool;
    pub fn get_dependent_generated_columns(
        root: *mut PlannerInfo,
        rti: Index,
        target_cols: *mut Bitmapset,
    ) -> *mut Bitmapset;
    pub static mut cursor_tuple_fraction: f64;
    pub fn query_planner(
        root: *mut PlannerInfo,
        qp_callback: query_pathkeys_callback,
        qp_extra: *mut ::core::ffi::c_void,
    ) -> *mut RelOptInfo;
    pub fn preprocess_minmax_aggregates(root: *mut PlannerInfo);
    pub fn create_plan(root: *mut PlannerInfo, best_path: *mut Path) -> *mut Plan;
    pub fn make_foreignscan(
        qptlist: *mut List,
        qpqual: *mut List,
        scanrelid: Index,
        fdw_exprs: *mut List,
        fdw_private: *mut List,
        fdw_scan_tlist: *mut List,
        fdw_recheck_quals: *mut List,
        outer_plan: *mut Plan,
    ) -> *mut ForeignScan;
    pub fn change_plan_targetlist(
        subplan: *mut Plan,
        tlist: *mut List,
        tlist_parallel_safe: bool,
    ) -> *mut Plan;
    pub fn materialize_finished_plan(subplan: *mut Plan) -> *mut Plan;
    pub fn is_projection_capable_path(path: *mut Path) -> bool;
    pub fn is_projection_capable_plan(plan: *mut Plan) -> bool;
    pub fn make_sort_from_sortclauses(sortcls: *mut List, lefttree: *mut Plan) -> *mut Sort;
    pub fn make_agg(
        tlist: *mut List,
        qual: *mut List,
        aggstrategy: AggStrategy::Type,
        aggsplit: AggSplit::Type,
        numGroupCols: ::core::ffi::c_int,
        grpColIdx: *mut AttrNumber,
        grpOperators: *mut Oid,
        grpCollations: *mut Oid,
        groupingSets: *mut List,
        chain: *mut List,
        dNumGroups: f64,
        transitionSpace: Size,
        lefttree: *mut Plan,
    ) -> *mut Agg;
    pub fn make_limit(
        lefttree: *mut Plan,
        limitOffset: *mut Node,
        limitCount: *mut Node,
        limitOption: LimitOption::Type,
        uniqNumCols: ::core::ffi::c_int,
        uniqColIdx: *mut AttrNumber,
        uniqOperators: *mut Oid,
        uniqCollations: *mut Oid,
    ) -> *mut Limit;
    pub static mut from_collapse_limit: ::core::ffi::c_int;
    pub static mut join_collapse_limit: ::core::ffi::c_int;
    pub fn add_base_rels_to_query(root: *mut PlannerInfo, jtnode: *mut Node);
    pub fn add_other_rels_to_query(root: *mut PlannerInfo);
    pub fn build_base_rel_tlists(root: *mut PlannerInfo, final_tlist: *mut List);
    pub fn add_vars_to_targetlist(root: *mut PlannerInfo, vars: *mut List, where_needed: Relids);
    pub fn find_lateral_references(root: *mut PlannerInfo);
    pub fn create_lateral_join_info(root: *mut PlannerInfo);
    pub fn deconstruct_jointree(root: *mut PlannerInfo) -> *mut List;
    pub fn restriction_is_always_true(
        root: *mut PlannerInfo,
        restrictinfo: *mut RestrictInfo,
    ) -> bool;
    pub fn restriction_is_always_false(
        root: *mut PlannerInfo,
        restrictinfo: *mut RestrictInfo,
    ) -> bool;
    pub fn distribute_restrictinfo_to_rels(root: *mut PlannerInfo, restrictinfo: *mut RestrictInfo);
    pub fn process_implied_equality(
        root: *mut PlannerInfo,
        opno: Oid,
        collation: Oid,
        item1: *mut Expr,
        item2: *mut Expr,
        qualscope: Relids,
        security_level: Index,
        both_const: bool,
    ) -> *mut RestrictInfo;
    pub fn build_implied_join_equality(
        root: *mut PlannerInfo,
        opno: Oid,
        collation: Oid,
        item1: *mut Expr,
        item2: *mut Expr,
        qualscope: Relids,
        security_level: Index,
    ) -> *mut RestrictInfo;
    pub fn match_foreign_keys_to_quals(root: *mut PlannerInfo);
    pub fn remove_useless_joins(root: *mut PlannerInfo, joinlist: *mut List) -> *mut List;
    pub fn reduce_unique_semijoins(root: *mut PlannerInfo);
    pub fn query_supports_distinctness(query: *mut Query) -> bool;
    pub fn query_is_distinct_for(query: *mut Query, colnos: *mut List, opids: *mut List) -> bool;
    pub fn innerrel_is_unique(
        root: *mut PlannerInfo,
        joinrelids: Relids,
        outerrelids: Relids,
        innerrel: *mut RelOptInfo,
        jointype: JoinType::Type,
        restrictlist: *mut List,
        force_cache: bool,
    ) -> bool;
    pub fn set_plan_references(root: *mut PlannerInfo, plan: *mut Plan) -> *mut Plan;
    pub fn trivial_subqueryscan(plan: *mut SubqueryScan) -> bool;
    pub fn find_minmax_agg_replacement_param(
        root: *mut PlannerInfo,
        aggref: *mut Aggref,
    ) -> *mut Param;
    pub fn record_plan_function_dependency(root: *mut PlannerInfo, funcid: Oid);
    pub fn record_plan_type_dependency(root: *mut PlannerInfo, typid: Oid);
    pub fn extract_query_dependencies_walker(node: *mut Node, context: *mut PlannerInfo) -> bool;
    pub static mut planner_hook: planner_hook_type;
    pub static mut create_upper_paths_hook: create_upper_paths_hook_type;
    pub fn standard_planner(
        parse: *mut Query,
        query_string: *const ::core::ffi::c_char,
        cursorOptions: ::core::ffi::c_int,
        boundParams: ParamListInfo,
    ) -> *mut PlannedStmt;
    pub fn subquery_planner(
        glob: *mut PlannerGlobal,
        parse: *mut Query,
        parent_root: *mut PlannerInfo,
        hasRecursion: bool,
        tuple_fraction: f64,
        setops: *mut SetOperationStmt,
    ) -> *mut PlannerInfo;
    pub fn select_rowmark_type(
        rte: *mut RangeTblEntry,
        strength: LockClauseStrength::Type,
    ) -> RowMarkType::Type;
    pub fn limit_needed(parse: *mut Query) -> bool;
    pub fn mark_partial_aggref(agg: *mut Aggref, aggsplit: AggSplit::Type);
    pub fn get_cheapest_fractional_path(rel: *mut RelOptInfo, tuple_fraction: f64) -> *mut Path;
    pub fn preprocess_phv_expression(root: *mut PlannerInfo, expr: *mut Expr) -> *mut Expr;
    pub fn make_restrictinfo(
        root: *mut PlannerInfo,
        clause: *mut Expr,
        is_pushed_down: bool,
        has_clone: bool,
        is_clone: bool,
        pseudoconstant: bool,
        security_level: Index,
        required_relids: Relids,
        incompatible_relids: Relids,
        outer_relids: Relids,
    ) -> *mut RestrictInfo;
    pub fn commute_restrictinfo(rinfo: *mut RestrictInfo, comm_op: Oid) -> *mut RestrictInfo;
    pub fn restriction_is_or_clause(restrictinfo: *mut RestrictInfo) -> bool;
    pub fn restriction_is_securely_promotable(
        restrictinfo: *mut RestrictInfo,
        rel: *mut RelOptInfo,
    ) -> bool;
    pub fn get_actual_clauses(restrictinfo_list: *mut List) -> *mut List;
    pub fn extract_actual_clauses(restrictinfo_list: *mut List, pseudoconstant: bool) -> *mut List;
    pub fn extract_actual_join_clauses(
        restrictinfo_list: *mut List,
        joinrelids: Relids,
        joinquals: *mut *mut List,
        otherquals: *mut *mut List,
    );
    pub fn join_clause_is_movable_to(rinfo: *mut RestrictInfo, baserel: *mut RelOptInfo) -> bool;
    pub fn join_clause_is_movable_into(
        rinfo: *mut RestrictInfo,
        currentrelids: Relids,
        current_and_outer: Relids,
    ) -> bool;
    pub fn tlist_member(node: *mut Expr, targetlist: *mut List) -> *mut TargetEntry;
    pub fn add_to_flat_tlist(tlist: *mut List, exprs: *mut List) -> *mut List;
    pub fn get_tlist_exprs(tlist: *mut List, includeJunk: bool) -> *mut List;
    pub fn tlist_same_exprs(tlist1: *mut List, tlist2: *mut List) -> bool;
    pub fn tlist_same_datatypes(tlist: *mut List, colTypes: *mut List, junkOK: bool) -> bool;
    pub fn tlist_same_collations(tlist: *mut List, colCollations: *mut List, junkOK: bool) -> bool;
    pub fn apply_tlist_labeling(dest_tlist: *mut List, src_tlist: *mut List);
    pub fn extract_grouping_ops(groupClause: *mut List) -> *mut Oid;
    pub fn extract_grouping_collations(groupClause: *mut List, tlist: *mut List) -> *mut Oid;
    pub fn extract_grouping_cols(groupClause: *mut List, tlist: *mut List) -> *mut AttrNumber;
    pub fn grouping_is_sortable(groupClause: *mut List) -> bool;
    pub fn grouping_is_hashable(groupClause: *mut List) -> bool;
    pub fn make_pathtarget_from_tlist(tlist: *mut List) -> *mut PathTarget;
    pub fn make_tlist_from_pathtarget(target: *mut PathTarget) -> *mut List;
    pub fn copy_pathtarget(src: *mut PathTarget) -> *mut PathTarget;
    pub fn create_empty_pathtarget() -> *mut PathTarget;
    pub fn add_column_to_pathtarget(target: *mut PathTarget, expr: *mut Expr, sortgroupref: Index);
    pub fn add_new_column_to_pathtarget(target: *mut PathTarget, expr: *mut Expr);
    pub fn add_new_columns_to_pathtarget(target: *mut PathTarget, exprs: *mut List);
    pub fn apply_pathtarget_labeling_to_tlist(tlist: *mut List, target: *mut PathTarget);
    pub fn split_pathtarget_at_srfs(
        root: *mut PlannerInfo,
        target: *mut PathTarget,
        input_target: *mut PathTarget,
        targets: *mut *mut List,
        targets_contain_srfs: *mut *mut List,
    );
    pub static mut compute_query_id: ::core::ffi::c_int;
    pub fn CleanQuerytext(
        query: *const ::core::ffi::c_char,
        location: *mut ::core::ffi::c_int,
        len: *mut ::core::ffi::c_int,
    ) -> *const ::core::ffi::c_char;
    pub fn JumbleQuery(query: *mut Query) -> *mut JumbleState;
    pub fn EnableQueryId();
    pub static mut query_id_enabled: bool;
    pub static mut post_parse_analyze_hook: post_parse_analyze_hook_type;
    pub fn parse_analyze_fixedparams(
        parseTree: *mut RawStmt,
        sourceText: *const ::core::ffi::c_char,
        paramTypes: *const Oid,
        numParams: ::core::ffi::c_int,
        queryEnv: *mut QueryEnvironment,
    ) -> *mut Query;
    pub fn parse_analyze_varparams(
        parseTree: *mut RawStmt,
        sourceText: *const ::core::ffi::c_char,
        paramTypes: *mut *mut Oid,
        numParams: *mut ::core::ffi::c_int,
        queryEnv: *mut QueryEnvironment,
    ) -> *mut Query;
    pub fn parse_analyze_withcb(
        parseTree: *mut RawStmt,
        sourceText: *const ::core::ffi::c_char,
        parserSetup: ParserSetupHook,
        parserSetupArg: *mut ::core::ffi::c_void,
        queryEnv: *mut QueryEnvironment,
    ) -> *mut Query;
    pub fn parse_sub_analyze(
        parseTree: *mut Node,
        parentParseState: *mut ParseState,
        parentCTE: *mut CommonTableExpr,
        locked_from_parent: bool,
        resolve_unknowns: bool,
    ) -> *mut Query;
    pub fn transformInsertRow(
        pstate: *mut ParseState,
        exprlist: *mut List,
        stmtcols: *mut List,
        icolumns: *mut List,
        attrnos: *mut List,
        strip_indirection: bool,
    ) -> *mut List;
    pub fn transformUpdateTargetList(pstate: *mut ParseState, origTlist: *mut List) -> *mut List;
    pub fn transformReturningList(
        pstate: *mut ParseState,
        returningList: *mut List,
        exprKind: ParseExprKind::Type,
    ) -> *mut List;
    pub fn transformTopLevelStmt(pstate: *mut ParseState, parseTree: *mut RawStmt) -> *mut Query;
    pub fn transformStmt(pstate: *mut ParseState, parseTree: *mut Node) -> *mut Query;
    pub fn stmt_requires_parse_analysis(parseTree: *mut RawStmt) -> bool;
    pub fn analyze_requires_snapshot(parseTree: *mut RawStmt) -> bool;
    pub fn LCS_asString(strength: LockClauseStrength::Type) -> *const ::core::ffi::c_char;
    pub fn CheckSelectLocking(qry: *mut Query, strength: LockClauseStrength::Type);
    pub fn applyLockingClause(
        qry: *mut Query,
        rtindex: Index,
        strength: LockClauseStrength::Type,
        waitPolicy: LockWaitPolicy::Type,
        pushedDown: bool,
    );
    pub fn BuildOnConflictExcludedTargetlist(targetrel: Relation, exclRelIndex: Index)
        -> *mut List;
    pub fn makeSortGroupClauseForSetOp(rescoltype: Oid, require_hash: bool)
        -> *mut SortGroupClause;
    pub fn assign_query_collations(pstate: *mut ParseState, query: *mut Query);
    pub fn assign_list_collations(pstate: *mut ParseState, exprs: *mut List);
    pub fn assign_expr_collations(pstate: *mut ParseState, expr: *mut Node);
    pub fn select_common_collation(pstate: *mut ParseState, exprs: *mut List, none_ok: bool)
        -> Oid;
    pub static mut Transform_null_equals: bool;
    pub fn transformExpr(
        pstate: *mut ParseState,
        expr: *mut Node,
        exprKind: ParseExprKind::Type,
    ) -> *mut Node;
    pub fn ParseExprKindName(exprKind: ParseExprKind::Type) -> *const ::core::ffi::c_char;
    pub fn ParseFuncOrColumn(
        pstate: *mut ParseState,
        funcname: *mut List,
        fargs: *mut List,
        last_srf: *mut Node,
        fn_: *mut FuncCall,
        proc_call: bool,
        location: ::core::ffi::c_int,
    ) -> *mut Node;
    pub fn func_get_detail(
        funcname: *mut List,
        fargs: *mut List,
        fargnames: *mut List,
        nargs: ::core::ffi::c_int,
        argtypes: *mut Oid,
        expand_variadic: bool,
        expand_defaults: bool,
        include_out_arguments: bool,
        funcid: *mut Oid,
        rettype: *mut Oid,
        retset: *mut bool,
        nvargs: *mut ::core::ffi::c_int,
        vatype: *mut Oid,
        true_typeids: *mut *mut Oid,
        argdefaults: *mut *mut List,
    ) -> FuncDetailCode::Type;
    pub fn func_match_argtypes(
        nargs: ::core::ffi::c_int,
        input_typeids: *mut Oid,
        raw_candidates: FuncCandidateList,
        candidates: *mut FuncCandidateList,
    ) -> ::core::ffi::c_int;
    pub fn func_select_candidate(
        nargs: ::core::ffi::c_int,
        input_typeids: *mut Oid,
        candidates: FuncCandidateList,
    ) -> FuncCandidateList;
    pub fn make_fn_arguments(
        pstate: *mut ParseState,
        fargs: *mut List,
        actual_arg_types: *mut Oid,
        declared_arg_types: *mut Oid,
    );
    pub fn funcname_signature_string(
        funcname: *const ::core::ffi::c_char,
        nargs: ::core::ffi::c_int,
        argnames: *mut List,
        argtypes: *const Oid,
    ) -> *const ::core::ffi::c_char;
    pub fn func_signature_string(
        funcname: *mut List,
        nargs: ::core::ffi::c_int,
        argnames: *mut List,
        argtypes: *const Oid,
    ) -> *const ::core::ffi::c_char;
    pub fn LookupFuncName(
        funcname: *mut List,
        nargs: ::core::ffi::c_int,
        argtypes: *const Oid,
        missing_ok: bool,
    ) -> Oid;
    pub fn LookupFuncWithArgs(
        objtype: ObjectType::Type,
        func: *mut ObjectWithArgs,
        missing_ok: bool,
    ) -> Oid;
    pub fn check_srf_call_placement(
        pstate: *mut ParseState,
        last_srf: *mut Node,
        location: ::core::ffi::c_int,
    );
    pub fn LookupOperName(
        pstate: *mut ParseState,
        opername: *mut List,
        oprleft: Oid,
        oprright: Oid,
        noError: bool,
        location: ::core::ffi::c_int,
    ) -> Oid;
    pub fn LookupOperWithArgs(oper: *mut ObjectWithArgs, noError: bool) -> Oid;
    pub fn oper(
        pstate: *mut ParseState,
        opname: *mut List,
        ltypeId: Oid,
        rtypeId: Oid,
        noError: bool,
        location: ::core::ffi::c_int,
    ) -> Operator;
    pub fn left_oper(
        pstate: *mut ParseState,
        op: *mut List,
        arg: Oid,
        noError: bool,
        location: ::core::ffi::c_int,
    ) -> Operator;
    pub fn compatible_oper(
        pstate: *mut ParseState,
        op: *mut List,
        arg1: Oid,
        arg2: Oid,
        noError: bool,
        location: ::core::ffi::c_int,
    ) -> Operator;
    pub fn op_signature_string(op: *mut List, arg1: Oid, arg2: Oid) -> *const ::core::ffi::c_char;
    pub fn get_sort_group_operators(
        argtype: Oid,
        needLT: bool,
        needEQ: bool,
        needGT: bool,
        ltOpr: *mut Oid,
        eqOpr: *mut Oid,
        gtOpr: *mut Oid,
        isHashable: *mut bool,
    );
    pub fn compatible_oper_opid(op: *mut List, arg1: Oid, arg2: Oid, noError: bool) -> Oid;
    pub fn oprid(op: Operator) -> Oid;
    pub fn oprfuncid(op: Operator) -> Oid;
    pub fn make_op(
        pstate: *mut ParseState,
        opname: *mut List,
        ltree: *mut Node,
        rtree: *mut Node,
        last_srf: *mut Node,
        location: ::core::ffi::c_int,
    ) -> *mut Expr;
    pub fn make_scalar_array_op(
        pstate: *mut ParseState,
        opname: *mut List,
        useOr: bool,
        ltree: *mut Node,
        rtree: *mut Node,
        location: ::core::ffi::c_int,
    ) -> *mut Expr;
    pub fn refnameNamespaceItem(
        pstate: *mut ParseState,
        schemaname: *const ::core::ffi::c_char,
        refname: *const ::core::ffi::c_char,
        location: ::core::ffi::c_int,
        sublevels_up: *mut ::core::ffi::c_int,
    ) -> *mut ParseNamespaceItem;
    pub fn scanNameSpaceForCTE(
        pstate: *mut ParseState,
        refname: *const ::core::ffi::c_char,
        ctelevelsup: *mut Index,
    ) -> *mut CommonTableExpr;
    pub fn scanNameSpaceForENR(
        pstate: *mut ParseState,
        refname: *const ::core::ffi::c_char,
    ) -> bool;
    pub fn checkNameSpaceConflicts(
        pstate: *mut ParseState,
        namespace1: *mut List,
        namespace2: *mut List,
    );
    pub fn GetNSItemByRangeTablePosn(
        pstate: *mut ParseState,
        varno: ::core::ffi::c_int,
        sublevels_up: ::core::ffi::c_int,
    ) -> *mut ParseNamespaceItem;
    pub fn GetRTEByRangeTablePosn(
        pstate: *mut ParseState,
        varno: ::core::ffi::c_int,
        sublevels_up: ::core::ffi::c_int,
    ) -> *mut RangeTblEntry;
    pub fn GetCTEForRTE(
        pstate: *mut ParseState,
        rte: *mut RangeTblEntry,
        rtelevelsup: ::core::ffi::c_int,
    ) -> *mut CommonTableExpr;
    pub fn scanNSItemForColumn(
        pstate: *mut ParseState,
        nsitem: *mut ParseNamespaceItem,
        sublevels_up: ::core::ffi::c_int,
        colname: *const ::core::ffi::c_char,
        location: ::core::ffi::c_int,
    ) -> *mut Node;
    pub fn colNameToVar(
        pstate: *mut ParseState,
        colname: *const ::core::ffi::c_char,
        localonly: bool,
        location: ::core::ffi::c_int,
    ) -> *mut Node;
    pub fn markNullableIfNeeded(pstate: *mut ParseState, var: *mut Var);
    pub fn markVarForSelectPriv(pstate: *mut ParseState, var: *mut Var);
    pub fn parserOpenTable(
        pstate: *mut ParseState,
        relation: *const RangeVar,
        lockmode: ::core::ffi::c_int,
    ) -> Relation;
    pub fn addRangeTableEntry(
        pstate: *mut ParseState,
        relation: *mut RangeVar,
        alias: *mut Alias,
        inh: bool,
        inFromCl: bool,
    ) -> *mut ParseNamespaceItem;
    pub fn addRangeTableEntryForRelation(
        pstate: *mut ParseState,
        rel: Relation,
        lockmode: ::core::ffi::c_int,
        alias: *mut Alias,
        inh: bool,
        inFromCl: bool,
    ) -> *mut ParseNamespaceItem;
    pub fn addRangeTableEntryForSubquery(
        pstate: *mut ParseState,
        subquery: *mut Query,
        alias: *mut Alias,
        lateral: bool,
        inFromCl: bool,
    ) -> *mut ParseNamespaceItem;
    pub fn addRangeTableEntryForFunction(
        pstate: *mut ParseState,
        funcnames: *mut List,
        funcexprs: *mut List,
        coldeflists: *mut List,
        rangefunc: *mut RangeFunction,
        lateral: bool,
        inFromCl: bool,
    ) -> *mut ParseNamespaceItem;
    pub fn addRangeTableEntryForValues(
        pstate: *mut ParseState,
        exprs: *mut List,
        coltypes: *mut List,
        coltypmods: *mut List,
        colcollations: *mut List,
        alias: *mut Alias,
        lateral: bool,
        inFromCl: bool,
    ) -> *mut ParseNamespaceItem;
    pub fn addRangeTableEntryForTableFunc(
        pstate: *mut ParseState,
        tf: *mut TableFunc,
        alias: *mut Alias,
        lateral: bool,
        inFromCl: bool,
    ) -> *mut ParseNamespaceItem;
    pub fn addRangeTableEntryForJoin(
        pstate: *mut ParseState,
        colnames: *mut List,
        nscolumns: *mut ParseNamespaceColumn,
        jointype: JoinType::Type,
        nummergedcols: ::core::ffi::c_int,
        aliasvars: *mut List,
        leftcols: *mut List,
        rightcols: *mut List,
        join_using_alias: *mut Alias,
        alias: *mut Alias,
        inFromCl: bool,
    ) -> *mut ParseNamespaceItem;
    pub fn addRangeTableEntryForCTE(
        pstate: *mut ParseState,
        cte: *mut CommonTableExpr,
        levelsup: Index,
        rv: *mut RangeVar,
        inFromCl: bool,
    ) -> *mut ParseNamespaceItem;
    pub fn addRangeTableEntryForENR(
        pstate: *mut ParseState,
        rv: *mut RangeVar,
        inFromCl: bool,
    ) -> *mut ParseNamespaceItem;
    pub fn addRTEPermissionInfo(
        rteperminfos: *mut *mut List,
        rte: *mut RangeTblEntry,
    ) -> *mut RTEPermissionInfo;
    pub fn getRTEPermissionInfo(
        rteperminfos: *mut List,
        rte: *mut RangeTblEntry,
    ) -> *mut RTEPermissionInfo;
    pub fn isLockedRefname(pstate: *mut ParseState, refname: *const ::core::ffi::c_char) -> bool;
    pub fn addNSItemToQuery(
        pstate: *mut ParseState,
        nsitem: *mut ParseNamespaceItem,
        addToJoinList: bool,
        addToRelNameSpace: bool,
        addToVarNameSpace: bool,
    );
    pub fn errorMissingRTE(pstate: *mut ParseState, relation: *mut RangeVar) -> !;
    pub fn errorMissingColumn(
        pstate: *mut ParseState,
        relname: *const ::core::ffi::c_char,
        colname: *const ::core::ffi::c_char,
        location: ::core::ffi::c_int,
    ) -> !;
    pub fn expandRTE(
        rte: *mut RangeTblEntry,
        rtindex: ::core::ffi::c_int,
        sublevels_up: ::core::ffi::c_int,
        location: ::core::ffi::c_int,
        include_dropped: bool,
        colnames: *mut *mut List,
        colvars: *mut *mut List,
    );
    pub fn expandNSItemVars(
        pstate: *mut ParseState,
        nsitem: *mut ParseNamespaceItem,
        sublevels_up: ::core::ffi::c_int,
        location: ::core::ffi::c_int,
        colnames: *mut *mut List,
    ) -> *mut List;
    pub fn expandNSItemAttrs(
        pstate: *mut ParseState,
        nsitem: *mut ParseNamespaceItem,
        sublevels_up: ::core::ffi::c_int,
        require_col_privs: bool,
        location: ::core::ffi::c_int,
    ) -> *mut List;
    pub fn attnameAttNum(
        rd: Relation,
        attname: *const ::core::ffi::c_char,
        sysColOK: bool,
    ) -> ::core::ffi::c_int;
    pub fn attnumAttName(rd: Relation, attid: ::core::ffi::c_int) -> *const NameData;
    pub fn attnumTypeId(rd: Relation, attid: ::core::ffi::c_int) -> Oid;
    pub fn attnumCollationId(rd: Relation, attid: ::core::ffi::c_int) -> Oid;
    pub fn isQueryUsingTempRelation(query: *mut Query) -> bool;
    pub fn LookupTypeName(
        pstate: *mut ParseState,
        typeName: *const TypeName,
        typmod_p: *mut int32,
        missing_ok: bool,
    ) -> Type;
    pub fn LookupTypeNameExtended(
        pstate: *mut ParseState,
        typeName: *const TypeName,
        typmod_p: *mut int32,
        temp_ok: bool,
        missing_ok: bool,
    ) -> Type;
    pub fn LookupTypeNameOid(
        pstate: *mut ParseState,
        typeName: *const TypeName,
        missing_ok: bool,
    ) -> Oid;
    pub fn typenameType(
        pstate: *mut ParseState,
        typeName: *const TypeName,
        typmod_p: *mut int32,
    ) -> Type;
    pub fn typenameTypeId(pstate: *mut ParseState, typeName: *const TypeName) -> Oid;
    pub fn typenameTypeIdAndMod(
        pstate: *mut ParseState,
        typeName: *const TypeName,
        typeid_p: *mut Oid,
        typmod_p: *mut int32,
    );
    pub fn TypeNameToString(typeName: *const TypeName) -> *mut ::core::ffi::c_char;
    pub fn TypeNameListToString(typenames: *mut List) -> *mut ::core::ffi::c_char;
    pub fn LookupCollation(
        pstate: *mut ParseState,
        collnames: *mut List,
        location: ::core::ffi::c_int,
    ) -> Oid;
    pub fn GetColumnDefCollation(
        pstate: *mut ParseState,
        coldef: *const ColumnDef,
        typeOid: Oid,
    ) -> Oid;
    pub fn typeidType(id: Oid) -> Type;
    pub fn typeTypeId(tp: Type) -> Oid;
    pub fn typeLen(t: Type) -> int16;
    pub fn typeByVal(t: Type) -> bool;
    pub fn typeTypeName(t: Type) -> *mut ::core::ffi::c_char;
    pub fn typeTypeRelid(typ: Type) -> Oid;
    pub fn typeTypeCollation(typ: Type) -> Oid;
    pub fn stringTypeDatum(tp: Type, string: *mut ::core::ffi::c_char, atttypmod: int32) -> Datum;
    pub fn typeidTypeRelid(type_id: Oid) -> Oid;
    pub fn typeOrDomainTypeRelid(type_id: Oid) -> Oid;
    pub fn typeStringToTypeName(
        str_: *const ::core::ffi::c_char,
        escontext: *mut Node,
    ) -> *mut TypeName;
    pub fn parseTypeString(
        str_: *const ::core::ffi::c_char,
        typeid_p: *mut Oid,
        typmod_p: *mut int32,
        escontext: *mut Node,
    ) -> bool;
    pub fn IsBinaryCoercible(srctype: Oid, targettype: Oid) -> bool;
    pub fn IsBinaryCoercibleWithCast(srctype: Oid, targettype: Oid, castoid: *mut Oid) -> bool;
    pub fn IsPreferredType(category: TYPCATEGORY, type_: Oid) -> bool;
    pub fn TypeCategory(type_: Oid) -> TYPCATEGORY;
    pub fn coerce_to_target_type(
        pstate: *mut ParseState,
        expr: *mut Node,
        exprtype: Oid,
        targettype: Oid,
        targettypmod: int32,
        ccontext: CoercionContext::Type,
        cformat: CoercionForm::Type,
        location: ::core::ffi::c_int,
    ) -> *mut Node;
    pub fn can_coerce_type(
        nargs: ::core::ffi::c_int,
        input_typeids: *const Oid,
        target_typeids: *const Oid,
        ccontext: CoercionContext::Type,
    ) -> bool;
    pub fn coerce_type(
        pstate: *mut ParseState,
        node: *mut Node,
        inputTypeId: Oid,
        targetTypeId: Oid,
        targetTypeMod: int32,
        ccontext: CoercionContext::Type,
        cformat: CoercionForm::Type,
        location: ::core::ffi::c_int,
    ) -> *mut Node;
    pub fn coerce_to_domain(
        arg: *mut Node,
        baseTypeId: Oid,
        baseTypeMod: int32,
        typeId: Oid,
        ccontext: CoercionContext::Type,
        cformat: CoercionForm::Type,
        location: ::core::ffi::c_int,
        hideInputCoercion: bool,
    ) -> *mut Node;
    pub fn coerce_to_boolean(
        pstate: *mut ParseState,
        node: *mut Node,
        constructName: *const ::core::ffi::c_char,
    ) -> *mut Node;
    pub fn coerce_to_specific_type(
        pstate: *mut ParseState,
        node: *mut Node,
        targetTypeId: Oid,
        constructName: *const ::core::ffi::c_char,
    ) -> *mut Node;
    pub fn coerce_to_specific_type_typmod(
        pstate: *mut ParseState,
        node: *mut Node,
        targetTypeId: Oid,
        targetTypmod: int32,
        constructName: *const ::core::ffi::c_char,
    ) -> *mut Node;
    pub fn coerce_null_to_domain(
        typid: Oid,
        typmod: int32,
        collation: Oid,
        typlen: ::core::ffi::c_int,
        typbyval: bool,
    ) -> *mut Node;
    pub fn parser_coercion_errposition(
        pstate: *mut ParseState,
        coerce_location: ::core::ffi::c_int,
        input_expr: *mut Node,
    ) -> ::core::ffi::c_int;
    pub fn select_common_type(
        pstate: *mut ParseState,
        exprs: *mut List,
        context: *const ::core::ffi::c_char,
        which_expr: *mut *mut Node,
    ) -> Oid;
    pub fn coerce_to_common_type(
        pstate: *mut ParseState,
        node: *mut Node,
        targetTypeId: Oid,
        context: *const ::core::ffi::c_char,
    ) -> *mut Node;
    pub fn verify_common_type(common_type: Oid, exprs: *mut List) -> bool;
    pub fn select_common_typmod(
        pstate: *mut ParseState,
        exprs: *mut List,
        common_type: Oid,
    ) -> int32;
    pub fn check_generic_type_consistency(
        actual_arg_types: *const Oid,
        declared_arg_types: *const Oid,
        nargs: ::core::ffi::c_int,
    ) -> bool;
    pub fn enforce_generic_type_consistency(
        actual_arg_types: *const Oid,
        declared_arg_types: *mut Oid,
        nargs: ::core::ffi::c_int,
        rettype: Oid,
        allow_poly: bool,
    ) -> Oid;
    pub fn check_valid_polymorphic_signature(
        ret_type: Oid,
        declared_arg_types: *const Oid,
        nargs: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn check_valid_internal_signature(
        ret_type: Oid,
        declared_arg_types: *const Oid,
        nargs: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn find_coercion_pathway(
        targetTypeId: Oid,
        sourceTypeId: Oid,
        ccontext: CoercionContext::Type,
        funcid: *mut Oid,
    ) -> CoercionPathType::Type;
    pub fn find_typmod_coercion_function(typeId: Oid, funcid: *mut Oid) -> CoercionPathType::Type;
    pub fn get_rte_attribute_name(
        rte: *mut RangeTblEntry,
        attnum: AttrNumber,
    ) -> *mut ::core::ffi::c_char;
    pub fn get_rte_attribute_is_dropped(rte: *mut RangeTblEntry, attnum: AttrNumber) -> bool;
    pub fn get_tle_by_resno(tlist: *mut List, resno: AttrNumber) -> *mut TargetEntry;
    pub fn get_parse_rowmark(qry: *mut Query, rtindex: Index) -> *mut RowMarkClause;
    pub fn downcase_truncate_identifier(
        ident: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
        warn: bool,
    ) -> *mut ::core::ffi::c_char;
    pub fn downcase_identifier(
        ident: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
        warn: bool,
        truncate: bool,
    ) -> *mut ::core::ffi::c_char;
    pub fn truncate_identifier(
        ident: *mut ::core::ffi::c_char,
        len: ::core::ffi::c_int,
        warn: bool,
    );
    pub fn scanner_isspace(ch: ::core::ffi::c_char) -> bool;
    pub fn get_hash_partition_greatest_modulus(bound: PartitionBoundInfo) -> ::core::ffi::c_int;
    pub fn compute_partition_hash_value(
        partnatts: ::core::ffi::c_int,
        partsupfunc: *mut FmgrInfo,
        partcollation: *const Oid,
        values: *const Datum,
        isnull: *const bool,
    ) -> uint64;
    pub fn get_qual_from_partbound(parent: Relation, spec: *mut PartitionBoundSpec) -> *mut List;
    pub fn partition_bounds_create(
        boundspecs: *mut *mut PartitionBoundSpec,
        nparts: ::core::ffi::c_int,
        key: PartitionKey,
        mapping: *mut *mut ::core::ffi::c_int,
    ) -> PartitionBoundInfo;
    pub fn partition_bounds_equal(
        partnatts: ::core::ffi::c_int,
        parttyplen: *mut int16,
        parttypbyval: *mut bool,
        b1: PartitionBoundInfo,
        b2: PartitionBoundInfo,
    ) -> bool;
    pub fn partition_bounds_copy(src: PartitionBoundInfo, key: PartitionKey) -> PartitionBoundInfo;
    pub fn partition_bounds_merge(
        partnatts: ::core::ffi::c_int,
        partsupfunc: *mut FmgrInfo,
        partcollation: *mut Oid,
        outer_rel: *mut RelOptInfo,
        inner_rel: *mut RelOptInfo,
        jointype: JoinType::Type,
        outer_parts: *mut *mut List,
        inner_parts: *mut *mut List,
    ) -> PartitionBoundInfo;
    pub fn partitions_are_ordered(
        boundinfo: PartitionBoundInfo,
        live_parts: *mut Bitmapset,
    ) -> bool;
    pub fn check_new_partition_bound(
        relname: *mut ::core::ffi::c_char,
        parent: Relation,
        spec: *mut PartitionBoundSpec,
        pstate: *mut ParseState,
    );
    pub fn check_default_partition_contents(
        parent: Relation,
        default_rel: Relation,
        new_spec: *mut PartitionBoundSpec,
    );
    pub fn partition_rbound_datum_cmp(
        partsupfunc: *mut FmgrInfo,
        partcollation: *mut Oid,
        rb_datums: *mut Datum,
        rb_kind: *mut PartitionRangeDatumKind::Type,
        tuple_datums: *mut Datum,
        n_tuple_datums: ::core::ffi::c_int,
    ) -> int32;
    pub fn partition_list_bsearch(
        partsupfunc: *mut FmgrInfo,
        partcollation: *mut Oid,
        boundinfo: PartitionBoundInfo,
        value: Datum,
        is_equal: *mut bool,
    ) -> ::core::ffi::c_int;
    pub fn partition_range_datum_bsearch(
        partsupfunc: *mut FmgrInfo,
        partcollation: *mut Oid,
        boundinfo: PartitionBoundInfo,
        nvalues: ::core::ffi::c_int,
        values: *mut Datum,
        is_equal: *mut bool,
    ) -> ::core::ffi::c_int;
    pub fn partition_hash_bsearch(
        boundinfo: PartitionBoundInfo,
        modulus: ::core::ffi::c_int,
        remainder: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn RelationGetPartitionDesc(rel: Relation, omit_detached: bool) -> PartitionDesc;
    pub fn CreatePartitionDirectory(mcxt: MemoryContext, omit_detached: bool)
        -> PartitionDirectory;
    pub fn PartitionDirectoryLookup(arg1: PartitionDirectory, arg2: Relation) -> PartitionDesc;
    pub fn DestroyPartitionDirectory(pdir: PartitionDirectory);
    pub fn get_default_oid_from_partdesc(partdesc: PartitionDesc) -> Oid;
    pub fn make_partition_pruneinfo(
        root: *mut PlannerInfo,
        parentrel: *mut RelOptInfo,
        subpaths: *mut List,
        prunequal: *mut List,
    ) -> *mut PartitionPruneInfo;
    pub fn prune_append_rel_partitions(rel: *mut RelOptInfo) -> *mut Bitmapset;
    pub fn get_matching_partitions(
        context: *mut PartitionPruneContext,
        pruning_steps: *mut List,
    ) -> *mut Bitmapset;
    pub fn make_expanded_record_from_typeid(
        type_id: Oid,
        typmod: int32,
        parentcontext: MemoryContext,
    ) -> *mut ExpandedRecordHeader;
    pub fn make_expanded_record_from_tupdesc(
        tupdesc: TupleDesc,
        parentcontext: MemoryContext,
    ) -> *mut ExpandedRecordHeader;
    pub fn make_expanded_record_from_exprecord(
        olderh: *mut ExpandedRecordHeader,
        parentcontext: MemoryContext,
    ) -> *mut ExpandedRecordHeader;
    pub fn expanded_record_set_tuple(
        erh: *mut ExpandedRecordHeader,
        tuple: HeapTuple,
        copy: bool,
        expand_external: bool,
    );
    pub fn make_expanded_record_from_datum(
        recorddatum: Datum,
        parentcontext: MemoryContext,
    ) -> Datum;
    pub fn expanded_record_fetch_tupdesc(erh: *mut ExpandedRecordHeader) -> TupleDesc;
    pub fn expanded_record_get_tuple(erh: *mut ExpandedRecordHeader) -> HeapTuple;
    pub fn DatumGetExpandedRecord(d: Datum) -> *mut ExpandedRecordHeader;
    pub fn deconstruct_expanded_record(erh: *mut ExpandedRecordHeader);
    pub fn expanded_record_lookup_field(
        erh: *mut ExpandedRecordHeader,
        fieldname: *const ::core::ffi::c_char,
        finfo: *mut ExpandedRecordFieldInfo,
    ) -> bool;
    pub fn expanded_record_fetch_field(
        erh: *mut ExpandedRecordHeader,
        fnumber: ::core::ffi::c_int,
        isnull: *mut bool,
    ) -> Datum;
    pub fn expanded_record_set_field_internal(
        erh: *mut ExpandedRecordHeader,
        fnumber: ::core::ffi::c_int,
        newValue: Datum,
        isnull: bool,
        expand_external: bool,
        check_constraints: bool,
    );
    pub fn expanded_record_set_fields(
        erh: *mut ExpandedRecordHeader,
        newValues: *const Datum,
        isnulls: *const bool,
        expand_external: bool,
    );
    pub static mut plpgsql_IdentifierLookup: IdentifierLookup::Type;
    pub static mut plpgsql_variable_conflict: ::core::ffi::c_int;
    pub static mut plpgsql_print_strict_params: bool;
    pub static mut plpgsql_check_asserts: bool;
    pub static mut plpgsql_extra_warnings: ::core::ffi::c_int;
    pub static mut plpgsql_extra_errors: ::core::ffi::c_int;
    pub static mut plpgsql_check_syntax: bool;
    pub static mut plpgsql_DumpExecTree: bool;
    pub static mut plpgsql_parse_result: *mut PLpgSQL_stmt_block;
    pub static mut plpgsql_nDatums: ::core::ffi::c_int;
    pub static mut plpgsql_Datums: *mut *mut PLpgSQL_datum;
    pub static mut plpgsql_error_funcname: *mut ::core::ffi::c_char;
    pub static mut plpgsql_curr_compile: *mut PLpgSQL_function;
    pub static mut plpgsql_compile_tmp_cxt: MemoryContext;
    pub static mut plpgsql_plugin_ptr: *mut *mut PLpgSQL_plugin;
    #[doc = " Function declarations"]
    pub fn plpgsql_compile(fcinfo: FunctionCallInfo, forValidator: bool) -> *mut PLpgSQL_function;
    pub fn plpgsql_compile_inline(proc_source: *mut ::core::ffi::c_char) -> *mut PLpgSQL_function;
    pub fn plpgsql_parser_setup(pstate: *mut ParseState, expr: *mut PLpgSQL_expr);
    pub fn plpgsql_parse_word(
        word1: *mut ::core::ffi::c_char,
        yytxt: *const ::core::ffi::c_char,
        lookup: bool,
        wdatum: *mut PLwdatum,
        word: *mut PLword,
    ) -> bool;
    pub fn plpgsql_parse_dblword(
        word1: *mut ::core::ffi::c_char,
        word2: *mut ::core::ffi::c_char,
        wdatum: *mut PLwdatum,
        cword: *mut PLcword,
    ) -> bool;
    pub fn plpgsql_parse_tripword(
        word1: *mut ::core::ffi::c_char,
        word2: *mut ::core::ffi::c_char,
        word3: *mut ::core::ffi::c_char,
        wdatum: *mut PLwdatum,
        cword: *mut PLcword,
    ) -> bool;
    pub fn plpgsql_parse_wordtype(ident: *mut ::core::ffi::c_char) -> *mut PLpgSQL_type;
    pub fn plpgsql_parse_cwordtype(idents: *mut List) -> *mut PLpgSQL_type;
    pub fn plpgsql_parse_wordrowtype(ident: *mut ::core::ffi::c_char) -> *mut PLpgSQL_type;
    pub fn plpgsql_parse_cwordrowtype(idents: *mut List) -> *mut PLpgSQL_type;
    pub fn plpgsql_build_datatype(
        typeOid: Oid,
        typmod: int32,
        collation: Oid,
        origtypname: *mut TypeName,
    ) -> *mut PLpgSQL_type;
    pub fn plpgsql_build_datatype_arrayof(dtype: *mut PLpgSQL_type) -> *mut PLpgSQL_type;
    pub fn plpgsql_build_variable(
        refname: *const ::core::ffi::c_char,
        lineno: ::core::ffi::c_int,
        dtype: *mut PLpgSQL_type,
        add2namespace: bool,
    ) -> *mut PLpgSQL_variable;
    pub fn plpgsql_build_record(
        refname: *const ::core::ffi::c_char,
        lineno: ::core::ffi::c_int,
        dtype: *mut PLpgSQL_type,
        rectypeid: Oid,
        add2namespace: bool,
    ) -> *mut PLpgSQL_rec;
    pub fn plpgsql_build_recfield(
        rec: *mut PLpgSQL_rec,
        fldname: *const ::core::ffi::c_char,
    ) -> *mut PLpgSQL_recfield;
    pub fn plpgsql_recognize_err_condition(
        condname: *const ::core::ffi::c_char,
        allow_sqlstate: bool,
    ) -> ::core::ffi::c_int;
    pub fn plpgsql_parse_err_condition(
        condname: *mut ::core::ffi::c_char,
    ) -> *mut PLpgSQL_condition;
    pub fn plpgsql_adddatum(newdatum: *mut PLpgSQL_datum);
    pub fn plpgsql_add_initdatums(varnos: *mut *mut ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn plpgsql_HashTableInit();
    pub fn plpgsql_exec_function(
        func: *mut PLpgSQL_function,
        fcinfo: FunctionCallInfo,
        simple_eval_estate: *mut EState,
        simple_eval_resowner: ResourceOwner,
        procedure_resowner: ResourceOwner,
        atomic: bool,
    ) -> Datum;
    pub fn plpgsql_exec_trigger(
        func: *mut PLpgSQL_function,
        trigdata: *mut TriggerData,
    ) -> HeapTuple;
    pub fn plpgsql_exec_event_trigger(func: *mut PLpgSQL_function, trigdata: *mut EventTriggerData);
    pub fn plpgsql_xact_cb(event: XactEvent::Type, arg: *mut ::core::ffi::c_void);
    pub fn plpgsql_subxact_cb(
        event: SubXactEvent::Type,
        mySubid: SubTransactionId,
        parentSubid: SubTransactionId,
        arg: *mut ::core::ffi::c_void,
    );
    pub fn plpgsql_exec_get_datum_type(
        estate: *mut PLpgSQL_execstate,
        datum: *mut PLpgSQL_datum,
    ) -> Oid;
    pub fn plpgsql_exec_get_datum_type_info(
        estate: *mut PLpgSQL_execstate,
        datum: *mut PLpgSQL_datum,
        typeId: *mut Oid,
        typMod: *mut int32,
        collation: *mut Oid,
    );
    pub fn plpgsql_ns_init();
    pub fn plpgsql_ns_push(label: *const ::core::ffi::c_char, label_type: PLpgSQL_label_type::Type);
    pub fn plpgsql_ns_pop();
    pub fn plpgsql_ns_top() -> *mut PLpgSQL_nsitem;
    pub fn plpgsql_ns_additem(
        itemtype: PLpgSQL_nsitem_type::Type,
        itemno: ::core::ffi::c_int,
        name: *const ::core::ffi::c_char,
    );
    pub fn plpgsql_ns_lookup(
        ns_cur: *mut PLpgSQL_nsitem,
        localmode: bool,
        name1: *const ::core::ffi::c_char,
        name2: *const ::core::ffi::c_char,
        name3: *const ::core::ffi::c_char,
        names_used: *mut ::core::ffi::c_int,
    ) -> *mut PLpgSQL_nsitem;
    pub fn plpgsql_ns_lookup_label(
        ns_cur: *mut PLpgSQL_nsitem,
        name: *const ::core::ffi::c_char,
    ) -> *mut PLpgSQL_nsitem;
    pub fn plpgsql_ns_find_nearest_loop(ns_cur: *mut PLpgSQL_nsitem) -> *mut PLpgSQL_nsitem;
    pub fn plpgsql_stmt_typename(stmt: *mut PLpgSQL_stmt) -> *const ::core::ffi::c_char;
    pub fn plpgsql_getdiag_kindname(kind: PLpgSQL_getdiag_kind::Type)
        -> *const ::core::ffi::c_char;
    pub fn plpgsql_free_function_memory(func: *mut PLpgSQL_function);
    pub fn plpgsql_dumptree(func: *mut PLpgSQL_function);
    pub fn plpgsql_base_yylex() -> ::core::ffi::c_int;
    pub fn plpgsql_yylex() -> ::core::ffi::c_int;
    pub fn plpgsql_token_length() -> ::core::ffi::c_int;
    pub fn plpgsql_push_back_token(token: ::core::ffi::c_int);
    pub fn plpgsql_token_is_unreserved_keyword(token: ::core::ffi::c_int) -> bool;
    pub fn plpgsql_append_source_text(
        buf: StringInfo,
        startlocation: ::core::ffi::c_int,
        endlocation: ::core::ffi::c_int,
    );
    pub fn plpgsql_peek() -> ::core::ffi::c_int;
    pub fn plpgsql_peek2(
        tok1_p: *mut ::core::ffi::c_int,
        tok2_p: *mut ::core::ffi::c_int,
        tok1_loc: *mut ::core::ffi::c_int,
        tok2_loc: *mut ::core::ffi::c_int,
    );
    pub fn plpgsql_scanner_errposition(location: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn plpgsql_yyerror(message: *const ::core::ffi::c_char) -> !;
    pub fn plpgsql_location_to_lineno(location: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn plpgsql_latest_lineno() -> ::core::ffi::c_int;
    pub fn plpgsql_scanner_init(str_: *const ::core::ffi::c_char);
    pub fn plpgsql_scanner_finish();
    pub fn plpgsql_yyparse() -> ::core::ffi::c_int;
    pub static mut EnableSSL: bool;
    pub static mut SuperuserReservedConnections: ::core::ffi::c_int;
    pub static mut ReservedConnections: ::core::ffi::c_int;
    pub static mut PostPortNumber: ::core::ffi::c_int;
    pub static mut Unix_socket_permissions: ::core::ffi::c_int;
    pub static mut Unix_socket_group: *mut ::core::ffi::c_char;
    pub static mut Unix_socket_directories: *mut ::core::ffi::c_char;
    pub static mut ListenAddresses: *mut ::core::ffi::c_char;
    pub static mut ClientAuthInProgress: bool;
    pub static mut PreAuthDelay: ::core::ffi::c_int;
    pub static mut AuthenticationTimeout: ::core::ffi::c_int;
    pub static mut Log_connections: bool;
    pub static mut log_hostname: bool;
    pub static mut enable_bonjour: bool;
    pub static mut bonjour_name: *mut ::core::ffi::c_char;
    pub static mut restart_after_crash: bool;
    pub static mut remove_temp_files_after_crash: bool;
    pub static mut send_abort_for_crash: bool;
    pub static mut send_abort_for_kill: bool;
    pub static mut postmaster_alive_fds: [::core::ffi::c_int; 2usize];
    pub static mut progname: *const ::core::ffi::c_char;
    pub static mut LoadedSSL: bool;
    pub fn PostmasterMain(argc: ::core::ffi::c_int, argv: *mut *mut ::core::ffi::c_char) -> !;
    pub fn ClosePostmasterPorts(am_syslogger: bool);
    pub fn InitProcessGlobals();
    pub fn MaxLivePostmasterChildren() -> ::core::ffi::c_int;
    pub fn PostmasterMarkPIDForWorkerNotify(arg1: ::core::ffi::c_int) -> bool;
    pub fn processCancelRequest(backendPID: ::core::ffi::c_int, cancelAuthCode: int32);
    pub static mut MyClientSocket: *mut ClientSocket;
    pub fn postmaster_child_launch(
        child_type: BackendType::Type,
        startup_data: *mut ::core::ffi::c_char,
        startup_data_len: usize,
        client_sock: *mut ClientSocket,
    ) -> pid_t;
    pub fn PostmasterChildName(child_type: BackendType::Type) -> *const ::core::ffi::c_char;
    pub static mut Logging_collector: bool;
    pub static mut Log_RotationAge: ::core::ffi::c_int;
    pub static mut Log_RotationSize: ::core::ffi::c_int;
    pub static mut Log_directory: *mut ::core::ffi::c_char;
    pub static mut Log_filename: *mut ::core::ffi::c_char;
    pub static mut Log_truncate_on_rotation: bool;
    pub static mut Log_file_mode: ::core::ffi::c_int;
    pub static mut syslogPipe: [::core::ffi::c_int; 2usize];
    pub fn SysLogger_Start() -> ::core::ffi::c_int;
    pub fn write_syslogger_file(
        buffer: *const ::core::ffi::c_char,
        count: ::core::ffi::c_int,
        destination: ::core::ffi::c_int,
    );
    pub fn SysLoggerMain(startup_data: *mut ::core::ffi::c_char, startup_data_len: usize) -> !;
    pub fn CheckLogrotateSignal() -> bool;
    pub fn RemoveLogrotateSignalFiles();
    pub static mut logical_decoding_work_mem: ::core::ffi::c_int;
    pub static mut debug_logical_replication_streaming: ::core::ffi::c_int;
    pub fn ReorderBufferAllocate() -> *mut ReorderBuffer;
    pub fn ReorderBufferFree(rb: *mut ReorderBuffer);
    pub fn ReorderBufferGetTupleBuf(rb: *mut ReorderBuffer, tuple_len: Size) -> HeapTuple;
    pub fn ReorderBufferReturnTupleBuf(tuple: HeapTuple);
    pub fn ReorderBufferGetChange(rb: *mut ReorderBuffer) -> *mut ReorderBufferChange;
    pub fn ReorderBufferReturnChange(
        rb: *mut ReorderBuffer,
        change: *mut ReorderBufferChange,
        upd_mem: bool,
    );
    pub fn ReorderBufferGetRelids(rb: *mut ReorderBuffer, nrelids: ::core::ffi::c_int) -> *mut Oid;
    pub fn ReorderBufferReturnRelids(rb: *mut ReorderBuffer, relids: *mut Oid);
    pub fn ReorderBufferQueueChange(
        rb: *mut ReorderBuffer,
        xid: TransactionId,
        lsn: XLogRecPtr,
        change: *mut ReorderBufferChange,
        toast_insert: bool,
    );
    pub fn ReorderBufferQueueMessage(
        rb: *mut ReorderBuffer,
        xid: TransactionId,
        snap: Snapshot,
        lsn: XLogRecPtr,
        transactional: bool,
        prefix: *const ::core::ffi::c_char,
        message_size: Size,
        message: *const ::core::ffi::c_char,
    );
    pub fn ReorderBufferCommit(
        rb: *mut ReorderBuffer,
        xid: TransactionId,
        commit_lsn: XLogRecPtr,
        end_lsn: XLogRecPtr,
        commit_time: TimestampTz,
        origin_id: RepOriginId,
        origin_lsn: XLogRecPtr,
    );
    pub fn ReorderBufferFinishPrepared(
        rb: *mut ReorderBuffer,
        xid: TransactionId,
        commit_lsn: XLogRecPtr,
        end_lsn: XLogRecPtr,
        two_phase_at: XLogRecPtr,
        commit_time: TimestampTz,
        origin_id: RepOriginId,
        origin_lsn: XLogRecPtr,
        gid: *mut ::core::ffi::c_char,
        is_commit: bool,
    );
    pub fn ReorderBufferAssignChild(
        rb: *mut ReorderBuffer,
        xid: TransactionId,
        subxid: TransactionId,
        lsn: XLogRecPtr,
    );
    pub fn ReorderBufferCommitChild(
        rb: *mut ReorderBuffer,
        xid: TransactionId,
        subxid: TransactionId,
        commit_lsn: XLogRecPtr,
        end_lsn: XLogRecPtr,
    );
    pub fn ReorderBufferAbort(
        rb: *mut ReorderBuffer,
        xid: TransactionId,
        lsn: XLogRecPtr,
        abort_time: TimestampTz,
    );
    pub fn ReorderBufferAbortOld(rb: *mut ReorderBuffer, oldestRunningXid: TransactionId);
    pub fn ReorderBufferForget(rb: *mut ReorderBuffer, xid: TransactionId, lsn: XLogRecPtr);
    pub fn ReorderBufferInvalidate(rb: *mut ReorderBuffer, xid: TransactionId, lsn: XLogRecPtr);
    pub fn ReorderBufferSetBaseSnapshot(
        rb: *mut ReorderBuffer,
        xid: TransactionId,
        lsn: XLogRecPtr,
        snap: Snapshot,
    );
    pub fn ReorderBufferAddSnapshot(
        rb: *mut ReorderBuffer,
        xid: TransactionId,
        lsn: XLogRecPtr,
        snap: Snapshot,
    );
    pub fn ReorderBufferAddNewCommandId(
        rb: *mut ReorderBuffer,
        xid: TransactionId,
        lsn: XLogRecPtr,
        cid: CommandId,
    );
    pub fn ReorderBufferAddNewTupleCids(
        rb: *mut ReorderBuffer,
        xid: TransactionId,
        lsn: XLogRecPtr,
        locator: RelFileLocator,
        tid: ItemPointerData,
        cmin: CommandId,
        cmax: CommandId,
        combocid: CommandId,
    );
    pub fn ReorderBufferAddInvalidations(
        rb: *mut ReorderBuffer,
        xid: TransactionId,
        lsn: XLogRecPtr,
        nmsgs: Size,
        msgs: *mut SharedInvalidationMessage,
    );
    pub fn ReorderBufferImmediateInvalidation(
        rb: *mut ReorderBuffer,
        ninvalidations: uint32,
        invalidations: *mut SharedInvalidationMessage,
    );
    pub fn ReorderBufferProcessXid(rb: *mut ReorderBuffer, xid: TransactionId, lsn: XLogRecPtr);
    pub fn ReorderBufferXidSetCatalogChanges(
        rb: *mut ReorderBuffer,
        xid: TransactionId,
        lsn: XLogRecPtr,
    );
    pub fn ReorderBufferXidHasCatalogChanges(rb: *mut ReorderBuffer, xid: TransactionId) -> bool;
    pub fn ReorderBufferXidHasBaseSnapshot(rb: *mut ReorderBuffer, xid: TransactionId) -> bool;
    pub fn ReorderBufferRememberPrepareInfo(
        rb: *mut ReorderBuffer,
        xid: TransactionId,
        prepare_lsn: XLogRecPtr,
        end_lsn: XLogRecPtr,
        prepare_time: TimestampTz,
        origin_id: RepOriginId,
        origin_lsn: XLogRecPtr,
    ) -> bool;
    pub fn ReorderBufferSkipPrepare(rb: *mut ReorderBuffer, xid: TransactionId);
    pub fn ReorderBufferPrepare(
        rb: *mut ReorderBuffer,
        xid: TransactionId,
        gid: *mut ::core::ffi::c_char,
    );
    pub fn ReorderBufferGetOldestTXN(rb: *mut ReorderBuffer) -> *mut ReorderBufferTXN;
    pub fn ReorderBufferGetOldestXmin(rb: *mut ReorderBuffer) -> TransactionId;
    pub fn ReorderBufferGetCatalogChangesXacts(rb: *mut ReorderBuffer) -> *mut TransactionId;
    pub fn ReorderBufferSetRestartPoint(rb: *mut ReorderBuffer, ptr: XLogRecPtr);
    pub fn StartupReorderBuffer();
    pub fn _PG_output_plugin_init(cb: *mut OutputPluginCallbacks);
    pub fn OutputPluginPrepareWrite(ctx: *mut LogicalDecodingContext, last_write: bool);
    pub fn OutputPluginWrite(ctx: *mut LogicalDecodingContext, last_write: bool);
    pub fn OutputPluginUpdateProgress(ctx: *mut LogicalDecodingContext, skipped_xact: bool);
    pub fn logicalrep_write_begin(out: StringInfo, txn: *mut ReorderBufferTXN);
    pub fn logicalrep_read_begin(in_: StringInfo, begin_data: *mut LogicalRepBeginData);
    pub fn logicalrep_write_commit(
        out: StringInfo,
        txn: *mut ReorderBufferTXN,
        commit_lsn: XLogRecPtr,
    );
    pub fn logicalrep_read_commit(in_: StringInfo, commit_data: *mut LogicalRepCommitData);
    pub fn logicalrep_write_begin_prepare(out: StringInfo, txn: *mut ReorderBufferTXN);
    pub fn logicalrep_read_begin_prepare(
        in_: StringInfo,
        begin_data: *mut LogicalRepPreparedTxnData,
    );
    pub fn logicalrep_write_prepare(
        out: StringInfo,
        txn: *mut ReorderBufferTXN,
        prepare_lsn: XLogRecPtr,
    );
    pub fn logicalrep_read_prepare(in_: StringInfo, prepare_data: *mut LogicalRepPreparedTxnData);
    pub fn logicalrep_write_commit_prepared(
        out: StringInfo,
        txn: *mut ReorderBufferTXN,
        commit_lsn: XLogRecPtr,
    );
    pub fn logicalrep_read_commit_prepared(
        in_: StringInfo,
        prepare_data: *mut LogicalRepCommitPreparedTxnData,
    );
    pub fn logicalrep_write_rollback_prepared(
        out: StringInfo,
        txn: *mut ReorderBufferTXN,
        prepare_end_lsn: XLogRecPtr,
        prepare_time: TimestampTz,
    );
    pub fn logicalrep_read_rollback_prepared(
        in_: StringInfo,
        rollback_data: *mut LogicalRepRollbackPreparedTxnData,
    );
    pub fn logicalrep_write_stream_prepare(
        out: StringInfo,
        txn: *mut ReorderBufferTXN,
        prepare_lsn: XLogRecPtr,
    );
    pub fn logicalrep_read_stream_prepare(
        in_: StringInfo,
        prepare_data: *mut LogicalRepPreparedTxnData,
    );
    pub fn logicalrep_write_origin(
        out: StringInfo,
        origin: *const ::core::ffi::c_char,
        origin_lsn: XLogRecPtr,
    );
    pub fn logicalrep_read_origin(
        in_: StringInfo,
        origin_lsn: *mut XLogRecPtr,
    ) -> *mut ::core::ffi::c_char;
    pub fn logicalrep_write_insert(
        out: StringInfo,
        xid: TransactionId,
        rel: Relation,
        newslot: *mut TupleTableSlot,
        binary: bool,
        columns: *mut Bitmapset,
    );
    pub fn logicalrep_read_insert(
        in_: StringInfo,
        newtup: *mut LogicalRepTupleData,
    ) -> LogicalRepRelId;
    pub fn logicalrep_write_update(
        out: StringInfo,
        xid: TransactionId,
        rel: Relation,
        oldslot: *mut TupleTableSlot,
        newslot: *mut TupleTableSlot,
        binary: bool,
        columns: *mut Bitmapset,
    );
    pub fn logicalrep_read_update(
        in_: StringInfo,
        has_oldtuple: *mut bool,
        oldtup: *mut LogicalRepTupleData,
        newtup: *mut LogicalRepTupleData,
    ) -> LogicalRepRelId;
    pub fn logicalrep_write_delete(
        out: StringInfo,
        xid: TransactionId,
        rel: Relation,
        oldslot: *mut TupleTableSlot,
        binary: bool,
        columns: *mut Bitmapset,
    );
    pub fn logicalrep_read_delete(
        in_: StringInfo,
        oldtup: *mut LogicalRepTupleData,
    ) -> LogicalRepRelId;
    pub fn logicalrep_write_truncate(
        out: StringInfo,
        xid: TransactionId,
        nrelids: ::core::ffi::c_int,
        relids: *mut Oid,
        cascade: bool,
        restart_seqs: bool,
    );
    pub fn logicalrep_read_truncate(
        in_: StringInfo,
        cascade: *mut bool,
        restart_seqs: *mut bool,
    ) -> *mut List;
    pub fn logicalrep_write_message(
        out: StringInfo,
        xid: TransactionId,
        lsn: XLogRecPtr,
        transactional: bool,
        prefix: *const ::core::ffi::c_char,
        sz: Size,
        message: *const ::core::ffi::c_char,
    );
    pub fn logicalrep_write_rel(
        out: StringInfo,
        xid: TransactionId,
        rel: Relation,
        columns: *mut Bitmapset,
    );
    pub fn logicalrep_read_rel(in_: StringInfo) -> *mut LogicalRepRelation;
    pub fn logicalrep_write_typ(out: StringInfo, xid: TransactionId, typoid: Oid);
    pub fn logicalrep_read_typ(in_: StringInfo, ltyp: *mut LogicalRepTyp);
    pub fn logicalrep_write_stream_start(out: StringInfo, xid: TransactionId, first_segment: bool);
    pub fn logicalrep_read_stream_start(in_: StringInfo, first_segment: *mut bool)
        -> TransactionId;
    pub fn logicalrep_write_stream_stop(out: StringInfo);
    pub fn logicalrep_write_stream_commit(
        out: StringInfo,
        txn: *mut ReorderBufferTXN,
        commit_lsn: XLogRecPtr,
    );
    pub fn logicalrep_read_stream_commit(
        in_: StringInfo,
        commit_data: *mut LogicalRepCommitData,
    ) -> TransactionId;
    pub fn logicalrep_write_stream_abort(
        out: StringInfo,
        xid: TransactionId,
        subxid: TransactionId,
        abort_lsn: XLogRecPtr,
        abort_time: TimestampTz,
        write_abort_info: bool,
    );
    pub fn logicalrep_read_stream_abort(
        in_: StringInfo,
        abort_data: *mut LogicalRepStreamAbortData,
        read_abort_info: bool,
    );
    pub fn logicalrep_message_type(action: LogicalRepMsgType::Type) -> *const ::core::ffi::c_char;
    pub static mut am_walsender: bool;
    pub static mut am_cascading_walsender: bool;
    pub static mut am_db_walsender: bool;
    pub static mut wake_wal_senders: bool;
    pub static mut max_wal_senders: ::core::ffi::c_int;
    pub static mut wal_sender_timeout: ::core::ffi::c_int;
    pub static mut log_replication_commands: bool;
    pub fn InitWalSender();
    pub fn exec_replication_command(cmd_string: *const ::core::ffi::c_char) -> bool;
    pub fn WalSndErrorCleanup();
    pub fn WalSndResourceCleanup(isCommit: bool);
    pub fn PhysicalWakeupLogicalWalSnd();
    pub fn GetStandbyFlushRecPtr(tli: *mut TimeLineID) -> XLogRecPtr;
    pub fn WalSndSignals();
    pub fn WalSndShmemSize() -> Size;
    pub fn WalSndShmemInit();
    pub fn WalSndWakeup(physical: bool, logical: bool);
    pub fn WalSndInitStopping();
    pub fn WalSndWaitStopping();
    pub fn HandleWalSndInitStopping();
    pub fn WalSndRqstFileReload();
    pub static mut wal_receiver_status_interval: ::core::ffi::c_int;
    pub static mut wal_receiver_timeout: ::core::ffi::c_int;
    pub static mut hot_standby_feedback: bool;
    pub static mut WalRcv: *mut WalRcvData;
    pub static mut WalReceiverFunctions: *mut WalReceiverFunctionsType;
    pub fn WalReceiverMain(startup_data: *mut ::core::ffi::c_char, startup_data_len: usize) -> !;
    pub fn ProcessWalRcvInterrupts();
    pub fn WalRcvForceReply();
    pub fn WalRcvShmemSize() -> Size;
    pub fn WalRcvShmemInit();
    pub fn ShutdownWalRcv();
    pub fn WalRcvStreaming() -> bool;
    pub fn WalRcvRunning() -> bool;
    pub fn RequestXLogStreaming(
        tli: TimeLineID,
        recptr: XLogRecPtr,
        conninfo: *const ::core::ffi::c_char,
        slotname: *const ::core::ffi::c_char,
        create_temp_slot: bool,
    );
    pub fn GetWalRcvFlushRecPtr(
        latestChunkStart: *mut XLogRecPtr,
        receiveTLI: *mut TimeLineID,
    ) -> XLogRecPtr;
    pub fn GetWalRcvWriteRecPtr() -> XLogRecPtr;
    pub fn GetReplicationApplyDelay() -> ::core::ffi::c_int;
    pub fn GetReplicationTransferLatency() -> ::core::ffi::c_int;
    pub static SlotInvalidationCauses: [*const ::core::ffi::c_char; 0usize];
    pub static mut ReplicationSlotCtl: *mut ReplicationSlotCtlData;
    pub static mut MyReplicationSlot: *mut ReplicationSlot;
    pub static mut max_replication_slots: ::core::ffi::c_int;
    pub static mut synchronized_standby_slots: *mut ::core::ffi::c_char;
    pub fn ReplicationSlotsShmemSize() -> Size;
    pub fn ReplicationSlotsShmemInit();
    pub fn ReplicationSlotCreate(
        name: *const ::core::ffi::c_char,
        db_specific: bool,
        persistency: ReplicationSlotPersistency::Type,
        two_phase: bool,
        failover: bool,
        synced: bool,
    );
    pub fn ReplicationSlotPersist();
    pub fn ReplicationSlotDrop(name: *const ::core::ffi::c_char, nowait: bool);
    pub fn ReplicationSlotDropAcquired();
    pub fn ReplicationSlotAlter(name: *const ::core::ffi::c_char, failover: bool);
    pub fn ReplicationSlotAcquire(name: *const ::core::ffi::c_char, nowait: bool);
    pub fn ReplicationSlotRelease();
    pub fn ReplicationSlotCleanup(synced_only: bool);
    pub fn ReplicationSlotSave();
    pub fn ReplicationSlotMarkDirty();
    pub fn ReplicationSlotInitialize();
    pub fn ReplicationSlotValidateName(
        name: *const ::core::ffi::c_char,
        elevel: ::core::ffi::c_int,
    ) -> bool;
    pub fn ReplicationSlotReserveWal();
    pub fn ReplicationSlotsComputeRequiredXmin(already_locked: bool);
    pub fn ReplicationSlotsComputeRequiredLSN();
    pub fn ReplicationSlotsComputeLogicalRestartLSN() -> XLogRecPtr;
    pub fn ReplicationSlotsCountDBSlots(
        dboid: Oid,
        nslots: *mut ::core::ffi::c_int,
        nactive: *mut ::core::ffi::c_int,
    ) -> bool;
    pub fn ReplicationSlotsDropDBSlots(dboid: Oid);
    pub fn InvalidateObsoleteReplicationSlots(
        cause: ReplicationSlotInvalidationCause::Type,
        oldestSegno: XLogSegNo,
        dboid: Oid,
        snapshotConflictHorizon: TransactionId,
    ) -> bool;
    pub fn SearchNamedReplicationSlot(
        name: *const ::core::ffi::c_char,
        need_lock: bool,
    ) -> *mut ReplicationSlot;
    pub fn ReplicationSlotIndex(slot: *mut ReplicationSlot) -> ::core::ffi::c_int;
    pub fn ReplicationSlotName(index: ::core::ffi::c_int, name: Name) -> bool;
    pub fn ReplicationSlotNameForTablesync(
        suboid: Oid,
        relid: Oid,
        syncslotname: *mut ::core::ffi::c_char,
        szslot: Size,
    );
    pub fn ReplicationSlotDropAtPubNode(
        wrconn: *mut WalReceiverConn,
        slotname: *mut ::core::ffi::c_char,
        missing_ok: bool,
    );
    pub fn StartupReplicationSlots();
    pub fn CheckPointReplicationSlots(is_shutdown: bool);
    pub fn CheckSlotRequirements();
    pub fn CheckSlotPermissions();
    pub fn GetSlotInvalidationCause(
        invalidation_reason: *const ::core::ffi::c_char,
    ) -> ReplicationSlotInvalidationCause::Type;
    pub fn SlotExistsInSyncStandbySlots(slot_name: *const ::core::ffi::c_char) -> bool;
    pub fn StandbySlotsHaveCaughtup(wait_for_lsn: XLogRecPtr, elevel: ::core::ffi::c_int) -> bool;
    pub fn WaitForStandbyConfirmation(wait_for_lsn: XLogRecPtr);
    pub fn CheckLogicalDecodingRequirements();
    pub fn CreateInitDecodingContext(
        plugin: *const ::core::ffi::c_char,
        output_plugin_options: *mut List,
        need_full_snapshot: bool,
        restart_lsn: XLogRecPtr,
        xl_routine: *mut XLogReaderRoutine,
        prepare_write: LogicalOutputPluginWriterPrepareWrite,
        do_write: LogicalOutputPluginWriterWrite,
        update_progress: LogicalOutputPluginWriterUpdateProgress,
    ) -> *mut LogicalDecodingContext;
    pub fn CreateDecodingContext(
        start_lsn: XLogRecPtr,
        output_plugin_options: *mut List,
        fast_forward: bool,
        xl_routine: *mut XLogReaderRoutine,
        prepare_write: LogicalOutputPluginWriterPrepareWrite,
        do_write: LogicalOutputPluginWriterWrite,
        update_progress: LogicalOutputPluginWriterUpdateProgress,
    ) -> *mut LogicalDecodingContext;
    pub fn DecodingContextFindStartpoint(ctx: *mut LogicalDecodingContext);
    pub fn DecodingContextReady(ctx: *mut LogicalDecodingContext) -> bool;
    pub fn FreeDecodingContext(ctx: *mut LogicalDecodingContext);
    pub fn LogicalIncreaseXminForSlot(current_lsn: XLogRecPtr, xmin: TransactionId);
    pub fn LogicalIncreaseRestartDecodingForSlot(current_lsn: XLogRecPtr, restart_lsn: XLogRecPtr);
    pub fn LogicalConfirmReceivedLocation(lsn: XLogRecPtr);
    pub fn filter_prepare_cb_wrapper(
        ctx: *mut LogicalDecodingContext,
        xid: TransactionId,
        gid: *const ::core::ffi::c_char,
    ) -> bool;
    pub fn filter_by_origin_cb_wrapper(
        ctx: *mut LogicalDecodingContext,
        origin_id: RepOriginId,
    ) -> bool;
    pub fn ResetLogicalStreamingState();
    pub fn UpdateDecodingStats(ctx: *mut LogicalDecodingContext);
    pub fn LogicalReplicationSlotHasPendingWal(end_of_wal: XLogRecPtr) -> bool;
    pub fn LogicalSlotAdvanceAndCheckSnapState(
        moveto: XLogRecPtr,
        found_consistent_snapshot: *mut bool,
    ) -> XLogRecPtr;
    pub static mut ParallelApplyMessagePending: sig_atomic_t;
    pub fn ApplyWorkerMain(main_arg: Datum);
    pub fn ParallelApplyWorkerMain(main_arg: Datum);
    pub fn TablesyncWorkerMain(main_arg: Datum);
    pub fn IsLogicalWorker() -> bool;
    pub fn IsLogicalParallelApplyWorker() -> bool;
    pub fn HandleParallelApplyMessageInterrupt();
    pub fn HandleParallelApplyMessages();
    pub fn LogicalRepWorkersWakeupAtCommit(subid: Oid);
    pub fn AtEOXact_LogicalRepWorkers(isCommit: bool);
    pub fn QueryRewrite(parsetree: *mut Query) -> *mut List;
    pub fn AcquireRewriteLocks(parsetree: *mut Query, forExecute: bool, forUpdatePushedDown: bool);
    pub fn build_column_default(rel: Relation, attrno: ::core::ffi::c_int) -> *mut Node;
    pub fn get_view_query(view: Relation) -> *mut Query;
    pub fn view_has_instead_trigger(
        view: Relation,
        event: CmdType::Type,
        mergeActionList: *mut List,
    ) -> bool;
    pub fn view_query_is_auto_updatable(
        viewquery: *mut Query,
        check_cols: bool,
    ) -> *const ::core::ffi::c_char;
    pub fn relation_is_updatable(
        reloid: Oid,
        outer_reloids: *mut List,
        include_triggers: bool,
        include_cols: *mut Bitmapset,
    ) -> ::core::ffi::c_int;
    pub fn error_view_not_updatable(
        view: Relation,
        command: CmdType::Type,
        mergeActionList: *mut List,
        detail: *const ::core::ffi::c_char,
    );
    pub static mut row_security_policy_hook_permissive: row_security_policy_hook_type;
    pub static mut row_security_policy_hook_restrictive: row_security_policy_hook_type;
    pub fn get_row_security_policies(
        root: *mut Query,
        rte: *mut RangeTblEntry,
        rt_index: ::core::ffi::c_int,
        securityQuals: *mut *mut List,
        withCheckOptions: *mut *mut List,
        hasRowSecurity: *mut bool,
        hasSubLinks: *mut bool,
    );
    pub static mut BufferDescriptors: *mut BufferDescPadded;
    pub static mut BufferIOCVArray: *mut ConditionVariableMinimallyPadded;
    pub static mut BackendWritebackContext: WritebackContext;
    pub static mut LocalBufferDescriptors: *mut BufferDesc;
    pub fn LockBufHdr(desc: *mut BufferDesc) -> uint32;
    pub static mut CkptBufferIds: *mut CkptSortItem;
    pub static buffer_io_resowner_desc: ResourceOwnerDesc;
    pub static buffer_pin_resowner_desc: ResourceOwnerDesc;
    pub fn WritebackContextInit(
        context: *mut WritebackContext,
        max_pending: *mut ::core::ffi::c_int,
    );
    pub fn IssuePendingWritebacks(wb_context: *mut WritebackContext, io_context: IOContext::Type);
    pub fn ScheduleBufferTagForWriteback(
        wb_context: *mut WritebackContext,
        io_context: IOContext::Type,
        tag: *mut BufferTag,
    );
    pub fn IOContextForStrategy(strategy: BufferAccessStrategy) -> IOContext::Type;
    pub fn StrategyGetBuffer(
        strategy: BufferAccessStrategy,
        buf_state: *mut uint32,
        from_ring: *mut bool,
    ) -> *mut BufferDesc;
    pub fn StrategyFreeBuffer(buf: *mut BufferDesc);
    pub fn StrategyRejectBuffer(
        strategy: BufferAccessStrategy,
        buf: *mut BufferDesc,
        from_ring: bool,
    ) -> bool;
    pub fn StrategySyncStart(
        complete_passes: *mut uint32,
        num_buf_alloc: *mut uint32,
    ) -> ::core::ffi::c_int;
    pub fn StrategyNotifyBgWriter(bgwprocno: ::core::ffi::c_int);
    pub fn StrategyShmemSize() -> Size;
    pub fn StrategyInitialize(init: bool);
    pub fn have_free_buffer() -> bool;
    pub fn BufTableShmemSize(size: ::core::ffi::c_int) -> Size;
    pub fn InitBufTable(size: ::core::ffi::c_int);
    pub fn BufTableHashCode(tagPtr: *mut BufferTag) -> uint32;
    pub fn BufTableLookup(tagPtr: *mut BufferTag, hashcode: uint32) -> ::core::ffi::c_int;
    pub fn BufTableInsert(
        tagPtr: *mut BufferTag,
        hashcode: uint32,
        buf_id: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn BufTableDelete(tagPtr: *mut BufferTag, hashcode: uint32);
    pub fn PinLocalBuffer(buf_hdr: *mut BufferDesc, adjust_usagecount: bool) -> bool;
    pub fn UnpinLocalBuffer(buffer: Buffer);
    pub fn UnpinLocalBufferNoOwner(buffer: Buffer);
    pub fn PrefetchLocalBuffer(
        smgr: SMgrRelation,
        forkNum: ForkNumber::Type,
        blockNum: BlockNumber,
    ) -> PrefetchBufferResult;
    pub fn LocalBufferAlloc(
        smgr: SMgrRelation,
        forkNum: ForkNumber::Type,
        blockNum: BlockNumber,
        foundPtr: *mut bool,
    ) -> *mut BufferDesc;
    pub fn ExtendBufferedRelLocal(
        bmr: BufferManagerRelation,
        fork: ForkNumber::Type,
        flags: uint32,
        extend_by: uint32,
        extend_upto: BlockNumber,
        buffers: *mut Buffer,
        extended_by: *mut uint32,
    ) -> BlockNumber;
    pub fn MarkLocalBufferDirty(buffer: Buffer);
    pub fn DropRelationLocalBuffers(
        rlocator: RelFileLocator,
        forkNum: ForkNumber::Type,
        firstDelBlock: BlockNumber,
    );
    pub fn DropRelationAllLocalBuffers(rlocator: RelFileLocator);
    pub fn AtEOXact_LocalBuffers(isCommit: bool);
    pub fn BufFileCreateTemp(interXact: bool) -> *mut BufFile;
    pub fn BufFileClose(file: *mut BufFile);
    pub fn BufFileRead(file: *mut BufFile, ptr: *mut ::core::ffi::c_void, size: usize) -> usize;
    pub fn BufFileReadExact(file: *mut BufFile, ptr: *mut ::core::ffi::c_void, size: usize);
    pub fn BufFileReadMaybeEOF(
        file: *mut BufFile,
        ptr: *mut ::core::ffi::c_void,
        size: usize,
        eofOK: bool,
    ) -> usize;
    pub fn BufFileWrite(file: *mut BufFile, ptr: *const ::core::ffi::c_void, size: usize);
    pub fn BufFileSeek(
        file: *mut BufFile,
        fileno: ::core::ffi::c_int,
        offset: off_t,
        whence: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn BufFileTell(file: *mut BufFile, fileno: *mut ::core::ffi::c_int, offset: *mut off_t);
    pub fn BufFileSeekBlock(file: *mut BufFile, blknum: int64) -> ::core::ffi::c_int;
    pub fn BufFileSize(file: *mut BufFile) -> int64;
    pub fn BufFileAppend(target: *mut BufFile, source: *mut BufFile) -> int64;
    pub fn BufFileCreateFileSet(
        fileset: *mut FileSet,
        name: *const ::core::ffi::c_char,
    ) -> *mut BufFile;
    pub fn BufFileExportFileSet(file: *mut BufFile);
    pub fn BufFileOpenFileSet(
        fileset: *mut FileSet,
        name: *const ::core::ffi::c_char,
        mode: ::core::ffi::c_int,
        missing_ok: bool,
    ) -> *mut BufFile;
    pub fn BufFileDeleteFileSet(
        fileset: *mut FileSet,
        name: *const ::core::ffi::c_char,
        missing_ok: bool,
    );
    pub fn BufFileTruncateFileSet(file: *mut BufFile, fileno: ::core::ffi::c_int, offset: off_t);
    pub fn GetFreeIndexPage(rel: Relation) -> BlockNumber;
    pub fn RecordFreeIndexPage(rel: Relation, freeBlock: BlockNumber);
    pub fn RecordUsedIndexPage(rel: Relation, usedBlock: BlockNumber);
    pub fn IndexFreeSpaceMapVacuum(rel: Relation);
    pub fn GetRecordedFreeSpace(rel: Relation, heapBlk: BlockNumber) -> Size;
    pub fn GetPageWithFreeSpace(rel: Relation, spaceNeeded: Size) -> BlockNumber;
    pub fn RecordAndGetPageWithFreeSpace(
        rel: Relation,
        oldPage: BlockNumber,
        oldSpaceAvail: Size,
        spaceNeeded: Size,
    ) -> BlockNumber;
    pub fn RecordPageWithFreeSpace(rel: Relation, heapBlk: BlockNumber, spaceAvail: Size);
    pub fn XLogRecordPageWithFreeSpace(
        rlocator: RelFileLocator,
        heapBlk: BlockNumber,
        spaceAvail: Size,
    );
    pub fn FreeSpaceMapPrepareTruncateRel(rel: Relation, nblocks: BlockNumber) -> BlockNumber;
    pub fn FreeSpaceMapVacuum(rel: Relation);
    pub fn FreeSpaceMapVacuumRange(rel: Relation, start: BlockNumber, end: BlockNumber);
    pub static mut proc_exit_inprogress: bool;
    pub static mut shmem_exit_inprogress: bool;
    pub fn proc_exit(code: ::core::ffi::c_int) -> !;
    pub fn shmem_exit(code: ::core::ffi::c_int);
    pub fn on_proc_exit(function: pg_on_exit_callback, arg: Datum);
    pub fn on_shmem_exit(function: pg_on_exit_callback, arg: Datum);
    pub fn before_shmem_exit(function: pg_on_exit_callback, arg: Datum);
    pub fn cancel_before_shmem_exit(function: pg_on_exit_callback, arg: Datum);
    pub fn on_exit_reset();
    pub fn check_on_shmem_exit_lists_are_empty();
    pub static mut shmem_startup_hook: shmem_startup_hook_type;
    pub fn CalculateShmemSize(num_semaphores: *mut ::core::ffi::c_int) -> Size;
    pub fn CreateSharedMemoryAndSemaphores();
    pub fn InitializeShmemGUCs();
    pub fn RelationInitLockInfo(relation: Relation);
    pub fn LockRelationOid(relid: Oid, lockmode: LOCKMODE);
    pub fn LockRelationId(relid: *mut LockRelId, lockmode: LOCKMODE);
    pub fn ConditionalLockRelationOid(relid: Oid, lockmode: LOCKMODE) -> bool;
    pub fn UnlockRelationId(relid: *mut LockRelId, lockmode: LOCKMODE);
    pub fn UnlockRelationOid(relid: Oid, lockmode: LOCKMODE);
    pub fn LockRelation(relation: Relation, lockmode: LOCKMODE);
    pub fn ConditionalLockRelation(relation: Relation, lockmode: LOCKMODE) -> bool;
    pub fn UnlockRelation(relation: Relation, lockmode: LOCKMODE);
    pub fn CheckRelationLockedByMe(
        relation: Relation,
        lockmode: LOCKMODE,
        orstronger: bool,
    ) -> bool;
    pub fn CheckRelationOidLockedByMe(relid: Oid, lockmode: LOCKMODE, orstronger: bool) -> bool;
    pub fn LockHasWaitersRelation(relation: Relation, lockmode: LOCKMODE) -> bool;
    pub fn LockRelationIdForSession(relid: *mut LockRelId, lockmode: LOCKMODE);
    pub fn UnlockRelationIdForSession(relid: *mut LockRelId, lockmode: LOCKMODE);
    pub fn LockRelationForExtension(relation: Relation, lockmode: LOCKMODE);
    pub fn UnlockRelationForExtension(relation: Relation, lockmode: LOCKMODE);
    pub fn ConditionalLockRelationForExtension(relation: Relation, lockmode: LOCKMODE) -> bool;
    pub fn RelationExtensionLockWaiterCount(relation: Relation) -> ::core::ffi::c_int;
    pub fn LockDatabaseFrozenIds(lockmode: LOCKMODE);
    pub fn LockPage(relation: Relation, blkno: BlockNumber, lockmode: LOCKMODE);
    pub fn ConditionalLockPage(relation: Relation, blkno: BlockNumber, lockmode: LOCKMODE) -> bool;
    pub fn UnlockPage(relation: Relation, blkno: BlockNumber, lockmode: LOCKMODE);
    pub fn LockTuple(relation: Relation, tid: ItemPointer, lockmode: LOCKMODE);
    pub fn ConditionalLockTuple(relation: Relation, tid: ItemPointer, lockmode: LOCKMODE) -> bool;
    pub fn UnlockTuple(relation: Relation, tid: ItemPointer, lockmode: LOCKMODE);
    pub fn XactLockTableInsert(xid: TransactionId);
    pub fn XactLockTableDelete(xid: TransactionId);
    pub fn XactLockTableWait(
        xid: TransactionId,
        rel: Relation,
        ctid: ItemPointer,
        oper: XLTW_Oper::Type,
    );
    pub fn ConditionalXactLockTableWait(xid: TransactionId) -> bool;
    pub fn WaitForLockers(heaplocktag: LOCKTAG, lockmode: LOCKMODE, progress: bool);
    pub fn WaitForLockersMultiple(locktags: *mut List, lockmode: LOCKMODE, progress: bool);
    pub fn SpeculativeInsertionLockAcquire(xid: TransactionId) -> uint32;
    pub fn SpeculativeInsertionLockRelease(xid: TransactionId);
    pub fn SpeculativeInsertionWait(xid: TransactionId, token: uint32);
    pub fn LockDatabaseObject(classid: Oid, objid: Oid, objsubid: uint16, lockmode: LOCKMODE);
    pub fn ConditionalLockDatabaseObject(
        classid: Oid,
        objid: Oid,
        objsubid: uint16,
        lockmode: LOCKMODE,
    ) -> bool;
    pub fn UnlockDatabaseObject(classid: Oid, objid: Oid, objsubid: uint16, lockmode: LOCKMODE);
    pub fn LockSharedObject(classid: Oid, objid: Oid, objsubid: uint16, lockmode: LOCKMODE);
    pub fn ConditionalLockSharedObject(
        classid: Oid,
        objid: Oid,
        objsubid: uint16,
        lockmode: LOCKMODE,
    ) -> bool;
    pub fn UnlockSharedObject(classid: Oid, objid: Oid, objsubid: uint16, lockmode: LOCKMODE);
    pub fn LockSharedObjectForSession(
        classid: Oid,
        objid: Oid,
        objsubid: uint16,
        lockmode: LOCKMODE,
    );
    pub fn UnlockSharedObjectForSession(
        classid: Oid,
        objid: Oid,
        objsubid: uint16,
        lockmode: LOCKMODE,
    );
    pub fn LockApplyTransactionForSession(
        suboid: Oid,
        xid: TransactionId,
        objid: uint16,
        lockmode: LOCKMODE,
    );
    pub fn UnlockApplyTransactionForSession(
        suboid: Oid,
        xid: TransactionId,
        objid: uint16,
        lockmode: LOCKMODE,
    );
    pub fn DescribeLockTag(buf: StringInfo, tag: *const LOCKTAG);
    pub fn GetLockNameFromTagType(locktag_type: uint16) -> *const ::core::ffi::c_char;
    pub fn ProcSignalShmemSize() -> Size;
    pub fn ProcSignalShmemInit();
    pub fn ProcSignalInit();
    pub fn SendProcSignal(
        pid: pid_t,
        reason: ProcSignalReason::Type,
        procNumber: ProcNumber,
    ) -> ::core::ffi::c_int;
    pub fn EmitProcSignalBarrier(type_: ProcSignalBarrierType::Type) -> uint64;
    pub fn WaitForProcSignalBarrier(generation: uint64);
    pub fn ProcessProcSignalBarrier();
    pub fn procsignal_sigusr1_handler(postgres_signal_arg: ::core::ffi::c_int);
    pub fn standby_redo(record: *mut XLogReaderState);
    pub fn standby_desc(buf: StringInfo, record: *mut XLogReaderState);
    pub fn standby_identify(info: uint8) -> *const ::core::ffi::c_char;
    pub fn standby_desc_invalidations(
        buf: StringInfo,
        nmsgs: ::core::ffi::c_int,
        msgs: *mut SharedInvalidationMessage,
        dbId: Oid,
        tsId: Oid,
        relcacheInitFileInval: bool,
    );
    pub static mut max_standby_archive_delay: ::core::ffi::c_int;
    pub static mut max_standby_streaming_delay: ::core::ffi::c_int;
    pub static mut log_recovery_conflict_waits: bool;
    pub fn InitRecoveryTransactionEnvironment();
    pub fn ShutdownRecoveryTransactionEnvironment();
    pub fn ResolveRecoveryConflictWithSnapshot(
        snapshotConflictHorizon: TransactionId,
        isCatalogRel: bool,
        locator: RelFileLocator,
    );
    pub fn ResolveRecoveryConflictWithSnapshotFullXid(
        snapshotConflictHorizon: FullTransactionId,
        isCatalogRel: bool,
        locator: RelFileLocator,
    );
    pub fn ResolveRecoveryConflictWithTablespace(tsid: Oid);
    pub fn ResolveRecoveryConflictWithDatabase(dbid: Oid);
    pub fn ResolveRecoveryConflictWithLock(locktag: LOCKTAG, logging_conflict: bool);
    pub fn ResolveRecoveryConflictWithBufferPin();
    pub fn CheckRecoveryConflictDeadlock();
    pub fn StandbyDeadLockHandler();
    pub fn StandbyTimeoutHandler();
    pub fn StandbyLockTimeoutHandler();
    pub fn LogRecoveryConflict(
        reason: ProcSignalReason::Type,
        wait_start: TimestampTz,
        now: TimestampTz,
        wait_list: *mut VirtualTransactionId,
        still_waiting: bool,
    );
    pub fn StandbyAcquireAccessExclusiveLock(xid: TransactionId, dbOid: Oid, relOid: Oid);
    pub fn StandbyReleaseLockTree(
        xid: TransactionId,
        nsubxids: ::core::ffi::c_int,
        subxids: *mut TransactionId,
    );
    pub fn StandbyReleaseAllLocks();
    pub fn StandbyReleaseOldLocks(oldxid: TransactionId);
    pub fn LogAccessExclusiveLock(dbOid: Oid, relOid: Oid);
    pub fn LogAccessExclusiveLockPrepare();
    pub fn LogStandbySnapshot() -> XLogRecPtr;
    pub fn LogStandbyInvalidations(
        nmsgs: ::core::ffi::c_int,
        msgs: *mut SharedInvalidationMessage,
        relcacheInitFileInval: bool,
    );
    pub fn ProcArrayShmemSize() -> Size;
    pub fn CreateSharedProcArray();
    pub fn ProcArrayAdd(proc_: *mut PGPROC);
    pub fn ProcArrayRemove(proc_: *mut PGPROC, latestXid: TransactionId);
    pub fn ProcArrayEndTransaction(proc_: *mut PGPROC, latestXid: TransactionId);
    pub fn ProcArrayClearTransaction(proc_: *mut PGPROC);
    pub fn ProcArrayInitRecovery(initializedUptoXID: TransactionId);
    pub fn ProcArrayApplyRecoveryInfo(running: RunningTransactions);
    pub fn ProcArrayApplyXidAssignment(
        topxid: TransactionId,
        nsubxids: ::core::ffi::c_int,
        subxids: *mut TransactionId,
    );
    pub fn RecordKnownAssignedTransactionIds(xid: TransactionId);
    pub fn ExpireTreeKnownAssignedTransactionIds(
        xid: TransactionId,
        nsubxids: ::core::ffi::c_int,
        subxids: *mut TransactionId,
        max_xid: TransactionId,
    );
    pub fn ExpireAllKnownAssignedTransactionIds();
    pub fn ExpireOldKnownAssignedTransactionIds(xid: TransactionId);
    pub fn KnownAssignedTransactionIdsIdleMaintenance();
    pub fn GetMaxSnapshotXidCount() -> ::core::ffi::c_int;
    pub fn GetMaxSnapshotSubxidCount() -> ::core::ffi::c_int;
    pub fn GetSnapshotData(snapshot: Snapshot) -> Snapshot;
    pub fn ProcArrayInstallImportedXmin(
        xmin: TransactionId,
        sourcevxid: *mut VirtualTransactionId,
    ) -> bool;
    pub fn ProcArrayInstallRestoredXmin(xmin: TransactionId, proc_: *mut PGPROC) -> bool;
    pub fn GetRunningTransactionData() -> RunningTransactions;
    pub fn TransactionIdIsInProgress(xid: TransactionId) -> bool;
    pub fn TransactionIdIsActive(xid: TransactionId) -> bool;
    pub fn GetOldestNonRemovableTransactionId(rel: Relation) -> TransactionId;
    pub fn GetOldestTransactionIdConsideredRunning() -> TransactionId;
    pub fn GetOldestActiveTransactionId() -> TransactionId;
    pub fn GetOldestSafeDecodingTransactionId(catalogOnly: bool) -> TransactionId;
    pub fn GetReplicationHorizons(xmin: *mut TransactionId, catalog_xmin: *mut TransactionId);
    pub fn GetVirtualXIDsDelayingChkpt(
        nvxids: *mut ::core::ffi::c_int,
        type_: ::core::ffi::c_int,
    ) -> *mut VirtualTransactionId;
    pub fn HaveVirtualXIDsDelayingChkpt(
        vxids: *mut VirtualTransactionId,
        nvxids: ::core::ffi::c_int,
        type_: ::core::ffi::c_int,
    ) -> bool;
    pub fn ProcNumberGetProc(procNumber: ::core::ffi::c_int) -> *mut PGPROC;
    pub fn ProcNumberGetTransactionIds(
        procNumber: ::core::ffi::c_int,
        xid: *mut TransactionId,
        xmin: *mut TransactionId,
        nsubxid: *mut ::core::ffi::c_int,
        overflowed: *mut bool,
    );
    pub fn BackendPidGetProc(pid: ::core::ffi::c_int) -> *mut PGPROC;
    pub fn BackendPidGetProcWithLock(pid: ::core::ffi::c_int) -> *mut PGPROC;
    pub fn BackendXidGetPid(xid: TransactionId) -> ::core::ffi::c_int;
    pub fn IsBackendPid(pid: ::core::ffi::c_int) -> bool;
    pub fn GetCurrentVirtualXIDs(
        limitXmin: TransactionId,
        excludeXmin0: bool,
        allDbs: bool,
        excludeVacuum: ::core::ffi::c_int,
        nvxids: *mut ::core::ffi::c_int,
    ) -> *mut VirtualTransactionId;
    pub fn GetConflictingVirtualXIDs(
        limitXmin: TransactionId,
        dbOid: Oid,
    ) -> *mut VirtualTransactionId;
    pub fn CancelVirtualTransaction(
        vxid: VirtualTransactionId,
        sigmode: ProcSignalReason::Type,
    ) -> pid_t;
    pub fn SignalVirtualTransaction(
        vxid: VirtualTransactionId,
        sigmode: ProcSignalReason::Type,
        conflictPending: bool,
    ) -> pid_t;
    pub fn MinimumActiveBackends(min: ::core::ffi::c_int) -> bool;
    pub fn CountDBBackends(databaseid: Oid) -> ::core::ffi::c_int;
    pub fn CountDBConnections(databaseid: Oid) -> ::core::ffi::c_int;
    pub fn CancelDBBackends(
        databaseid: Oid,
        sigmode: ProcSignalReason::Type,
        conflictPending: bool,
    );
    pub fn CountUserBackends(roleid: Oid) -> ::core::ffi::c_int;
    pub fn CountOtherDBBackends(
        databaseId: Oid,
        nbackends: *mut ::core::ffi::c_int,
        nprepared: *mut ::core::ffi::c_int,
    ) -> bool;
    pub fn TerminateOtherDBBackends(databaseId: Oid);
    pub fn XidCacheRemoveRunningXids(
        xid: TransactionId,
        nxids: ::core::ffi::c_int,
        xids: *const TransactionId,
        latestXid: TransactionId,
    );
    pub fn ProcArraySetReplicationSlotXmin(
        xmin: TransactionId,
        catalog_xmin: TransactionId,
        already_locked: bool,
    );
    pub fn ProcArrayGetReplicationSlotXmin(
        xmin: *mut TransactionId,
        catalog_xmin: *mut TransactionId,
    );
    pub static mut ActivePortal: Portal;
    pub fn ChoosePortalStrategy(stmts: *mut List) -> PortalStrategy::Type;
    pub fn FetchPortalTargetList(portal: Portal) -> *mut List;
    pub fn FetchStatementTargetList(stmt: *mut Node) -> *mut List;
    pub fn PortalStart(
        portal: Portal,
        params: ParamListInfo,
        eflags: ::core::ffi::c_int,
        snapshot: Snapshot,
    );
    pub fn PortalSetResultFormat(portal: Portal, nFormats: ::core::ffi::c_int, formats: *mut int16);
    pub fn PortalRun(
        portal: Portal,
        count: ::core::ffi::c_long,
        isTopLevel: bool,
        run_once: bool,
        dest: *mut DestReceiver,
        altdest: *mut DestReceiver,
        qc: *mut QueryCompletion,
    ) -> bool;
    pub fn PortalRunFetch(
        portal: Portal,
        fdirection: FetchDirection::Type,
        count: ::core::ffi::c_long,
        dest: *mut DestReceiver,
    ) -> uint64;
    pub fn PlannedStmtRequiresSnapshot(pstmt: *mut PlannedStmt) -> bool;
    pub fn EnsurePortalSnapshotExists();
    pub static mut whereToSendOutput: CommandDest::Type;
    pub static mut debug_query_string: *const ::core::ffi::c_char;
    pub static mut max_stack_depth: ::core::ffi::c_int;
    pub static mut PostAuthDelay: ::core::ffi::c_int;
    pub static mut client_connection_check_interval: ::core::ffi::c_int;
    pub static mut log_statement: ::core::ffi::c_int;
    pub static mut restrict_nonsystem_relation_kind: ::core::ffi::c_int;
    pub fn pg_parse_query(query_string: *const ::core::ffi::c_char) -> *mut List;
    pub fn pg_rewrite_query(query: *mut Query) -> *mut List;
    pub fn pg_analyze_and_rewrite_fixedparams(
        parsetree: *mut RawStmt,
        query_string: *const ::core::ffi::c_char,
        paramTypes: *const Oid,
        numParams: ::core::ffi::c_int,
        queryEnv: *mut QueryEnvironment,
    ) -> *mut List;
    pub fn pg_analyze_and_rewrite_varparams(
        parsetree: *mut RawStmt,
        query_string: *const ::core::ffi::c_char,
        paramTypes: *mut *mut Oid,
        numParams: *mut ::core::ffi::c_int,
        queryEnv: *mut QueryEnvironment,
    ) -> *mut List;
    pub fn pg_analyze_and_rewrite_withcb(
        parsetree: *mut RawStmt,
        query_string: *const ::core::ffi::c_char,
        parserSetup: ParserSetupHook,
        parserSetupArg: *mut ::core::ffi::c_void,
        queryEnv: *mut QueryEnvironment,
    ) -> *mut List;
    pub fn pg_plan_query(
        querytree: *mut Query,
        query_string: *const ::core::ffi::c_char,
        cursorOptions: ::core::ffi::c_int,
        boundParams: ParamListInfo,
    ) -> *mut PlannedStmt;
    pub fn pg_plan_queries(
        querytrees: *mut List,
        query_string: *const ::core::ffi::c_char,
        cursorOptions: ::core::ffi::c_int,
        boundParams: ParamListInfo,
    ) -> *mut List;
    pub fn die(postgres_signal_arg: ::core::ffi::c_int);
    pub fn quickdie(postgres_signal_arg: ::core::ffi::c_int) -> !;
    pub fn StatementCancelHandler(postgres_signal_arg: ::core::ffi::c_int);
    pub fn FloatExceptionHandler(postgres_signal_arg: ::core::ffi::c_int) -> !;
    pub fn HandleRecoveryConflictInterrupt(reason: ProcSignalReason::Type);
    pub fn ProcessClientReadInterrupt(blocked: bool);
    pub fn ProcessClientWriteInterrupt(blocked: bool);
    pub fn process_postgres_switches(
        argc: ::core::ffi::c_int,
        argv: *mut *mut ::core::ffi::c_char,
        ctx: GucContext::Type,
        dbname: *mut *const ::core::ffi::c_char,
    );
    pub fn PostgresSingleUserMain(
        argc: ::core::ffi::c_int,
        argv: *mut *mut ::core::ffi::c_char,
        username: *const ::core::ffi::c_char,
    ) -> !;
    pub fn PostgresMain(
        dbname: *const ::core::ffi::c_char,
        username: *const ::core::ffi::c_char,
    ) -> !;
    pub fn get_stack_depth_rlimit() -> ::core::ffi::c_long;
    pub fn ResetUsage();
    pub fn ShowUsage(title: *const ::core::ffi::c_char);
    pub fn check_log_duration(
        msec_str: *mut ::core::ffi::c_char,
        was_logged: bool,
    ) -> ::core::ffi::c_int;
    pub fn set_debug_options(
        debug_flag: ::core::ffi::c_int,
        context: GucContext::Type,
        source: GucSource::Type,
    );
    pub fn set_plan_disabling_options(
        arg: *const ::core::ffi::c_char,
        context: GucContext::Type,
        source: GucSource::Type,
    ) -> bool;
    pub fn get_stats_option_name(arg: *const ::core::ffi::c_char) -> *const ::core::ffi::c_char;
    pub static mut ProcessUtility_hook: ProcessUtility_hook_type;
    pub fn ProcessUtility(
        pstmt: *mut PlannedStmt,
        queryString: *const ::core::ffi::c_char,
        readOnlyTree: bool,
        context: ProcessUtilityContext::Type,
        params: ParamListInfo,
        queryEnv: *mut QueryEnvironment,
        dest: *mut DestReceiver,
        qc: *mut QueryCompletion,
    );
    pub fn standard_ProcessUtility(
        pstmt: *mut PlannedStmt,
        queryString: *const ::core::ffi::c_char,
        readOnlyTree: bool,
        context: ProcessUtilityContext::Type,
        params: ParamListInfo,
        queryEnv: *mut QueryEnvironment,
        dest: *mut DestReceiver,
        qc: *mut QueryCompletion,
    );
    pub fn ProcessUtilityForAlterTable(stmt: *mut Node, context: *mut AlterTableUtilityContext);
    pub fn UtilityReturnsTuples(parsetree: *mut Node) -> bool;
    pub fn UtilityTupleDescriptor(parsetree: *mut Node) -> TupleDesc;
    pub fn UtilityContainsQuery(parsetree: *mut Node) -> *mut Query;
    pub fn CreateCommandTag(parsetree: *mut Node) -> CommandTag::Type;
    pub fn GetCommandLogLevel(parsetree: *mut Node) -> LogStmtLevel::Type;
    pub fn CommandIsReadOnly(pstmt: *mut PlannedStmt) -> bool;
    pub static mut TSCurrentConfig: *mut ::core::ffi::c_char;
    pub fn lookup_ts_parser_cache(prsId: Oid) -> *mut TSParserCacheEntry;
    pub fn lookup_ts_dictionary_cache(dictId: Oid) -> *mut TSDictionaryCacheEntry;
    pub fn lookup_ts_config_cache(cfgId: Oid) -> *mut TSConfigCacheEntry;
    pub fn getTSCurrentConfig(emitError: bool) -> Oid;
    pub fn compareWordEntryPos(
        a: *const ::core::ffi::c_void,
        b: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub static tsearch_op_priority: [::core::ffi::c_int; 4usize];
    pub fn get_tsearch_config_filename(
        basename: *const ::core::ffi::c_char,
        extension: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn readstoplist(
        fname: *const ::core::ffi::c_char,
        s: *mut StopList,
        wordop: ::core::option::Option<
            unsafe extern "C-unwind" fn(
                arg1: *const ::core::ffi::c_char,
            ) -> *mut ::core::ffi::c_char,
        >,
    );
    pub fn searchstoplist(s: *mut StopList, key: *mut ::core::ffi::c_char) -> bool;
    pub fn init_tsvector_parser(
        input: *mut ::core::ffi::c_char,
        flags: ::core::ffi::c_int,
        escontext: *mut Node,
    ) -> TSVectorParseState;
    pub fn reset_tsvector_parser(state: TSVectorParseState, input: *mut ::core::ffi::c_char);
    pub fn gettoken_tsvector(
        state: TSVectorParseState,
        strval: *mut *mut ::core::ffi::c_char,
        lenval: *mut ::core::ffi::c_int,
        pos_ptr: *mut *mut WordEntryPos,
        poslen: *mut ::core::ffi::c_int,
        endptr: *mut *mut ::core::ffi::c_char,
    ) -> bool;
    pub fn close_tsvector_parser(state: TSVectorParseState);
    pub fn parse_tsquery(
        buf: *mut ::core::ffi::c_char,
        pushval: PushFunction,
        opaque: Datum,
        flags: ::core::ffi::c_int,
        escontext: *mut Node,
    ) -> TSQuery;
    pub fn pushValue(
        state: TSQueryParserState,
        strval: *mut ::core::ffi::c_char,
        lenval: ::core::ffi::c_int,
        weight: int16,
        prefix: bool,
    );
    pub fn pushStop(state: TSQueryParserState);
    pub fn pushOperator(state: TSQueryParserState, oper: int8, distance: int16);
    pub fn parsetext(
        cfgId: Oid,
        prs: *mut ParsedText,
        buf: *mut ::core::ffi::c_char,
        buflen: int32,
    );
    pub fn hlparsetext(
        cfgId: Oid,
        prs: *mut HeadlineParsedText,
        query: TSQuery,
        buf: *mut ::core::ffi::c_char,
        buflen: int32,
    );
    pub fn generateHeadline(prs: *mut HeadlineParsedText) -> *mut text;
    pub fn TS_execute(
        curitem: *mut QueryItem,
        arg: *mut ::core::ffi::c_void,
        flags: uint32,
        chkcond: TSExecuteCallback,
    ) -> bool;
    pub fn TS_execute_ternary(
        curitem: *mut QueryItem,
        arg: *mut ::core::ffi::c_void,
        flags: uint32,
        chkcond: TSExecuteCallback,
    ) -> TSTernaryValue::Type;
    pub fn TS_execute_locations(
        curitem: *mut QueryItem,
        arg: *mut ::core::ffi::c_void,
        flags: uint32,
        chkcond: TSExecuteCallback,
    ) -> *mut List;
    pub fn tsquery_requires_match(curitem: *mut QueryItem) -> bool;
    pub fn make_tsvector(prs: *mut ParsedText) -> TSVector;
    pub fn tsCompareString(
        a: *mut ::core::ffi::c_char,
        lena: ::core::ffi::c_int,
        b: *mut ::core::ffi::c_char,
        lenb: ::core::ffi::c_int,
        prefix: bool,
    ) -> int32;
    pub fn clean_NOT(ptr: *mut QueryItem, len: *mut int32) -> *mut QueryItem;
    pub fn cleanup_tsquery_stopwords(in_: TSQuery, noisy: bool) -> TSQuery;
    pub fn QT2QTN(in_: *mut QueryItem, operand: *mut ::core::ffi::c_char) -> *mut QTNode;
    pub fn QTN2QT(in_: *mut QTNode) -> TSQuery;
    pub fn QTNFree(in_: *mut QTNode);
    pub fn QTNSort(in_: *mut QTNode);
    pub fn QTNTernary(in_: *mut QTNode);
    pub fn QTNBinary(in_: *mut QTNode);
    pub fn QTNodeCompare(an: *mut QTNode, bn: *mut QTNode) -> ::core::ffi::c_int;
    pub fn QTNCopy(in_: *mut QTNode) -> *mut QTNode;
    pub fn QTNClearFlags(in_: *mut QTNode, flags: uint32);
    pub fn QTNEq(a: *mut QTNode, b: *mut QTNode) -> bool;
    pub fn makeTSQuerySign(a: TSQuery) -> TSQuerySign;
    pub fn findsubquery(
        root: *mut QTNode,
        ex: *mut QTNode,
        subs: *mut QTNode,
        isfind: *mut bool,
    ) -> *mut QTNode;
    pub fn heap_tableam_handler(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteaout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namein(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2vectorin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2vectorout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xidin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xidout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boollt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolgt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn booleq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn chareq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texteq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xideq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cideq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn chargt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn chartoi4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i4tochar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameregexeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ddl_command_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ddl_command_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ddl_command_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pgsql_version(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ddl_command_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn eqsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn neqsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn scalarltsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn scalargtsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn eqjoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn neqjoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn scalarltjoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn scalargtjoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unknownin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unknownout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_above_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_below_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_overlap(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_above(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_left(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_right(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_below(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn on_pb(fcinfo: FunctionCallInfo) -> Datum;
    pub fn on_ppath(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_center(fcinfo: FunctionCallInfo) -> Datum;
    pub fn areasel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn areajoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2mod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4mod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oideq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_same(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_contain(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_left(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_overleft(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_overright(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_right(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_contained(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_contain_pt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_node_tree_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_node_tree_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_node_tree_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_node_tree_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_center(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_center(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dround(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtrunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dsqrt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dcbrt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dpow(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dexp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dlog1(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i2tod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i2tof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtoi2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ftoi2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn line_distance(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameeqtext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namelttext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameletext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namegetext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namegttext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namenetext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btnametextcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texteqname(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textltname(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textlename(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textgename(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textgtname(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textnename(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bttextnamecmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameconcatoid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn table_am_handler_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn table_am_handler_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timeofday(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_nextoid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_combine(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inter_sl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inter_lb(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ftod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i2toi4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i4toi2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_jit_available(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i4tod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtoi4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i4tof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ftoi4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn width_bucket_float8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn index_am_handler_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn index_am_handler_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashmacaddr8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hash_aclitem(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bthandler(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashhandler(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gisthandler(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginhandler(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spghandler(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brinhandler(fcinfo: FunctionCallInfo) -> Datum;
    pub fn scalarlesel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn scalargesel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn amvalidate(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_same(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_contain(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_left(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_overleft(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_overright(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_right(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_contained(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_overlap(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint2cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint4cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat4cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat8cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btoidcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_bp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btcharcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btnamecmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bttextcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_distance(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_interpt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_ps(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_pb(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_sb(fcinfo: FunctionCallInfo) -> Datum;
    pub fn close_ps(fcinfo: FunctionCallInfo) -> Datum;
    pub fn close_pb(fcinfo: FunctionCallInfo) -> Datum;
    pub fn close_sb(fcinfo: FunctionCallInfo) -> Datum;
    pub fn on_ps(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_distance(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_ppath(fcinfo: FunctionCallInfo) -> Datum;
    pub fn on_sb(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inter_sb(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_to_array_null(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_append(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_prepend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_sp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_bs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btarraycmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_cat(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_to_text_null(fcinfo: FunctionCallInfo) -> Datum;
    pub fn scalarlejoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_to_array(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_to_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn scalargejoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashmacaddr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashtext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn rtrim1(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btoidvectorcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn name_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn name_bpchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_pathp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashinet(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashint4extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hash_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_num_nulls(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_num_nonnulls(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashint2extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashint8extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashfloat4extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashfloat8extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashoidextended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashcharextended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashnameextended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashtextextended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashint2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashint4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashfloat4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashfloat8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashoid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashname(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashvarlena(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashoidvector(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int84eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int84ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int84lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int84gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int84le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int84ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int84(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int48(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i8tod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtoi8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_abbrev(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_abbrev(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_set_masklen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hash_array(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_set_masklen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_indexam_has_property(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_index_has_property(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_index_column_has_property(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i8tof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ftoi8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namelt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namele(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namegt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namege(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namene(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_indexam_progress_phasename(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectoreq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorgt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_network(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_netmask(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_masklen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_broadcast(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_host(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_lp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_ls(fcinfo: FunctionCallInfo) -> Datum;
    pub fn current_user(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_family(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int82(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_create(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteaoctetlen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteaGetByte(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteaSetByte(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteaGetBit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteaSetBit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_sl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_cpoly(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_distance(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_show(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn session_user(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_dims(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_ndims(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteaoverlay(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteaoverlay_no_len(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int28(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_import(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_export(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4inc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_import_with_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashvarlenaextended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashoidvectorextended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hash_aclitem_extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashmacaddrextended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashinetextended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hash_numeric_extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashmacaddr8extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hash_array_extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_polyc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_client_encoding(fcinfo: FunctionCallInfo) -> Datum;
    pub fn current_query(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int82pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int82mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int82mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int82div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int28pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint8cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_mul_flt4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_div_flt4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn flt4_mul_cash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textpos(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textnlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int48eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int48ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int48lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int48gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int48le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int48ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namelike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namenlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn char_bpchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn current_database(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_mul_cash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_mul_cash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_mul_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_div_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_mul_int2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_div_int2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lower(fcinfo: FunctionCallInfo) -> Datum;
    pub fn upper(fcinfo: FunctionCallInfo) -> Datum;
    pub fn initcap(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lpad(fcinfo: FunctionCallInfo) -> Datum;
    pub fn rpad(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ltrim(fcinfo: FunctionCallInfo) -> Datum;
    pub fn rtrim(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_substr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn translate(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ltrim1(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_substr_no_len(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btrim(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btrim1(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_mul_flt8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_div_flt8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cashlarger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cashsmaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn flt8_mul_cash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_sub(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_subeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_sup(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_supeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_words(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int28mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int28mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_char(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8mod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn char_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int28div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashint8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_open(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_close(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_loread(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lowrite(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_lseek(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_creat(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_tell(fcinfo: FunctionCallInfo) -> Datum;
    pub fn on_pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn on_sl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn close_pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_unlink(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashbpcharextended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_inter(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_area(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_width(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_height(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_distance(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_area(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_intersect(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_diagonal(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_n_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_n_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_n_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_n_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_n_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_length(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_vert(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_horiz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_distance(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_slope(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_construct(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_intersect(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_parallel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_perp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_vertical(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_horizontal(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_truncate(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textlike_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texticregexeq_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texticlike_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_izone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_point_compress(fcinfo: FunctionCallInfo) -> Datum;
    pub fn aclitemin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn aclitemout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn aclinsert(fcinfo: FunctionCallInfo) -> Datum;
    pub fn aclremove(fcinfo: FunctionCallInfo) -> Datum;
    pub fn aclcontains(fcinfo: FunctionCallInfo) -> Datum;
    pub fn getdatabaseencoding(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varcharin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varcharout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchareq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchargt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn aclitem_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_prepared_xact(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_step_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_step_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_regclass(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashbpchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn format_type(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_wal(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_wal_replay_pause_state(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_pli(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_mii(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_add_pt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_sub_pt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_mul_pt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_div_pt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_zone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_part(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_part(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_subset_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_justify_hours(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_path_exists_tz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_path_query_tz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_path_query_array_tz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid_age(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_pl_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_mi_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_subscripts(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_subscripts_nodir(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_fill(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dlog10(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_age(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_scale(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8inc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texticregexeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texticregexne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameicregexeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameicregexne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteain(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unique_key_recheck(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameregexne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textlen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textcat(fcinfo: FunctionCallInfo) -> Datum;
    pub fn PG_char_to_encoding(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn parse_ident(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_column_size(fcinfo: FunctionCallInfo) -> Datum;
    pub fn overlaps_timetz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn datetime_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_part(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int84pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int84mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int84mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int84div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int48pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int48mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int48mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int48div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn quote_ident(fcinfo: FunctionCallInfo) -> Datum;
    pub fn quote_literal(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_trunc_zone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_fill_with_lower_bounds(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i8tooid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidtoi8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn quote_nullable(fcinfo: FunctionCallInfo) -> Datum;
    pub fn suppress_redundant_updates_trigger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tideq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_unnest(fcinfo: FunctionCallInfo) -> Datum;
    pub fn currtid_byrelname(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_justify_days(fcinfo: FunctionCallInfo) -> Datum;
    pub fn datetimetz_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn now(fcinfo: FunctionCallInfo) -> Datum;
    pub fn positionsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn positionjoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn contsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn contjoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn overlaps_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn overlaps_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharlen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectortypes(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_hostmask(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexeq_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn makeaclitem(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lock_status(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_finite(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textoctetlen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharoctetlen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_fac(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_part(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_constraintdef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_timetz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_finite(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_finite(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_backend_start(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_backend_client_addr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_backend_client_port(fcinfo: FunctionCallInfo) -> Datum;
    pub fn current_schema(fcinfo: FunctionCallInfo) -> Datum;
    pub fn current_schemas(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textoverlay(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textoverlay_no_len(fcinfo: FunctionCallInfo) -> Datum;
    pub fn line_parallel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn line_perp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn line_vertical(fcinfo: FunctionCallInfo) -> Datum;
    pub fn line_horizontal(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_center(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn points_box(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_add(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_sub(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_contain_pt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pt_contained_poly(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_isclosed(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_isopen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_npoints(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_close(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_open(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_add(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_add_pt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_sub_pt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_mul_pt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_div_pt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn construct_point(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_add(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_sub(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_npoints(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_box(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_path(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_poly(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_poly(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_same(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_contain(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_left(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_overleft(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_overright(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_right(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_contained(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_overlap(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_below(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_above(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_area(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_diameter(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_radius(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_distance(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cr_circle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_circle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_poly(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_pc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_contain_pt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pt_contained_circle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_circle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_box(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_length(fcinfo: FunctionCallInfo) -> Datum;
    pub fn close_ls(fcinfo: FunctionCallInfo) -> Datum;
    pub fn close_lseg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn line_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn line_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn line_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn line_construct_pp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn line_interpt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn line_intersect(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bit_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bit_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_ruledef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nextval_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn currval_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn setval_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varbit_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varbit_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn biteq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitgt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn PG_encoding_to_char(fcinfo: FunctionCallInfo) -> Datum;
    pub fn drandom(fcinfo: FunctionCallInfo) -> Datum;
    pub fn setseed(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dasin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dacos(fcinfo: FunctionCallInfo) -> Datum;
    pub fn datan(fcinfo: FunctionCallInfo) -> Datum;
    pub fn datan2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dsin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dcos(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtan(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dcot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn degrees(fcinfo: FunctionCallInfo) -> Datum;
    pub fn radians(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dpi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_typeof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ascii(fcinfo: FunctionCallInfo) -> Datum;
    pub fn chr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn repeat(fcinfo: FunctionCallInfo) -> Datum;
    pub fn similar_escape(fcinfo: FunctionCallInfo) -> Datum;
    pub fn mul_d_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texticlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texticnlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameiclike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameicnlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn like_escape(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidgt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_viewdef_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_viewdef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_userbyid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_indexdef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_check_ins(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_check_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_cascade_del(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_cascade_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_restrict_del(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_restrict_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_setnull_del(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_setnull_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_setdefault_del(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_setdefault_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_noaction_del(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_noaction_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_triggerdef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_serial_sequence(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bit_and(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bit_or(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitxor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitnot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitshiftleft(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitshiftright(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitcat(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitsubstr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitlength(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitoctetlength(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitfromint4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bittoint4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_keywords(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varbit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_hash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn aclexplode(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_mi_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btboolcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_hash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_hash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitposition(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitsubstr_no_len(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_sign(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_round(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_ceil(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_floor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn length_in_encoding(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_convert_from(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_to_cidr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_expr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_convert_to(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_add(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_sub(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_mod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_sqrt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_exp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_ln(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_log(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_power(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_float4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_float8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_pl_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_mi_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_pl_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_mi_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_inc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn setval3_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_to_char(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_to_char(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_uminus(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_to_char(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_to_char(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_to_char(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4_to_char(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_to_char(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_to_number(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_int2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_convert(fcinfo: FunctionCallInfo) -> Datum;
    pub fn iclikesel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn icnlikesel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn iclikejoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn icnlikejoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexeqsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn likesel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn icregexeqsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexnesel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nlikesel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn icregexnesel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexeqjoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn likejoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn icregexeqjoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexnejoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nlikejoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn icregexnejoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_avg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_var_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_stddev_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_avg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_var_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_stddev_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_avg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_ascii_default(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_ascii_enc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_ascii_encname(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int28eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int28ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int28lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int28gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int28le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int28ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int82eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int82ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int82lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int82gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int82le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int82ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2and(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2or(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2xor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2not(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2shl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2shr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4and(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4or(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4xor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4not(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4shl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4shr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8and(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8or(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8xor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8not(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8shl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8shr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8up(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2up(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4up(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4up(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8up(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_uplus(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_numscans(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_tuples_returned(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_tuples_fetched(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_tuples_inserted(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_tuples_updated(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_tuples_deleted(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_blocks_fetched(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_blocks_hit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_backend_idset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_backend_pid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_backend_dbid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_backend_userid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_backend_activity(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_numbackends(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_xact_commit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_xact_rollback(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_blocks_fetched(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_blocks_hit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_encode(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_decode(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteaeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytealt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteale(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteagt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteage(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteane(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteacmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_scale(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_avg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidlarger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidsmaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_scale(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_scale(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_scale(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_tuples_hot_updated(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_div_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn similar_to_escape_2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn similar_to_escape_1(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytealike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteanlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn like_escape_bytea(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteacat(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytea_substr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytea_substr_no_len(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteapos(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteatrim(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_part(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_activity(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_path_query_first_tz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_backend_pid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_path_match_tz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_pl_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_mi_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_conf_load_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_zone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_izone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_hash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_timetz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_to_char(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_age(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_zone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_izone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_pl_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_mi_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexsubstr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitfromint8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bittoint8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn show_config_by_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn set_config_by_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_table_is_visible(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_type_is_visible(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_function_is_visible(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_operator_is_visible(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_opclass_is_visible(fcinfo: FunctionCallInfo) -> Datum;
    pub fn show_all_settings(fcinfo: FunctionCallInfo) -> Datum;
    pub fn replace_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn split_part(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_hex32(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_hex64(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_lower(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_upper(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_conversion_is_visible(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_backend_activity_start(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_terminate_backend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_functiondef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_column_compression(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_force_next_flush(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_pattern_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_pattern_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_function_arguments(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_pattern_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_pattern_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_function_result(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bttext_pattern_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_database_size_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn width_bucket_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_cancel_backend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_backup_start(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_pattern_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_pattern_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_length(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_pattern_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_pattern_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_point_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btbpchar_pattern_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint48cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint84cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint24cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint42cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint28cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint82cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat48cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat84cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_client_addr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_client_port(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_server_addr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_server_port(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocedurein(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocedureout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperatorin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperatorout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regclassin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regclassout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regtypein(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regtypeout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_clear_snapshot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_function_identity_arguments(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashtid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashtidextended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn fmgr_internal_validator(fcinfo: FunctionCallInfo) -> Datum;
    pub fn fmgr_c_validator(fcinfo: FunctionCallInfo) -> Datum;
    pub fn fmgr_sql_validator(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_function_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_function_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_function_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_function_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_function_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_function_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_reset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_backend_memory_contexts(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexreplace_noopt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexreplace(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_total_relation_size(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_size_pretty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_options_to_table(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cstring_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cstring_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn any_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn any_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyarray_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyarray_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn void_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn void_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn trigger_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn trigger_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn language_handler_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn language_handler_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn internal_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn internal_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_slru(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_reset_slru(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dceil(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dfloor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dsign(fcinfo: FunctionCallInfo) -> Datum;
    pub fn md5_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyelement_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyelement_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn postgresql_fdw_validator(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_encoding_max_length_sql(fcinfo: FunctionCallInfo) -> Datum;
    pub fn md5_bytea(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_tablespace_size_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_tablespace_size_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_database_size_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_unnest(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_relation_size(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_lt_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_le_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_eq_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_gt_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_ge_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_ne_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_cmp_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_lt_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_le_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_eq_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_gt_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_ge_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_ne_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_cmp_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_lt_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_le_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_eq_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_gt_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_ge_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_ne_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_cmp_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_lt_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_le_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_eq_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_gt_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_ge_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_ne_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_cmp_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_tablespace_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_tablespace_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_tablespace_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_tablespace_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_tablespace_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_tablespace_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn shell_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn shell_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2vectorrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2vectorsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytearecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteasend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unknownrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unknownsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namerecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namesend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varcharrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varcharsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xidrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xidsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocedurerecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regproceduresend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regopersend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperatorrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperatorsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regclassrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regclasssend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regtyperecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regtypesend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bit_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bit_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varbit_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varbit_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dsinh(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dcosh(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtanh(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dasinh(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dacosh(fcinfo: FunctionCallInfo) -> Datum;
    pub fn datanh(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn line_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn line_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cstring_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cstring_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyarray_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyarray_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_ruledef_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_viewdef_name_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_viewdef_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_indexdef_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_constraintdef_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_expr_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_prepared_statement(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_cursor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_var_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_stddev_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_var_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn booland_statefunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolor_statefunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_lt_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_le_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_eq_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_gt_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_ge_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_ne_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_cmp_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_lt_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_le_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_eq_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_gt_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_ge_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_ne_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_cmp_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_tablespace_databases(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_bool(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bool_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lastval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_postmaster_start_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_blocking_pids(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_below(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_overbelow(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_overabove(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_above(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_below(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_overbelow(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_overabove(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_above(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_box_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_float8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_box_penalty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_box_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_box_union(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_box_same(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_poly_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_poly_compress(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_overbelow(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_overabove(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_circle_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_circle_compress(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_stddev_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn domain_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn domain_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_timezone_abbrevs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xmlexists(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_reload_conf(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_rotate_logfile(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_file_1arg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_file_off_len(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ls_dir_1arg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_sleep(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetnot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetand(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetpl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetmi_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetmi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn statement_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn clock_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_cmp_prefix(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_justify_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_triggerdef_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dasind(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dacosd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn datand(fcinfo: FunctionCallInfo) -> Datum;
    pub fn datan2d(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dsind(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dcosd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtand(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dcotd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_backup_stop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_avg_serialize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_avg_deserialize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginarrayextract(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginarrayconsistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn arrayoverlap(fcinfo: FunctionCallInfo) -> Datum;
    pub fn arraycontains(fcinfo: FunctionCallInfo) -> Datum;
    pub fn arraycontained(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_tuples_returned(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_tuples_fetched(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_tuples_inserted(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_tuples_updated(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_tuples_deleted(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_matches_no_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_matches(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_split_to_table_no_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_split_to_table(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_split_to_array_no_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_split_to_array(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_checkpointer_num_timed(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_checkpointer_num_requested(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_checkpointer_buffers_written(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_bgwriter_buf_written_clean(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_bgwriter_maxwritten_clean(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginqueryarrayextract(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anynonarray_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anynonarray_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_last_vacuum_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_last_autovacuum_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_last_analyze_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_last_autoanalyze_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_avg_combine(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_avg_serialize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_avg_deserialize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_backend_wait_event_type(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidgt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bttidcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidlarger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidsmaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8inc_any(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8inc_float8_float8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_sxx(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_syy(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_sxy(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_avgx(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_avgy(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_r2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_slope(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_intercept(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_covar_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_covar_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_corr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_blk_read_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_blk_write_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_switch_wal(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_current_wal_lsn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_walfile_name_offset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_walfile_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_current_wal_insert_lsn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_backend_wait_event(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_my_temp_schema(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_is_other_temp_schema(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_timezone_names(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_backend_xact_start(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_buf_alloc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_live_tuples(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_dead_tuples(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_lock_shared_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_lock_shared_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_unlock_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_unlock_shared_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_lock_shared_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_lock_shared_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_unlock_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_unlock_shared_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_unlock_all(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xml_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xml_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xmlcomment(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texttoxml(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xmlvalidate(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xml_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xml_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xmlconcat2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varbittypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn intervaltypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn intervaltypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptztypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptztypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetztypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetztypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchartypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchartypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varchartypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varchartypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numerictypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numerictypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bittypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bittypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varbittypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xmltotext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn table_to_xml(fcinfo: FunctionCallInfo) -> Datum;
    pub fn query_to_xml(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cursor_to_xml(fcinfo: FunctionCallInfo) -> Datum;
    pub fn table_to_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
    pub fn query_to_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cursor_to_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
    pub fn table_to_xml_and_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
    pub fn query_to_xml_and_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xpath(fcinfo: FunctionCallInfo) -> Datum;
    pub fn schema_to_xml(fcinfo: FunctionCallInfo) -> Datum;
    pub fn schema_to_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
    pub fn schema_to_xml_and_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
    pub fn database_to_xml(fcinfo: FunctionCallInfo) -> Datum;
    pub fn database_to_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
    pub fn database_to_xml_and_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_snapshot_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_snapshot_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_snapshot_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_snapshot_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_current_xact_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_current_snapshot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_snapshot_xmin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_snapshot_xmax(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_snapshot_xip(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_visible_in_snapshot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_hash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn booltext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_function_calls(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_function_total_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_function_self_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btrecordcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_table_size(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_indexes_size(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_relation_filenode(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_foreign_data_wrapper_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_foreign_data_wrapper_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_foreign_data_wrapper_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_foreign_data_wrapper_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_foreign_data_wrapper_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_foreign_data_wrapper_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_name_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_name_name_attnum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_name_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_name_id_attnum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_id_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_id_name_attnum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_id_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_id_id_attnum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_name_attnum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_id_attnum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_any_column_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_any_column_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_any_column_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_any_column_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_any_column_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_any_column_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitoverlay(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitoverlay_no_len(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitgetbit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitsetbit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_relation_filepath(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_listening_channels(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_notify(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_xact_numscans(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_xact_tuples_returned(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_xact_tuples_fetched(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_xact_tuples_inserted(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_xact_tuples_updated(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_xact_tuples_deleted(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_xact_tuples_hot_updated(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_xact_blocks_fetched(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_xact_blocks_hit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_xact_function_calls(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_xact_function_total_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_xact_function_self_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xpath_exists(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xml_is_well_formed(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xml_is_well_formed_document(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xml_is_well_formed_content(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_vacuum_count(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_autovacuum_count(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_analyze_count(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_autoanalyze_count(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_concat(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_concat_ws(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_left(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_right(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_reverse(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_point_distance(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_conflict_tablespace(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_conflict_lock(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_conflict_snapshot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_conflict_bufferpin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_conflict_startup_deadlock(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_conflict_all(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_wal_replay_pause(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_wal_replay_resume(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_is_wal_replay_paused(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_stat_reset_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_bgwriter_stat_reset_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginarrayextract_2args(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_extract_tsvector_2args(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_sequence_parameters(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_available_extensions(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_available_extension_versions(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_extension_update_paths(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_extension_config_dump(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_extract_tsquery_5args(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_tsquery_consistent_6args(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_xact_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_xact_lock_shared_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_xact_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_xact_lock_shared_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_xact_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_xact_lock_shared_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_xact_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_xact_lock_shared_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varchar_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_create_restore_point(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_wal_senders(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_row_number(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_rank(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_dense_rank(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_percent_rank(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_cume_dist(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_ntile(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lag(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lag_with_offset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lag_with_offset_and_default(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lead(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lead_with_offset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lead_with_offset_and_default(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_first_value(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_last_value(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_nth_value(fcinfo: FunctionCallInfo) -> Datum;
    pub fn fdw_handler_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn fdw_handler_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn void_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn void_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint2sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint4sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint8sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat4sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat8sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btoidsortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btnamesortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_not(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_and(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_or(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_temp_files(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_temp_bytes(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_deadlocks(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_to_json(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_to_json_pretty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn row_to_json(fcinfo: FunctionCallInfo) -> Datum;
    pub fn row_to_json_pretty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varbit_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_viewdef_wrap(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_checkpointer_write_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_checkpointer_sync_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_collation_for(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_trigger_depth(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_wal_lsn_diff(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_size_pretty_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_remove(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_replace(fcinfo: FunctionCallInfo) -> Datum;
    pub fn rangesel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_lseek64(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_tell64(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_truncate64(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_json(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_mod_since_analyze(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_cardinality(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_image_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_image_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_image_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_image_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_image_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_image_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btrecordimagecmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_archiver(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_build_array(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_build_array_noargs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_build_object(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_build_object_noargs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_two_arg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_to_record(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_to_recordset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_array_length(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_each(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_populate_record(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_typeof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_object_field_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_array_element(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_array_element_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_extract_path(fcinfo: FunctionCallInfo) -> Datum;
    pub fn width_bucket_array(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_array_elements(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_hash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bttextsortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_step_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_strip_nulls(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_strip_nulls(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_object(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_object_two_arg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_object_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_object_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_build_array(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_build_array_noargs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_build_object(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_build_object_noargs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_ppoly(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_position(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_position_start(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_positions(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_circle_distance(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_scale(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_point_fetch(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_poly_distance(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_cpoint(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_polyp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_file_off_len_missing(fcinfo: FunctionCallInfo) -> Datum;
    pub fn show_config_by_name_missing_ok(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_binary_file_off_len_missing(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_notification_queue_usage(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ls_dir(fcinfo: FunctionCallInfo) -> Datum;
    pub fn row_security_active(fcinfo: FunctionCallInfo) -> Datum;
    pub fn row_security_active_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_concat(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_delete(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_delete_idx(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_delete_path(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_set(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_pretty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_file(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xidneq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsm_handler_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsm_handler_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsm_bernoulli_handler(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsm_system_handler(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_wal_receiver(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_progress_info(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_filter(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_setweight_by_filter(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_delete_str(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_unnest(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_delete_arr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_avg_combine(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_avg_combine(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_to_array(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_to_tsvector(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn show_all_file_settings(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_current_wal_flush_lsn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytea_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bttext_pattern_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btbpchar_pattern_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_size_bytes(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_serialize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_deserialize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_avg_combine(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_poly_combine(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_poly_serialize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_poly_deserialize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_combine(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_combine(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_delete_array(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_mul_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_div_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_current_xact_id_if_assigned(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_partkeydef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ls_logdir(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ls_waldir(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ndistinct_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ndistinct_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ndistinct_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ndistinct_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_xact_status(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_safe_snapshot_blocking_pids(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_isolation_test_session_is_blocked(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_identify_object_as_address(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_opcinfo(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_add_value(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_union(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_avg_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_poly_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_poly_avg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_poly_var_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_poly_var_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_poly_stddev_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_poly_stddev_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_match_no_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_match(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_mul_cash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_config(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_hba_file_rules(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_statistics_obj_is_visible(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_dependencies_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_dependencies_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_dependencies_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_dependencies_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_partition_constraintdef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_hash_extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_hash_extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_hash_extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_hash_extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_hash_extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashenumextended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_statisticsobjdef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_hash_extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hash_range_extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_hash_extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn sha224_bytea(fcinfo: FunctionCallInfo) -> Datum;
    pub fn sha256_bytea(fcinfo: FunctionCallInfo) -> Datum;
    pub fn sha384_bytea(fcinfo: FunctionCallInfo) -> Datum;
    pub fn sha512_bytea(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_partition_tree(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_partition_root(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_partition_ancestors(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_checksum_failures(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stats_ext_mcvlist_items(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_checksum_last_failure(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gen_random_uuid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsvector_options(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_point_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_promote(fcinfo: FunctionCallInfo) -> Datum;
    pub fn prefixsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn prefixjoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_control_system(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_control_checkpoint(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_control_recovery(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_control_init(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_import_system_collations(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_collation_actual_version(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_int2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_float4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_filenode_relation(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_from_bytea(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_get(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_get_fragment(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_put(fcinfo: FunctionCallInfo) -> Datum;
    pub fn make_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn make_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn make_timestamptz_at_timezone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn make_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_array_elements_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_range_quad_config(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_range_quad_choose(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_range_quad_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_range_quad_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_range_quad_leaf_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_populate_recordset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regoperator(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_object_field(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regprocedure(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_compare_jsonb(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_extract_jsonb(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_extract_jsonb_query(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_consistent_jsonb(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_extract_jsonb_path(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_extract_jsonb_query_path(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_consistent_jsonb_path(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_triconsistent_jsonb(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_triconsistent_jsonb_path(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_to_record(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_to_recordset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regoper(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regtype(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regproc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regclass(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bool_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bool_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bool_alltrue(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bool_anytrue(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyenum_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyenum_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashenum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_first(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_last(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_range_bounds(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_range_all(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn string_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn string_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_describe_object(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_format(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_format_nv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytea_string_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytea_string_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8dec(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8dec_any(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_avg_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_overlap(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_gist_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_gist_union(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_gist_compress(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_bool(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_gist_penalty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_gist_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_gist_same(fcinfo: FunctionCallInfo) -> Datum;
    pub fn networksel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn networkjoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_event_trigger_dropped_objects(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_avg_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_avg_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2int4_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_gist_fetch(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_logical_emit_message_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_logical_emit_message_bytea(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_insert(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_xact_commit_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_set_next_pg_type_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_last_committed_xact(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_set_next_array_pg_type_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_set_next_heap_pg_class_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_set_next_index_pg_class_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_set_next_toast_pg_class_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_set_next_pg_enum_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_set_next_pg_authid_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_create_empty_extension(fcinfo: FunctionCallInfo) -> Datum;
    pub fn event_trigger_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn event_trigger_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvectorin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvectorout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsqueryin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsqueryout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_strip(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_setweight(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_concat(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_match_vq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_match_qv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvectorsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvectorrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquerysend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsqueryrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsvectorin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsvectorout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsvector_compress(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsvector_decompress(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsvector_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsvector_union(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsvector_same(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsvector_penalty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsvector_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_extract_tsvector(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_extract_tsquery(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_tsquery_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquery_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquery_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquery_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquery_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquery_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquery_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquery_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquery_and(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquery_or(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquery_not(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquery_numnode(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquerytree(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquery_rewrite(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquery_rewrite_query(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsmatchsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsmatchjoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_typanalyze(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_stat1(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_stat2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsq_mcontains(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsq_mcontained(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsquery_compress(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_starts_with(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsquery_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsquery_union(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsquery_same(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsquery_penalty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsquery_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_rank_wttf(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_rank_wtt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_rank_ttf(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_rank_tt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_rankcd_wttf(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_rankcd_wtt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_rankcd_ttf(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_rankcd_tt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_length(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_token_type_byid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_token_type_byname(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_parse_byid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_parse_byname(fcinfo: FunctionCallInfo) -> Datum;
    pub fn prsd_start(fcinfo: FunctionCallInfo) -> Datum;
    pub fn prsd_nexttoken(fcinfo: FunctionCallInfo) -> Datum;
    pub fn prsd_end(fcinfo: FunctionCallInfo) -> Datum;
    pub fn prsd_headline(fcinfo: FunctionCallInfo) -> Datum;
    pub fn prsd_lextype(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_lexize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_cmp_tslexeme(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dsimple_init(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dsimple_lexize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dsynonym_init(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dsynonym_lexize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dispell_init(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dispell_lexize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regconfigin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regconfigout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regconfigrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regconfigsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn thesaurus_init(fcinfo: FunctionCallInfo) -> Datum;
    pub fn thesaurus_lexize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_headline_byid_opt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_headline_byid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_tsvector_byid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_tsquery_byid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn plainto_tsquery_byid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_tsvector(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_tsquery(fcinfo: FunctionCallInfo) -> Datum;
    pub fn plainto_tsquery(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_update_trigger_byid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_update_trigger_bycolumn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_headline_opt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_headline(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ts_parser_is_visible(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ts_dict_is_visible(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ts_config_is_visible(fcinfo: FunctionCallInfo) -> Datum;
    pub fn get_current_ts_config(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_match_tt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_match_tq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ts_template_is_visible(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regdictionaryin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regdictionaryout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regdictionaryrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regdictionarysend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_reset_shared(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_reset_single_table_counters(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_reset_single_function_counters(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_tablespace_location(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_create_physical_replication_slot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_drop_replication_slot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_replication_slots(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_logical_slot_get_changes(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_logical_slot_get_binary_changes(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_logical_slot_peek_changes(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_logical_slot_peek_binary_changes(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_create_logical_replication_slot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_jsonb(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_snapshot_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_clean_pending_list(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsvector_consistent_oldsig(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_extract_tsquery_oldsig(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_tsquery_consistent_oldsig(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsquery_consistent_oldsig(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_spg_config(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_spg_choose(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_spg_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_spg_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_spg_leaf_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_current_logfile(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_current_logfile_1arg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_function_arg_default(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_export_snapshot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_is_in_recovery(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_cash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_cash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xmltext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_collation_is_visible(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_typanalyze(fcinfo: FunctionCallInfo) -> Datum;
    pub fn arraycontsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn arraycontjoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_multixact_members(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_last_wal_receive_lsn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_last_wal_replay_lsn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_div_cash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_cash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_file_all(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_binary_file_off_len(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_binary_file_all(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_opfamily_is_visible(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_last_xact_replay_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyrange_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyrange_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_identify_object(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_constructor2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_constructor3(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_relation_is_updatable(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_column_is_updatable(fcinfo: FunctionCallInfo) -> Datum;
    pub fn make_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn make_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_lower(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_upper(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_empty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_lower_inc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_upper_inc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_lower_inf(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_upper_inf(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_overlaps(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_contains_elem(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_contains(fcinfo: FunctionCallInfo) -> Datum;
    pub fn elem_contained_by_range(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_contained_by(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_adjacent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_before(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_after(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_overleft(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_overright(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_union(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_intersect(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_minus(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_gist_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_gist_union(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_replication_slot_advance(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_gist_penalty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_gist_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_gist_same(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hash_range(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4range_canonical(fcinfo: FunctionCallInfo) -> Datum;
    pub fn daterange_canonical(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_typanalyze(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginarraytriconsistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_tsquery_triconsistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4range_subdiff(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8range_subdiff(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numrange_subdiff(fcinfo: FunctionCallInfo) -> Datum;
    pub fn daterange_subdiff(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8range_canonical(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsrange_subdiff(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tstzrange_subdiff(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_object_keys(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_each_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn mxid_age(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_extract_path_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn acldefault_sql(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_field(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_field_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_array_element(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_array_element_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_extract_path(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_summarize_new_values(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_extract_path_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_object_address(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_array_elements(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_array_length(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_keys(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_each(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_each_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_populate_record(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_populate_recordset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_typeof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_array_elements_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ordered_set_transition(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ordered_set_transition_multi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn percentile_disc_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn percentile_cont_float8_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn percentile_cont_interval_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn percentile_disc_multi_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn percentile_cont_float8_multi_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn percentile_cont_interval_multi_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn mode_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hypothetical_rank_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hypothetical_percent_rank_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hypothetical_cume_dist_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hypothetical_dense_rank_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_int4_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_int8_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_unnest_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_box_distance(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_summarize_range(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonpath_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonpath_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonpath_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonpath_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_path_exists(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_path_query(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_path_query_array(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_path_query_first(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_path_match(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_path_exists_opr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_path_match_opr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_desummarize_range(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_quad_config(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_quad_choose(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_quad_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_quad_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_quad_leaf_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_kd_config(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_kd_choose(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_kd_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_kd_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_text_config(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_text_choose(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_text_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_text_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_text_leaf_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_sequence_last_value(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_hash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_contains(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_exists(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_exists_any(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_exists_all(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_contained(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_agg_array_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_agg_array_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_merge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_merge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boxes_bound_box(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_same_family(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_set_record_init_privs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regnamespacein(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regnamespaceout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regnamespace(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regnamespacerecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regnamespacesend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_box(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regroleout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regrole(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regrolerecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regrolesend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regrolein(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_set_missing_value(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_inclusion_opcinfo(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_inclusion_add_value(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_inclusion_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_inclusion_union(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_not(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_and(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_or(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddrtomacaddr8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8tomacaddr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_set7bit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_int8_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_int4_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_int4_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_int4_int2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_int2_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_int2_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_int2_int2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_date_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_timestamp_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_timestamptz_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_interval_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_time_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_timetz_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_float8_float8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_float4_float8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_numeric_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regcollationin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regcollationout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regcollation(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regcollationrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regcollationsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_headline_jsonb_byid_opt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_headline_jsonb_byid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_headline_jsonb_opt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_headline_jsonb(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_headline_json_byid_opt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_headline_json_byid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_headline_json_opt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_headline_json(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_string_to_tsvector(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_string_to_tsvector(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_string_to_tsvector_byid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_string_to_tsvector_byid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_to_tsvector(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_to_tsvector_byid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_to_tsvector(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_to_tsvector_byid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_copy_physical_replication_slot_a(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_copy_physical_replication_slot_b(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_copy_logical_replication_slot_a(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_copy_logical_replication_slot_b(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_copy_logical_replication_slot_c(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anycompatiblemultirange_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anycompatiblemultirange_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_merge_from_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anymultirange_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anymultirange_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_lower(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_upper(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_empty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_lower_inc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_upper_inc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_lower_inf(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_upper_inf(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_typanalyze(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirangesel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_overlaps_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_overlaps_range(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_overlaps_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_contains_elem(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_contains_range(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_contains_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn elem_contained_by_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_contained_by_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_contained_by_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_adjacent_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_adjacent_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_adjacent_range(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_before_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_before_range(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_before_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_after_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_after_range(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_after_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_overleft_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_overleft_range(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_overleft_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_overright_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_overright_range(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_overright_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_union(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_minus(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_intersect(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hash_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hash_multirange_extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_constructor0(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_constructor1(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_constructor2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unicode_normalize_func(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unicode_is_normalized(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_intersect_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_set_next_multirange_pg_type_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_set_next_multirange_array_pg_type_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_intersect_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_contains_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_contained_by_range(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_log_backend_memory_contexts(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_set_next_heap_relfilenode(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_set_next_index_relfilenode(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_set_next_toast_relfilenode(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_set_next_pg_tablespace_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unicode_version(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_event_trigger_table_rewrite_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_event_trigger_table_rewrite_reason(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_event_trigger_ddl_commands(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_bloom_opcinfo(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_bloom_add_value(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_bloom_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_bloom_union(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_bloom_options(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_bloom_summary_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_bloom_summary_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_bloom_summary_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_bloom_summary_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_opcinfo(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_add_value(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_union(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_options(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_int2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_float4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_float8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_tid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_uuid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_timetz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_pg_lsn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_macaddr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_macaddr8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_inet(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_summary_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_summary_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_summary_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_summary_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn phraseto_tsquery(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquery_phrase(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquery_phrase_distance(fcinfo: FunctionCallInfo) -> Datum;
    pub fn phraseto_tsquery_byid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn websearch_to_tsquery_byid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn websearch_to_tsquery(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_bbox_quad_config(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_poly_quad_compress(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_box_quad_config(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_box_quad_choose(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_box_quad_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_box_quad_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_box_quad_leaf_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_mcv_list_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_mcv_list_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_mcv_list_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_mcv_list_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_pli(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_mii(fcinfo: FunctionCallInfo) -> Datum;
    pub fn satisfies_hash_partition(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ls_tmpdir_noargs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ls_tmpdir_1arg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ls_archive_statusdir(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid8lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid8gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid8le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid8ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn matchingsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn matchingjoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_min_scale(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_trim_scale(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4gcd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8gcd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4lcm(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8lcm(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_gcd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_lcm(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btvarstrequalimage(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btequalimage(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_shmem_allocations(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_ins_since_vacuum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_set_lax(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid8in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid8toxid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid8out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid8recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid8send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid8eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid8ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anycompatible_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anycompatible_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anycompatiblearray_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anycompatiblearray_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anycompatiblearray_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anycompatiblearray_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anycompatiblenonarray_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anycompatiblenonarray_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anycompatiblerange_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anycompatiblerange_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid8cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid8_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid8_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_replication_origin_create(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_replication_origin_drop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_replication_origin_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_replication_origin_session_setup(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_replication_origin_session_reset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_replication_origin_session_is_setup(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_replication_origin_session_progress(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_replication_origin_xact_setup(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_replication_origin_xact_reset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_replication_origin_advance(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_replication_origin_progress(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_show_replication_origin_status(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_subscript_handler(fcinfo: FunctionCallInfo) -> Datum;
    pub fn icu_unicode_version(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_pg_lsn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unicode_assigned(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_backend_subxact(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_subscription(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_publication_tables(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_replica_identity_index(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_relation_is_publishable(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_gist_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_gist_compress(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_catalog_foreign_keys(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_to_table(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_to_table_null(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bit_bit_count(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytea_bit_count(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_xact_commit_timestamp_origin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_replication_slot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_reset_replication_slot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn trim_array(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_statisticsobjdef_expressions(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_statisticsobjdef_columns(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_bin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_bin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_subscript_handler(fcinfo: FunctionCallInfo) -> Datum;
    pub fn raw_array_subscript_handler(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_session_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_active_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_idle_in_transaction_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_sessions(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_sessions_abandoned(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_sessions_fatal(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_sessions_killed(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hash_record(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hash_record_extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytealtrim(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteartrim(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_function_sqlbody(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unistr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn extract_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn extract_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn extract_timetz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn extract_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn extract_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn extract_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_parameter_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_parameter_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_parameter_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_file_all_missing(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_binary_file_all_missing(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_input_is_valid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_input_error_info(fcinfo: FunctionCallInfo) -> Datum;
    pub fn drandom_normal(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_split_walfile_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_io(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_shuffle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_sample(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_tuples_newpage_updated(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_xact_tuples_newpage_updated(fcinfo: FunctionCallInfo) -> Datum;
    pub fn derf(fcinfo: FunctionCallInfo) -> Datum;
    pub fn derfc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_pl_interval_at_zone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_wal_resource_managers(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_have_stats(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_subscription_stats(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_reset_subscription_stats(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_row_number_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_rank_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_dense_rank_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8inc_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_settings_get_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stop_making_pinned_objects(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_starts_with_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_recovery_prefetch(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_database_collation_actual_version(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ident_file_mappings(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexreplace_extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexreplace_extended_no_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexreplace_extended_no_n(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_count_no_start(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_count_no_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_count(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_instr_no_start(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_instr_no_n(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_instr_no_endoption(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_instr_no_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_instr_no_subexpr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_instr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_like_no_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_like(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_substr_no_start(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_substr_no_n(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_substr_no_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_substr_no_subexpr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_substr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ls_logicalsnapdir(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ls_logicalmapdir(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ls_replslotdir(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_mi_interval_at_zone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_timestamptz_at_zone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_agg_strict_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_agg_strict_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_agg_unique_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_agg_unique_strict_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_agg_strict_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_object_agg_strict_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_object_agg_unique_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_object_agg_unique_strict_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn any_value_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_agg_combine(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_agg_serialize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_agg_deserialize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_agg_array_combine(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_agg_array_serialize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_agg_array_deserialize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn string_agg_combine(fcinfo: FunctionCallInfo) -> Datum;
    pub fn string_agg_serialize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn string_agg_deserialize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_log_standby_snapshot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_percent_rank_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_cume_dist_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_ntile_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_conflict_logicalslot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_lastscan(fcinfo: FunctionCallInfo) -> Datum;
    pub fn system_user(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_logical_slot_has_caught_up(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_checkpointer_stat_reset_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_basetype(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_column_toast_chunk_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regtypemod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_wait_events(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_add_sub_rel_state(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_replorigin_advance(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_available_wal_summaries(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_wal_summary_contents(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_wal_summarizer_state(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_avg_serialize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_avg_deserialize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_checkpointer_restartpoints_timed(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_checkpointer_restartpoints_requested(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_checkpointer_restartpoints_performed(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_bin32(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_bin64(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_oct32(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_oct64(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_at_local(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_at_local(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_at_local(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_populate_record_valid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4random(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8random(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_random(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_extract_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_extract_version(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_sync_replication_slots(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_contains_elem_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn elem_contained_by_range_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn parse_bool(value: *const ::core::ffi::c_char, result: *mut bool) -> bool;
    pub fn parse_bool_with_len(
        value: *const ::core::ffi::c_char,
        len: usize,
        result: *mut bool,
    ) -> bool;
    pub fn domain_check(
        value: Datum,
        isnull: bool,
        domainType: Oid,
        extra: *mut *mut ::core::ffi::c_void,
        mcxt: MemoryContext,
    );
    pub fn domain_check_safe(
        value: Datum,
        isnull: bool,
        domainType: Oid,
        extra: *mut *mut ::core::ffi::c_void,
        mcxt: MemoryContext,
        escontext: *mut Node,
    ) -> bool;
    pub fn errdatatype(datatypeOid: Oid) -> ::core::ffi::c_int;
    pub fn errdomainconstraint(
        datatypeOid: Oid,
        conname: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn hex_encode(
        src: *const ::core::ffi::c_char,
        len: usize,
        dst: *mut ::core::ffi::c_char,
    ) -> uint64;
    pub fn hex_decode(
        src: *const ::core::ffi::c_char,
        len: usize,
        dst: *mut ::core::ffi::c_char,
    ) -> uint64;
    pub fn hex_decode_safe(
        src: *const ::core::ffi::c_char,
        len: usize,
        dst: *mut ::core::ffi::c_char,
        escontext: *mut Node,
    ) -> uint64;
    pub fn buildint2vector(int2s: *const int16, n: ::core::ffi::c_int) -> *mut int2vector;
    pub fn namestrcpy(name: Name, str_: *const ::core::ffi::c_char);
    pub fn namestrcmp(name: Name, str_: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn pg_strtoint16(s: *const ::core::ffi::c_char) -> int16;
    pub fn pg_strtoint16_safe(s: *const ::core::ffi::c_char, escontext: *mut Node) -> int16;
    pub fn pg_strtoint32(s: *const ::core::ffi::c_char) -> int32;
    pub fn pg_strtoint32_safe(s: *const ::core::ffi::c_char, escontext: *mut Node) -> int32;
    pub fn pg_strtoint64(s: *const ::core::ffi::c_char) -> int64;
    pub fn pg_strtoint64_safe(s: *const ::core::ffi::c_char, escontext: *mut Node) -> int64;
    pub fn uint32in_subr(
        s: *const ::core::ffi::c_char,
        endloc: *mut *mut ::core::ffi::c_char,
        typname: *const ::core::ffi::c_char,
        escontext: *mut Node,
    ) -> uint32;
    pub fn uint64in_subr(
        s: *const ::core::ffi::c_char,
        endloc: *mut *mut ::core::ffi::c_char,
        typname: *const ::core::ffi::c_char,
        escontext: *mut Node,
    ) -> uint64;
    pub fn pg_itoa(i: int16, a: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn pg_ultoa_n(value: uint32, a: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn pg_ulltoa_n(value: uint64, a: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn pg_ltoa(value: int32, a: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn pg_lltoa(value: int64, a: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn pg_ultostr_zeropad(
        str_: *mut ::core::ffi::c_char,
        value: uint32,
        minwidth: int32,
    ) -> *mut ::core::ffi::c_char;
    pub fn pg_ultostr(str_: *mut ::core::ffi::c_char, value: uint32) -> *mut ::core::ffi::c_char;
    pub fn buildoidvector(oids: *const Oid, n: ::core::ffi::c_int) -> *mut oidvector;
    pub fn oidparse(node: *mut Node) -> Oid;
    pub fn oid_cmp(
        p1: *const ::core::ffi::c_void,
        p2: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn regexp_fixed_prefix(
        text_re: *mut text,
        case_insensitive: bool,
        collation: Oid,
        exact: *mut bool,
    ) -> *mut ::core::ffi::c_char;
    pub static mut quote_all_identifiers: bool;
    pub fn quote_identifier(ident: *const ::core::ffi::c_char) -> *const ::core::ffi::c_char;
    pub fn quote_qualified_identifier(
        qualifier: *const ::core::ffi::c_char,
        ident: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn generate_operator_clause(
        buf: fmStringInfo,
        leftop: *const ::core::ffi::c_char,
        leftoptype: Oid,
        opoid: Oid,
        rightop: *const ::core::ffi::c_char,
        rightoptype: Oid,
    );
    pub fn bpchartruelen(
        s: *mut ::core::ffi::c_char,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn cstring_to_text(s: *const ::core::ffi::c_char) -> *mut text;
    pub fn cstring_to_text_with_len(
        s: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
    ) -> *mut text;
    pub fn text_to_cstring(t: *const text) -> *mut ::core::ffi::c_char;
    pub fn text_to_cstring_buffer(src: *const text, dst: *mut ::core::ffi::c_char, dst_len: usize);
    pub fn xidComparator(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn xidLogicalComparator(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn pg_inet_cidr_ntop(
        af: ::core::ffi::c_int,
        src: *const ::core::ffi::c_void,
        bits: ::core::ffi::c_int,
        dst: *mut ::core::ffi::c_char,
        size: usize,
    ) -> *mut ::core::ffi::c_char;
    pub fn pg_inet_net_pton(
        af: ::core::ffi::c_int,
        src: *const ::core::ffi::c_char,
        dst: *mut ::core::ffi::c_void,
        size: usize,
    ) -> ::core::ffi::c_int;
    pub fn convert_network_to_scalar(value: Datum, typid: Oid, failure: *mut bool) -> f64;
    pub fn network_scan_first(in_: Datum) -> Datum;
    pub fn network_scan_last(in_: Datum) -> Datum;
    pub fn clean_ipv6_addr(addr_family: ::core::ffi::c_int, addr: *mut ::core::ffi::c_char);
    pub fn numeric_float8_no_overflow(fcinfo: FunctionCallInfo) -> Datum;
    pub fn format_type_extended(
        type_oid: Oid,
        typemod: int32,
        flags: bits16,
    ) -> *mut ::core::ffi::c_char;
    pub fn format_type_be(type_oid: Oid) -> *mut ::core::ffi::c_char;
    pub fn format_type_be_qualified(type_oid: Oid) -> *mut ::core::ffi::c_char;
    pub fn format_type_with_typemod(type_oid: Oid, typemod: int32) -> *mut ::core::ffi::c_char;
    pub fn type_maximum_size(type_oid: Oid, typemod: int32) -> int32;
    pub fn quote_literal_cstr(rawstr: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn anytime_typmod_check(istz: bool, typmod: int32) -> int32;
    pub fn date2timestamp_no_overflow(dateVal: DateADT) -> f64;
    pub fn date2timestamp_opt_overflow(
        dateVal: DateADT,
        overflow: *mut ::core::ffi::c_int,
    ) -> Timestamp;
    pub fn date2timestamptz_opt_overflow(
        dateVal: DateADT,
        overflow: *mut ::core::ffi::c_int,
    ) -> TimestampTz;
    pub fn date_cmp_timestamp_internal(dateVal: DateADT, dt2: Timestamp) -> int32;
    pub fn date_cmp_timestamptz_internal(dateVal: DateADT, dt2: TimestampTz) -> int32;
    pub fn EncodeSpecialDate(dt: DateADT, str_: *mut ::core::ffi::c_char);
    pub fn GetSQLCurrentDate() -> DateADT;
    pub fn GetSQLCurrentTime(typmod: int32) -> *mut TimeTzADT;
    pub fn GetSQLLocalTime(typmod: int32) -> TimeADT;
    pub fn time2tm(time: TimeADT, tm: *mut pg_tm, fsec: *mut fsec_t) -> ::core::ffi::c_int;
    pub fn timetz2tm(
        time: *mut TimeTzADT,
        tm: *mut pg_tm,
        fsec: *mut fsec_t,
        tzp: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn tm2time(tm: *mut pg_tm, fsec: fsec_t, result: *mut TimeADT) -> ::core::ffi::c_int;
    pub fn tm2timetz(
        tm: *mut pg_tm,
        fsec: fsec_t,
        tz: ::core::ffi::c_int,
        result: *mut TimeTzADT,
    ) -> ::core::ffi::c_int;
    pub fn time_overflows(
        hour: ::core::ffi::c_int,
        min: ::core::ffi::c_int,
        sec: ::core::ffi::c_int,
        fsec: fsec_t,
    ) -> bool;
    pub fn float_time_overflows(
        hour: ::core::ffi::c_int,
        min: ::core::ffi::c_int,
        sec: f64,
    ) -> bool;
    pub fn AdjustTimeForTypmod(time: *mut TimeADT, typmod: int32);
    pub static months: [*const ::core::ffi::c_char; 0usize];
    pub static days: [*const ::core::ffi::c_char; 0usize];
    pub static mut day_tab: [[::core::ffi::c_int; 13usize]; 2usize];
    pub fn GetCurrentDateTime(tm: *mut pg_tm);
    pub fn GetCurrentTimeUsec(tm: *mut pg_tm, fsec: *mut fsec_t, tzp: *mut ::core::ffi::c_int);
    pub fn j2date(
        jd: ::core::ffi::c_int,
        year: *mut ::core::ffi::c_int,
        month: *mut ::core::ffi::c_int,
        day: *mut ::core::ffi::c_int,
    );
    pub fn date2j(
        year: ::core::ffi::c_int,
        month: ::core::ffi::c_int,
        day: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn ParseDateTime(
        timestr: *const ::core::ffi::c_char,
        workbuf: *mut ::core::ffi::c_char,
        buflen: usize,
        field: *mut *mut ::core::ffi::c_char,
        ftype: *mut ::core::ffi::c_int,
        maxfields: ::core::ffi::c_int,
        numfields: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn DecodeDateTime(
        field: *mut *mut ::core::ffi::c_char,
        ftype: *mut ::core::ffi::c_int,
        nf: ::core::ffi::c_int,
        dtype: *mut ::core::ffi::c_int,
        tm: *mut pg_tm,
        fsec: *mut fsec_t,
        tzp: *mut ::core::ffi::c_int,
        extra: *mut DateTimeErrorExtra,
    ) -> ::core::ffi::c_int;
    pub fn DecodeTimezone(
        str_: *const ::core::ffi::c_char,
        tzp: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn DecodeTimeOnly(
        field: *mut *mut ::core::ffi::c_char,
        ftype: *mut ::core::ffi::c_int,
        nf: ::core::ffi::c_int,
        dtype: *mut ::core::ffi::c_int,
        tm: *mut pg_tm,
        fsec: *mut fsec_t,
        tzp: *mut ::core::ffi::c_int,
        extra: *mut DateTimeErrorExtra,
    ) -> ::core::ffi::c_int;
    pub fn DecodeInterval(
        field: *mut *mut ::core::ffi::c_char,
        ftype: *mut ::core::ffi::c_int,
        nf: ::core::ffi::c_int,
        range: ::core::ffi::c_int,
        dtype: *mut ::core::ffi::c_int,
        itm_in: *mut pg_itm_in,
    ) -> ::core::ffi::c_int;
    pub fn DecodeISO8601Interval(
        str_: *mut ::core::ffi::c_char,
        dtype: *mut ::core::ffi::c_int,
        itm_in: *mut pg_itm_in,
    ) -> ::core::ffi::c_int;
    pub fn DateTimeParseError(
        dterr: ::core::ffi::c_int,
        extra: *mut DateTimeErrorExtra,
        str_: *const ::core::ffi::c_char,
        datatype: *const ::core::ffi::c_char,
        escontext: *mut Node,
    );
    pub fn DetermineTimeZoneOffset(tm: *mut pg_tm, tzp: *mut pg_tz) -> ::core::ffi::c_int;
    pub fn DetermineTimeZoneAbbrevOffset(
        tm: *mut pg_tm,
        abbr: *const ::core::ffi::c_char,
        tzp: *mut pg_tz,
    ) -> ::core::ffi::c_int;
    pub fn DetermineTimeZoneAbbrevOffsetTS(
        ts: TimestampTz,
        abbr: *const ::core::ffi::c_char,
        tzp: *mut pg_tz,
        isdst: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn EncodeDateOnly(
        tm: *mut pg_tm,
        style: ::core::ffi::c_int,
        str_: *mut ::core::ffi::c_char,
    );
    pub fn EncodeTimeOnly(
        tm: *mut pg_tm,
        fsec: fsec_t,
        print_tz: bool,
        tz: ::core::ffi::c_int,
        style: ::core::ffi::c_int,
        str_: *mut ::core::ffi::c_char,
    );
    pub fn EncodeDateTime(
        tm: *mut pg_tm,
        fsec: fsec_t,
        print_tz: bool,
        tz: ::core::ffi::c_int,
        tzn: *const ::core::ffi::c_char,
        style: ::core::ffi::c_int,
        str_: *mut ::core::ffi::c_char,
    );
    pub fn EncodeInterval(
        itm: *mut pg_itm,
        style: ::core::ffi::c_int,
        str_: *mut ::core::ffi::c_char,
    );
    pub fn EncodeSpecialTimestamp(dt: Timestamp, str_: *mut ::core::ffi::c_char);
    pub fn ValidateDate(
        fmask: ::core::ffi::c_int,
        isjulian: bool,
        is2digits: bool,
        bc: bool,
        tm: *mut pg_tm,
    ) -> ::core::ffi::c_int;
    pub fn DecodeTimezoneAbbrev(
        field: ::core::ffi::c_int,
        lowtoken: *const ::core::ffi::c_char,
        ftype: *mut ::core::ffi::c_int,
        offset: *mut ::core::ffi::c_int,
        tz: *mut *mut pg_tz,
        extra: *mut DateTimeErrorExtra,
    ) -> ::core::ffi::c_int;
    pub fn DecodeSpecial(
        field: ::core::ffi::c_int,
        lowtoken: *const ::core::ffi::c_char,
        val: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn DecodeUnits(
        field: ::core::ffi::c_int,
        lowtoken: *const ::core::ffi::c_char,
        val: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn DecodeTimezoneName(
        tzname: *const ::core::ffi::c_char,
        offset: *mut ::core::ffi::c_int,
        tz: *mut *mut pg_tz,
    ) -> ::core::ffi::c_int;
    pub fn DecodeTimezoneNameToTz(tzname: *const ::core::ffi::c_char) -> *mut pg_tz;
    pub fn DecodeTimezoneAbbrevPrefix(
        str_: *const ::core::ffi::c_char,
        offset: *mut ::core::ffi::c_int,
        tz: *mut *mut pg_tz,
    ) -> ::core::ffi::c_int;
    pub fn j2day(date: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn TemporalSimplify(max_precis: int32, node: *mut Node) -> *mut Node;
    pub fn CheckDateTokenTables() -> bool;
    pub fn ConvertTimeZoneAbbrevs(
        abbrevs: *mut tzEntry,
        n: ::core::ffi::c_int,
    ) -> *mut TimeZoneAbbrevTable;
    pub fn InstallTimeZoneAbbrevs(tbl: *mut TimeZoneAbbrevTable);
    pub fn AdjustTimestampForTypmod(
        time: *mut Timestamp,
        typmod: int32,
        escontext: *mut Node,
    ) -> bool;
    pub static mut extra_float_digits: ::core::ffi::c_int;
    pub fn float_overflow_error() -> !;
    pub fn float_underflow_error() -> !;
    pub fn float_zero_divide_error() -> !;
    pub fn is_infinite(val: float8) -> ::core::ffi::c_int;
    pub fn float8in_internal(
        num: *mut ::core::ffi::c_char,
        endptr_p: *mut *mut ::core::ffi::c_char,
        type_name: *const ::core::ffi::c_char,
        orig_string: *const ::core::ffi::c_char,
        escontext: *mut Node,
    ) -> float8;
    pub fn float4in_internal(
        num: *mut ::core::ffi::c_char,
        endptr_p: *mut *mut ::core::ffi::c_char,
        type_name: *const ::core::ffi::c_char,
        orig_string: *const ::core::ffi::c_char,
        escontext: *mut Node,
    ) -> float4;
    pub fn float8out_internal(num: float8) -> *mut ::core::ffi::c_char;
    pub fn float4_cmp_internal(a: float4, b: float4) -> ::core::ffi::c_int;
    pub fn float8_cmp_internal(a: float8, b: float8) -> ::core::ffi::c_int;
    pub fn pg_hypot(x: float8, y: float8) -> float8;
    pub fn escape_json(buf: StringInfo, str_: *const ::core::ffi::c_char);
    pub fn JsonEncodeDateTime(
        buf: *mut ::core::ffi::c_char,
        value: Datum,
        typid: Oid,
        tzp: *const ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn to_json_is_immutable(typoid: Oid) -> bool;
    pub fn json_build_object_worker(
        nargs: ::core::ffi::c_int,
        args: *const Datum,
        nulls: *const bool,
        types: *const Oid,
        absent_on_null: bool,
        unique_keys: bool,
    ) -> Datum;
    pub fn json_build_array_worker(
        nargs: ::core::ffi::c_int,
        args: *const Datum,
        nulls: *const bool,
        types: *const Oid,
        absent_on_null: bool,
    ) -> Datum;
    pub fn json_validate(json: *mut text, check_unique_keys: bool, throw_error: bool) -> bool;
    pub static mut pg_global_prng_state: pg_prng_state;
    pub fn pg_prng_seed(state: *mut pg_prng_state, seed: uint64);
    pub fn pg_prng_fseed(state: *mut pg_prng_state, fseed: f64);
    pub fn pg_prng_seed_check(state: *mut pg_prng_state) -> bool;
    pub fn pg_prng_uint64(state: *mut pg_prng_state) -> uint64;
    pub fn pg_prng_uint64_range(state: *mut pg_prng_state, rmin: uint64, rmax: uint64) -> uint64;
    pub fn pg_prng_int64(state: *mut pg_prng_state) -> int64;
    pub fn pg_prng_int64p(state: *mut pg_prng_state) -> int64;
    pub fn pg_prng_int64_range(state: *mut pg_prng_state, rmin: int64, rmax: int64) -> int64;
    pub fn pg_prng_uint32(state: *mut pg_prng_state) -> uint32;
    pub fn pg_prng_int32(state: *mut pg_prng_state) -> int32;
    pub fn pg_prng_int32p(state: *mut pg_prng_state) -> int32;
    pub fn pg_prng_double(state: *mut pg_prng_state) -> f64;
    pub fn pg_prng_double_normal(state: *mut pg_prng_state) -> f64;
    pub fn pg_prng_bool(state: *mut pg_prng_state) -> bool;
    pub fn numeric_is_nan(num: Numeric) -> bool;
    pub fn numeric_is_inf(num: Numeric) -> bool;
    pub fn numeric_maximum_size(typmod: int32) -> int32;
    pub fn numeric_out_sci(num: Numeric, scale: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
    pub fn numeric_normalize(num: Numeric) -> *mut ::core::ffi::c_char;
    pub fn int64_to_numeric(val: int64) -> Numeric;
    pub fn int64_div_fast_to_numeric(val1: int64, log10val2: ::core::ffi::c_int) -> Numeric;
    pub fn numeric_add_opt_error(num1: Numeric, num2: Numeric, have_error: *mut bool) -> Numeric;
    pub fn numeric_sub_opt_error(num1: Numeric, num2: Numeric, have_error: *mut bool) -> Numeric;
    pub fn numeric_mul_opt_error(num1: Numeric, num2: Numeric, have_error: *mut bool) -> Numeric;
    pub fn numeric_div_opt_error(num1: Numeric, num2: Numeric, have_error: *mut bool) -> Numeric;
    pub fn numeric_mod_opt_error(num1: Numeric, num2: Numeric, have_error: *mut bool) -> Numeric;
    pub fn numeric_int4_opt_error(num: Numeric, have_error: *mut bool) -> int32;
    pub fn numeric_int8_opt_error(num: Numeric, have_error: *mut bool) -> int64;
    pub fn random_numeric(state: *mut pg_prng_state, rmin: Numeric, rmax: Numeric) -> Numeric;
    pub fn getJsonbOffset(jc: *const JsonbContainer, index: ::core::ffi::c_int) -> uint32;
    pub fn getJsonbLength(jc: *const JsonbContainer, index: ::core::ffi::c_int) -> uint32;
    pub fn compareJsonbContainers(
        a: *mut JsonbContainer,
        b: *mut JsonbContainer,
    ) -> ::core::ffi::c_int;
    pub fn findJsonbValueFromContainer(
        container: *mut JsonbContainer,
        flags: uint32,
        key: *mut JsonbValue,
    ) -> *mut JsonbValue;
    pub fn getKeyJsonValueFromContainer(
        container: *mut JsonbContainer,
        keyVal: *const ::core::ffi::c_char,
        keyLen: ::core::ffi::c_int,
        res: *mut JsonbValue,
    ) -> *mut JsonbValue;
    pub fn getIthJsonbValueFromContainer(
        container: *mut JsonbContainer,
        i: uint32,
    ) -> *mut JsonbValue;
    pub fn pushJsonbValue(
        pstate: *mut *mut JsonbParseState,
        seq: JsonbIteratorToken::Type,
        jbval: *mut JsonbValue,
    ) -> *mut JsonbValue;
    pub fn JsonbIteratorInit(container: *mut JsonbContainer) -> *mut JsonbIterator;
    pub fn JsonbIteratorNext(
        it: *mut *mut JsonbIterator,
        val: *mut JsonbValue,
        skipNested: bool,
    ) -> JsonbIteratorToken::Type;
    pub fn JsonbToJsonbValue(jsonb: *mut Jsonb, val: *mut JsonbValue);
    pub fn JsonbValueToJsonb(val: *mut JsonbValue) -> *mut Jsonb;
    pub fn JsonbDeepContains(
        val: *mut *mut JsonbIterator,
        mContained: *mut *mut JsonbIterator,
    ) -> bool;
    pub fn JsonbHashScalarValue(scalarVal: *const JsonbValue, hash: *mut uint32);
    pub fn JsonbHashScalarValueExtended(
        scalarVal: *const JsonbValue,
        hash: *mut uint64,
        seed: uint64,
    );
    pub fn JsonbToCString(
        out: StringInfo,
        in_: *mut JsonbContainer,
        estimated_len: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn JsonbToCStringIndent(
        out: StringInfo,
        in_: *mut JsonbContainer,
        estimated_len: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn JsonbUnquote(jb: *mut Jsonb) -> *mut ::core::ffi::c_char;
    pub fn JsonbExtractScalar(jbc: *mut JsonbContainer, res: *mut JsonbValue) -> bool;
    pub fn JsonbTypeName(val: *mut JsonbValue) -> *const ::core::ffi::c_char;
    pub fn jsonb_set_element(
        jb: *mut Jsonb,
        path: *mut Datum,
        path_len: ::core::ffi::c_int,
        newval: *mut JsonbValue,
    ) -> Datum;
    pub fn jsonb_get_element(
        jb: *mut Jsonb,
        path: *mut Datum,
        npath: ::core::ffi::c_int,
        isnull: *mut bool,
        as_text: bool,
    ) -> Datum;
    pub fn to_jsonb_is_immutable(typoid: Oid) -> bool;
    pub fn jsonb_build_object_worker(
        nargs: ::core::ffi::c_int,
        args: *const Datum,
        nulls: *const bool,
        types: *const Oid,
        absent_on_null: bool,
        unique_keys: bool,
    ) -> Datum;
    pub fn jsonb_build_array_worker(
        nargs: ::core::ffi::c_int,
        args: *const Datum,
        nulls: *const bool,
        types: *const Oid,
        absent_on_null: bool,
    ) -> Datum;
    pub static mut get_attavgwidth_hook: get_attavgwidth_hook_type;
    pub fn op_in_opfamily(opno: Oid, opfamily: Oid) -> bool;
    pub fn get_op_opfamily_strategy(opno: Oid, opfamily: Oid) -> ::core::ffi::c_int;
    pub fn get_op_opfamily_sortfamily(opno: Oid, opfamily: Oid) -> Oid;
    pub fn get_op_opfamily_properties(
        opno: Oid,
        opfamily: Oid,
        ordering_op: bool,
        strategy: *mut ::core::ffi::c_int,
        lefttype: *mut Oid,
        righttype: *mut Oid,
    );
    pub fn get_opfamily_member(
        opfamily: Oid,
        lefttype: Oid,
        righttype: Oid,
        strategy: int16,
    ) -> Oid;
    pub fn get_ordering_op_properties(
        opno: Oid,
        opfamily: *mut Oid,
        opcintype: *mut Oid,
        strategy: *mut int16,
    ) -> bool;
    pub fn get_equality_op_for_ordering_op(opno: Oid, reverse: *mut bool) -> Oid;
    pub fn get_ordering_op_for_equality_op(opno: Oid, use_lhs_type: bool) -> Oid;
    pub fn get_mergejoin_opfamilies(opno: Oid) -> *mut List;
    pub fn get_compatible_hash_operators(opno: Oid, lhs_opno: *mut Oid, rhs_opno: *mut Oid)
        -> bool;
    pub fn get_op_hash_functions(
        opno: Oid,
        lhs_procno: *mut RegProcedure,
        rhs_procno: *mut RegProcedure,
    ) -> bool;
    pub fn get_op_btree_interpretation(opno: Oid) -> *mut List;
    pub fn equality_ops_are_compatible(opno1: Oid, opno2: Oid) -> bool;
    pub fn comparison_ops_are_compatible(opno1: Oid, opno2: Oid) -> bool;
    pub fn get_opfamily_proc(opfamily: Oid, lefttype: Oid, righttype: Oid, procnum: int16) -> Oid;
    pub fn get_attname(
        relid: Oid,
        attnum: AttrNumber,
        missing_ok: bool,
    ) -> *mut ::core::ffi::c_char;
    pub fn get_attnum(relid: Oid, attname: *const ::core::ffi::c_char) -> AttrNumber;
    pub fn get_attgenerated(relid: Oid, attnum: AttrNumber) -> ::core::ffi::c_char;
    pub fn get_atttype(relid: Oid, attnum: AttrNumber) -> Oid;
    pub fn get_atttypetypmodcoll(
        relid: Oid,
        attnum: AttrNumber,
        typid: *mut Oid,
        typmod: *mut int32,
        collid: *mut Oid,
    );
    pub fn get_attoptions(relid: Oid, attnum: int16) -> Datum;
    pub fn get_cast_oid(sourcetypeid: Oid, targettypeid: Oid, missing_ok: bool) -> Oid;
    pub fn get_collation_name(colloid: Oid) -> *mut ::core::ffi::c_char;
    pub fn get_collation_isdeterministic(colloid: Oid) -> bool;
    pub fn get_constraint_name(conoid: Oid) -> *mut ::core::ffi::c_char;
    pub fn get_constraint_index(conoid: Oid) -> Oid;
    pub fn get_constraint_type(conoid: Oid) -> ::core::ffi::c_char;
    pub fn get_language_name(langoid: Oid, missing_ok: bool) -> *mut ::core::ffi::c_char;
    pub fn get_opclass_family(opclass: Oid) -> Oid;
    pub fn get_opclass_input_type(opclass: Oid) -> Oid;
    pub fn get_opclass_opfamily_and_input_type(
        opclass: Oid,
        opfamily: *mut Oid,
        opcintype: *mut Oid,
    ) -> bool;
    pub fn get_opclass_method(opclass: Oid) -> Oid;
    pub fn get_opcode(opno: Oid) -> RegProcedure;
    pub fn get_opname(opno: Oid) -> *mut ::core::ffi::c_char;
    pub fn get_op_rettype(opno: Oid) -> Oid;
    pub fn op_input_types(opno: Oid, lefttype: *mut Oid, righttype: *mut Oid);
    pub fn op_mergejoinable(opno: Oid, inputtype: Oid) -> bool;
    pub fn op_hashjoinable(opno: Oid, inputtype: Oid) -> bool;
    pub fn op_strict(opno: Oid) -> bool;
    pub fn op_volatile(opno: Oid) -> ::core::ffi::c_char;
    pub fn get_commutator(opno: Oid) -> Oid;
    pub fn get_negator(opno: Oid) -> Oid;
    pub fn get_oprrest(opno: Oid) -> RegProcedure;
    pub fn get_oprjoin(opno: Oid) -> RegProcedure;
    pub fn get_func_name(funcid: Oid) -> *mut ::core::ffi::c_char;
    pub fn get_func_namespace(funcid: Oid) -> Oid;
    pub fn get_func_rettype(funcid: Oid) -> Oid;
    pub fn get_func_nargs(funcid: Oid) -> ::core::ffi::c_int;
    pub fn get_func_signature(
        funcid: Oid,
        argtypes: *mut *mut Oid,
        nargs: *mut ::core::ffi::c_int,
    ) -> Oid;
    pub fn get_func_variadictype(funcid: Oid) -> Oid;
    pub fn get_func_retset(funcid: Oid) -> bool;
    pub fn func_strict(funcid: Oid) -> bool;
    pub fn func_volatile(funcid: Oid) -> ::core::ffi::c_char;
    pub fn func_parallel(funcid: Oid) -> ::core::ffi::c_char;
    pub fn get_func_prokind(funcid: Oid) -> ::core::ffi::c_char;
    pub fn get_func_leakproof(funcid: Oid) -> bool;
    pub fn get_func_support(funcid: Oid) -> RegProcedure;
    pub fn get_relname_relid(relname: *const ::core::ffi::c_char, relnamespace: Oid) -> Oid;
    pub fn get_rel_name(relid: Oid) -> *mut ::core::ffi::c_char;
    pub fn get_rel_namespace(relid: Oid) -> Oid;
    pub fn get_rel_type_id(relid: Oid) -> Oid;
    pub fn get_rel_relkind(relid: Oid) -> ::core::ffi::c_char;
    pub fn get_rel_relispartition(relid: Oid) -> bool;
    pub fn get_rel_tablespace(relid: Oid) -> Oid;
    pub fn get_rel_persistence(relid: Oid) -> ::core::ffi::c_char;
    pub fn get_rel_relam(relid: Oid) -> Oid;
    pub fn get_transform_fromsql(typid: Oid, langid: Oid, trftypes: *mut List) -> Oid;
    pub fn get_transform_tosql(typid: Oid, langid: Oid, trftypes: *mut List) -> Oid;
    pub fn get_typisdefined(typid: Oid) -> bool;
    pub fn get_typlen(typid: Oid) -> int16;
    pub fn get_typbyval(typid: Oid) -> bool;
    pub fn get_typlenbyval(typid: Oid, typlen: *mut int16, typbyval: *mut bool);
    pub fn get_typlenbyvalalign(
        typid: Oid,
        typlen: *mut int16,
        typbyval: *mut bool,
        typalign: *mut ::core::ffi::c_char,
    );
    pub fn getTypeIOParam(typeTuple: HeapTuple) -> Oid;
    pub fn get_type_io_data(
        typid: Oid,
        which_func: IOFuncSelector::Type,
        typlen: *mut int16,
        typbyval: *mut bool,
        typalign: *mut ::core::ffi::c_char,
        typdelim: *mut ::core::ffi::c_char,
        typioparam: *mut Oid,
        func: *mut Oid,
    );
    pub fn get_typstorage(typid: Oid) -> ::core::ffi::c_char;
    pub fn get_typdefault(typid: Oid) -> *mut Node;
    pub fn get_typtype(typid: Oid) -> ::core::ffi::c_char;
    pub fn type_is_rowtype(typid: Oid) -> bool;
    pub fn type_is_enum(typid: Oid) -> bool;
    pub fn type_is_range(typid: Oid) -> bool;
    pub fn type_is_multirange(typid: Oid) -> bool;
    pub fn get_type_category_preferred(
        typid: Oid,
        typcategory: *mut ::core::ffi::c_char,
        typispreferred: *mut bool,
    );
    pub fn get_typ_typrelid(typid: Oid) -> Oid;
    pub fn get_element_type(typid: Oid) -> Oid;
    pub fn get_array_type(typid: Oid) -> Oid;
    pub fn get_promoted_array_type(typid: Oid) -> Oid;
    pub fn get_base_element_type(typid: Oid) -> Oid;
    pub fn getTypeInputInfo(type_: Oid, typInput: *mut Oid, typIOParam: *mut Oid);
    pub fn getTypeOutputInfo(type_: Oid, typOutput: *mut Oid, typIsVarlena: *mut bool);
    pub fn getTypeBinaryInputInfo(type_: Oid, typReceive: *mut Oid, typIOParam: *mut Oid);
    pub fn getTypeBinaryOutputInfo(type_: Oid, typSend: *mut Oid, typIsVarlena: *mut bool);
    pub fn get_typmodin(typid: Oid) -> Oid;
    pub fn get_typcollation(typid: Oid) -> Oid;
    pub fn type_is_collatable(typid: Oid) -> bool;
    pub fn get_typsubscript(typid: Oid, typelemp: *mut Oid) -> RegProcedure;
    pub fn getSubscriptingRoutines(typid: Oid, typelemp: *mut Oid) -> *const SubscriptRoutines;
    pub fn getBaseType(typid: Oid) -> Oid;
    pub fn getBaseTypeAndTypmod(typid: Oid, typmod: *mut int32) -> Oid;
    pub fn get_typavgwidth(typid: Oid, typmod: int32) -> int32;
    pub fn get_attavgwidth(relid: Oid, attnum: AttrNumber) -> int32;
    pub fn get_attstatsslot(
        sslot: *mut AttStatsSlot,
        statstuple: HeapTuple,
        reqkind: ::core::ffi::c_int,
        reqop: Oid,
        flags: ::core::ffi::c_int,
    ) -> bool;
    pub fn free_attstatsslot(sslot: *mut AttStatsSlot);
    pub fn get_namespace_name(nspid: Oid) -> *mut ::core::ffi::c_char;
    pub fn get_namespace_name_or_temp(nspid: Oid) -> *mut ::core::ffi::c_char;
    pub fn get_range_subtype(rangeOid: Oid) -> Oid;
    pub fn get_range_collation(rangeOid: Oid) -> Oid;
    pub fn get_range_multirange(rangeOid: Oid) -> Oid;
    pub fn get_multirange_range(multirangeOid: Oid) -> Oid;
    pub fn get_index_column_opclass(index_oid: Oid, attno: ::core::ffi::c_int) -> Oid;
    pub fn get_index_isreplident(index_oid: Oid) -> bool;
    pub fn get_index_isvalid(index_oid: Oid) -> bool;
    pub fn get_index_isclustered(index_oid: Oid) -> bool;
    pub fn get_publication_oid(pubname: *const ::core::ffi::c_char, missing_ok: bool) -> Oid;
    pub fn get_publication_name(pubid: Oid, missing_ok: bool) -> *mut ::core::ffi::c_char;
    pub fn get_subscription_oid(subname: *const ::core::ffi::c_char, missing_ok: bool) -> Oid;
    pub fn get_subscription_name(subid: Oid, missing_ok: bool) -> *mut ::core::ffi::c_char;
    pub fn format_procedure_extended(procedure_oid: Oid, flags: bits16)
        -> *mut ::core::ffi::c_char;
    pub fn format_operator_extended(operator_oid: Oid, flags: bits16) -> *mut ::core::ffi::c_char;
    pub fn stringToQualifiedNameList(
        string: *const ::core::ffi::c_char,
        escontext: *mut Node,
    ) -> *mut List;
    pub fn format_procedure(procedure_oid: Oid) -> *mut ::core::ffi::c_char;
    pub fn format_procedure_qualified(procedure_oid: Oid) -> *mut ::core::ffi::c_char;
    pub fn format_procedure_parts(
        procedure_oid: Oid,
        objnames: *mut *mut List,
        objargs: *mut *mut List,
        missing_ok: bool,
    );
    pub fn format_operator(operator_oid: Oid) -> *mut ::core::ffi::c_char;
    pub fn format_operator_qualified(operator_oid: Oid) -> *mut ::core::ffi::c_char;
    pub fn format_operator_parts(
        operator_oid: Oid,
        objnames: *mut *mut List,
        objargs: *mut *mut List,
        missing_ok: bool,
    );
    pub static mut row_security: bool;
    pub fn check_enable_rls(relid: Oid, checkAsUser: Oid, noError: bool) -> ::core::ffi::c_int;
    pub fn pg_get_indexdef_string(indexrelid: Oid) -> *mut ::core::ffi::c_char;
    pub fn pg_get_indexdef_columns(indexrelid: Oid, pretty: bool) -> *mut ::core::ffi::c_char;
    pub fn pg_get_indexdef_columns_extended(
        indexrelid: Oid,
        flags: bits16,
    ) -> *mut ::core::ffi::c_char;
    pub fn pg_get_querydef(query: *mut Query, pretty: bool) -> *mut ::core::ffi::c_char;
    pub fn pg_get_partkeydef_columns(relid: Oid, pretty: bool) -> *mut ::core::ffi::c_char;
    pub fn pg_get_partconstrdef_string(
        partitionId: Oid,
        aliasname: *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn pg_get_constraintdef_command(constraintId: Oid) -> *mut ::core::ffi::c_char;
    pub fn deparse_expression(
        expr: *mut Node,
        dpcontext: *mut List,
        forceprefix: bool,
        showimplicit: bool,
    ) -> *mut ::core::ffi::c_char;
    pub fn deparse_context_for(aliasname: *const ::core::ffi::c_char, relid: Oid) -> *mut List;
    pub fn deparse_context_for_plan_tree(
        pstmt: *mut PlannedStmt,
        rtable_names: *mut List,
    ) -> *mut List;
    pub fn set_deparse_context_plan(
        dpcontext: *mut List,
        plan: *mut Plan,
        ancestors: *mut List,
    ) -> *mut List;
    pub fn select_rtable_names_for_explain(
        rtable: *mut List,
        rels_used: *mut Bitmapset,
    ) -> *mut List;
    pub fn generate_collation_name(collid: Oid) -> *mut ::core::ffi::c_char;
    pub fn generate_opclass_name(opclass: Oid) -> *mut ::core::ffi::c_char;
    pub fn get_range_partbound_string(bound_datums: *mut List) -> *mut ::core::ffi::c_char;
    pub fn pg_get_statisticsobjdef_string(statextid: Oid) -> *mut ::core::ffi::c_char;
    pub fn sampler_random_init_state(seed: uint32, randstate: *mut pg_prng_state);
    pub fn sampler_random_fract(randstate: *mut pg_prng_state) -> f64;
    pub fn BlockSampler_Init(
        bs: BlockSampler,
        nblocks: BlockNumber,
        samplesize: ::core::ffi::c_int,
        randseed: uint32,
    ) -> BlockNumber;
    pub fn BlockSampler_HasMore(bs: BlockSampler) -> bool;
    pub fn BlockSampler_Next(bs: BlockSampler) -> BlockNumber;
    pub fn reservoir_init_selection_state(rs: ReservoirState, n: ::core::ffi::c_int);
    pub fn reservoir_get_next_S(rs: ReservoirState, t: f64, n: ::core::ffi::c_int) -> f64;
    pub static mut get_relation_stats_hook: get_relation_stats_hook_type;
    pub static mut get_index_stats_hook: get_index_stats_hook_type;
    pub fn examine_variable(
        root: *mut PlannerInfo,
        node: *mut Node,
        varRelid: ::core::ffi::c_int,
        vardata: *mut VariableStatData,
    );
    pub fn statistic_proc_security_check(vardata: *mut VariableStatData, func_oid: Oid) -> bool;
    pub fn get_restriction_variable(
        root: *mut PlannerInfo,
        args: *mut List,
        varRelid: ::core::ffi::c_int,
        vardata: *mut VariableStatData,
        other: *mut *mut Node,
        varonleft: *mut bool,
    ) -> bool;
    pub fn get_join_variables(
        root: *mut PlannerInfo,
        args: *mut List,
        sjinfo: *mut SpecialJoinInfo,
        vardata1: *mut VariableStatData,
        vardata2: *mut VariableStatData,
        join_is_reversed: *mut bool,
    );
    pub fn get_variable_numdistinct(vardata: *mut VariableStatData, isdefault: *mut bool) -> f64;
    pub fn mcv_selectivity(
        vardata: *mut VariableStatData,
        opproc: *mut FmgrInfo,
        collation: Oid,
        constval: Datum,
        varonleft: bool,
        sumcommonp: *mut f64,
    ) -> f64;
    pub fn histogram_selectivity(
        vardata: *mut VariableStatData,
        opproc: *mut FmgrInfo,
        collation: Oid,
        constval: Datum,
        varonleft: bool,
        min_hist_size: ::core::ffi::c_int,
        n_skip: ::core::ffi::c_int,
        hist_size: *mut ::core::ffi::c_int,
    ) -> f64;
    pub fn generic_restriction_selectivity(
        root: *mut PlannerInfo,
        oproid: Oid,
        collation: Oid,
        args: *mut List,
        varRelid: ::core::ffi::c_int,
        default_selectivity: f64,
    ) -> f64;
    pub fn ineq_histogram_selectivity(
        root: *mut PlannerInfo,
        vardata: *mut VariableStatData,
        opoid: Oid,
        opproc: *mut FmgrInfo,
        isgt: bool,
        iseq: bool,
        collation: Oid,
        constval: Datum,
        consttype: Oid,
    ) -> f64;
    pub fn var_eq_const(
        vardata: *mut VariableStatData,
        oproid: Oid,
        collation: Oid,
        constval: Datum,
        constisnull: bool,
        varonleft: bool,
        negate: bool,
    ) -> f64;
    pub fn var_eq_non_const(
        vardata: *mut VariableStatData,
        oproid: Oid,
        collation: Oid,
        other: *mut Node,
        varonleft: bool,
        negate: bool,
    ) -> f64;
    pub fn boolvarsel(
        root: *mut PlannerInfo,
        arg: *mut Node,
        varRelid: ::core::ffi::c_int,
    ) -> Selectivity;
    pub fn booltestsel(
        root: *mut PlannerInfo,
        booltesttype: BoolTestType::Type,
        arg: *mut Node,
        varRelid: ::core::ffi::c_int,
        jointype: JoinType::Type,
        sjinfo: *mut SpecialJoinInfo,
    ) -> Selectivity;
    pub fn nulltestsel(
        root: *mut PlannerInfo,
        nulltesttype: NullTestType::Type,
        arg: *mut Node,
        varRelid: ::core::ffi::c_int,
        jointype: JoinType::Type,
        sjinfo: *mut SpecialJoinInfo,
    ) -> Selectivity;
    pub fn scalararraysel(
        root: *mut PlannerInfo,
        clause: *mut ScalarArrayOpExpr,
        is_join_clause: bool,
        varRelid: ::core::ffi::c_int,
        jointype: JoinType::Type,
        sjinfo: *mut SpecialJoinInfo,
    ) -> Selectivity;
    pub fn estimate_array_length(root: *mut PlannerInfo, arrayexpr: *mut Node) -> f64;
    pub fn rowcomparesel(
        root: *mut PlannerInfo,
        clause: *mut RowCompareExpr,
        varRelid: ::core::ffi::c_int,
        jointype: JoinType::Type,
        sjinfo: *mut SpecialJoinInfo,
    ) -> Selectivity;
    pub fn mergejoinscansel(
        root: *mut PlannerInfo,
        clause: *mut Node,
        opfamily: Oid,
        strategy: ::core::ffi::c_int,
        nulls_first: bool,
        leftstart: *mut Selectivity,
        leftend: *mut Selectivity,
        rightstart: *mut Selectivity,
        rightend: *mut Selectivity,
    );
    pub fn estimate_num_groups(
        root: *mut PlannerInfo,
        groupExprs: *mut List,
        input_rows: f64,
        pgset: *mut *mut List,
        estinfo: *mut EstimationInfo,
    ) -> f64;
    pub fn estimate_hash_bucket_stats(
        root: *mut PlannerInfo,
        hashkey: *mut Node,
        nbuckets: f64,
        mcv_freq: *mut Selectivity,
        bucketsize_frac: *mut Selectivity,
    );
    pub fn estimate_hashagg_tablesize(
        root: *mut PlannerInfo,
        path: *mut Path,
        agg_costs: *const AggClauseCosts,
        dNumGroups: f64,
    ) -> f64;
    pub fn get_quals_from_indexclauses(indexclauses: *mut List) -> *mut List;
    pub fn index_other_operands_eval_cost(root: *mut PlannerInfo, indexquals: *mut List) -> Cost;
    pub fn add_predicate_to_index_quals(
        index: *mut IndexOptInfo,
        indexQuals: *mut List,
    ) -> *mut List;
    pub fn genericcostestimate(
        root: *mut PlannerInfo,
        path: *mut IndexPath,
        loop_count: f64,
        costs: *mut GenericCosts,
    );
    pub fn scalararraysel_containment(
        root: *mut PlannerInfo,
        leftop: *mut Node,
        rightop: *mut Node,
        elemtype: Oid,
        isEquality: bool,
        useOr: bool,
        varRelid: ::core::ffi::c_int,
    ) -> Selectivity;
    pub fn get_tablespace_page_costs(
        spcid: Oid,
        spc_random_page_cost: *mut float8,
        spc_seq_page_cost: *mut float8,
    );
    pub fn get_tablespace_io_concurrency(spcid: Oid) -> ::core::ffi::c_int;
    pub fn get_tablespace_maintenance_io_concurrency(spcid: Oid) -> ::core::ffi::c_int;
    pub fn CreateCacheMemoryContext();
    pub fn InitCatCache(
        id: ::core::ffi::c_int,
        reloid: Oid,
        indexoid: Oid,
        nkeys: ::core::ffi::c_int,
        key: *const ::core::ffi::c_int,
        nbuckets: ::core::ffi::c_int,
    ) -> *mut CatCache;
    pub fn InitCatCachePhase2(cache: *mut CatCache, touch_index: bool);
    pub fn SearchCatCache(
        cache: *mut CatCache,
        v1: Datum,
        v2: Datum,
        v3: Datum,
        v4: Datum,
    ) -> HeapTuple;
    pub fn SearchCatCache1(cache: *mut CatCache, v1: Datum) -> HeapTuple;
    pub fn SearchCatCache2(cache: *mut CatCache, v1: Datum, v2: Datum) -> HeapTuple;
    pub fn SearchCatCache3(cache: *mut CatCache, v1: Datum, v2: Datum, v3: Datum) -> HeapTuple;
    pub fn SearchCatCache4(
        cache: *mut CatCache,
        v1: Datum,
        v2: Datum,
        v3: Datum,
        v4: Datum,
    ) -> HeapTuple;
    pub fn ReleaseCatCache(tuple: HeapTuple);
    pub fn GetCatCacheHashValue(
        cache: *mut CatCache,
        v1: Datum,
        v2: Datum,
        v3: Datum,
        v4: Datum,
    ) -> uint32;
    pub fn SearchCatCacheList(
        cache: *mut CatCache,
        nkeys: ::core::ffi::c_int,
        v1: Datum,
        v2: Datum,
        v3: Datum,
    ) -> *mut CatCList;
    pub fn ReleaseCatCacheList(list: *mut CatCList);
    pub fn ResetCatalogCaches();
    pub fn ResetCatalogCachesExt(debug_discard: bool);
    pub fn CatalogCacheFlushCatalog(catId: Oid);
    pub fn CatCacheInvalidate(cache: *mut CatCache, hashValue: uint32);
    pub fn PrepareToInvalidateCacheTuple(
        relation: Relation,
        tuple: HeapTuple,
        newtuple: HeapTuple,
        function: ::core::option::Option<
            unsafe extern "C-unwind" fn(arg1: ::core::ffi::c_int, arg2: uint32, arg3: Oid),
        >,
    );
    pub fn InitCatalogCache();
    pub fn InitCatalogCachePhase2();
    pub fn SearchSysCache(
        cacheId: ::core::ffi::c_int,
        key1: Datum,
        key2: Datum,
        key3: Datum,
        key4: Datum,
    ) -> HeapTuple;
    pub fn SearchSysCache1(cacheId: ::core::ffi::c_int, key1: Datum) -> HeapTuple;
    pub fn SearchSysCache2(cacheId: ::core::ffi::c_int, key1: Datum, key2: Datum) -> HeapTuple;
    pub fn SearchSysCache3(
        cacheId: ::core::ffi::c_int,
        key1: Datum,
        key2: Datum,
        key3: Datum,
    ) -> HeapTuple;
    pub fn SearchSysCache4(
        cacheId: ::core::ffi::c_int,
        key1: Datum,
        key2: Datum,
        key3: Datum,
        key4: Datum,
    ) -> HeapTuple;
    pub fn ReleaseSysCache(tuple: HeapTuple);
    pub fn SearchSysCacheLocked1(cacheId: ::core::ffi::c_int, key1: Datum) -> HeapTuple;
    pub fn SearchSysCacheCopy(
        cacheId: ::core::ffi::c_int,
        key1: Datum,
        key2: Datum,
        key3: Datum,
        key4: Datum,
    ) -> HeapTuple;
    pub fn SearchSysCacheLockedCopy1(cacheId: ::core::ffi::c_int, key1: Datum) -> HeapTuple;
    pub fn SearchSysCacheExists(
        cacheId: ::core::ffi::c_int,
        key1: Datum,
        key2: Datum,
        key3: Datum,
        key4: Datum,
    ) -> bool;
    pub fn GetSysCacheOid(
        cacheId: ::core::ffi::c_int,
        oidcol: AttrNumber,
        key1: Datum,
        key2: Datum,
        key3: Datum,
        key4: Datum,
    ) -> Oid;
    pub fn SearchSysCacheAttName(relid: Oid, attname: *const ::core::ffi::c_char) -> HeapTuple;
    pub fn SearchSysCacheCopyAttName(relid: Oid, attname: *const ::core::ffi::c_char) -> HeapTuple;
    pub fn SearchSysCacheExistsAttName(relid: Oid, attname: *const ::core::ffi::c_char) -> bool;
    pub fn SearchSysCacheAttNum(relid: Oid, attnum: int16) -> HeapTuple;
    pub fn SearchSysCacheCopyAttNum(relid: Oid, attnum: int16) -> HeapTuple;
    pub fn SysCacheGetAttr(
        cacheId: ::core::ffi::c_int,
        tup: HeapTuple,
        attributeNumber: AttrNumber,
        isNull: *mut bool,
    ) -> Datum;
    pub fn SysCacheGetAttrNotNull(
        cacheId: ::core::ffi::c_int,
        tup: HeapTuple,
        attributeNumber: AttrNumber,
    ) -> Datum;
    pub fn GetSysCacheHashValue(
        cacheId: ::core::ffi::c_int,
        key1: Datum,
        key2: Datum,
        key3: Datum,
        key4: Datum,
    ) -> uint32;
    pub fn SearchSysCacheList(
        cacheId: ::core::ffi::c_int,
        nkeys: ::core::ffi::c_int,
        key1: Datum,
        key2: Datum,
        key3: Datum,
    ) -> *mut catclist;
    pub fn SysCacheInvalidate(cacheId: ::core::ffi::c_int, hashValue: uint32);
    pub fn RelationInvalidatesSnapshotsOnly(relid: Oid) -> bool;
    pub fn RelationHasSysCache(relid: Oid) -> bool;
    pub fn RelationSupportsSysCache(relid: Oid) -> bool;
    pub fn range_contains_elem_internal(
        typcache: *mut TypeCacheEntry,
        r: *const RangeType,
        val: Datum,
    ) -> bool;
    pub fn range_eq_internal(
        typcache: *mut TypeCacheEntry,
        r1: *const RangeType,
        r2: *const RangeType,
    ) -> bool;
    pub fn range_ne_internal(
        typcache: *mut TypeCacheEntry,
        r1: *const RangeType,
        r2: *const RangeType,
    ) -> bool;
    pub fn range_contains_internal(
        typcache: *mut TypeCacheEntry,
        r1: *const RangeType,
        r2: *const RangeType,
    ) -> bool;
    pub fn range_contained_by_internal(
        typcache: *mut TypeCacheEntry,
        r1: *const RangeType,
        r2: *const RangeType,
    ) -> bool;
    pub fn range_before_internal(
        typcache: *mut TypeCacheEntry,
        r1: *const RangeType,
        r2: *const RangeType,
    ) -> bool;
    pub fn range_after_internal(
        typcache: *mut TypeCacheEntry,
        r1: *const RangeType,
        r2: *const RangeType,
    ) -> bool;
    pub fn range_adjacent_internal(
        typcache: *mut TypeCacheEntry,
        r1: *const RangeType,
        r2: *const RangeType,
    ) -> bool;
    pub fn range_overlaps_internal(
        typcache: *mut TypeCacheEntry,
        r1: *const RangeType,
        r2: *const RangeType,
    ) -> bool;
    pub fn range_overleft_internal(
        typcache: *mut TypeCacheEntry,
        r1: *const RangeType,
        r2: *const RangeType,
    ) -> bool;
    pub fn range_overright_internal(
        typcache: *mut TypeCacheEntry,
        r1: *const RangeType,
        r2: *const RangeType,
    ) -> bool;
    pub fn range_union_internal(
        typcache: *mut TypeCacheEntry,
        r1: *mut RangeType,
        r2: *mut RangeType,
        strict: bool,
    ) -> *mut RangeType;
    pub fn range_minus_internal(
        typcache: *mut TypeCacheEntry,
        r1: *mut RangeType,
        r2: *mut RangeType,
    ) -> *mut RangeType;
    pub fn range_intersect_internal(
        typcache: *mut TypeCacheEntry,
        r1: *const RangeType,
        r2: *const RangeType,
    ) -> *mut RangeType;
    pub fn range_get_typcache(fcinfo: FunctionCallInfo, rngtypid: Oid) -> *mut TypeCacheEntry;
    pub fn range_serialize(
        typcache: *mut TypeCacheEntry,
        lower: *mut RangeBound,
        upper: *mut RangeBound,
        empty: bool,
        escontext: *mut Node,
    ) -> *mut RangeType;
    pub fn range_deserialize(
        typcache: *mut TypeCacheEntry,
        range: *const RangeType,
        lower: *mut RangeBound,
        upper: *mut RangeBound,
        empty: *mut bool,
    );
    pub fn range_get_flags(range: *const RangeType) -> ::core::ffi::c_char;
    pub fn range_set_contain_empty(range: *mut RangeType);
    pub fn make_range(
        typcache: *mut TypeCacheEntry,
        lower: *mut RangeBound,
        upper: *mut RangeBound,
        empty: bool,
        escontext: *mut Node,
    ) -> *mut RangeType;
    pub fn range_cmp_bounds(
        typcache: *mut TypeCacheEntry,
        b1: *const RangeBound,
        b2: *const RangeBound,
    ) -> ::core::ffi::c_int;
    pub fn range_cmp_bound_values(
        typcache: *mut TypeCacheEntry,
        b1: *const RangeBound,
        b2: *const RangeBound,
    ) -> ::core::ffi::c_int;
    pub fn range_compare(
        key1: *const ::core::ffi::c_void,
        key2: *const ::core::ffi::c_void,
        arg: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn bounds_adjacent(
        typcache: *mut TypeCacheEntry,
        boundA: RangeBound,
        boundB: RangeBound,
    ) -> bool;
    pub fn make_empty_range(typcache: *mut TypeCacheEntry) -> *mut RangeType;
    pub fn range_split_internal(
        typcache: *mut TypeCacheEntry,
        r1: *const RangeType,
        r2: *const RangeType,
        output1: *mut *mut RangeType,
        output2: *mut *mut RangeType,
    ) -> bool;
    pub fn varstr_cmp(
        arg1: *const ::core::ffi::c_char,
        len1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        len2: ::core::ffi::c_int,
        collid: Oid,
    ) -> ::core::ffi::c_int;
    pub fn varstr_sortsupport(ssup: SortSupport, typid: Oid, collid: Oid);
    pub fn varstr_levenshtein(
        source: *const ::core::ffi::c_char,
        slen: ::core::ffi::c_int,
        target: *const ::core::ffi::c_char,
        tlen: ::core::ffi::c_int,
        ins_c: ::core::ffi::c_int,
        del_c: ::core::ffi::c_int,
        sub_c: ::core::ffi::c_int,
        trusted: bool,
    ) -> ::core::ffi::c_int;
    pub fn varstr_levenshtein_less_equal(
        source: *const ::core::ffi::c_char,
        slen: ::core::ffi::c_int,
        target: *const ::core::ffi::c_char,
        tlen: ::core::ffi::c_int,
        ins_c: ::core::ffi::c_int,
        del_c: ::core::ffi::c_int,
        sub_c: ::core::ffi::c_int,
        max_d: ::core::ffi::c_int,
        trusted: bool,
    ) -> ::core::ffi::c_int;
    pub fn textToQualifiedNameList(textval: *mut text) -> *mut List;
    pub fn SplitIdentifierString(
        rawstring: *mut ::core::ffi::c_char,
        separator: ::core::ffi::c_char,
        namelist: *mut *mut List,
    ) -> bool;
    pub fn SplitDirectoriesString(
        rawstring: *mut ::core::ffi::c_char,
        separator: ::core::ffi::c_char,
        namelist: *mut *mut List,
    ) -> bool;
    pub fn SplitGUCList(
        rawstring: *mut ::core::ffi::c_char,
        separator: ::core::ffi::c_char,
        namelist: *mut *mut List,
    ) -> bool;
    pub fn replace_text_regexp(
        src_text: *mut text,
        pattern_text: *mut text,
        replace_text: *mut text,
        cflags: ::core::ffi::c_int,
        collation: Oid,
        search_start: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
    ) -> *mut text;
    pub fn initClosestMatch(
        state: *mut ClosestMatchState,
        source: *const ::core::ffi::c_char,
        max_d: ::core::ffi::c_int,
    );
    pub fn updateClosestMatch(state: *mut ClosestMatchState, candidate: *const ::core::ffi::c_char);
    pub fn getClosestMatch(state: *mut ClosestMatchState) -> *const ::core::ffi::c_char;
}
#[deprecated(since = "0.12.0", note = "you want pg_sys::A_Expr_Kind::AEXPR_OP")]
pub const A_Expr_Kind_AEXPR_OP: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::A_Expr_Kind::AEXPR_OP_ANY")]
pub const A_Expr_Kind_AEXPR_OP_ANY: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::A_Expr_Kind::AEXPR_OP_ALL")]
pub const A_Expr_Kind_AEXPR_OP_ALL: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::A_Expr_Kind::AEXPR_DISTINCT")]
pub const A_Expr_Kind_AEXPR_DISTINCT: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::A_Expr_Kind::AEXPR_NOT_DISTINCT")]
pub const A_Expr_Kind_AEXPR_NOT_DISTINCT: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::A_Expr_Kind::AEXPR_NULLIF")]
pub const A_Expr_Kind_AEXPR_NULLIF: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::A_Expr_Kind::AEXPR_IN")]
pub const A_Expr_Kind_AEXPR_IN: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::A_Expr_Kind::AEXPR_LIKE")]
pub const A_Expr_Kind_AEXPR_LIKE: u32 = 7;
#[deprecated(since = "0.12.0", note = "you want pg_sys::A_Expr_Kind::AEXPR_ILIKE")]
pub const A_Expr_Kind_AEXPR_ILIKE: u32 = 8;
#[deprecated(since = "0.12.0", note = "you want pg_sys::A_Expr_Kind::AEXPR_SIMILAR")]
pub const A_Expr_Kind_AEXPR_SIMILAR: u32 = 9;
#[deprecated(since = "0.12.0", note = "you want pg_sys::A_Expr_Kind::AEXPR_BETWEEN")]
pub const A_Expr_Kind_AEXPR_BETWEEN: u32 = 10;
#[deprecated(since = "0.12.0", note = "you want pg_sys::A_Expr_Kind::AEXPR_NOT_BETWEEN")]
pub const A_Expr_Kind_AEXPR_NOT_BETWEEN: u32 = 11;
#[deprecated(since = "0.12.0", note = "you want pg_sys::A_Expr_Kind::AEXPR_BETWEEN_SYM")]
pub const A_Expr_Kind_AEXPR_BETWEEN_SYM: u32 = 12;
#[deprecated(since = "0.12.0", note = "you want pg_sys::A_Expr_Kind::AEXPR_NOT_BETWEEN_SYM")]
pub const A_Expr_Kind_AEXPR_NOT_BETWEEN_SYM: u32 = 13;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AclMaskHow::ACLMASK_ALL")]
pub const AclMaskHow_ACLMASK_ALL: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AclMaskHow::ACLMASK_ANY")]
pub const AclMaskHow_ACLMASK_ANY: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AclResult::ACLCHECK_OK")]
pub const AclResult_ACLCHECK_OK: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AclResult::ACLCHECK_NO_PRIV")]
pub const AclResult_ACLCHECK_NO_PRIV: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AclResult::ACLCHECK_NOT_OWNER")]
pub const AclResult_ACLCHECK_NOT_OWNER: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AggSplit::AGGSPLIT_SIMPLE")]
pub const AggSplit_AGGSPLIT_SIMPLE: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AggSplit::AGGSPLIT_INITIAL_SERIAL")]
pub const AggSplit_AGGSPLIT_INITIAL_SERIAL: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AggSplit::AGGSPLIT_FINAL_DESERIAL")]
pub const AggSplit_AGGSPLIT_FINAL_DESERIAL: u32 = 9;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AggStrategy::AGG_PLAIN")]
pub const AggStrategy_AGG_PLAIN: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AggStrategy::AGG_SORTED")]
pub const AggStrategy_AGG_SORTED: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AggStrategy::AGG_HASHED")]
pub const AggStrategy_AGG_HASHED: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AggStrategy::AGG_MIXED")]
pub const AggStrategy_AGG_MIXED: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterPublicationAction::AP_AddObjects")]
pub const AlterPublicationAction_AP_AddObjects: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterPublicationAction::AP_DropObjects")]
pub const AlterPublicationAction_AP_DropObjects: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterPublicationAction::AP_SetObjects")]
pub const AlterPublicationAction_AP_SetObjects: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::AlterSubscriptionType::ALTER_SUBSCRIPTION_OPTIONS"
)]
pub const AlterSubscriptionType_ALTER_SUBSCRIPTION_OPTIONS: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::AlterSubscriptionType::ALTER_SUBSCRIPTION_CONNECTION"
)]
pub const AlterSubscriptionType_ALTER_SUBSCRIPTION_CONNECTION: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::AlterSubscriptionType::ALTER_SUBSCRIPTION_SET_PUBLICATION"
)]
pub const AlterSubscriptionType_ALTER_SUBSCRIPTION_SET_PUBLICATION: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::AlterSubscriptionType::ALTER_SUBSCRIPTION_ADD_PUBLICATION"
)]
pub const AlterSubscriptionType_ALTER_SUBSCRIPTION_ADD_PUBLICATION: u32 = 3;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::AlterSubscriptionType::ALTER_SUBSCRIPTION_DROP_PUBLICATION"
)]
pub const AlterSubscriptionType_ALTER_SUBSCRIPTION_DROP_PUBLICATION: u32 = 4;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::AlterSubscriptionType::ALTER_SUBSCRIPTION_REFRESH"
)]
pub const AlterSubscriptionType_ALTER_SUBSCRIPTION_REFRESH: u32 = 5;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::AlterSubscriptionType::ALTER_SUBSCRIPTION_ENABLED"
)]
pub const AlterSubscriptionType_ALTER_SUBSCRIPTION_ENABLED: u32 = 6;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::AlterSubscriptionType::ALTER_SUBSCRIPTION_SKIP"
)]
pub const AlterSubscriptionType_ALTER_SUBSCRIPTION_SKIP: u32 = 7;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::AlterTSConfigType::ALTER_TSCONFIG_ADD_MAPPING"
)]
pub const AlterTSConfigType_ALTER_TSCONFIG_ADD_MAPPING: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::AlterTSConfigType::ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN"
)]
pub const AlterTSConfigType_ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::AlterTSConfigType::ALTER_TSCONFIG_REPLACE_DICT"
)]
pub const AlterTSConfigType_ALTER_TSCONFIG_REPLACE_DICT: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::AlterTSConfigType::ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN"
)]
pub const AlterTSConfigType_ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN: u32 = 3;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::AlterTSConfigType::ALTER_TSCONFIG_DROP_MAPPING"
)]
pub const AlterTSConfigType_ALTER_TSCONFIG_DROP_MAPPING: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_AddColumn")]
pub const AlterTableType_AT_AddColumn: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_AddColumnToView")]
pub const AlterTableType_AT_AddColumnToView: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_ColumnDefault")]
pub const AlterTableType_AT_ColumnDefault: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_CookedColumnDefault")]
pub const AlterTableType_AT_CookedColumnDefault: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_DropNotNull")]
pub const AlterTableType_AT_DropNotNull: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_SetNotNull")]
pub const AlterTableType_AT_SetNotNull: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_SetExpression")]
pub const AlterTableType_AT_SetExpression: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_DropExpression")]
pub const AlterTableType_AT_DropExpression: u32 = 7;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_CheckNotNull")]
pub const AlterTableType_AT_CheckNotNull: u32 = 8;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_SetStatistics")]
pub const AlterTableType_AT_SetStatistics: u32 = 9;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_SetOptions")]
pub const AlterTableType_AT_SetOptions: u32 = 10;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_ResetOptions")]
pub const AlterTableType_AT_ResetOptions: u32 = 11;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_SetStorage")]
pub const AlterTableType_AT_SetStorage: u32 = 12;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_SetCompression")]
pub const AlterTableType_AT_SetCompression: u32 = 13;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_DropColumn")]
pub const AlterTableType_AT_DropColumn: u32 = 14;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_AddIndex")]
pub const AlterTableType_AT_AddIndex: u32 = 15;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_ReAddIndex")]
pub const AlterTableType_AT_ReAddIndex: u32 = 16;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_AddConstraint")]
pub const AlterTableType_AT_AddConstraint: u32 = 17;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_ReAddConstraint")]
pub const AlterTableType_AT_ReAddConstraint: u32 = 18;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_ReAddDomainConstraint")]
pub const AlterTableType_AT_ReAddDomainConstraint: u32 = 19;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_AlterConstraint")]
pub const AlterTableType_AT_AlterConstraint: u32 = 20;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_ValidateConstraint")]
pub const AlterTableType_AT_ValidateConstraint: u32 = 21;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_AddIndexConstraint")]
pub const AlterTableType_AT_AddIndexConstraint: u32 = 22;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_DropConstraint")]
pub const AlterTableType_AT_DropConstraint: u32 = 23;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_ReAddComment")]
pub const AlterTableType_AT_ReAddComment: u32 = 24;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_AlterColumnType")]
pub const AlterTableType_AT_AlterColumnType: u32 = 25;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::AlterTableType::AT_AlterColumnGenericOptions"
)]
pub const AlterTableType_AT_AlterColumnGenericOptions: u32 = 26;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_ChangeOwner")]
pub const AlterTableType_AT_ChangeOwner: u32 = 27;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_ClusterOn")]
pub const AlterTableType_AT_ClusterOn: u32 = 28;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_DropCluster")]
pub const AlterTableType_AT_DropCluster: u32 = 29;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_SetLogged")]
pub const AlterTableType_AT_SetLogged: u32 = 30;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_SetUnLogged")]
pub const AlterTableType_AT_SetUnLogged: u32 = 31;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_DropOids")]
pub const AlterTableType_AT_DropOids: u32 = 32;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_SetAccessMethod")]
pub const AlterTableType_AT_SetAccessMethod: u32 = 33;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_SetTableSpace")]
pub const AlterTableType_AT_SetTableSpace: u32 = 34;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_SetRelOptions")]
pub const AlterTableType_AT_SetRelOptions: u32 = 35;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_ResetRelOptions")]
pub const AlterTableType_AT_ResetRelOptions: u32 = 36;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_ReplaceRelOptions")]
pub const AlterTableType_AT_ReplaceRelOptions: u32 = 37;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_EnableTrig")]
pub const AlterTableType_AT_EnableTrig: u32 = 38;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_EnableAlwaysTrig")]
pub const AlterTableType_AT_EnableAlwaysTrig: u32 = 39;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_EnableReplicaTrig")]
pub const AlterTableType_AT_EnableReplicaTrig: u32 = 40;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_DisableTrig")]
pub const AlterTableType_AT_DisableTrig: u32 = 41;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_EnableTrigAll")]
pub const AlterTableType_AT_EnableTrigAll: u32 = 42;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_DisableTrigAll")]
pub const AlterTableType_AT_DisableTrigAll: u32 = 43;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_EnableTrigUser")]
pub const AlterTableType_AT_EnableTrigUser: u32 = 44;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_DisableTrigUser")]
pub const AlterTableType_AT_DisableTrigUser: u32 = 45;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_EnableRule")]
pub const AlterTableType_AT_EnableRule: u32 = 46;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_EnableAlwaysRule")]
pub const AlterTableType_AT_EnableAlwaysRule: u32 = 47;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_EnableReplicaRule")]
pub const AlterTableType_AT_EnableReplicaRule: u32 = 48;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_DisableRule")]
pub const AlterTableType_AT_DisableRule: u32 = 49;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_AddInherit")]
pub const AlterTableType_AT_AddInherit: u32 = 50;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_DropInherit")]
pub const AlterTableType_AT_DropInherit: u32 = 51;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_AddOf")]
pub const AlterTableType_AT_AddOf: u32 = 52;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_DropOf")]
pub const AlterTableType_AT_DropOf: u32 = 53;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_ReplicaIdentity")]
pub const AlterTableType_AT_ReplicaIdentity: u32 = 54;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_EnableRowSecurity")]
pub const AlterTableType_AT_EnableRowSecurity: u32 = 55;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_DisableRowSecurity")]
pub const AlterTableType_AT_DisableRowSecurity: u32 = 56;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_ForceRowSecurity")]
pub const AlterTableType_AT_ForceRowSecurity: u32 = 57;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_NoForceRowSecurity")]
pub const AlterTableType_AT_NoForceRowSecurity: u32 = 58;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_GenericOptions")]
pub const AlterTableType_AT_GenericOptions: u32 = 59;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_AttachPartition")]
pub const AlterTableType_AT_AttachPartition: u32 = 60;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_DetachPartition")]
pub const AlterTableType_AT_DetachPartition: u32 = 61;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::AlterTableType::AT_DetachPartitionFinalize"
)]
pub const AlterTableType_AT_DetachPartitionFinalize: u32 = 62;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_AddIdentity")]
pub const AlterTableType_AT_AddIdentity: u32 = 63;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_SetIdentity")]
pub const AlterTableType_AT_SetIdentity: u32 = 64;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_DropIdentity")]
pub const AlterTableType_AT_DropIdentity: u32 = 65;
#[deprecated(since = "0.12.0", note = "you want pg_sys::AlterTableType::AT_ReAddStatistics")]
pub const AlterTableType_AT_ReAddStatistics: u32 = 66;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ArchiveMode::ARCHIVE_MODE_OFF")]
pub const ArchiveMode_ARCHIVE_MODE_OFF: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ArchiveMode::ARCHIVE_MODE_ON")]
pub const ArchiveMode_ARCHIVE_MODE_ON: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ArchiveMode::ARCHIVE_MODE_ALWAYS")]
pub const ArchiveMode_ARCHIVE_MODE_ALWAYS: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BMS_Comparison::BMS_EQUAL")]
pub const BMS_Comparison_BMS_EQUAL: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BMS_Comparison::BMS_SUBSET1")]
pub const BMS_Comparison_BMS_SUBSET1: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BMS_Comparison::BMS_SUBSET2")]
pub const BMS_Comparison_BMS_SUBSET2: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BMS_Comparison::BMS_DIFFERENT")]
pub const BMS_Comparison_BMS_DIFFERENT: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BMS_Membership::BMS_EMPTY_SET")]
pub const BMS_Membership_BMS_EMPTY_SET: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BMS_Membership::BMS_SINGLETON")]
pub const BMS_Membership_BMS_SINGLETON: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BMS_Membership::BMS_MULTIPLE")]
pub const BMS_Membership_BMS_MULTIPLE: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BackendState::STATE_UNDEFINED")]
pub const BackendState_STATE_UNDEFINED: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BackendState::STATE_IDLE")]
pub const BackendState_STATE_IDLE: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BackendState::STATE_RUNNING")]
pub const BackendState_STATE_RUNNING: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BackendState::STATE_IDLEINTRANSACTION")]
pub const BackendState_STATE_IDLEINTRANSACTION: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BackendState::STATE_FASTPATH")]
pub const BackendState_STATE_FASTPATH: u32 = 4;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BackendState::STATE_IDLEINTRANSACTION_ABORTED"
)]
pub const BackendState_STATE_IDLEINTRANSACTION_ABORTED: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BackendState::STATE_DISABLED")]
pub const BackendState_STATE_DISABLED: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BackendType::B_INVALID")]
pub const BackendType_B_INVALID: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BackendType::B_BACKEND")]
pub const BackendType_B_BACKEND: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BackendType::B_AUTOVAC_LAUNCHER")]
pub const BackendType_B_AUTOVAC_LAUNCHER: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BackendType::B_AUTOVAC_WORKER")]
pub const BackendType_B_AUTOVAC_WORKER: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BackendType::B_BG_WORKER")]
pub const BackendType_B_BG_WORKER: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BackendType::B_WAL_SENDER")]
pub const BackendType_B_WAL_SENDER: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BackendType::B_SLOTSYNC_WORKER")]
pub const BackendType_B_SLOTSYNC_WORKER: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BackendType::B_STANDALONE_BACKEND")]
pub const BackendType_B_STANDALONE_BACKEND: u32 = 7;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BackendType::B_ARCHIVER")]
pub const BackendType_B_ARCHIVER: u32 = 8;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BackendType::B_BG_WRITER")]
pub const BackendType_B_BG_WRITER: u32 = 9;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BackendType::B_CHECKPOINTER")]
pub const BackendType_B_CHECKPOINTER: u32 = 10;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BackendType::B_STARTUP")]
pub const BackendType_B_STARTUP: u32 = 11;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BackendType::B_WAL_RECEIVER")]
pub const BackendType_B_WAL_RECEIVER: u32 = 12;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BackendType::B_WAL_SUMMARIZER")]
pub const BackendType_B_WAL_SUMMARIZER: u32 = 13;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BackendType::B_WAL_WRITER")]
pub const BackendType_B_WAL_WRITER: u32 = 14;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BackendType::B_LOGGER")]
pub const BackendType_B_LOGGER: u32 = 15;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BackslashQuoteType::BACKSLASH_QUOTE_OFF")]
pub const BackslashQuoteType_BACKSLASH_QUOTE_OFF: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BackslashQuoteType::BACKSLASH_QUOTE_ON")]
pub const BackslashQuoteType_BACKSLASH_QUOTE_ON: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BackslashQuoteType::BACKSLASH_QUOTE_SAFE_ENCODING"
)]
pub const BackslashQuoteType_BACKSLASH_QUOTE_SAFE_ENCODING: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BgWorkerStartTime::BgWorkerStart_PostmasterStart"
)]
pub const BgWorkerStartTime_BgWorkerStart_PostmasterStart: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BgWorkerStartTime::BgWorkerStart_ConsistentState"
)]
pub const BgWorkerStartTime_BgWorkerStart_ConsistentState: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BgWorkerStartTime::BgWorkerStart_RecoveryFinished"
)]
pub const BgWorkerStartTime_BgWorkerStart_RecoveryFinished: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BgwHandleStatus::BGWH_STARTED")]
pub const BgwHandleStatus_BGWH_STARTED: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BgwHandleStatus::BGWH_NOT_YET_STARTED")]
pub const BgwHandleStatus_BGWH_NOT_YET_STARTED: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BgwHandleStatus::BGWH_STOPPED")]
pub const BgwHandleStatus_BGWH_STOPPED: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BgwHandleStatus::BGWH_POSTMASTER_DIED")]
pub const BgwHandleStatus_BGWH_POSTMASTER_DIED: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BoolExprType::AND_EXPR")]
pub const BoolExprType_AND_EXPR: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BoolExprType::OR_EXPR")]
pub const BoolExprType_OR_EXPR: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BoolExprType::NOT_EXPR")]
pub const BoolExprType_NOT_EXPR: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BoolTestType::IS_TRUE")]
pub const BoolTestType_IS_TRUE: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BoolTestType::IS_NOT_TRUE")]
pub const BoolTestType_IS_NOT_TRUE: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BoolTestType::IS_FALSE")]
pub const BoolTestType_IS_FALSE: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BoolTestType::IS_NOT_FALSE")]
pub const BoolTestType_IS_NOT_FALSE: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BoolTestType::IS_UNKNOWN")]
pub const BoolTestType_IS_UNKNOWN: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BoolTestType::IS_NOT_UNKNOWN")]
pub const BoolTestType_IS_NOT_UNKNOWN: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BufferAccessStrategyType::BAS_NORMAL")]
pub const BufferAccessStrategyType_BAS_NORMAL: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BufferAccessStrategyType::BAS_BULKREAD")]
pub const BufferAccessStrategyType_BAS_BULKREAD: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BufferAccessStrategyType::BAS_BULKWRITE")]
pub const BufferAccessStrategyType_BAS_BULKWRITE: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BufferAccessStrategyType::BAS_VACUUM")]
pub const BufferAccessStrategyType_BAS_VACUUM: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_XACT_BUFFER")]
pub const BuiltinTrancheIds_LWTRANCHE_XACT_BUFFER: u32 = 53;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_COMMITTS_BUFFER"
)]
pub const BuiltinTrancheIds_LWTRANCHE_COMMITTS_BUFFER: u32 = 54;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_SUBTRANS_BUFFER"
)]
pub const BuiltinTrancheIds_LWTRANCHE_SUBTRANS_BUFFER: u32 = 55;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_MULTIXACTOFFSET_BUFFER"
)]
pub const BuiltinTrancheIds_LWTRANCHE_MULTIXACTOFFSET_BUFFER: u32 = 56;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_MULTIXACTMEMBER_BUFFER"
)]
pub const BuiltinTrancheIds_LWTRANCHE_MULTIXACTMEMBER_BUFFER: u32 = 57;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_NOTIFY_BUFFER"
)]
pub const BuiltinTrancheIds_LWTRANCHE_NOTIFY_BUFFER: u32 = 58;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_SERIAL_BUFFER"
)]
pub const BuiltinTrancheIds_LWTRANCHE_SERIAL_BUFFER: u32 = 59;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_WAL_INSERT")]
pub const BuiltinTrancheIds_LWTRANCHE_WAL_INSERT: u32 = 60;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_BUFFER_CONTENT"
)]
pub const BuiltinTrancheIds_LWTRANCHE_BUFFER_CONTENT: u32 = 61;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_REPLICATION_ORIGIN_STATE"
)]
pub const BuiltinTrancheIds_LWTRANCHE_REPLICATION_ORIGIN_STATE: u32 = 62;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_REPLICATION_SLOT_IO"
)]
pub const BuiltinTrancheIds_LWTRANCHE_REPLICATION_SLOT_IO: u32 = 63;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_LOCK_FASTPATH"
)]
pub const BuiltinTrancheIds_LWTRANCHE_LOCK_FASTPATH: u32 = 64;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_BUFFER_MAPPING"
)]
pub const BuiltinTrancheIds_LWTRANCHE_BUFFER_MAPPING: u32 = 65;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_LOCK_MANAGER")]
pub const BuiltinTrancheIds_LWTRANCHE_LOCK_MANAGER: u32 = 66;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_PREDICATE_LOCK_MANAGER"
)]
pub const BuiltinTrancheIds_LWTRANCHE_PREDICATE_LOCK_MANAGER: u32 = 67;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_PARALLEL_HASH_JOIN"
)]
pub const BuiltinTrancheIds_LWTRANCHE_PARALLEL_HASH_JOIN: u32 = 68;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_PARALLEL_QUERY_DSA"
)]
pub const BuiltinTrancheIds_LWTRANCHE_PARALLEL_QUERY_DSA: u32 = 69;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_PER_SESSION_DSA"
)]
pub const BuiltinTrancheIds_LWTRANCHE_PER_SESSION_DSA: u32 = 70;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_PER_SESSION_RECORD_TYPE"
)]
pub const BuiltinTrancheIds_LWTRANCHE_PER_SESSION_RECORD_TYPE: u32 = 71;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_PER_SESSION_RECORD_TYPMOD"
)]
pub const BuiltinTrancheIds_LWTRANCHE_PER_SESSION_RECORD_TYPMOD: u32 = 72;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_SHARED_TUPLESTORE"
)]
pub const BuiltinTrancheIds_LWTRANCHE_SHARED_TUPLESTORE: u32 = 73;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_SHARED_TIDBITMAP"
)]
pub const BuiltinTrancheIds_LWTRANCHE_SHARED_TIDBITMAP: u32 = 74;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_PARALLEL_APPEND"
)]
pub const BuiltinTrancheIds_LWTRANCHE_PARALLEL_APPEND: u32 = 75;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_PER_XACT_PREDICATE_LIST"
)]
pub const BuiltinTrancheIds_LWTRANCHE_PER_XACT_PREDICATE_LIST: u32 = 76;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_PGSTATS_DSA")]
pub const BuiltinTrancheIds_LWTRANCHE_PGSTATS_DSA: u32 = 77;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_PGSTATS_HASH")]
pub const BuiltinTrancheIds_LWTRANCHE_PGSTATS_HASH: u32 = 78;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_PGSTATS_DATA")]
pub const BuiltinTrancheIds_LWTRANCHE_PGSTATS_DATA: u32 = 79;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_LAUNCHER_DSA")]
pub const BuiltinTrancheIds_LWTRANCHE_LAUNCHER_DSA: u32 = 80;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_LAUNCHER_HASH"
)]
pub const BuiltinTrancheIds_LWTRANCHE_LAUNCHER_HASH: u32 = 81;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_DSM_REGISTRY_DSA"
)]
pub const BuiltinTrancheIds_LWTRANCHE_DSM_REGISTRY_DSA: u32 = 82;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_DSM_REGISTRY_HASH"
)]
pub const BuiltinTrancheIds_LWTRANCHE_DSM_REGISTRY_HASH: u32 = 83;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_COMMITTS_SLRU"
)]
pub const BuiltinTrancheIds_LWTRANCHE_COMMITTS_SLRU: u32 = 84;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_MULTIXACTMEMBER_SLRU"
)]
pub const BuiltinTrancheIds_LWTRANCHE_MULTIXACTMEMBER_SLRU: u32 = 85;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_MULTIXACTOFFSET_SLRU"
)]
pub const BuiltinTrancheIds_LWTRANCHE_MULTIXACTOFFSET_SLRU: u32 = 86;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_NOTIFY_SLRU")]
pub const BuiltinTrancheIds_LWTRANCHE_NOTIFY_SLRU: u32 = 87;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_SERIAL_SLRU")]
pub const BuiltinTrancheIds_LWTRANCHE_SERIAL_SLRU: u32 = 88;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_SUBTRANS_SLRU"
)]
pub const BuiltinTrancheIds_LWTRANCHE_SUBTRANS_SLRU: u32 = 89;
#[deprecated(since = "0.12.0", note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_XACT_SLRU")]
pub const BuiltinTrancheIds_LWTRANCHE_XACT_SLRU: u32 = 90;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_PARALLEL_VACUUM_DSA"
)]
pub const BuiltinTrancheIds_LWTRANCHE_PARALLEL_VACUUM_DSA: u32 = 91;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::BuiltinTrancheIds::LWTRANCHE_FIRST_USER_DEFINED"
)]
pub const BuiltinTrancheIds_LWTRANCHE_FIRST_USER_DEFINED: u32 = 92;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CRSSnapshotAction::CRS_EXPORT_SNAPSHOT")]
pub const CRSSnapshotAction_CRS_EXPORT_SNAPSHOT: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CRSSnapshotAction::CRS_NOEXPORT_SNAPSHOT")]
pub const CRSSnapshotAction_CRS_NOEXPORT_SNAPSHOT: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CRSSnapshotAction::CRS_USE_SNAPSHOT")]
pub const CRSSnapshotAction_CRS_USE_SNAPSHOT: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CTEMaterialize::CTEMaterializeDefault")]
pub const CTEMaterialize_CTEMaterializeDefault: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CTEMaterialize::CTEMaterializeAlways")]
pub const CTEMaterialize_CTEMaterializeAlways: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CTEMaterialize::CTEMaterializeNever")]
pub const CTEMaterialize_CTEMaterializeNever: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CheckEnableRlsResult::RLS_NONE")]
pub const CheckEnableRlsResult_RLS_NONE: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CheckEnableRlsResult::RLS_NONE_ENV")]
pub const CheckEnableRlsResult_RLS_NONE_ENV: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CheckEnableRlsResult::RLS_ENABLED")]
pub const CheckEnableRlsResult_RLS_ENABLED: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CmdType::CMD_UNKNOWN")]
pub const CmdType_CMD_UNKNOWN: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CmdType::CMD_SELECT")]
pub const CmdType_CMD_SELECT: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CmdType::CMD_UPDATE")]
pub const CmdType_CMD_UPDATE: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CmdType::CMD_INSERT")]
pub const CmdType_CMD_INSERT: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CmdType::CMD_DELETE")]
pub const CmdType_CMD_DELETE: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CmdType::CMD_MERGE")]
pub const CmdType_CMD_MERGE: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CmdType::CMD_UTILITY")]
pub const CmdType_CMD_UTILITY: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CmdType::CMD_NOTHING")]
pub const CmdType_CMD_NOTHING: u32 = 7;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CoercionContext::COERCION_IMPLICIT")]
pub const CoercionContext_COERCION_IMPLICIT: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CoercionContext::COERCION_ASSIGNMENT")]
pub const CoercionContext_COERCION_ASSIGNMENT: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CoercionContext::COERCION_PLPGSQL")]
pub const CoercionContext_COERCION_PLPGSQL: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CoercionContext::COERCION_EXPLICIT")]
pub const CoercionContext_COERCION_EXPLICIT: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CoercionForm::COERCE_EXPLICIT_CALL")]
pub const CoercionForm_COERCE_EXPLICIT_CALL: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CoercionForm::COERCE_EXPLICIT_CAST")]
pub const CoercionForm_COERCE_EXPLICIT_CAST: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CoercionForm::COERCE_IMPLICIT_CAST")]
pub const CoercionForm_COERCE_IMPLICIT_CAST: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CoercionForm::COERCE_SQL_SYNTAX")]
pub const CoercionForm_COERCE_SQL_SYNTAX: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CoercionPathType::COERCION_PATH_NONE")]
pub const CoercionPathType_COERCION_PATH_NONE: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CoercionPathType::COERCION_PATH_FUNC")]
pub const CoercionPathType_COERCION_PATH_FUNC: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::CoercionPathType::COERCION_PATH_RELABELTYPE"
)]
pub const CoercionPathType_COERCION_PATH_RELABELTYPE: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::CoercionPathType::COERCION_PATH_ARRAYCOERCE"
)]
pub const CoercionPathType_COERCION_PATH_ARRAYCOERCE: u32 = 3;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::CoercionPathType::COERCION_PATH_COERCEVIAIO"
)]
pub const CoercionPathType_COERCION_PATH_COERCEVIAIO: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CollectedCommandType::SCT_Simple")]
pub const CollectedCommandType_SCT_Simple: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CollectedCommandType::SCT_AlterTable")]
pub const CollectedCommandType_SCT_AlterTable: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CollectedCommandType::SCT_Grant")]
pub const CollectedCommandType_SCT_Grant: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CollectedCommandType::SCT_AlterOpFamily")]
pub const CollectedCommandType_SCT_AlterOpFamily: u32 = 3;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::CollectedCommandType::SCT_AlterDefaultPrivileges"
)]
pub const CollectedCommandType_SCT_AlterDefaultPrivileges: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CollectedCommandType::SCT_CreateOpClass")]
pub const CollectedCommandType_SCT_CreateOpClass: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CollectedCommandType::SCT_AlterTSConfig")]
pub const CollectedCommandType_SCT_AlterTSConfig: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandDest::DestNone")]
pub const CommandDest_DestNone: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandDest::DestDebug")]
pub const CommandDest_DestDebug: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandDest::DestRemote")]
pub const CommandDest_DestRemote: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandDest::DestRemoteExecute")]
pub const CommandDest_DestRemoteExecute: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandDest::DestRemoteSimple")]
pub const CommandDest_DestRemoteSimple: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandDest::DestSPI")]
pub const CommandDest_DestSPI: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandDest::DestTuplestore")]
pub const CommandDest_DestTuplestore: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandDest::DestIntoRel")]
pub const CommandDest_DestIntoRel: u32 = 7;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandDest::DestCopyOut")]
pub const CommandDest_DestCopyOut: u32 = 8;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandDest::DestSQLFunction")]
pub const CommandDest_DestSQLFunction: u32 = 9;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandDest::DestTransientRel")]
pub const CommandDest_DestTransientRel: u32 = 10;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandDest::DestTupleQueue")]
pub const CommandDest_DestTupleQueue: u32 = 11;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandDest::DestExplainSerialize")]
pub const CommandDest_DestExplainSerialize: u32 = 12;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_UNKNOWN")]
pub const CommandTag_CMDTAG_UNKNOWN: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_ACCESS_METHOD")]
pub const CommandTag_CMDTAG_ALTER_ACCESS_METHOD: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_AGGREGATE")]
pub const CommandTag_CMDTAG_ALTER_AGGREGATE: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_CAST")]
pub const CommandTag_CMDTAG_ALTER_CAST: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_COLLATION")]
pub const CommandTag_CMDTAG_ALTER_COLLATION: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_CONSTRAINT")]
pub const CommandTag_CMDTAG_ALTER_CONSTRAINT: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_CONVERSION")]
pub const CommandTag_CMDTAG_ALTER_CONVERSION: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_DATABASE")]
pub const CommandTag_CMDTAG_ALTER_DATABASE: u32 = 7;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::CommandTag::CMDTAG_ALTER_DEFAULT_PRIVILEGES"
)]
pub const CommandTag_CMDTAG_ALTER_DEFAULT_PRIVILEGES: u32 = 8;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_DOMAIN")]
pub const CommandTag_CMDTAG_ALTER_DOMAIN: u32 = 9;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_EVENT_TRIGGER")]
pub const CommandTag_CMDTAG_ALTER_EVENT_TRIGGER: u32 = 10;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_EXTENSION")]
pub const CommandTag_CMDTAG_ALTER_EXTENSION: u32 = 11;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::CommandTag::CMDTAG_ALTER_FOREIGN_DATA_WRAPPER"
)]
pub const CommandTag_CMDTAG_ALTER_FOREIGN_DATA_WRAPPER: u32 = 12;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_FOREIGN_TABLE")]
pub const CommandTag_CMDTAG_ALTER_FOREIGN_TABLE: u32 = 13;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_FUNCTION")]
pub const CommandTag_CMDTAG_ALTER_FUNCTION: u32 = 14;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_INDEX")]
pub const CommandTag_CMDTAG_ALTER_INDEX: u32 = 15;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_LANGUAGE")]
pub const CommandTag_CMDTAG_ALTER_LANGUAGE: u32 = 16;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_LARGE_OBJECT")]
pub const CommandTag_CMDTAG_ALTER_LARGE_OBJECT: u32 = 17;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::CommandTag::CMDTAG_ALTER_MATERIALIZED_VIEW"
)]
pub const CommandTag_CMDTAG_ALTER_MATERIALIZED_VIEW: u32 = 18;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_OPERATOR")]
pub const CommandTag_CMDTAG_ALTER_OPERATOR: u32 = 19;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_OPERATOR_CLASS")]
pub const CommandTag_CMDTAG_ALTER_OPERATOR_CLASS: u32 = 20;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_OPERATOR_FAMILY")]
pub const CommandTag_CMDTAG_ALTER_OPERATOR_FAMILY: u32 = 21;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_POLICY")]
pub const CommandTag_CMDTAG_ALTER_POLICY: u32 = 22;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_PROCEDURE")]
pub const CommandTag_CMDTAG_ALTER_PROCEDURE: u32 = 23;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_PUBLICATION")]
pub const CommandTag_CMDTAG_ALTER_PUBLICATION: u32 = 24;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_ROLE")]
pub const CommandTag_CMDTAG_ALTER_ROLE: u32 = 25;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_ROUTINE")]
pub const CommandTag_CMDTAG_ALTER_ROUTINE: u32 = 26;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_RULE")]
pub const CommandTag_CMDTAG_ALTER_RULE: u32 = 27;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_SCHEMA")]
pub const CommandTag_CMDTAG_ALTER_SCHEMA: u32 = 28;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_SEQUENCE")]
pub const CommandTag_CMDTAG_ALTER_SEQUENCE: u32 = 29;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_SERVER")]
pub const CommandTag_CMDTAG_ALTER_SERVER: u32 = 30;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_STATISTICS")]
pub const CommandTag_CMDTAG_ALTER_STATISTICS: u32 = 31;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_SUBSCRIPTION")]
pub const CommandTag_CMDTAG_ALTER_SUBSCRIPTION: u32 = 32;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_SYSTEM")]
pub const CommandTag_CMDTAG_ALTER_SYSTEM: u32 = 33;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_TABLE")]
pub const CommandTag_CMDTAG_ALTER_TABLE: u32 = 34;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_TABLESPACE")]
pub const CommandTag_CMDTAG_ALTER_TABLESPACE: u32 = 35;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::CommandTag::CMDTAG_ALTER_TEXT_SEARCH_CONFIGURATION"
)]
pub const CommandTag_CMDTAG_ALTER_TEXT_SEARCH_CONFIGURATION: u32 = 36;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::CommandTag::CMDTAG_ALTER_TEXT_SEARCH_DICTIONARY"
)]
pub const CommandTag_CMDTAG_ALTER_TEXT_SEARCH_DICTIONARY: u32 = 37;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::CommandTag::CMDTAG_ALTER_TEXT_SEARCH_PARSER"
)]
pub const CommandTag_CMDTAG_ALTER_TEXT_SEARCH_PARSER: u32 = 38;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::CommandTag::CMDTAG_ALTER_TEXT_SEARCH_TEMPLATE"
)]
pub const CommandTag_CMDTAG_ALTER_TEXT_SEARCH_TEMPLATE: u32 = 39;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_TRANSFORM")]
pub const CommandTag_CMDTAG_ALTER_TRANSFORM: u32 = 40;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_TRIGGER")]
pub const CommandTag_CMDTAG_ALTER_TRIGGER: u32 = 41;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_TYPE")]
pub const CommandTag_CMDTAG_ALTER_TYPE: u32 = 42;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_USER_MAPPING")]
pub const CommandTag_CMDTAG_ALTER_USER_MAPPING: u32 = 43;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ALTER_VIEW")]
pub const CommandTag_CMDTAG_ALTER_VIEW: u32 = 44;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ANALYZE")]
pub const CommandTag_CMDTAG_ANALYZE: u32 = 45;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_BEGIN")]
pub const CommandTag_CMDTAG_BEGIN: u32 = 46;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CALL")]
pub const CommandTag_CMDTAG_CALL: u32 = 47;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CHECKPOINT")]
pub const CommandTag_CMDTAG_CHECKPOINT: u32 = 48;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CLOSE")]
pub const CommandTag_CMDTAG_CLOSE: u32 = 49;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CLOSE_CURSOR")]
pub const CommandTag_CMDTAG_CLOSE_CURSOR: u32 = 50;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CLOSE_CURSOR_ALL")]
pub const CommandTag_CMDTAG_CLOSE_CURSOR_ALL: u32 = 51;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CLUSTER")]
pub const CommandTag_CMDTAG_CLUSTER: u32 = 52;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_COMMENT")]
pub const CommandTag_CMDTAG_COMMENT: u32 = 53;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_COMMIT")]
pub const CommandTag_CMDTAG_COMMIT: u32 = 54;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_COMMIT_PREPARED")]
pub const CommandTag_CMDTAG_COMMIT_PREPARED: u32 = 55;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_COPY")]
pub const CommandTag_CMDTAG_COPY: u32 = 56;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_COPY_FROM")]
pub const CommandTag_CMDTAG_COPY_FROM: u32 = 57;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_ACCESS_METHOD")]
pub const CommandTag_CMDTAG_CREATE_ACCESS_METHOD: u32 = 58;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_AGGREGATE")]
pub const CommandTag_CMDTAG_CREATE_AGGREGATE: u32 = 59;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_CAST")]
pub const CommandTag_CMDTAG_CREATE_CAST: u32 = 60;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_COLLATION")]
pub const CommandTag_CMDTAG_CREATE_COLLATION: u32 = 61;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_CONSTRAINT")]
pub const CommandTag_CMDTAG_CREATE_CONSTRAINT: u32 = 62;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_CONVERSION")]
pub const CommandTag_CMDTAG_CREATE_CONVERSION: u32 = 63;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_DATABASE")]
pub const CommandTag_CMDTAG_CREATE_DATABASE: u32 = 64;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_DOMAIN")]
pub const CommandTag_CMDTAG_CREATE_DOMAIN: u32 = 65;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_EVENT_TRIGGER")]
pub const CommandTag_CMDTAG_CREATE_EVENT_TRIGGER: u32 = 66;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_EXTENSION")]
pub const CommandTag_CMDTAG_CREATE_EXTENSION: u32 = 67;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::CommandTag::CMDTAG_CREATE_FOREIGN_DATA_WRAPPER"
)]
pub const CommandTag_CMDTAG_CREATE_FOREIGN_DATA_WRAPPER: u32 = 68;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_FOREIGN_TABLE")]
pub const CommandTag_CMDTAG_CREATE_FOREIGN_TABLE: u32 = 69;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_FUNCTION")]
pub const CommandTag_CMDTAG_CREATE_FUNCTION: u32 = 70;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_INDEX")]
pub const CommandTag_CMDTAG_CREATE_INDEX: u32 = 71;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_LANGUAGE")]
pub const CommandTag_CMDTAG_CREATE_LANGUAGE: u32 = 72;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::CommandTag::CMDTAG_CREATE_MATERIALIZED_VIEW"
)]
pub const CommandTag_CMDTAG_CREATE_MATERIALIZED_VIEW: u32 = 73;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_OPERATOR")]
pub const CommandTag_CMDTAG_CREATE_OPERATOR: u32 = 74;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_OPERATOR_CLASS")]
pub const CommandTag_CMDTAG_CREATE_OPERATOR_CLASS: u32 = 75;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_OPERATOR_FAMILY")]
pub const CommandTag_CMDTAG_CREATE_OPERATOR_FAMILY: u32 = 76;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_POLICY")]
pub const CommandTag_CMDTAG_CREATE_POLICY: u32 = 77;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_PROCEDURE")]
pub const CommandTag_CMDTAG_CREATE_PROCEDURE: u32 = 78;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_PUBLICATION")]
pub const CommandTag_CMDTAG_CREATE_PUBLICATION: u32 = 79;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_ROLE")]
pub const CommandTag_CMDTAG_CREATE_ROLE: u32 = 80;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_ROUTINE")]
pub const CommandTag_CMDTAG_CREATE_ROUTINE: u32 = 81;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_RULE")]
pub const CommandTag_CMDTAG_CREATE_RULE: u32 = 82;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_SCHEMA")]
pub const CommandTag_CMDTAG_CREATE_SCHEMA: u32 = 83;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_SEQUENCE")]
pub const CommandTag_CMDTAG_CREATE_SEQUENCE: u32 = 84;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_SERVER")]
pub const CommandTag_CMDTAG_CREATE_SERVER: u32 = 85;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_STATISTICS")]
pub const CommandTag_CMDTAG_CREATE_STATISTICS: u32 = 86;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_SUBSCRIPTION")]
pub const CommandTag_CMDTAG_CREATE_SUBSCRIPTION: u32 = 87;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_TABLE")]
pub const CommandTag_CMDTAG_CREATE_TABLE: u32 = 88;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_TABLE_AS")]
pub const CommandTag_CMDTAG_CREATE_TABLE_AS: u32 = 89;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_TABLESPACE")]
pub const CommandTag_CMDTAG_CREATE_TABLESPACE: u32 = 90;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::CommandTag::CMDTAG_CREATE_TEXT_SEARCH_CONFIGURATION"
)]
pub const CommandTag_CMDTAG_CREATE_TEXT_SEARCH_CONFIGURATION: u32 = 91;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::CommandTag::CMDTAG_CREATE_TEXT_SEARCH_DICTIONARY"
)]
pub const CommandTag_CMDTAG_CREATE_TEXT_SEARCH_DICTIONARY: u32 = 92;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::CommandTag::CMDTAG_CREATE_TEXT_SEARCH_PARSER"
)]
pub const CommandTag_CMDTAG_CREATE_TEXT_SEARCH_PARSER: u32 = 93;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::CommandTag::CMDTAG_CREATE_TEXT_SEARCH_TEMPLATE"
)]
pub const CommandTag_CMDTAG_CREATE_TEXT_SEARCH_TEMPLATE: u32 = 94;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_TRANSFORM")]
pub const CommandTag_CMDTAG_CREATE_TRANSFORM: u32 = 95;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_TRIGGER")]
pub const CommandTag_CMDTAG_CREATE_TRIGGER: u32 = 96;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_TYPE")]
pub const CommandTag_CMDTAG_CREATE_TYPE: u32 = 97;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_USER_MAPPING")]
pub const CommandTag_CMDTAG_CREATE_USER_MAPPING: u32 = 98;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_CREATE_VIEW")]
pub const CommandTag_CMDTAG_CREATE_VIEW: u32 = 99;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DEALLOCATE")]
pub const CommandTag_CMDTAG_DEALLOCATE: u32 = 100;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DEALLOCATE_ALL")]
pub const CommandTag_CMDTAG_DEALLOCATE_ALL: u32 = 101;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DECLARE_CURSOR")]
pub const CommandTag_CMDTAG_DECLARE_CURSOR: u32 = 102;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DELETE")]
pub const CommandTag_CMDTAG_DELETE: u32 = 103;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DISCARD")]
pub const CommandTag_CMDTAG_DISCARD: u32 = 104;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DISCARD_ALL")]
pub const CommandTag_CMDTAG_DISCARD_ALL: u32 = 105;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DISCARD_PLANS")]
pub const CommandTag_CMDTAG_DISCARD_PLANS: u32 = 106;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DISCARD_SEQUENCES")]
pub const CommandTag_CMDTAG_DISCARD_SEQUENCES: u32 = 107;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DISCARD_TEMP")]
pub const CommandTag_CMDTAG_DISCARD_TEMP: u32 = 108;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DO")]
pub const CommandTag_CMDTAG_DO: u32 = 109;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_ACCESS_METHOD")]
pub const CommandTag_CMDTAG_DROP_ACCESS_METHOD: u32 = 110;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_AGGREGATE")]
pub const CommandTag_CMDTAG_DROP_AGGREGATE: u32 = 111;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_CAST")]
pub const CommandTag_CMDTAG_DROP_CAST: u32 = 112;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_COLLATION")]
pub const CommandTag_CMDTAG_DROP_COLLATION: u32 = 113;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_CONSTRAINT")]
pub const CommandTag_CMDTAG_DROP_CONSTRAINT: u32 = 114;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_CONVERSION")]
pub const CommandTag_CMDTAG_DROP_CONVERSION: u32 = 115;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_DATABASE")]
pub const CommandTag_CMDTAG_DROP_DATABASE: u32 = 116;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_DOMAIN")]
pub const CommandTag_CMDTAG_DROP_DOMAIN: u32 = 117;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_EVENT_TRIGGER")]
pub const CommandTag_CMDTAG_DROP_EVENT_TRIGGER: u32 = 118;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_EXTENSION")]
pub const CommandTag_CMDTAG_DROP_EXTENSION: u32 = 119;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::CommandTag::CMDTAG_DROP_FOREIGN_DATA_WRAPPER"
)]
pub const CommandTag_CMDTAG_DROP_FOREIGN_DATA_WRAPPER: u32 = 120;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_FOREIGN_TABLE")]
pub const CommandTag_CMDTAG_DROP_FOREIGN_TABLE: u32 = 121;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_FUNCTION")]
pub const CommandTag_CMDTAG_DROP_FUNCTION: u32 = 122;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_INDEX")]
pub const CommandTag_CMDTAG_DROP_INDEX: u32 = 123;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_LANGUAGE")]
pub const CommandTag_CMDTAG_DROP_LANGUAGE: u32 = 124;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_MATERIALIZED_VIEW")]
pub const CommandTag_CMDTAG_DROP_MATERIALIZED_VIEW: u32 = 125;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_OPERATOR")]
pub const CommandTag_CMDTAG_DROP_OPERATOR: u32 = 126;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_OPERATOR_CLASS")]
pub const CommandTag_CMDTAG_DROP_OPERATOR_CLASS: u32 = 127;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_OPERATOR_FAMILY")]
pub const CommandTag_CMDTAG_DROP_OPERATOR_FAMILY: u32 = 128;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_OWNED")]
pub const CommandTag_CMDTAG_DROP_OWNED: u32 = 129;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_POLICY")]
pub const CommandTag_CMDTAG_DROP_POLICY: u32 = 130;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_PROCEDURE")]
pub const CommandTag_CMDTAG_DROP_PROCEDURE: u32 = 131;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_PUBLICATION")]
pub const CommandTag_CMDTAG_DROP_PUBLICATION: u32 = 132;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_ROLE")]
pub const CommandTag_CMDTAG_DROP_ROLE: u32 = 133;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_ROUTINE")]
pub const CommandTag_CMDTAG_DROP_ROUTINE: u32 = 134;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_RULE")]
pub const CommandTag_CMDTAG_DROP_RULE: u32 = 135;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_SCHEMA")]
pub const CommandTag_CMDTAG_DROP_SCHEMA: u32 = 136;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_SEQUENCE")]
pub const CommandTag_CMDTAG_DROP_SEQUENCE: u32 = 137;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_SERVER")]
pub const CommandTag_CMDTAG_DROP_SERVER: u32 = 138;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_STATISTICS")]
pub const CommandTag_CMDTAG_DROP_STATISTICS: u32 = 139;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_SUBSCRIPTION")]
pub const CommandTag_CMDTAG_DROP_SUBSCRIPTION: u32 = 140;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_TABLE")]
pub const CommandTag_CMDTAG_DROP_TABLE: u32 = 141;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_TABLESPACE")]
pub const CommandTag_CMDTAG_DROP_TABLESPACE: u32 = 142;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::CommandTag::CMDTAG_DROP_TEXT_SEARCH_CONFIGURATION"
)]
pub const CommandTag_CMDTAG_DROP_TEXT_SEARCH_CONFIGURATION: u32 = 143;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::CommandTag::CMDTAG_DROP_TEXT_SEARCH_DICTIONARY"
)]
pub const CommandTag_CMDTAG_DROP_TEXT_SEARCH_DICTIONARY: u32 = 144;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::CommandTag::CMDTAG_DROP_TEXT_SEARCH_PARSER"
)]
pub const CommandTag_CMDTAG_DROP_TEXT_SEARCH_PARSER: u32 = 145;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::CommandTag::CMDTAG_DROP_TEXT_SEARCH_TEMPLATE"
)]
pub const CommandTag_CMDTAG_DROP_TEXT_SEARCH_TEMPLATE: u32 = 146;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_TRANSFORM")]
pub const CommandTag_CMDTAG_DROP_TRANSFORM: u32 = 147;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_TRIGGER")]
pub const CommandTag_CMDTAG_DROP_TRIGGER: u32 = 148;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_TYPE")]
pub const CommandTag_CMDTAG_DROP_TYPE: u32 = 149;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_USER_MAPPING")]
pub const CommandTag_CMDTAG_DROP_USER_MAPPING: u32 = 150;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_DROP_VIEW")]
pub const CommandTag_CMDTAG_DROP_VIEW: u32 = 151;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_EXECUTE")]
pub const CommandTag_CMDTAG_EXECUTE: u32 = 152;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_EXPLAIN")]
pub const CommandTag_CMDTAG_EXPLAIN: u32 = 153;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_FETCH")]
pub const CommandTag_CMDTAG_FETCH: u32 = 154;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_GRANT")]
pub const CommandTag_CMDTAG_GRANT: u32 = 155;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_GRANT_ROLE")]
pub const CommandTag_CMDTAG_GRANT_ROLE: u32 = 156;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_IMPORT_FOREIGN_SCHEMA")]
pub const CommandTag_CMDTAG_IMPORT_FOREIGN_SCHEMA: u32 = 157;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_INSERT")]
pub const CommandTag_CMDTAG_INSERT: u32 = 158;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_LISTEN")]
pub const CommandTag_CMDTAG_LISTEN: u32 = 159;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_LOAD")]
pub const CommandTag_CMDTAG_LOAD: u32 = 160;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_LOCK_TABLE")]
pub const CommandTag_CMDTAG_LOCK_TABLE: u32 = 161;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_LOGIN")]
pub const CommandTag_CMDTAG_LOGIN: u32 = 162;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_MERGE")]
pub const CommandTag_CMDTAG_MERGE: u32 = 163;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_MOVE")]
pub const CommandTag_CMDTAG_MOVE: u32 = 164;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_NOTIFY")]
pub const CommandTag_CMDTAG_NOTIFY: u32 = 165;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_PREPARE")]
pub const CommandTag_CMDTAG_PREPARE: u32 = 166;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_PREPARE_TRANSACTION")]
pub const CommandTag_CMDTAG_PREPARE_TRANSACTION: u32 = 167;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_REASSIGN_OWNED")]
pub const CommandTag_CMDTAG_REASSIGN_OWNED: u32 = 168;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::CommandTag::CMDTAG_REFRESH_MATERIALIZED_VIEW"
)]
pub const CommandTag_CMDTAG_REFRESH_MATERIALIZED_VIEW: u32 = 169;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_REINDEX")]
pub const CommandTag_CMDTAG_REINDEX: u32 = 170;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_RELEASE")]
pub const CommandTag_CMDTAG_RELEASE: u32 = 171;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_RESET")]
pub const CommandTag_CMDTAG_RESET: u32 = 172;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_REVOKE")]
pub const CommandTag_CMDTAG_REVOKE: u32 = 173;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_REVOKE_ROLE")]
pub const CommandTag_CMDTAG_REVOKE_ROLE: u32 = 174;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ROLLBACK")]
pub const CommandTag_CMDTAG_ROLLBACK: u32 = 175;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_ROLLBACK_PREPARED")]
pub const CommandTag_CMDTAG_ROLLBACK_PREPARED: u32 = 176;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_SAVEPOINT")]
pub const CommandTag_CMDTAG_SAVEPOINT: u32 = 177;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_SECURITY_LABEL")]
pub const CommandTag_CMDTAG_SECURITY_LABEL: u32 = 178;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_SELECT")]
pub const CommandTag_CMDTAG_SELECT: u32 = 179;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_SELECT_FOR_KEY_SHARE")]
pub const CommandTag_CMDTAG_SELECT_FOR_KEY_SHARE: u32 = 180;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::CommandTag::CMDTAG_SELECT_FOR_NO_KEY_UPDATE"
)]
pub const CommandTag_CMDTAG_SELECT_FOR_NO_KEY_UPDATE: u32 = 181;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_SELECT_FOR_SHARE")]
pub const CommandTag_CMDTAG_SELECT_FOR_SHARE: u32 = 182;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_SELECT_FOR_UPDATE")]
pub const CommandTag_CMDTAG_SELECT_FOR_UPDATE: u32 = 183;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_SELECT_INTO")]
pub const CommandTag_CMDTAG_SELECT_INTO: u32 = 184;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_SET")]
pub const CommandTag_CMDTAG_SET: u32 = 185;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_SET_CONSTRAINTS")]
pub const CommandTag_CMDTAG_SET_CONSTRAINTS: u32 = 186;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_SHOW")]
pub const CommandTag_CMDTAG_SHOW: u32 = 187;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_START_TRANSACTION")]
pub const CommandTag_CMDTAG_START_TRANSACTION: u32 = 188;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_TRUNCATE_TABLE")]
pub const CommandTag_CMDTAG_TRUNCATE_TABLE: u32 = 189;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_UNLISTEN")]
pub const CommandTag_CMDTAG_UNLISTEN: u32 = 190;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_UPDATE")]
pub const CommandTag_CMDTAG_UPDATE: u32 = 191;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CommandTag::CMDTAG_VACUUM")]
pub const CommandTag_CMDTAG_VACUUM: u32 = 192;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ComputeQueryIdType::COMPUTE_QUERY_ID_OFF")]
pub const ComputeQueryIdType_COMPUTE_QUERY_ID_OFF: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ComputeQueryIdType::COMPUTE_QUERY_ID_ON")]
pub const ComputeQueryIdType_COMPUTE_QUERY_ID_ON: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ComputeQueryIdType::COMPUTE_QUERY_ID_AUTO")]
pub const ComputeQueryIdType_COMPUTE_QUERY_ID_AUTO: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ComputeQueryIdType::COMPUTE_QUERY_ID_REGRESS"
)]
pub const ComputeQueryIdType_COMPUTE_QUERY_ID_REGRESS: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ConstrType::CONSTR_NULL")]
pub const ConstrType_CONSTR_NULL: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ConstrType::CONSTR_NOTNULL")]
pub const ConstrType_CONSTR_NOTNULL: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ConstrType::CONSTR_DEFAULT")]
pub const ConstrType_CONSTR_DEFAULT: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ConstrType::CONSTR_IDENTITY")]
pub const ConstrType_CONSTR_IDENTITY: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ConstrType::CONSTR_GENERATED")]
pub const ConstrType_CONSTR_GENERATED: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ConstrType::CONSTR_CHECK")]
pub const ConstrType_CONSTR_CHECK: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ConstrType::CONSTR_PRIMARY")]
pub const ConstrType_CONSTR_PRIMARY: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ConstrType::CONSTR_UNIQUE")]
pub const ConstrType_CONSTR_UNIQUE: u32 = 7;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ConstrType::CONSTR_EXCLUSION")]
pub const ConstrType_CONSTR_EXCLUSION: u32 = 8;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ConstrType::CONSTR_FOREIGN")]
pub const ConstrType_CONSTR_FOREIGN: u32 = 9;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ConstrType::CONSTR_ATTR_DEFERRABLE")]
pub const ConstrType_CONSTR_ATTR_DEFERRABLE: u32 = 10;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ConstrType::CONSTR_ATTR_NOT_DEFERRABLE")]
pub const ConstrType_CONSTR_ATTR_NOT_DEFERRABLE: u32 = 11;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ConstrType::CONSTR_ATTR_DEFERRED")]
pub const ConstrType_CONSTR_ATTR_DEFERRED: u32 = 12;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ConstrType::CONSTR_ATTR_IMMEDIATE")]
pub const ConstrType_CONSTR_ATTR_IMMEDIATE: u32 = 13;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ConstraintExclusionType::CONSTRAINT_EXCLUSION_OFF"
)]
pub const ConstraintExclusionType_CONSTRAINT_EXCLUSION_OFF: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ConstraintExclusionType::CONSTRAINT_EXCLUSION_ON"
)]
pub const ConstraintExclusionType_CONSTRAINT_EXCLUSION_ON: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ConstraintExclusionType::CONSTRAINT_EXCLUSION_PARTITION"
)]
pub const ConstraintExclusionType_CONSTRAINT_EXCLUSION_PARTITION: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CopyHeaderChoice::COPY_HEADER_FALSE")]
pub const CopyHeaderChoice_COPY_HEADER_FALSE: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CopyHeaderChoice::COPY_HEADER_TRUE")]
pub const CopyHeaderChoice_COPY_HEADER_TRUE: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CopyHeaderChoice::COPY_HEADER_MATCH")]
pub const CopyHeaderChoice_COPY_HEADER_MATCH: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::CopyLogVerbosityChoice::COPY_LOG_VERBOSITY_DEFAULT"
)]
pub const CopyLogVerbosityChoice_COPY_LOG_VERBOSITY_DEFAULT: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::CopyLogVerbosityChoice::COPY_LOG_VERBOSITY_VERBOSE"
)]
pub const CopyLogVerbosityChoice_COPY_LOG_VERBOSITY_VERBOSE: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CopyOnErrorChoice::COPY_ON_ERROR_STOP")]
pub const CopyOnErrorChoice_COPY_ON_ERROR_STOP: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CopyOnErrorChoice::COPY_ON_ERROR_IGNORE")]
pub const CopyOnErrorChoice_COPY_ON_ERROR_IGNORE: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CostSelector::STARTUP_COST")]
pub const CostSelector_STARTUP_COST: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::CostSelector::TOTAL_COST")]
pub const CostSelector_TOTAL_COST: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DBState::DB_STARTUP")]
pub const DBState_DB_STARTUP: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DBState::DB_SHUTDOWNED")]
pub const DBState_DB_SHUTDOWNED: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DBState::DB_SHUTDOWNED_IN_RECOVERY")]
pub const DBState_DB_SHUTDOWNED_IN_RECOVERY: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DBState::DB_SHUTDOWNING")]
pub const DBState_DB_SHUTDOWNING: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DBState::DB_IN_CRASH_RECOVERY")]
pub const DBState_DB_IN_CRASH_RECOVERY: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DBState::DB_IN_ARCHIVE_RECOVERY")]
pub const DBState_DB_IN_ARCHIVE_RECOVERY: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DBState::DB_IN_PRODUCTION")]
pub const DBState_DB_IN_PRODUCTION: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DeadLockState::DS_NOT_YET_CHECKED")]
pub const DeadLockState_DS_NOT_YET_CHECKED: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DeadLockState::DS_NO_DEADLOCK")]
pub const DeadLockState_DS_NO_DEADLOCK: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DeadLockState::DS_SOFT_DEADLOCK")]
pub const DeadLockState_DS_SOFT_DEADLOCK: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DeadLockState::DS_HARD_DEADLOCK")]
pub const DeadLockState_DS_HARD_DEADLOCK: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DeadLockState::DS_BLOCKED_BY_AUTOVACUUM")]
pub const DeadLockState_DS_BLOCKED_BY_AUTOVACUUM: u32 = 4;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::DebugLogicalRepStreamingMode::DEBUG_LOGICAL_REP_STREAMING_BUFFERED"
)]
pub const DebugLogicalRepStreamingMode_DEBUG_LOGICAL_REP_STREAMING_BUFFERED: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::DebugLogicalRepStreamingMode::DEBUG_LOGICAL_REP_STREAMING_IMMEDIATE"
)]
pub const DebugLogicalRepStreamingMode_DEBUG_LOGICAL_REP_STREAMING_IMMEDIATE: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DebugParallelMode::DEBUG_PARALLEL_OFF")]
pub const DebugParallelMode_DEBUG_PARALLEL_OFF: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DebugParallelMode::DEBUG_PARALLEL_ON")]
pub const DebugParallelMode_DEBUG_PARALLEL_ON: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DebugParallelMode::DEBUG_PARALLEL_REGRESS")]
pub const DebugParallelMode_DEBUG_PARALLEL_REGRESS: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DefElemAction::DEFELEM_UNSPEC")]
pub const DefElemAction_DEFELEM_UNSPEC: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DefElemAction::DEFELEM_SET")]
pub const DefElemAction_DEFELEM_SET: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DefElemAction::DEFELEM_ADD")]
pub const DefElemAction_DEFELEM_ADD: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DefElemAction::DEFELEM_DROP")]
pub const DefElemAction_DEFELEM_DROP: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DependencyType::DEPENDENCY_NORMAL")]
pub const DependencyType_DEPENDENCY_NORMAL: u32 = 110;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DependencyType::DEPENDENCY_AUTO")]
pub const DependencyType_DEPENDENCY_AUTO: u32 = 97;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DependencyType::DEPENDENCY_INTERNAL")]
pub const DependencyType_DEPENDENCY_INTERNAL: u32 = 105;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DependencyType::DEPENDENCY_PARTITION_PRI")]
pub const DependencyType_DEPENDENCY_PARTITION_PRI: u32 = 80;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DependencyType::DEPENDENCY_PARTITION_SEC")]
pub const DependencyType_DEPENDENCY_PARTITION_SEC: u32 = 83;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DependencyType::DEPENDENCY_EXTENSION")]
pub const DependencyType_DEPENDENCY_EXTENSION: u32 = 101;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DependencyType::DEPENDENCY_AUTO_EXTENSION")]
pub const DependencyType_DEPENDENCY_AUTO_EXTENSION: u32 = 120;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DiscardMode::DISCARD_ALL")]
pub const DiscardMode_DISCARD_ALL: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DiscardMode::DISCARD_PLANS")]
pub const DiscardMode_DISCARD_PLANS: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DiscardMode::DISCARD_SEQUENCES")]
pub const DiscardMode_DISCARD_SEQUENCES: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DiscardMode::DISCARD_TEMP")]
pub const DiscardMode_DISCARD_TEMP: u32 = 3;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::DomainConstraintType::DOM_CONSTRAINT_NOTNULL"
)]
pub const DomainConstraintType_DOM_CONSTRAINT_NOTNULL: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::DomainConstraintType::DOM_CONSTRAINT_CHECK"
)]
pub const DomainConstraintType_DOM_CONSTRAINT_CHECK: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DropBehavior::DROP_RESTRICT")]
pub const DropBehavior_DROP_RESTRICT: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::DropBehavior::DROP_CASCADE")]
pub const DropBehavior_DROP_CASCADE: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::EphemeralNameRelationType::ENR_NAMED_TUPLESTORE"
)]
pub const EphemeralNameRelationType_ENR_NAMED_TUPLESTORE: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExplainFormat::EXPLAIN_FORMAT_TEXT")]
pub const ExplainFormat_EXPLAIN_FORMAT_TEXT: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExplainFormat::EXPLAIN_FORMAT_XML")]
pub const ExplainFormat_EXPLAIN_FORMAT_XML: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExplainFormat::EXPLAIN_FORMAT_JSON")]
pub const ExplainFormat_EXPLAIN_FORMAT_JSON: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExplainFormat::EXPLAIN_FORMAT_YAML")]
pub const ExplainFormat_EXPLAIN_FORMAT_YAML: u32 = 3;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ExplainSerializeOption::EXPLAIN_SERIALIZE_NONE"
)]
pub const ExplainSerializeOption_EXPLAIN_SERIALIZE_NONE: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ExplainSerializeOption::EXPLAIN_SERIALIZE_TEXT"
)]
pub const ExplainSerializeOption_EXPLAIN_SERIALIZE_TEXT: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ExplainSerializeOption::EXPLAIN_SERIALIZE_BINARY"
)]
pub const ExplainSerializeOption_EXPLAIN_SERIALIZE_BINARY: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprDoneCond::ExprSingleResult")]
pub const ExprDoneCond_ExprSingleResult: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprDoneCond::ExprMultipleResult")]
pub const ExprDoneCond_ExprMultipleResult: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprDoneCond::ExprEndResult")]
pub const ExprDoneCond_ExprEndResult: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_DONE")]
pub const ExprEvalOp_EEOP_DONE: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_INNER_FETCHSOME")]
pub const ExprEvalOp_EEOP_INNER_FETCHSOME: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_OUTER_FETCHSOME")]
pub const ExprEvalOp_EEOP_OUTER_FETCHSOME: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_SCAN_FETCHSOME")]
pub const ExprEvalOp_EEOP_SCAN_FETCHSOME: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_INNER_VAR")]
pub const ExprEvalOp_EEOP_INNER_VAR: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_OUTER_VAR")]
pub const ExprEvalOp_EEOP_OUTER_VAR: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_SCAN_VAR")]
pub const ExprEvalOp_EEOP_SCAN_VAR: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_INNER_SYSVAR")]
pub const ExprEvalOp_EEOP_INNER_SYSVAR: u32 = 7;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_OUTER_SYSVAR")]
pub const ExprEvalOp_EEOP_OUTER_SYSVAR: u32 = 8;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_SCAN_SYSVAR")]
pub const ExprEvalOp_EEOP_SCAN_SYSVAR: u32 = 9;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_WHOLEROW")]
pub const ExprEvalOp_EEOP_WHOLEROW: u32 = 10;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_ASSIGN_INNER_VAR")]
pub const ExprEvalOp_EEOP_ASSIGN_INNER_VAR: u32 = 11;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_ASSIGN_OUTER_VAR")]
pub const ExprEvalOp_EEOP_ASSIGN_OUTER_VAR: u32 = 12;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_ASSIGN_SCAN_VAR")]
pub const ExprEvalOp_EEOP_ASSIGN_SCAN_VAR: u32 = 13;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_ASSIGN_TMP")]
pub const ExprEvalOp_EEOP_ASSIGN_TMP: u32 = 14;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_ASSIGN_TMP_MAKE_RO")]
pub const ExprEvalOp_EEOP_ASSIGN_TMP_MAKE_RO: u32 = 15;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_CONST")]
pub const ExprEvalOp_EEOP_CONST: u32 = 16;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_FUNCEXPR")]
pub const ExprEvalOp_EEOP_FUNCEXPR: u32 = 17;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_FUNCEXPR_STRICT")]
pub const ExprEvalOp_EEOP_FUNCEXPR_STRICT: u32 = 18;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_FUNCEXPR_FUSAGE")]
pub const ExprEvalOp_EEOP_FUNCEXPR_FUSAGE: u32 = 19;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_FUNCEXPR_STRICT_FUSAGE")]
pub const ExprEvalOp_EEOP_FUNCEXPR_STRICT_FUSAGE: u32 = 20;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_BOOL_AND_STEP_FIRST")]
pub const ExprEvalOp_EEOP_BOOL_AND_STEP_FIRST: u32 = 21;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_BOOL_AND_STEP")]
pub const ExprEvalOp_EEOP_BOOL_AND_STEP: u32 = 22;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_BOOL_AND_STEP_LAST")]
pub const ExprEvalOp_EEOP_BOOL_AND_STEP_LAST: u32 = 23;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_BOOL_OR_STEP_FIRST")]
pub const ExprEvalOp_EEOP_BOOL_OR_STEP_FIRST: u32 = 24;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_BOOL_OR_STEP")]
pub const ExprEvalOp_EEOP_BOOL_OR_STEP: u32 = 25;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_BOOL_OR_STEP_LAST")]
pub const ExprEvalOp_EEOP_BOOL_OR_STEP_LAST: u32 = 26;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_BOOL_NOT_STEP")]
pub const ExprEvalOp_EEOP_BOOL_NOT_STEP: u32 = 27;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_QUAL")]
pub const ExprEvalOp_EEOP_QUAL: u32 = 28;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_JUMP")]
pub const ExprEvalOp_EEOP_JUMP: u32 = 29;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_JUMP_IF_NULL")]
pub const ExprEvalOp_EEOP_JUMP_IF_NULL: u32 = 30;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_JUMP_IF_NOT_NULL")]
pub const ExprEvalOp_EEOP_JUMP_IF_NOT_NULL: u32 = 31;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_JUMP_IF_NOT_TRUE")]
pub const ExprEvalOp_EEOP_JUMP_IF_NOT_TRUE: u32 = 32;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_NULLTEST_ISNULL")]
pub const ExprEvalOp_EEOP_NULLTEST_ISNULL: u32 = 33;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_NULLTEST_ISNOTNULL")]
pub const ExprEvalOp_EEOP_NULLTEST_ISNOTNULL: u32 = 34;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_NULLTEST_ROWISNULL")]
pub const ExprEvalOp_EEOP_NULLTEST_ROWISNULL: u32 = 35;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_NULLTEST_ROWISNOTNULL")]
pub const ExprEvalOp_EEOP_NULLTEST_ROWISNOTNULL: u32 = 36;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_BOOLTEST_IS_TRUE")]
pub const ExprEvalOp_EEOP_BOOLTEST_IS_TRUE: u32 = 37;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_BOOLTEST_IS_NOT_TRUE")]
pub const ExprEvalOp_EEOP_BOOLTEST_IS_NOT_TRUE: u32 = 38;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_BOOLTEST_IS_FALSE")]
pub const ExprEvalOp_EEOP_BOOLTEST_IS_FALSE: u32 = 39;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_BOOLTEST_IS_NOT_FALSE")]
pub const ExprEvalOp_EEOP_BOOLTEST_IS_NOT_FALSE: u32 = 40;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_PARAM_EXEC")]
pub const ExprEvalOp_EEOP_PARAM_EXEC: u32 = 41;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_PARAM_EXTERN")]
pub const ExprEvalOp_EEOP_PARAM_EXTERN: u32 = 42;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_PARAM_CALLBACK")]
pub const ExprEvalOp_EEOP_PARAM_CALLBACK: u32 = 43;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_CASE_TESTVAL")]
pub const ExprEvalOp_EEOP_CASE_TESTVAL: u32 = 44;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_MAKE_READONLY")]
pub const ExprEvalOp_EEOP_MAKE_READONLY: u32 = 45;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_IOCOERCE")]
pub const ExprEvalOp_EEOP_IOCOERCE: u32 = 46;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_IOCOERCE_SAFE")]
pub const ExprEvalOp_EEOP_IOCOERCE_SAFE: u32 = 47;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_DISTINCT")]
pub const ExprEvalOp_EEOP_DISTINCT: u32 = 48;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_NOT_DISTINCT")]
pub const ExprEvalOp_EEOP_NOT_DISTINCT: u32 = 49;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_NULLIF")]
pub const ExprEvalOp_EEOP_NULLIF: u32 = 50;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_SQLVALUEFUNCTION")]
pub const ExprEvalOp_EEOP_SQLVALUEFUNCTION: u32 = 51;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_CURRENTOFEXPR")]
pub const ExprEvalOp_EEOP_CURRENTOFEXPR: u32 = 52;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_NEXTVALUEEXPR")]
pub const ExprEvalOp_EEOP_NEXTVALUEEXPR: u32 = 53;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_ARRAYEXPR")]
pub const ExprEvalOp_EEOP_ARRAYEXPR: u32 = 54;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_ARRAYCOERCE")]
pub const ExprEvalOp_EEOP_ARRAYCOERCE: u32 = 55;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_ROW")]
pub const ExprEvalOp_EEOP_ROW: u32 = 56;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_ROWCOMPARE_STEP")]
pub const ExprEvalOp_EEOP_ROWCOMPARE_STEP: u32 = 57;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_ROWCOMPARE_FINAL")]
pub const ExprEvalOp_EEOP_ROWCOMPARE_FINAL: u32 = 58;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_MINMAX")]
pub const ExprEvalOp_EEOP_MINMAX: u32 = 59;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_FIELDSELECT")]
pub const ExprEvalOp_EEOP_FIELDSELECT: u32 = 60;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_FIELDSTORE_DEFORM")]
pub const ExprEvalOp_EEOP_FIELDSTORE_DEFORM: u32 = 61;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_FIELDSTORE_FORM")]
pub const ExprEvalOp_EEOP_FIELDSTORE_FORM: u32 = 62;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_SBSREF_SUBSCRIPTS")]
pub const ExprEvalOp_EEOP_SBSREF_SUBSCRIPTS: u32 = 63;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_SBSREF_OLD")]
pub const ExprEvalOp_EEOP_SBSREF_OLD: u32 = 64;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_SBSREF_ASSIGN")]
pub const ExprEvalOp_EEOP_SBSREF_ASSIGN: u32 = 65;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_SBSREF_FETCH")]
pub const ExprEvalOp_EEOP_SBSREF_FETCH: u32 = 66;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_DOMAIN_TESTVAL")]
pub const ExprEvalOp_EEOP_DOMAIN_TESTVAL: u32 = 67;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_DOMAIN_NOTNULL")]
pub const ExprEvalOp_EEOP_DOMAIN_NOTNULL: u32 = 68;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_DOMAIN_CHECK")]
pub const ExprEvalOp_EEOP_DOMAIN_CHECK: u32 = 69;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_CONVERT_ROWTYPE")]
pub const ExprEvalOp_EEOP_CONVERT_ROWTYPE: u32 = 70;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_SCALARARRAYOP")]
pub const ExprEvalOp_EEOP_SCALARARRAYOP: u32 = 71;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_HASHED_SCALARARRAYOP")]
pub const ExprEvalOp_EEOP_HASHED_SCALARARRAYOP: u32 = 72;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_XMLEXPR")]
pub const ExprEvalOp_EEOP_XMLEXPR: u32 = 73;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_JSON_CONSTRUCTOR")]
pub const ExprEvalOp_EEOP_JSON_CONSTRUCTOR: u32 = 74;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_IS_JSON")]
pub const ExprEvalOp_EEOP_IS_JSON: u32 = 75;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_JSONEXPR_PATH")]
pub const ExprEvalOp_EEOP_JSONEXPR_PATH: u32 = 76;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_JSONEXPR_COERCION")]
pub const ExprEvalOp_EEOP_JSONEXPR_COERCION: u32 = 77;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_JSONEXPR_COERCION_FINISH")]
pub const ExprEvalOp_EEOP_JSONEXPR_COERCION_FINISH: u32 = 78;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_AGGREF")]
pub const ExprEvalOp_EEOP_AGGREF: u32 = 79;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_GROUPING_FUNC")]
pub const ExprEvalOp_EEOP_GROUPING_FUNC: u32 = 80;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_WINDOW_FUNC")]
pub const ExprEvalOp_EEOP_WINDOW_FUNC: u32 = 81;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_MERGE_SUPPORT_FUNC")]
pub const ExprEvalOp_EEOP_MERGE_SUPPORT_FUNC: u32 = 82;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_SUBPLAN")]
pub const ExprEvalOp_EEOP_SUBPLAN: u32 = 83;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_AGG_STRICT_DESERIALIZE")]
pub const ExprEvalOp_EEOP_AGG_STRICT_DESERIALIZE: u32 = 84;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_AGG_DESERIALIZE")]
pub const ExprEvalOp_EEOP_AGG_DESERIALIZE: u32 = 85;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ExprEvalOp::EEOP_AGG_STRICT_INPUT_CHECK_ARGS"
)]
pub const ExprEvalOp_EEOP_AGG_STRICT_INPUT_CHECK_ARGS: u32 = 86;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ExprEvalOp::EEOP_AGG_STRICT_INPUT_CHECK_NULLS"
)]
pub const ExprEvalOp_EEOP_AGG_STRICT_INPUT_CHECK_NULLS: u32 = 87;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ExprEvalOp::EEOP_AGG_PLAIN_PERGROUP_NULLCHECK"
)]
pub const ExprEvalOp_EEOP_AGG_PLAIN_PERGROUP_NULLCHECK: u32 = 88;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ExprEvalOp::EEOP_AGG_PLAIN_TRANS_INIT_STRICT_BYVAL"
)]
pub const ExprEvalOp_EEOP_AGG_PLAIN_TRANS_INIT_STRICT_BYVAL: u32 = 89;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ExprEvalOp::EEOP_AGG_PLAIN_TRANS_STRICT_BYVAL"
)]
pub const ExprEvalOp_EEOP_AGG_PLAIN_TRANS_STRICT_BYVAL: u32 = 90;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_AGG_PLAIN_TRANS_BYVAL")]
pub const ExprEvalOp_EEOP_AGG_PLAIN_TRANS_BYVAL: u32 = 91;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ExprEvalOp::EEOP_AGG_PLAIN_TRANS_INIT_STRICT_BYREF"
)]
pub const ExprEvalOp_EEOP_AGG_PLAIN_TRANS_INIT_STRICT_BYREF: u32 = 92;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ExprEvalOp::EEOP_AGG_PLAIN_TRANS_STRICT_BYREF"
)]
pub const ExprEvalOp_EEOP_AGG_PLAIN_TRANS_STRICT_BYREF: u32 = 93;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_AGG_PLAIN_TRANS_BYREF")]
pub const ExprEvalOp_EEOP_AGG_PLAIN_TRANS_BYREF: u32 = 94;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ExprEvalOp::EEOP_AGG_PRESORTED_DISTINCT_SINGLE"
)]
pub const ExprEvalOp_EEOP_AGG_PRESORTED_DISTINCT_SINGLE: u32 = 95;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ExprEvalOp::EEOP_AGG_PRESORTED_DISTINCT_MULTI"
)]
pub const ExprEvalOp_EEOP_AGG_PRESORTED_DISTINCT_MULTI: u32 = 96;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_AGG_ORDERED_TRANS_DATUM")]
pub const ExprEvalOp_EEOP_AGG_ORDERED_TRANS_DATUM: u32 = 97;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_AGG_ORDERED_TRANS_TUPLE")]
pub const ExprEvalOp_EEOP_AGG_ORDERED_TRANS_TUPLE: u32 = 98;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExprEvalOp::EEOP_LAST")]
pub const ExprEvalOp_EEOP_LAST: u32 = 99;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ExtendBufferedFlags::EB_SKIP_EXTENSION_LOCK"
)]
pub const ExtendBufferedFlags_EB_SKIP_EXTENSION_LOCK: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ExtendBufferedFlags::EB_PERFORMING_RECOVERY"
)]
pub const ExtendBufferedFlags_EB_PERFORMING_RECOVERY: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ExtendBufferedFlags::EB_CREATE_FORK_IF_NEEDED"
)]
pub const ExtendBufferedFlags_EB_CREATE_FORK_IF_NEEDED: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExtendBufferedFlags::EB_LOCK_FIRST")]
pub const ExtendBufferedFlags_EB_LOCK_FIRST: u32 = 8;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExtendBufferedFlags::EB_CLEAR_SIZE_CACHE")]
pub const ExtendBufferedFlags_EB_CLEAR_SIZE_CACHE: u32 = 16;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ExtendBufferedFlags::EB_LOCK_TARGET")]
pub const ExtendBufferedFlags_EB_LOCK_TARGET: u32 = 32;
#[deprecated(since = "0.12.0", note = "you want pg_sys::FetchDirection::FETCH_FORWARD")]
pub const FetchDirection_FETCH_FORWARD: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::FetchDirection::FETCH_BACKWARD")]
pub const FetchDirection_FETCH_BACKWARD: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::FetchDirection::FETCH_ABSOLUTE")]
pub const FetchDirection_FETCH_ABSOLUTE: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::FetchDirection::FETCH_RELATIVE")]
pub const FetchDirection_FETCH_RELATIVE: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::FmgrHookEventType::FHET_START")]
pub const FmgrHookEventType_FHET_START: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::FmgrHookEventType::FHET_END")]
pub const FmgrHookEventType_FHET_END: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::FmgrHookEventType::FHET_ABORT")]
pub const FmgrHookEventType_FHET_ABORT: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ForkNumber::InvalidForkNumber")]
pub const ForkNumber_InvalidForkNumber: i32 = -1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ForkNumber::MAIN_FORKNUM")]
pub const ForkNumber_MAIN_FORKNUM: i32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ForkNumber::FSM_FORKNUM")]
pub const ForkNumber_FSM_FORKNUM: i32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ForkNumber::VISIBILITYMAP_FORKNUM")]
pub const ForkNumber_VISIBILITYMAP_FORKNUM: i32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ForkNumber::INIT_FORKNUM")]
pub const ForkNumber_INIT_FORKNUM: i32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::FuncDetailCode::FUNCDETAIL_NOTFOUND")]
pub const FuncDetailCode_FUNCDETAIL_NOTFOUND: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::FuncDetailCode::FUNCDETAIL_MULTIPLE")]
pub const FuncDetailCode_FUNCDETAIL_MULTIPLE: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::FuncDetailCode::FUNCDETAIL_NORMAL")]
pub const FuncDetailCode_FUNCDETAIL_NORMAL: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::FuncDetailCode::FUNCDETAIL_PROCEDURE")]
pub const FuncDetailCode_FUNCDETAIL_PROCEDURE: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::FuncDetailCode::FUNCDETAIL_AGGREGATE")]
pub const FuncDetailCode_FUNCDETAIL_AGGREGATE: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::FuncDetailCode::FUNCDETAIL_WINDOWFUNC")]
pub const FuncDetailCode_FUNCDETAIL_WINDOWFUNC: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::FuncDetailCode::FUNCDETAIL_COERCION")]
pub const FuncDetailCode_FUNCDETAIL_COERCION: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::FunctionParameterMode::FUNC_PARAM_IN")]
pub const FunctionParameterMode_FUNC_PARAM_IN: u32 = 105;
#[deprecated(since = "0.12.0", note = "you want pg_sys::FunctionParameterMode::FUNC_PARAM_OUT")]
pub const FunctionParameterMode_FUNC_PARAM_OUT: u32 = 111;
#[deprecated(since = "0.12.0", note = "you want pg_sys::FunctionParameterMode::FUNC_PARAM_INOUT")]
pub const FunctionParameterMode_FUNC_PARAM_INOUT: u32 = 98;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::FunctionParameterMode::FUNC_PARAM_VARIADIC"
)]
pub const FunctionParameterMode_FUNC_PARAM_VARIADIC: u32 = 118;
#[deprecated(since = "0.12.0", note = "you want pg_sys::FunctionParameterMode::FUNC_PARAM_TABLE")]
pub const FunctionParameterMode_FUNC_PARAM_TABLE: u32 = 116;
#[deprecated(since = "0.12.0", note = "you want pg_sys::FunctionParameterMode::FUNC_PARAM_DEFAULT")]
pub const FunctionParameterMode_FUNC_PARAM_DEFAULT: u32 = 100;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GrantTargetType::ACL_TARGET_OBJECT")]
pub const GrantTargetType_ACL_TARGET_OBJECT: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GrantTargetType::ACL_TARGET_ALL_IN_SCHEMA")]
pub const GrantTargetType_ACL_TARGET_ALL_IN_SCHEMA: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GrantTargetType::ACL_TARGET_DEFAULTS")]
pub const GrantTargetType_ACL_TARGET_DEFAULTS: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GroupingSetKind::GROUPING_SET_EMPTY")]
pub const GroupingSetKind_GROUPING_SET_EMPTY: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GroupingSetKind::GROUPING_SET_SIMPLE")]
pub const GroupingSetKind_GROUPING_SET_SIMPLE: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GroupingSetKind::GROUPING_SET_ROLLUP")]
pub const GroupingSetKind_GROUPING_SET_ROLLUP: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GroupingSetKind::GROUPING_SET_CUBE")]
pub const GroupingSetKind_GROUPING_SET_CUBE: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GroupingSetKind::GROUPING_SET_SETS")]
pub const GroupingSetKind_GROUPING_SET_SETS: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GucAction::GUC_ACTION_SET")]
pub const GucAction_GUC_ACTION_SET: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GucAction::GUC_ACTION_LOCAL")]
pub const GucAction_GUC_ACTION_LOCAL: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GucAction::GUC_ACTION_SAVE")]
pub const GucAction_GUC_ACTION_SAVE: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GucContext::PGC_INTERNAL")]
pub const GucContext_PGC_INTERNAL: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GucContext::PGC_POSTMASTER")]
pub const GucContext_PGC_POSTMASTER: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GucContext::PGC_SIGHUP")]
pub const GucContext_PGC_SIGHUP: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GucContext::PGC_SU_BACKEND")]
pub const GucContext_PGC_SU_BACKEND: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GucContext::PGC_BACKEND")]
pub const GucContext_PGC_BACKEND: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GucContext::PGC_SUSET")]
pub const GucContext_PGC_SUSET: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GucContext::PGC_USERSET")]
pub const GucContext_PGC_USERSET: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GucSource::PGC_S_DEFAULT")]
pub const GucSource_PGC_S_DEFAULT: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GucSource::PGC_S_DYNAMIC_DEFAULT")]
pub const GucSource_PGC_S_DYNAMIC_DEFAULT: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GucSource::PGC_S_ENV_VAR")]
pub const GucSource_PGC_S_ENV_VAR: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GucSource::PGC_S_FILE")]
pub const GucSource_PGC_S_FILE: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GucSource::PGC_S_ARGV")]
pub const GucSource_PGC_S_ARGV: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GucSource::PGC_S_GLOBAL")]
pub const GucSource_PGC_S_GLOBAL: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GucSource::PGC_S_DATABASE")]
pub const GucSource_PGC_S_DATABASE: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GucSource::PGC_S_USER")]
pub const GucSource_PGC_S_USER: u32 = 7;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GucSource::PGC_S_DATABASE_USER")]
pub const GucSource_PGC_S_DATABASE_USER: u32 = 8;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GucSource::PGC_S_CLIENT")]
pub const GucSource_PGC_S_CLIENT: u32 = 9;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GucSource::PGC_S_OVERRIDE")]
pub const GucSource_PGC_S_OVERRIDE: u32 = 10;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GucSource::PGC_S_INTERACTIVE")]
pub const GucSource_PGC_S_INTERACTIVE: u32 = 11;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GucSource::PGC_S_TEST")]
pub const GucSource_PGC_S_TEST: u32 = 12;
#[deprecated(since = "0.12.0", note = "you want pg_sys::GucSource::PGC_S_SESSION")]
pub const GucSource_PGC_S_SESSION: u32 = 13;
#[deprecated(since = "0.12.0", note = "you want pg_sys::HASHACTION::HASH_FIND")]
pub const HASHACTION_HASH_FIND: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::HASHACTION::HASH_ENTER")]
pub const HASHACTION_HASH_ENTER: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::HASHACTION::HASH_REMOVE")]
pub const HASHACTION_HASH_REMOVE: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::HASHACTION::HASH_ENTER_NULL")]
pub const HASHACTION_HASH_ENTER_NULL: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::HTSV_Result::HEAPTUPLE_DEAD")]
pub const HTSV_Result_HEAPTUPLE_DEAD: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::HTSV_Result::HEAPTUPLE_LIVE")]
pub const HTSV_Result_HEAPTUPLE_LIVE: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::HTSV_Result::HEAPTUPLE_RECENTLY_DEAD")]
pub const HTSV_Result_HEAPTUPLE_RECENTLY_DEAD: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::HTSV_Result::HEAPTUPLE_INSERT_IN_PROGRESS")]
pub const HTSV_Result_HEAPTUPLE_INSERT_IN_PROGRESS: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::HTSV_Result::HEAPTUPLE_DELETE_IN_PROGRESS")]
pub const HTSV_Result_HEAPTUPLE_DELETE_IN_PROGRESS: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::HotStandbyState::STANDBY_DISABLED")]
pub const HotStandbyState_STANDBY_DISABLED: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::HotStandbyState::STANDBY_INITIALIZED")]
pub const HotStandbyState_STANDBY_INITIALIZED: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::HotStandbyState::STANDBY_SNAPSHOT_PENDING")]
pub const HotStandbyState_STANDBY_SNAPSHOT_PENDING: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::HotStandbyState::STANDBY_SNAPSHOT_READY")]
pub const HotStandbyState_STANDBY_SNAPSHOT_READY: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IOContext::IOCONTEXT_BULKREAD")]
pub const IOContext_IOCONTEXT_BULKREAD: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IOContext::IOCONTEXT_BULKWRITE")]
pub const IOContext_IOCONTEXT_BULKWRITE: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IOContext::IOCONTEXT_NORMAL")]
pub const IOContext_IOCONTEXT_NORMAL: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IOContext::IOCONTEXT_VACUUM")]
pub const IOContext_IOCONTEXT_VACUUM: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IOFuncSelector::IOFunc_input")]
pub const IOFuncSelector_IOFunc_input: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IOFuncSelector::IOFunc_output")]
pub const IOFuncSelector_IOFunc_output: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IOFuncSelector::IOFunc_receive")]
pub const IOFuncSelector_IOFunc_receive: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IOFuncSelector::IOFunc_send")]
pub const IOFuncSelector_IOFunc_send: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IOObject::IOOBJECT_RELATION")]
pub const IOObject_IOOBJECT_RELATION: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IOObject::IOOBJECT_TEMP_RELATION")]
pub const IOObject_IOOBJECT_TEMP_RELATION: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IOOp::IOOP_EVICT")]
pub const IOOp_IOOP_EVICT: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IOOp::IOOP_EXTEND")]
pub const IOOp_IOOP_EXTEND: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IOOp::IOOP_FSYNC")]
pub const IOOp_IOOP_FSYNC: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IOOp::IOOP_HIT")]
pub const IOOp_IOOP_HIT: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IOOp::IOOP_READ")]
pub const IOOp_IOOP_READ: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IOOp::IOOP_REUSE")]
pub const IOOp_IOOP_REUSE: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IOOp::IOOP_WRITE")]
pub const IOOp_IOOP_WRITE: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IOOp::IOOP_WRITEBACK")]
pub const IOOp_IOOP_WRITEBACK: u32 = 7;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::IdentifierLookup::IDENTIFIER_LOOKUP_NORMAL"
)]
pub const IdentifierLookup_IDENTIFIER_LOOKUP_NORMAL: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::IdentifierLookup::IDENTIFIER_LOOKUP_DECLARE"
)]
pub const IdentifierLookup_IDENTIFIER_LOOKUP_DECLARE: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IdentifierLookup::IDENTIFIER_LOOKUP_EXPR")]
pub const IdentifierLookup_IDENTIFIER_LOOKUP_EXPR: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ImportForeignSchemaType::FDW_IMPORT_SCHEMA_ALL"
)]
pub const ImportForeignSchemaType_FDW_IMPORT_SCHEMA_ALL: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ImportForeignSchemaType::FDW_IMPORT_SCHEMA_LIMIT_TO"
)]
pub const ImportForeignSchemaType_FDW_IMPORT_SCHEMA_LIMIT_TO: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ImportForeignSchemaType::FDW_IMPORT_SCHEMA_EXCEPT"
)]
pub const ImportForeignSchemaType_FDW_IMPORT_SCHEMA_EXCEPT: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::IncrementalSortExecutionStatus::INCSORT_LOADFULLSORT"
)]
pub const IncrementalSortExecutionStatus_INCSORT_LOADFULLSORT: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::IncrementalSortExecutionStatus::INCSORT_LOADPREFIXSORT"
)]
pub const IncrementalSortExecutionStatus_INCSORT_LOADPREFIXSORT: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::IncrementalSortExecutionStatus::INCSORT_READFULLSORT"
)]
pub const IncrementalSortExecutionStatus_INCSORT_READFULLSORT: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::IncrementalSortExecutionStatus::INCSORT_READPREFIXSORT"
)]
pub const IncrementalSortExecutionStatus_INCSORT_READPREFIXSORT: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IndexAMProperty::AMPROP_UNKNOWN")]
pub const IndexAMProperty_AMPROP_UNKNOWN: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IndexAMProperty::AMPROP_ASC")]
pub const IndexAMProperty_AMPROP_ASC: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IndexAMProperty::AMPROP_DESC")]
pub const IndexAMProperty_AMPROP_DESC: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IndexAMProperty::AMPROP_NULLS_FIRST")]
pub const IndexAMProperty_AMPROP_NULLS_FIRST: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IndexAMProperty::AMPROP_NULLS_LAST")]
pub const IndexAMProperty_AMPROP_NULLS_LAST: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IndexAMProperty::AMPROP_ORDERABLE")]
pub const IndexAMProperty_AMPROP_ORDERABLE: u32 = 5;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::IndexAMProperty::AMPROP_DISTANCE_ORDERABLE"
)]
pub const IndexAMProperty_AMPROP_DISTANCE_ORDERABLE: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IndexAMProperty::AMPROP_RETURNABLE")]
pub const IndexAMProperty_AMPROP_RETURNABLE: u32 = 7;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IndexAMProperty::AMPROP_SEARCH_ARRAY")]
pub const IndexAMProperty_AMPROP_SEARCH_ARRAY: u32 = 8;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IndexAMProperty::AMPROP_SEARCH_NULLS")]
pub const IndexAMProperty_AMPROP_SEARCH_NULLS: u32 = 9;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IndexAMProperty::AMPROP_CLUSTERABLE")]
pub const IndexAMProperty_AMPROP_CLUSTERABLE: u32 = 10;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IndexAMProperty::AMPROP_INDEX_SCAN")]
pub const IndexAMProperty_AMPROP_INDEX_SCAN: u32 = 11;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IndexAMProperty::AMPROP_BITMAP_SCAN")]
pub const IndexAMProperty_AMPROP_BITMAP_SCAN: u32 = 12;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IndexAMProperty::AMPROP_BACKWARD_SCAN")]
pub const IndexAMProperty_AMPROP_BACKWARD_SCAN: u32 = 13;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IndexAMProperty::AMPROP_CAN_ORDER")]
pub const IndexAMProperty_AMPROP_CAN_ORDER: u32 = 14;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IndexAMProperty::AMPROP_CAN_UNIQUE")]
pub const IndexAMProperty_AMPROP_CAN_UNIQUE: u32 = 15;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IndexAMProperty::AMPROP_CAN_MULTI_COL")]
pub const IndexAMProperty_AMPROP_CAN_MULTI_COL: u32 = 16;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IndexAMProperty::AMPROP_CAN_EXCLUDE")]
pub const IndexAMProperty_AMPROP_CAN_EXCLUDE: u32 = 17;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IndexAMProperty::AMPROP_CAN_INCLUDE")]
pub const IndexAMProperty_AMPROP_CAN_INCLUDE: u32 = 18;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::IndexAttrBitmapKind::INDEX_ATTR_BITMAP_KEY"
)]
pub const IndexAttrBitmapKind_INDEX_ATTR_BITMAP_KEY: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::IndexAttrBitmapKind::INDEX_ATTR_BITMAP_PRIMARY_KEY"
)]
pub const IndexAttrBitmapKind_INDEX_ATTR_BITMAP_PRIMARY_KEY: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::IndexAttrBitmapKind::INDEX_ATTR_BITMAP_IDENTITY_KEY"
)]
pub const IndexAttrBitmapKind_INDEX_ATTR_BITMAP_IDENTITY_KEY: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::IndexAttrBitmapKind::INDEX_ATTR_BITMAP_HOT_BLOCKING"
)]
pub const IndexAttrBitmapKind_INDEX_ATTR_BITMAP_HOT_BLOCKING: u32 = 3;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::IndexAttrBitmapKind::INDEX_ATTR_BITMAP_SUMMARIZED"
)]
pub const IndexAttrBitmapKind_INDEX_ATTR_BITMAP_SUMMARIZED: u32 = 4;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::IndexStateFlagsAction::INDEX_CREATE_SET_READY"
)]
pub const IndexStateFlagsAction_INDEX_CREATE_SET_READY: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::IndexStateFlagsAction::INDEX_CREATE_SET_VALID"
)]
pub const IndexStateFlagsAction_INDEX_CREATE_SET_VALID: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::IndexStateFlagsAction::INDEX_DROP_CLEAR_VALID"
)]
pub const IndexStateFlagsAction_INDEX_DROP_CLEAR_VALID: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::IndexStateFlagsAction::INDEX_DROP_SET_DEAD"
)]
pub const IndexStateFlagsAction_INDEX_DROP_SET_DEAD: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IndexUniqueCheck::UNIQUE_CHECK_NO")]
pub const IndexUniqueCheck_UNIQUE_CHECK_NO: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IndexUniqueCheck::UNIQUE_CHECK_YES")]
pub const IndexUniqueCheck_UNIQUE_CHECK_YES: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IndexUniqueCheck::UNIQUE_CHECK_PARTIAL")]
pub const IndexUniqueCheck_UNIQUE_CHECK_PARTIAL: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::IndexUniqueCheck::UNIQUE_CHECK_EXISTING")]
pub const IndexUniqueCheck_UNIQUE_CHECK_EXISTING: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::InstrumentOption::INSTRUMENT_TIMER")]
pub const InstrumentOption_INSTRUMENT_TIMER: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::InstrumentOption::INSTRUMENT_BUFFERS")]
pub const InstrumentOption_INSTRUMENT_BUFFERS: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::InstrumentOption::INSTRUMENT_ROWS")]
pub const InstrumentOption_INSTRUMENT_ROWS: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::InstrumentOption::INSTRUMENT_WAL")]
pub const InstrumentOption_INSTRUMENT_WAL: u32 = 8;
#[deprecated(since = "0.12.0", note = "you want pg_sys::InstrumentOption::INSTRUMENT_ALL")]
pub const InstrumentOption_INSTRUMENT_ALL: u32 = 2147483647;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JoinType::JOIN_INNER")]
pub const JoinType_JOIN_INNER: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JoinType::JOIN_LEFT")]
pub const JoinType_JOIN_LEFT: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JoinType::JOIN_FULL")]
pub const JoinType_JOIN_FULL: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JoinType::JOIN_RIGHT")]
pub const JoinType_JOIN_RIGHT: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JoinType::JOIN_SEMI")]
pub const JoinType_JOIN_SEMI: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JoinType::JOIN_ANTI")]
pub const JoinType_JOIN_ANTI: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JoinType::JOIN_RIGHT_ANTI")]
pub const JoinType_JOIN_RIGHT_ANTI: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JoinType::JOIN_UNIQUE_OUTER")]
pub const JoinType_JOIN_UNIQUE_OUTER: u32 = 7;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JoinType::JOIN_UNIQUE_INNER")]
pub const JoinType_JOIN_UNIQUE_INNER: u32 = 8;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonBehaviorType::JSON_BEHAVIOR_NULL")]
pub const JsonBehaviorType_JSON_BEHAVIOR_NULL: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonBehaviorType::JSON_BEHAVIOR_ERROR")]
pub const JsonBehaviorType_JSON_BEHAVIOR_ERROR: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonBehaviorType::JSON_BEHAVIOR_EMPTY")]
pub const JsonBehaviorType_JSON_BEHAVIOR_EMPTY: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonBehaviorType::JSON_BEHAVIOR_TRUE")]
pub const JsonBehaviorType_JSON_BEHAVIOR_TRUE: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonBehaviorType::JSON_BEHAVIOR_FALSE")]
pub const JsonBehaviorType_JSON_BEHAVIOR_FALSE: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonBehaviorType::JSON_BEHAVIOR_UNKNOWN")]
pub const JsonBehaviorType_JSON_BEHAVIOR_UNKNOWN: u32 = 5;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::JsonBehaviorType::JSON_BEHAVIOR_EMPTY_ARRAY"
)]
pub const JsonBehaviorType_JSON_BEHAVIOR_EMPTY_ARRAY: u32 = 6;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::JsonBehaviorType::JSON_BEHAVIOR_EMPTY_OBJECT"
)]
pub const JsonBehaviorType_JSON_BEHAVIOR_EMPTY_OBJECT: u32 = 7;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonBehaviorType::JSON_BEHAVIOR_DEFAULT")]
pub const JsonBehaviorType_JSON_BEHAVIOR_DEFAULT: u32 = 8;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonConstructorType::JSCTOR_JSON_OBJECT")]
pub const JsonConstructorType_JSCTOR_JSON_OBJECT: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonConstructorType::JSCTOR_JSON_ARRAY")]
pub const JsonConstructorType_JSCTOR_JSON_ARRAY: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::JsonConstructorType::JSCTOR_JSON_OBJECTAGG"
)]
pub const JsonConstructorType_JSCTOR_JSON_OBJECTAGG: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonConstructorType::JSCTOR_JSON_ARRAYAGG")]
pub const JsonConstructorType_JSCTOR_JSON_ARRAYAGG: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonConstructorType::JSCTOR_JSON_PARSE")]
pub const JsonConstructorType_JSCTOR_JSON_PARSE: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonConstructorType::JSCTOR_JSON_SCALAR")]
pub const JsonConstructorType_JSCTOR_JSON_SCALAR: u32 = 6;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::JsonConstructorType::JSCTOR_JSON_SERIALIZE"
)]
pub const JsonConstructorType_JSCTOR_JSON_SERIALIZE: u32 = 7;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonEncoding::JS_ENC_DEFAULT")]
pub const JsonEncoding_JS_ENC_DEFAULT: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonEncoding::JS_ENC_UTF8")]
pub const JsonEncoding_JS_ENC_UTF8: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonEncoding::JS_ENC_UTF16")]
pub const JsonEncoding_JS_ENC_UTF16: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonEncoding::JS_ENC_UTF32")]
pub const JsonEncoding_JS_ENC_UTF32: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonExprOp::JSON_EXISTS_OP")]
pub const JsonExprOp_JSON_EXISTS_OP: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonExprOp::JSON_QUERY_OP")]
pub const JsonExprOp_JSON_QUERY_OP: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonExprOp::JSON_VALUE_OP")]
pub const JsonExprOp_JSON_VALUE_OP: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonExprOp::JSON_TABLE_OP")]
pub const JsonExprOp_JSON_TABLE_OP: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonFormatType::JS_FORMAT_DEFAULT")]
pub const JsonFormatType_JS_FORMAT_DEFAULT: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonFormatType::JS_FORMAT_JSON")]
pub const JsonFormatType_JS_FORMAT_JSON: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonFormatType::JS_FORMAT_JSONB")]
pub const JsonFormatType_JS_FORMAT_JSONB: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonQuotes::JS_QUOTES_UNSPEC")]
pub const JsonQuotes_JS_QUOTES_UNSPEC: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonQuotes::JS_QUOTES_KEEP")]
pub const JsonQuotes_JS_QUOTES_KEEP: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonQuotes::JS_QUOTES_OMIT")]
pub const JsonQuotes_JS_QUOTES_OMIT: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonTableColumnType::JTC_FOR_ORDINALITY")]
pub const JsonTableColumnType_JTC_FOR_ORDINALITY: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonTableColumnType::JTC_REGULAR")]
pub const JsonTableColumnType_JTC_REGULAR: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonTableColumnType::JTC_EXISTS")]
pub const JsonTableColumnType_JTC_EXISTS: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonTableColumnType::JTC_FORMATTED")]
pub const JsonTableColumnType_JTC_FORMATTED: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonTableColumnType::JTC_NESTED")]
pub const JsonTableColumnType_JTC_NESTED: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonValueType::JS_TYPE_ANY")]
pub const JsonValueType_JS_TYPE_ANY: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonValueType::JS_TYPE_OBJECT")]
pub const JsonValueType_JS_TYPE_OBJECT: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonValueType::JS_TYPE_ARRAY")]
pub const JsonValueType_JS_TYPE_ARRAY: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonValueType::JS_TYPE_SCALAR")]
pub const JsonValueType_JS_TYPE_SCALAR: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonWrapper::JSW_UNSPEC")]
pub const JsonWrapper_JSW_UNSPEC: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonWrapper::JSW_NONE")]
pub const JsonWrapper_JSW_NONE: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonWrapper::JSW_CONDITIONAL")]
pub const JsonWrapper_JSW_CONDITIONAL: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonWrapper::JSW_UNCONDITIONAL")]
pub const JsonWrapper_JSW_UNCONDITIONAL: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonbIterState::JBI_ARRAY_START")]
pub const JsonbIterState_JBI_ARRAY_START: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonbIterState::JBI_ARRAY_ELEM")]
pub const JsonbIterState_JBI_ARRAY_ELEM: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonbIterState::JBI_OBJECT_START")]
pub const JsonbIterState_JBI_OBJECT_START: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonbIterState::JBI_OBJECT_KEY")]
pub const JsonbIterState_JBI_OBJECT_KEY: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonbIterState::JBI_OBJECT_VALUE")]
pub const JsonbIterState_JBI_OBJECT_VALUE: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonbIteratorToken::WJB_DONE")]
pub const JsonbIteratorToken_WJB_DONE: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonbIteratorToken::WJB_KEY")]
pub const JsonbIteratorToken_WJB_KEY: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonbIteratorToken::WJB_VALUE")]
pub const JsonbIteratorToken_WJB_VALUE: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonbIteratorToken::WJB_ELEM")]
pub const JsonbIteratorToken_WJB_ELEM: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonbIteratorToken::WJB_BEGIN_ARRAY")]
pub const JsonbIteratorToken_WJB_BEGIN_ARRAY: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonbIteratorToken::WJB_END_ARRAY")]
pub const JsonbIteratorToken_WJB_END_ARRAY: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonbIteratorToken::WJB_BEGIN_OBJECT")]
pub const JsonbIteratorToken_WJB_BEGIN_OBJECT: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::JsonbIteratorToken::WJB_END_OBJECT")]
pub const JsonbIteratorToken_WJB_END_OBJECT: u32 = 7;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LWLockMode::LW_EXCLUSIVE")]
pub const LWLockMode_LW_EXCLUSIVE: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LWLockMode::LW_SHARED")]
pub const LWLockMode_LW_SHARED: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LWLockMode::LW_WAIT_UNTIL_FREE")]
pub const LWLockMode_LW_WAIT_UNTIL_FREE: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LWLockWaitState::LW_WS_NOT_WAITING")]
pub const LWLockWaitState_LW_WS_NOT_WAITING: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LWLockWaitState::LW_WS_WAITING")]
pub const LWLockWaitState_LW_WS_WAITING: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LWLockWaitState::LW_WS_PENDING_WAKEUP")]
pub const LWLockWaitState_LW_WS_PENDING_WAKEUP: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LimitOption::LIMIT_OPTION_COUNT")]
pub const LimitOption_LIMIT_OPTION_COUNT: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LimitOption::LIMIT_OPTION_WITH_TIES")]
pub const LimitOption_LIMIT_OPTION_WITH_TIES: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LimitStateCond::LIMIT_INITIAL")]
pub const LimitStateCond_LIMIT_INITIAL: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LimitStateCond::LIMIT_RESCAN")]
pub const LimitStateCond_LIMIT_RESCAN: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LimitStateCond::LIMIT_EMPTY")]
pub const LimitStateCond_LIMIT_EMPTY: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LimitStateCond::LIMIT_INWINDOW")]
pub const LimitStateCond_LIMIT_INWINDOW: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LimitStateCond::LIMIT_WINDOWEND_TIES")]
pub const LimitStateCond_LIMIT_WINDOWEND_TIES: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LimitStateCond::LIMIT_SUBPLANEOF")]
pub const LimitStateCond_LIMIT_SUBPLANEOF: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LimitStateCond::LIMIT_WINDOWEND")]
pub const LimitStateCond_LIMIT_WINDOWEND: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LimitStateCond::LIMIT_WINDOWSTART")]
pub const LimitStateCond_LIMIT_WINDOWSTART: u32 = 7;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LockAcquireResult::LOCKACQUIRE_NOT_AVAIL")]
pub const LockAcquireResult_LOCKACQUIRE_NOT_AVAIL: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LockAcquireResult::LOCKACQUIRE_OK")]
pub const LockAcquireResult_LOCKACQUIRE_OK: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::LockAcquireResult::LOCKACQUIRE_ALREADY_HELD"
)]
pub const LockAcquireResult_LOCKACQUIRE_ALREADY_HELD: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::LockAcquireResult::LOCKACQUIRE_ALREADY_CLEAR"
)]
pub const LockAcquireResult_LOCKACQUIRE_ALREADY_CLEAR: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LockClauseStrength::LCS_NONE")]
pub const LockClauseStrength_LCS_NONE: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LockClauseStrength::LCS_FORKEYSHARE")]
pub const LockClauseStrength_LCS_FORKEYSHARE: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LockClauseStrength::LCS_FORSHARE")]
pub const LockClauseStrength_LCS_FORSHARE: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LockClauseStrength::LCS_FORNOKEYUPDATE")]
pub const LockClauseStrength_LCS_FORNOKEYUPDATE: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LockClauseStrength::LCS_FORUPDATE")]
pub const LockClauseStrength_LCS_FORUPDATE: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LockTagType::LOCKTAG_RELATION")]
pub const LockTagType_LOCKTAG_RELATION: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LockTagType::LOCKTAG_RELATION_EXTEND")]
pub const LockTagType_LOCKTAG_RELATION_EXTEND: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LockTagType::LOCKTAG_DATABASE_FROZEN_IDS")]
pub const LockTagType_LOCKTAG_DATABASE_FROZEN_IDS: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LockTagType::LOCKTAG_PAGE")]
pub const LockTagType_LOCKTAG_PAGE: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LockTagType::LOCKTAG_TUPLE")]
pub const LockTagType_LOCKTAG_TUPLE: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LockTagType::LOCKTAG_TRANSACTION")]
pub const LockTagType_LOCKTAG_TRANSACTION: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LockTagType::LOCKTAG_VIRTUALTRANSACTION")]
pub const LockTagType_LOCKTAG_VIRTUALTRANSACTION: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LockTagType::LOCKTAG_SPECULATIVE_TOKEN")]
pub const LockTagType_LOCKTAG_SPECULATIVE_TOKEN: u32 = 7;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LockTagType::LOCKTAG_OBJECT")]
pub const LockTagType_LOCKTAG_OBJECT: u32 = 8;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LockTagType::LOCKTAG_USERLOCK")]
pub const LockTagType_LOCKTAG_USERLOCK: u32 = 9;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LockTagType::LOCKTAG_ADVISORY")]
pub const LockTagType_LOCKTAG_ADVISORY: u32 = 10;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LockTagType::LOCKTAG_APPLY_TRANSACTION")]
pub const LockTagType_LOCKTAG_APPLY_TRANSACTION: u32 = 11;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LockTupleMode::LockTupleKeyShare")]
pub const LockTupleMode_LockTupleKeyShare: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LockTupleMode::LockTupleShare")]
pub const LockTupleMode_LockTupleShare: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LockTupleMode::LockTupleNoKeyExclusive")]
pub const LockTupleMode_LockTupleNoKeyExclusive: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LockTupleMode::LockTupleExclusive")]
pub const LockTupleMode_LockTupleExclusive: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LockWaitPolicy::LockWaitBlock")]
pub const LockWaitPolicy_LockWaitBlock: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LockWaitPolicy::LockWaitSkip")]
pub const LockWaitPolicy_LockWaitSkip: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LockWaitPolicy::LockWaitError")]
pub const LockWaitPolicy_LockWaitError: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LogStmtLevel::LOGSTMT_NONE")]
pub const LogStmtLevel_LOGSTMT_NONE: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LogStmtLevel::LOGSTMT_DDL")]
pub const LogStmtLevel_LOGSTMT_DDL: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LogStmtLevel::LOGSTMT_MOD")]
pub const LogStmtLevel_LOGSTMT_MOD: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LogStmtLevel::LOGSTMT_ALL")]
pub const LogStmtLevel_LOGSTMT_ALL: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LogicalRepMsgType::LOGICAL_REP_MSG_BEGIN")]
pub const LogicalRepMsgType_LOGICAL_REP_MSG_BEGIN: u32 = 66;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LogicalRepMsgType::LOGICAL_REP_MSG_COMMIT")]
pub const LogicalRepMsgType_LOGICAL_REP_MSG_COMMIT: u32 = 67;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LogicalRepMsgType::LOGICAL_REP_MSG_ORIGIN")]
pub const LogicalRepMsgType_LOGICAL_REP_MSG_ORIGIN: u32 = 79;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LogicalRepMsgType::LOGICAL_REP_MSG_INSERT")]
pub const LogicalRepMsgType_LOGICAL_REP_MSG_INSERT: u32 = 73;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LogicalRepMsgType::LOGICAL_REP_MSG_UPDATE")]
pub const LogicalRepMsgType_LOGICAL_REP_MSG_UPDATE: u32 = 85;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LogicalRepMsgType::LOGICAL_REP_MSG_DELETE")]
pub const LogicalRepMsgType_LOGICAL_REP_MSG_DELETE: u32 = 68;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::LogicalRepMsgType::LOGICAL_REP_MSG_TRUNCATE"
)]
pub const LogicalRepMsgType_LOGICAL_REP_MSG_TRUNCATE: u32 = 84;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::LogicalRepMsgType::LOGICAL_REP_MSG_RELATION"
)]
pub const LogicalRepMsgType_LOGICAL_REP_MSG_RELATION: u32 = 82;
#[deprecated(since = "0.12.0", note = "you want pg_sys::LogicalRepMsgType::LOGICAL_REP_MSG_TYPE")]
pub const LogicalRepMsgType_LOGICAL_REP_MSG_TYPE: u32 = 89;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::LogicalRepMsgType::LOGICAL_REP_MSG_MESSAGE"
)]
pub const LogicalRepMsgType_LOGICAL_REP_MSG_MESSAGE: u32 = 77;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::LogicalRepMsgType::LOGICAL_REP_MSG_BEGIN_PREPARE"
)]
pub const LogicalRepMsgType_LOGICAL_REP_MSG_BEGIN_PREPARE: u32 = 98;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::LogicalRepMsgType::LOGICAL_REP_MSG_PREPARE"
)]
pub const LogicalRepMsgType_LOGICAL_REP_MSG_PREPARE: u32 = 80;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::LogicalRepMsgType::LOGICAL_REP_MSG_COMMIT_PREPARED"
)]
pub const LogicalRepMsgType_LOGICAL_REP_MSG_COMMIT_PREPARED: u32 = 75;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::LogicalRepMsgType::LOGICAL_REP_MSG_ROLLBACK_PREPARED"
)]
pub const LogicalRepMsgType_LOGICAL_REP_MSG_ROLLBACK_PREPARED: u32 = 114;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::LogicalRepMsgType::LOGICAL_REP_MSG_STREAM_START"
)]
pub const LogicalRepMsgType_LOGICAL_REP_MSG_STREAM_START: u32 = 83;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::LogicalRepMsgType::LOGICAL_REP_MSG_STREAM_STOP"
)]
pub const LogicalRepMsgType_LOGICAL_REP_MSG_STREAM_STOP: u32 = 69;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::LogicalRepMsgType::LOGICAL_REP_MSG_STREAM_COMMIT"
)]
pub const LogicalRepMsgType_LOGICAL_REP_MSG_STREAM_COMMIT: u32 = 99;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::LogicalRepMsgType::LOGICAL_REP_MSG_STREAM_ABORT"
)]
pub const LogicalRepMsgType_LOGICAL_REP_MSG_STREAM_ABORT: u32 = 65;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::LogicalRepMsgType::LOGICAL_REP_MSG_STREAM_PREPARE"
)]
pub const LogicalRepMsgType_LOGICAL_REP_MSG_STREAM_PREPARE: u32 = 112;
#[deprecated(since = "0.12.0", note = "you want pg_sys::MergeMatchKind::MERGE_WHEN_MATCHED")]
pub const MergeMatchKind_MERGE_WHEN_MATCHED: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::MergeMatchKind::MERGE_WHEN_NOT_MATCHED_BY_SOURCE"
)]
pub const MergeMatchKind_MERGE_WHEN_NOT_MATCHED_BY_SOURCE: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::MergeMatchKind::MERGE_WHEN_NOT_MATCHED_BY_TARGET"
)]
pub const MergeMatchKind_MERGE_WHEN_NOT_MATCHED_BY_TARGET: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::MinMaxOp::IS_GREATEST")]
pub const MinMaxOp_IS_GREATEST: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::MinMaxOp::IS_LEAST")]
pub const MinMaxOp_IS_LEAST: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::MonotonicFunction::MONOTONICFUNC_NONE")]
pub const MonotonicFunction_MONOTONICFUNC_NONE: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::MonotonicFunction::MONOTONICFUNC_INCREASING"
)]
pub const MonotonicFunction_MONOTONICFUNC_INCREASING: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::MonotonicFunction::MONOTONICFUNC_DECREASING"
)]
pub const MonotonicFunction_MONOTONICFUNC_DECREASING: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::MonotonicFunction::MONOTONICFUNC_BOTH")]
pub const MonotonicFunction_MONOTONICFUNC_BOTH: u32 = 3;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::MultiXactStatus::MultiXactStatusForKeyShare"
)]
pub const MultiXactStatus_MultiXactStatusForKeyShare: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::MultiXactStatus::MultiXactStatusForShare")]
pub const MultiXactStatus_MultiXactStatusForShare: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::MultiXactStatus::MultiXactStatusForNoKeyUpdate"
)]
pub const MultiXactStatus_MultiXactStatusForNoKeyUpdate: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::MultiXactStatus::MultiXactStatusForUpdate")]
pub const MultiXactStatus_MultiXactStatusForUpdate: u32 = 3;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::MultiXactStatus::MultiXactStatusNoKeyUpdate"
)]
pub const MultiXactStatus_MultiXactStatusNoKeyUpdate: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::MultiXactStatus::MultiXactStatusUpdate")]
pub const MultiXactStatus_MultiXactStatusUpdate: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::NullTestType::IS_NULL")]
pub const NullTestType_IS_NULL: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::NullTestType::IS_NOT_NULL")]
pub const NullTestType_IS_NOT_NULL: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectAccessType::OAT_POST_CREATE")]
pub const ObjectAccessType_OAT_POST_CREATE: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectAccessType::OAT_DROP")]
pub const ObjectAccessType_OAT_DROP: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectAccessType::OAT_POST_ALTER")]
pub const ObjectAccessType_OAT_POST_ALTER: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectAccessType::OAT_NAMESPACE_SEARCH")]
pub const ObjectAccessType_OAT_NAMESPACE_SEARCH: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectAccessType::OAT_FUNCTION_EXECUTE")]
pub const ObjectAccessType_OAT_FUNCTION_EXECUTE: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectAccessType::OAT_TRUNCATE")]
pub const ObjectAccessType_OAT_TRUNCATE: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_ACCESS_METHOD")]
pub const ObjectType_OBJECT_ACCESS_METHOD: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_AGGREGATE")]
pub const ObjectType_OBJECT_AGGREGATE: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_AMOP")]
pub const ObjectType_OBJECT_AMOP: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_AMPROC")]
pub const ObjectType_OBJECT_AMPROC: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_ATTRIBUTE")]
pub const ObjectType_OBJECT_ATTRIBUTE: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_CAST")]
pub const ObjectType_OBJECT_CAST: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_COLUMN")]
pub const ObjectType_OBJECT_COLUMN: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_COLLATION")]
pub const ObjectType_OBJECT_COLLATION: u32 = 7;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_CONVERSION")]
pub const ObjectType_OBJECT_CONVERSION: u32 = 8;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_DATABASE")]
pub const ObjectType_OBJECT_DATABASE: u32 = 9;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_DEFAULT")]
pub const ObjectType_OBJECT_DEFAULT: u32 = 10;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_DEFACL")]
pub const ObjectType_OBJECT_DEFACL: u32 = 11;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_DOMAIN")]
pub const ObjectType_OBJECT_DOMAIN: u32 = 12;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_DOMCONSTRAINT")]
pub const ObjectType_OBJECT_DOMCONSTRAINT: u32 = 13;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_EVENT_TRIGGER")]
pub const ObjectType_OBJECT_EVENT_TRIGGER: u32 = 14;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_EXTENSION")]
pub const ObjectType_OBJECT_EXTENSION: u32 = 15;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_FDW")]
pub const ObjectType_OBJECT_FDW: u32 = 16;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_FOREIGN_SERVER")]
pub const ObjectType_OBJECT_FOREIGN_SERVER: u32 = 17;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_FOREIGN_TABLE")]
pub const ObjectType_OBJECT_FOREIGN_TABLE: u32 = 18;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_FUNCTION")]
pub const ObjectType_OBJECT_FUNCTION: u32 = 19;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_INDEX")]
pub const ObjectType_OBJECT_INDEX: u32 = 20;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_LANGUAGE")]
pub const ObjectType_OBJECT_LANGUAGE: u32 = 21;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_LARGEOBJECT")]
pub const ObjectType_OBJECT_LARGEOBJECT: u32 = 22;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_MATVIEW")]
pub const ObjectType_OBJECT_MATVIEW: u32 = 23;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_OPCLASS")]
pub const ObjectType_OBJECT_OPCLASS: u32 = 24;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_OPERATOR")]
pub const ObjectType_OBJECT_OPERATOR: u32 = 25;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_OPFAMILY")]
pub const ObjectType_OBJECT_OPFAMILY: u32 = 26;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_PARAMETER_ACL")]
pub const ObjectType_OBJECT_PARAMETER_ACL: u32 = 27;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_POLICY")]
pub const ObjectType_OBJECT_POLICY: u32 = 28;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_PROCEDURE")]
pub const ObjectType_OBJECT_PROCEDURE: u32 = 29;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_PUBLICATION")]
pub const ObjectType_OBJECT_PUBLICATION: u32 = 30;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_PUBLICATION_NAMESPACE")]
pub const ObjectType_OBJECT_PUBLICATION_NAMESPACE: u32 = 31;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_PUBLICATION_REL")]
pub const ObjectType_OBJECT_PUBLICATION_REL: u32 = 32;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_ROLE")]
pub const ObjectType_OBJECT_ROLE: u32 = 33;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_ROUTINE")]
pub const ObjectType_OBJECT_ROUTINE: u32 = 34;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_RULE")]
pub const ObjectType_OBJECT_RULE: u32 = 35;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_SCHEMA")]
pub const ObjectType_OBJECT_SCHEMA: u32 = 36;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_SEQUENCE")]
pub const ObjectType_OBJECT_SEQUENCE: u32 = 37;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_SUBSCRIPTION")]
pub const ObjectType_OBJECT_SUBSCRIPTION: u32 = 38;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_STATISTIC_EXT")]
pub const ObjectType_OBJECT_STATISTIC_EXT: u32 = 39;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_TABCONSTRAINT")]
pub const ObjectType_OBJECT_TABCONSTRAINT: u32 = 40;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_TABLE")]
pub const ObjectType_OBJECT_TABLE: u32 = 41;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_TABLESPACE")]
pub const ObjectType_OBJECT_TABLESPACE: u32 = 42;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_TRANSFORM")]
pub const ObjectType_OBJECT_TRANSFORM: u32 = 43;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_TRIGGER")]
pub const ObjectType_OBJECT_TRIGGER: u32 = 44;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_TSCONFIGURATION")]
pub const ObjectType_OBJECT_TSCONFIGURATION: u32 = 45;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_TSDICTIONARY")]
pub const ObjectType_OBJECT_TSDICTIONARY: u32 = 46;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_TSPARSER")]
pub const ObjectType_OBJECT_TSPARSER: u32 = 47;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_TSTEMPLATE")]
pub const ObjectType_OBJECT_TSTEMPLATE: u32 = 48;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_TYPE")]
pub const ObjectType_OBJECT_TYPE: u32 = 49;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_USER_MAPPING")]
pub const ObjectType_OBJECT_USER_MAPPING: u32 = 50;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ObjectType::OBJECT_VIEW")]
pub const ObjectType_OBJECT_VIEW: u32 = 51;
#[deprecated(since = "0.12.0", note = "you want pg_sys::OnCommitAction::ONCOMMIT_NOOP")]
pub const OnCommitAction_ONCOMMIT_NOOP: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::OnCommitAction::ONCOMMIT_PRESERVE_ROWS")]
pub const OnCommitAction_ONCOMMIT_PRESERVE_ROWS: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::OnCommitAction::ONCOMMIT_DELETE_ROWS")]
pub const OnCommitAction_ONCOMMIT_DELETE_ROWS: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::OnCommitAction::ONCOMMIT_DROP")]
pub const OnCommitAction_ONCOMMIT_DROP: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::OnConflictAction::ONCONFLICT_NONE")]
pub const OnConflictAction_ONCONFLICT_NONE: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::OnConflictAction::ONCONFLICT_NOTHING")]
pub const OnConflictAction_ONCONFLICT_NOTHING: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::OnConflictAction::ONCONFLICT_UPDATE")]
pub const OnConflictAction_ONCONFLICT_UPDATE: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::OutputPluginOutputType::OUTPUT_PLUGIN_BINARY_OUTPUT"
)]
pub const OutputPluginOutputType_OUTPUT_PLUGIN_BINARY_OUTPUT: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::OutputPluginOutputType::OUTPUT_PLUGIN_TEXTUAL_OUTPUT"
)]
pub const OutputPluginOutputType_OUTPUT_PLUGIN_TEXTUAL_OUTPUT: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::OverridingKind::OVERRIDING_NOT_SET")]
pub const OverridingKind_OVERRIDING_NOT_SET: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::OverridingKind::OVERRIDING_USER_VALUE")]
pub const OverridingKind_OVERRIDING_USER_VALUE: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::OverridingKind::OVERRIDING_SYSTEM_VALUE")]
pub const OverridingKind_OVERRIDING_SYSTEM_VALUE: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PGErrorVerbosity::PGERROR_TERSE")]
pub const PGErrorVerbosity_PGERROR_TERSE: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PGErrorVerbosity::PGERROR_DEFAULT")]
pub const PGErrorVerbosity_PGERROR_DEFAULT: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PGErrorVerbosity::PGERROR_VERBOSE")]
pub const PGErrorVerbosity_PGERROR_VERBOSE: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_datum_type::PLPGSQL_DTYPE_VAR")]
pub const PLpgSQL_datum_type_PLPGSQL_DTYPE_VAR: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_datum_type::PLPGSQL_DTYPE_ROW")]
pub const PLpgSQL_datum_type_PLPGSQL_DTYPE_ROW: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_datum_type::PLPGSQL_DTYPE_REC")]
pub const PLpgSQL_datum_type_PLPGSQL_DTYPE_REC: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_datum_type::PLPGSQL_DTYPE_RECFIELD"
)]
pub const PLpgSQL_datum_type_PLPGSQL_DTYPE_RECFIELD: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_datum_type::PLPGSQL_DTYPE_PROMISE")]
pub const PLpgSQL_datum_type_PLPGSQL_DTYPE_PROMISE: u32 = 4;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_getdiag_kind::PLPGSQL_GETDIAG_ROW_COUNT"
)]
pub const PLpgSQL_getdiag_kind_PLPGSQL_GETDIAG_ROW_COUNT: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_getdiag_kind::PLPGSQL_GETDIAG_CONTEXT"
)]
pub const PLpgSQL_getdiag_kind_PLPGSQL_GETDIAG_CONTEXT: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_getdiag_kind::PLPGSQL_GETDIAG_ERROR_CONTEXT"
)]
pub const PLpgSQL_getdiag_kind_PLPGSQL_GETDIAG_ERROR_CONTEXT: u32 = 3;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_getdiag_kind::PLPGSQL_GETDIAG_ERROR_DETAIL"
)]
pub const PLpgSQL_getdiag_kind_PLPGSQL_GETDIAG_ERROR_DETAIL: u32 = 4;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_getdiag_kind::PLPGSQL_GETDIAG_ERROR_HINT"
)]
pub const PLpgSQL_getdiag_kind_PLPGSQL_GETDIAG_ERROR_HINT: u32 = 5;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_getdiag_kind::PLPGSQL_GETDIAG_RETURNED_SQLSTATE"
)]
pub const PLpgSQL_getdiag_kind_PLPGSQL_GETDIAG_RETURNED_SQLSTATE: u32 = 6;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_getdiag_kind::PLPGSQL_GETDIAG_COLUMN_NAME"
)]
pub const PLpgSQL_getdiag_kind_PLPGSQL_GETDIAG_COLUMN_NAME: u32 = 7;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_getdiag_kind::PLPGSQL_GETDIAG_CONSTRAINT_NAME"
)]
pub const PLpgSQL_getdiag_kind_PLPGSQL_GETDIAG_CONSTRAINT_NAME: u32 = 8;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_getdiag_kind::PLPGSQL_GETDIAG_DATATYPE_NAME"
)]
pub const PLpgSQL_getdiag_kind_PLPGSQL_GETDIAG_DATATYPE_NAME: u32 = 9;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_getdiag_kind::PLPGSQL_GETDIAG_MESSAGE_TEXT"
)]
pub const PLpgSQL_getdiag_kind_PLPGSQL_GETDIAG_MESSAGE_TEXT: u32 = 10;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_getdiag_kind::PLPGSQL_GETDIAG_TABLE_NAME"
)]
pub const PLpgSQL_getdiag_kind_PLPGSQL_GETDIAG_TABLE_NAME: u32 = 11;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_getdiag_kind::PLPGSQL_GETDIAG_SCHEMA_NAME"
)]
pub const PLpgSQL_getdiag_kind_PLPGSQL_GETDIAG_SCHEMA_NAME: u32 = 12;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_label_type::PLPGSQL_LABEL_BLOCK")]
pub const PLpgSQL_label_type_PLPGSQL_LABEL_BLOCK: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_label_type::PLPGSQL_LABEL_LOOP")]
pub const PLpgSQL_label_type_PLPGSQL_LABEL_LOOP: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_label_type::PLPGSQL_LABEL_OTHER")]
pub const PLpgSQL_label_type_PLPGSQL_LABEL_OTHER: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_nsitem_type::PLPGSQL_NSTYPE_LABEL")]
pub const PLpgSQL_nsitem_type_PLPGSQL_NSTYPE_LABEL: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_nsitem_type::PLPGSQL_NSTYPE_VAR")]
pub const PLpgSQL_nsitem_type_PLPGSQL_NSTYPE_VAR: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_nsitem_type::PLPGSQL_NSTYPE_REC")]
pub const PLpgSQL_nsitem_type_PLPGSQL_NSTYPE_REC: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_promise_type::PLPGSQL_PROMISE_NONE"
)]
pub const PLpgSQL_promise_type_PLPGSQL_PROMISE_NONE: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_promise_type::PLPGSQL_PROMISE_TG_NAME"
)]
pub const PLpgSQL_promise_type_PLPGSQL_PROMISE_TG_NAME: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_promise_type::PLPGSQL_PROMISE_TG_WHEN"
)]
pub const PLpgSQL_promise_type_PLPGSQL_PROMISE_TG_WHEN: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_promise_type::PLPGSQL_PROMISE_TG_LEVEL"
)]
pub const PLpgSQL_promise_type_PLPGSQL_PROMISE_TG_LEVEL: u32 = 3;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_promise_type::PLPGSQL_PROMISE_TG_OP"
)]
pub const PLpgSQL_promise_type_PLPGSQL_PROMISE_TG_OP: u32 = 4;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_promise_type::PLPGSQL_PROMISE_TG_RELID"
)]
pub const PLpgSQL_promise_type_PLPGSQL_PROMISE_TG_RELID: u32 = 5;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_promise_type::PLPGSQL_PROMISE_TG_TABLE_NAME"
)]
pub const PLpgSQL_promise_type_PLPGSQL_PROMISE_TG_TABLE_NAME: u32 = 6;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_promise_type::PLPGSQL_PROMISE_TG_TABLE_SCHEMA"
)]
pub const PLpgSQL_promise_type_PLPGSQL_PROMISE_TG_TABLE_SCHEMA: u32 = 7;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_promise_type::PLPGSQL_PROMISE_TG_NARGS"
)]
pub const PLpgSQL_promise_type_PLPGSQL_PROMISE_TG_NARGS: u32 = 8;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_promise_type::PLPGSQL_PROMISE_TG_ARGV"
)]
pub const PLpgSQL_promise_type_PLPGSQL_PROMISE_TG_ARGV: u32 = 9;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_promise_type::PLPGSQL_PROMISE_TG_EVENT"
)]
pub const PLpgSQL_promise_type_PLPGSQL_PROMISE_TG_EVENT: u32 = 10;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_promise_type::PLPGSQL_PROMISE_TG_TAG"
)]
pub const PLpgSQL_promise_type_PLPGSQL_PROMISE_TG_TAG: u32 = 11;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_raise_option_type::PLPGSQL_RAISEOPTION_ERRCODE"
)]
pub const PLpgSQL_raise_option_type_PLPGSQL_RAISEOPTION_ERRCODE: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_raise_option_type::PLPGSQL_RAISEOPTION_MESSAGE"
)]
pub const PLpgSQL_raise_option_type_PLPGSQL_RAISEOPTION_MESSAGE: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_raise_option_type::PLPGSQL_RAISEOPTION_DETAIL"
)]
pub const PLpgSQL_raise_option_type_PLPGSQL_RAISEOPTION_DETAIL: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_raise_option_type::PLPGSQL_RAISEOPTION_HINT"
)]
pub const PLpgSQL_raise_option_type_PLPGSQL_RAISEOPTION_HINT: u32 = 3;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_raise_option_type::PLPGSQL_RAISEOPTION_COLUMN"
)]
pub const PLpgSQL_raise_option_type_PLPGSQL_RAISEOPTION_COLUMN: u32 = 4;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_raise_option_type::PLPGSQL_RAISEOPTION_CONSTRAINT"
)]
pub const PLpgSQL_raise_option_type_PLPGSQL_RAISEOPTION_CONSTRAINT: u32 = 5;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_raise_option_type::PLPGSQL_RAISEOPTION_DATATYPE"
)]
pub const PLpgSQL_raise_option_type_PLPGSQL_RAISEOPTION_DATATYPE: u32 = 6;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_raise_option_type::PLPGSQL_RAISEOPTION_TABLE"
)]
pub const PLpgSQL_raise_option_type_PLPGSQL_RAISEOPTION_TABLE: u32 = 7;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_raise_option_type::PLPGSQL_RAISEOPTION_SCHEMA"
)]
pub const PLpgSQL_raise_option_type_PLPGSQL_RAISEOPTION_SCHEMA: u32 = 8;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_resolve_option::PLPGSQL_RESOLVE_ERROR"
)]
pub const PLpgSQL_resolve_option_PLPGSQL_RESOLVE_ERROR: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_resolve_option::PLPGSQL_RESOLVE_VARIABLE"
)]
pub const PLpgSQL_resolve_option_PLPGSQL_RESOLVE_VARIABLE: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_resolve_option::PLPGSQL_RESOLVE_COLUMN"
)]
pub const PLpgSQL_resolve_option_PLPGSQL_RESOLVE_COLUMN: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_stmt_type::PLPGSQL_STMT_BLOCK")]
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_BLOCK: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_stmt_type::PLPGSQL_STMT_ASSIGN")]
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_ASSIGN: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_stmt_type::PLPGSQL_STMT_IF")]
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_IF: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_stmt_type::PLPGSQL_STMT_CASE")]
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_CASE: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_stmt_type::PLPGSQL_STMT_LOOP")]
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_LOOP: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_stmt_type::PLPGSQL_STMT_WHILE")]
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_WHILE: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_stmt_type::PLPGSQL_STMT_FORI")]
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_FORI: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_stmt_type::PLPGSQL_STMT_FORS")]
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_FORS: u32 = 7;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_stmt_type::PLPGSQL_STMT_FORC")]
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_FORC: u32 = 8;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_stmt_type::PLPGSQL_STMT_FOREACH_A")]
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_FOREACH_A: u32 = 9;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_stmt_type::PLPGSQL_STMT_EXIT")]
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_EXIT: u32 = 10;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_stmt_type::PLPGSQL_STMT_RETURN")]
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_RETURN: u32 = 11;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_stmt_type::PLPGSQL_STMT_RETURN_NEXT"
)]
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_RETURN_NEXT: u32 = 12;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_stmt_type::PLPGSQL_STMT_RETURN_QUERY"
)]
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_RETURN_QUERY: u32 = 13;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_stmt_type::PLPGSQL_STMT_RAISE")]
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_RAISE: u32 = 14;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_stmt_type::PLPGSQL_STMT_ASSERT")]
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_ASSERT: u32 = 15;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_stmt_type::PLPGSQL_STMT_EXECSQL")]
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_EXECSQL: u32 = 16;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PLpgSQL_stmt_type::PLPGSQL_STMT_DYNEXECUTE"
)]
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_DYNEXECUTE: u32 = 17;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_stmt_type::PLPGSQL_STMT_DYNFORS")]
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_DYNFORS: u32 = 18;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_stmt_type::PLPGSQL_STMT_GETDIAG")]
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_GETDIAG: u32 = 19;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_stmt_type::PLPGSQL_STMT_OPEN")]
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_OPEN: u32 = 20;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_stmt_type::PLPGSQL_STMT_FETCH")]
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_FETCH: u32 = 21;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_stmt_type::PLPGSQL_STMT_CLOSE")]
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_CLOSE: u32 = 22;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_stmt_type::PLPGSQL_STMT_PERFORM")]
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_PERFORM: u32 = 23;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_stmt_type::PLPGSQL_STMT_CALL")]
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_CALL: u32 = 24;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_stmt_type::PLPGSQL_STMT_COMMIT")]
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_COMMIT: u32 = 25;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_stmt_type::PLPGSQL_STMT_ROLLBACK")]
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_ROLLBACK: u32 = 26;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_trigtype::PLPGSQL_DML_TRIGGER")]
pub const PLpgSQL_trigtype_PLPGSQL_DML_TRIGGER: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_trigtype::PLPGSQL_EVENT_TRIGGER")]
pub const PLpgSQL_trigtype_PLPGSQL_EVENT_TRIGGER: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_trigtype::PLPGSQL_NOT_TRIGGER")]
pub const PLpgSQL_trigtype_PLPGSQL_NOT_TRIGGER: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_type_type::PLPGSQL_TTYPE_SCALAR")]
pub const PLpgSQL_type_type_PLPGSQL_TTYPE_SCALAR: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_type_type::PLPGSQL_TTYPE_REC")]
pub const PLpgSQL_type_type_PLPGSQL_TTYPE_REC: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PLpgSQL_type_type::PLPGSQL_TTYPE_PSEUDO")]
pub const PLpgSQL_type_type_PLPGSQL_TTYPE_PSEUDO: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParamKind::PARAM_EXTERN")]
pub const ParamKind_PARAM_EXTERN: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParamKind::PARAM_EXEC")]
pub const ParamKind_PARAM_EXEC: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParamKind::PARAM_SUBLINK")]
pub const ParamKind_PARAM_SUBLINK: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParamKind::PARAM_MULTIEXPR")]
pub const ParamKind_PARAM_MULTIEXPR: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_NONE")]
pub const ParseExprKind_EXPR_KIND_NONE: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_OTHER")]
pub const ParseExprKind_EXPR_KIND_OTHER: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_JOIN_ON")]
pub const ParseExprKind_EXPR_KIND_JOIN_ON: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_JOIN_USING")]
pub const ParseExprKind_EXPR_KIND_JOIN_USING: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_FROM_SUBSELECT")]
pub const ParseExprKind_EXPR_KIND_FROM_SUBSELECT: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_FROM_FUNCTION")]
pub const ParseExprKind_EXPR_KIND_FROM_FUNCTION: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_WHERE")]
pub const ParseExprKind_EXPR_KIND_WHERE: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_HAVING")]
pub const ParseExprKind_EXPR_KIND_HAVING: u32 = 7;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_FILTER")]
pub const ParseExprKind_EXPR_KIND_FILTER: u32 = 8;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_WINDOW_PARTITION")]
pub const ParseExprKind_EXPR_KIND_WINDOW_PARTITION: u32 = 9;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_WINDOW_ORDER")]
pub const ParseExprKind_EXPR_KIND_WINDOW_ORDER: u32 = 10;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ParseExprKind::EXPR_KIND_WINDOW_FRAME_RANGE"
)]
pub const ParseExprKind_EXPR_KIND_WINDOW_FRAME_RANGE: u32 = 11;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ParseExprKind::EXPR_KIND_WINDOW_FRAME_ROWS"
)]
pub const ParseExprKind_EXPR_KIND_WINDOW_FRAME_ROWS: u32 = 12;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ParseExprKind::EXPR_KIND_WINDOW_FRAME_GROUPS"
)]
pub const ParseExprKind_EXPR_KIND_WINDOW_FRAME_GROUPS: u32 = 13;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_SELECT_TARGET")]
pub const ParseExprKind_EXPR_KIND_SELECT_TARGET: u32 = 14;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_INSERT_TARGET")]
pub const ParseExprKind_EXPR_KIND_INSERT_TARGET: u32 = 15;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_UPDATE_SOURCE")]
pub const ParseExprKind_EXPR_KIND_UPDATE_SOURCE: u32 = 16;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_UPDATE_TARGET")]
pub const ParseExprKind_EXPR_KIND_UPDATE_TARGET: u32 = 17;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_MERGE_WHEN")]
pub const ParseExprKind_EXPR_KIND_MERGE_WHEN: u32 = 18;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_GROUP_BY")]
pub const ParseExprKind_EXPR_KIND_GROUP_BY: u32 = 19;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_ORDER_BY")]
pub const ParseExprKind_EXPR_KIND_ORDER_BY: u32 = 20;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_DISTINCT_ON")]
pub const ParseExprKind_EXPR_KIND_DISTINCT_ON: u32 = 21;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_LIMIT")]
pub const ParseExprKind_EXPR_KIND_LIMIT: u32 = 22;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_OFFSET")]
pub const ParseExprKind_EXPR_KIND_OFFSET: u32 = 23;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_RETURNING")]
pub const ParseExprKind_EXPR_KIND_RETURNING: u32 = 24;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_MERGE_RETURNING")]
pub const ParseExprKind_EXPR_KIND_MERGE_RETURNING: u32 = 25;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_VALUES")]
pub const ParseExprKind_EXPR_KIND_VALUES: u32 = 26;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_VALUES_SINGLE")]
pub const ParseExprKind_EXPR_KIND_VALUES_SINGLE: u32 = 27;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_CHECK_CONSTRAINT")]
pub const ParseExprKind_EXPR_KIND_CHECK_CONSTRAINT: u32 = 28;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_DOMAIN_CHECK")]
pub const ParseExprKind_EXPR_KIND_DOMAIN_CHECK: u32 = 29;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_COLUMN_DEFAULT")]
pub const ParseExprKind_EXPR_KIND_COLUMN_DEFAULT: u32 = 30;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_FUNCTION_DEFAULT")]
pub const ParseExprKind_EXPR_KIND_FUNCTION_DEFAULT: u32 = 31;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_INDEX_EXPRESSION")]
pub const ParseExprKind_EXPR_KIND_INDEX_EXPRESSION: u32 = 32;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_INDEX_PREDICATE")]
pub const ParseExprKind_EXPR_KIND_INDEX_PREDICATE: u32 = 33;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_STATS_EXPRESSION")]
pub const ParseExprKind_EXPR_KIND_STATS_EXPRESSION: u32 = 34;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ParseExprKind::EXPR_KIND_ALTER_COL_TRANSFORM"
)]
pub const ParseExprKind_EXPR_KIND_ALTER_COL_TRANSFORM: u32 = 35;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ParseExprKind::EXPR_KIND_EXECUTE_PARAMETER"
)]
pub const ParseExprKind_EXPR_KIND_EXECUTE_PARAMETER: u32 = 36;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_TRIGGER_WHEN")]
pub const ParseExprKind_EXPR_KIND_TRIGGER_WHEN: u32 = 37;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_POLICY")]
pub const ParseExprKind_EXPR_KIND_POLICY: u32 = 38;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_PARTITION_BOUND")]
pub const ParseExprKind_EXPR_KIND_PARTITION_BOUND: u32 = 39;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ParseExprKind::EXPR_KIND_PARTITION_EXPRESSION"
)]
pub const ParseExprKind_EXPR_KIND_PARTITION_EXPRESSION: u32 = 40;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_CALL_ARGUMENT")]
pub const ParseExprKind_EXPR_KIND_CALL_ARGUMENT: u32 = 41;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_COPY_WHERE")]
pub const ParseExprKind_EXPR_KIND_COPY_WHERE: u32 = 42;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_GENERATED_COLUMN")]
pub const ParseExprKind_EXPR_KIND_GENERATED_COLUMN: u32 = 43;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ParseExprKind::EXPR_KIND_CYCLE_MARK")]
pub const ParseExprKind_EXPR_KIND_CYCLE_MARK: u32 = 44;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PartitionPruneCombineOp::PARTPRUNE_COMBINE_UNION"
)]
pub const PartitionPruneCombineOp_PARTPRUNE_COMBINE_UNION: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PartitionPruneCombineOp::PARTPRUNE_COMBINE_INTERSECT"
)]
pub const PartitionPruneCombineOp_PARTPRUNE_COMBINE_INTERSECT: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PartitionRangeDatumKind::PARTITION_RANGE_DATUM_MINVALUE"
)]
pub const PartitionRangeDatumKind_PARTITION_RANGE_DATUM_MINVALUE: i32 = -1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PartitionRangeDatumKind::PARTITION_RANGE_DATUM_VALUE"
)]
pub const PartitionRangeDatumKind_PARTITION_RANGE_DATUM_VALUE: i32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PartitionRangeDatumKind::PARTITION_RANGE_DATUM_MAXVALUE"
)]
pub const PartitionRangeDatumKind_PARTITION_RANGE_DATUM_MAXVALUE: i32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PartitionStrategy::PARTITION_STRATEGY_LIST"
)]
pub const PartitionStrategy_PARTITION_STRATEGY_LIST: u32 = 108;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PartitionStrategy::PARTITION_STRATEGY_RANGE"
)]
pub const PartitionStrategy_PARTITION_STRATEGY_RANGE: u32 = 114;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PartitionStrategy::PARTITION_STRATEGY_HASH"
)]
pub const PartitionStrategy_PARTITION_STRATEGY_HASH: u32 = 104;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PartitionwiseAggregateType::PARTITIONWISE_AGGREGATE_NONE"
)]
pub const PartitionwiseAggregateType_PARTITIONWISE_AGGREGATE_NONE: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PartitionwiseAggregateType::PARTITIONWISE_AGGREGATE_FULL"
)]
pub const PartitionwiseAggregateType_PARTITIONWISE_AGGREGATE_FULL: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PartitionwiseAggregateType::PARTITIONWISE_AGGREGATE_PARTIAL"
)]
pub const PartitionwiseAggregateType_PARTITIONWISE_AGGREGATE_PARTIAL: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PasswordType::PASSWORD_TYPE_PLAINTEXT")]
pub const PasswordType_PASSWORD_TYPE_PLAINTEXT: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PasswordType::PASSWORD_TYPE_MD5")]
pub const PasswordType_PASSWORD_TYPE_MD5: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PasswordType::PASSWORD_TYPE_SCRAM_SHA_256")]
pub const PasswordType_PASSWORD_TYPE_SCRAM_SHA_256: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PathKeysComparison::PATHKEYS_EQUAL")]
pub const PathKeysComparison_PATHKEYS_EQUAL: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PathKeysComparison::PATHKEYS_BETTER1")]
pub const PathKeysComparison_PATHKEYS_BETTER1: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PathKeysComparison::PATHKEYS_BETTER2")]
pub const PathKeysComparison_PATHKEYS_BETTER2: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PathKeysComparison::PATHKEYS_DIFFERENT")]
pub const PathKeysComparison_PATHKEYS_DIFFERENT: u32 = 3;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PgStat_FetchConsistency::PGSTAT_FETCH_CONSISTENCY_NONE"
)]
pub const PgStat_FetchConsistency_PGSTAT_FETCH_CONSISTENCY_NONE: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PgStat_FetchConsistency::PGSTAT_FETCH_CONSISTENCY_CACHE"
)]
pub const PgStat_FetchConsistency_PGSTAT_FETCH_CONSISTENCY_CACHE: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PgStat_FetchConsistency::PGSTAT_FETCH_CONSISTENCY_SNAPSHOT"
)]
pub const PgStat_FetchConsistency_PGSTAT_FETCH_CONSISTENCY_SNAPSHOT: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PgStat_Kind::PGSTAT_KIND_INVALID")]
pub const PgStat_Kind_PGSTAT_KIND_INVALID: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PgStat_Kind::PGSTAT_KIND_DATABASE")]
pub const PgStat_Kind_PGSTAT_KIND_DATABASE: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PgStat_Kind::PGSTAT_KIND_RELATION")]
pub const PgStat_Kind_PGSTAT_KIND_RELATION: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PgStat_Kind::PGSTAT_KIND_FUNCTION")]
pub const PgStat_Kind_PGSTAT_KIND_FUNCTION: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PgStat_Kind::PGSTAT_KIND_REPLSLOT")]
pub const PgStat_Kind_PGSTAT_KIND_REPLSLOT: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PgStat_Kind::PGSTAT_KIND_SUBSCRIPTION")]
pub const PgStat_Kind_PGSTAT_KIND_SUBSCRIPTION: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PgStat_Kind::PGSTAT_KIND_ARCHIVER")]
pub const PgStat_Kind_PGSTAT_KIND_ARCHIVER: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PgStat_Kind::PGSTAT_KIND_BGWRITER")]
pub const PgStat_Kind_PGSTAT_KIND_BGWRITER: u32 = 7;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PgStat_Kind::PGSTAT_KIND_CHECKPOINTER")]
pub const PgStat_Kind_PGSTAT_KIND_CHECKPOINTER: u32 = 8;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PgStat_Kind::PGSTAT_KIND_IO")]
pub const PgStat_Kind_PGSTAT_KIND_IO: u32 = 9;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PgStat_Kind::PGSTAT_KIND_SLRU")]
pub const PgStat_Kind_PGSTAT_KIND_SLRU: u32 = 10;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PgStat_Kind::PGSTAT_KIND_WAL")]
pub const PgStat_Kind_PGSTAT_KIND_WAL: u32 = 11;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PlanCacheMode::PLAN_CACHE_MODE_AUTO")]
pub const PlanCacheMode_PLAN_CACHE_MODE_AUTO: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PlanCacheMode::PLAN_CACHE_MODE_FORCE_GENERIC_PLAN"
)]
pub const PlanCacheMode_PLAN_CACHE_MODE_FORCE_GENERIC_PLAN: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PlanCacheMode::PLAN_CACHE_MODE_FORCE_CUSTOM_PLAN"
)]
pub const PlanCacheMode_PLAN_CACHE_MODE_FORCE_CUSTOM_PLAN: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PortalStatus::PORTAL_NEW")]
pub const PortalStatus_PORTAL_NEW: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PortalStatus::PORTAL_DEFINED")]
pub const PortalStatus_PORTAL_DEFINED: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PortalStatus::PORTAL_READY")]
pub const PortalStatus_PORTAL_READY: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PortalStatus::PORTAL_ACTIVE")]
pub const PortalStatus_PORTAL_ACTIVE: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PortalStatus::PORTAL_DONE")]
pub const PortalStatus_PORTAL_DONE: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PortalStatus::PORTAL_FAILED")]
pub const PortalStatus_PORTAL_FAILED: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PortalStrategy::PORTAL_ONE_SELECT")]
pub const PortalStrategy_PORTAL_ONE_SELECT: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PortalStrategy::PORTAL_ONE_RETURNING")]
pub const PortalStrategy_PORTAL_ONE_RETURNING: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PortalStrategy::PORTAL_ONE_MOD_WITH")]
pub const PortalStrategy_PORTAL_ONE_MOD_WITH: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PortalStrategy::PORTAL_UTIL_SELECT")]
pub const PortalStrategy_PORTAL_UTIL_SELECT: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PortalStrategy::PORTAL_MULTI_QUERY")]
pub const PortalStrategy_PORTAL_MULTI_QUERY: u32 = 4;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ProcSignalBarrierType::PROCSIGNAL_BARRIER_SMGRRELEASE"
)]
pub const ProcSignalBarrierType_PROCSIGNAL_BARRIER_SMGRRELEASE: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ProcSignalReason::PROCSIG_CATCHUP_INTERRUPT"
)]
pub const ProcSignalReason_PROCSIG_CATCHUP_INTERRUPT: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ProcSignalReason::PROCSIG_NOTIFY_INTERRUPT"
)]
pub const ProcSignalReason_PROCSIG_NOTIFY_INTERRUPT: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ProcSignalReason::PROCSIG_PARALLEL_MESSAGE"
)]
pub const ProcSignalReason_PROCSIG_PARALLEL_MESSAGE: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ProcSignalReason::PROCSIG_WALSND_INIT_STOPPING"
)]
pub const ProcSignalReason_PROCSIG_WALSND_INIT_STOPPING: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ProcSignalReason::PROCSIG_BARRIER")]
pub const ProcSignalReason_PROCSIG_BARRIER: u32 = 4;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ProcSignalReason::PROCSIG_LOG_MEMORY_CONTEXT"
)]
pub const ProcSignalReason_PROCSIG_LOG_MEMORY_CONTEXT: u32 = 5;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ProcSignalReason::PROCSIG_PARALLEL_APPLY_MESSAGE"
)]
pub const ProcSignalReason_PROCSIG_PARALLEL_APPLY_MESSAGE: u32 = 6;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ProcSignalReason::PROCSIG_RECOVERY_CONFLICT_FIRST"
)]
pub const ProcSignalReason_PROCSIG_RECOVERY_CONFLICT_FIRST: u32 = 7;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ProcSignalReason::PROCSIG_RECOVERY_CONFLICT_DATABASE"
)]
pub const ProcSignalReason_PROCSIG_RECOVERY_CONFLICT_DATABASE: u32 = 7;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ProcSignalReason::PROCSIG_RECOVERY_CONFLICT_TABLESPACE"
)]
pub const ProcSignalReason_PROCSIG_RECOVERY_CONFLICT_TABLESPACE: u32 = 8;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ProcSignalReason::PROCSIG_RECOVERY_CONFLICT_LOCK"
)]
pub const ProcSignalReason_PROCSIG_RECOVERY_CONFLICT_LOCK: u32 = 9;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ProcSignalReason::PROCSIG_RECOVERY_CONFLICT_SNAPSHOT"
)]
pub const ProcSignalReason_PROCSIG_RECOVERY_CONFLICT_SNAPSHOT: u32 = 10;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ProcSignalReason::PROCSIG_RECOVERY_CONFLICT_LOGICALSLOT"
)]
pub const ProcSignalReason_PROCSIG_RECOVERY_CONFLICT_LOGICALSLOT: u32 = 11;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ProcSignalReason::PROCSIG_RECOVERY_CONFLICT_BUFFERPIN"
)]
pub const ProcSignalReason_PROCSIG_RECOVERY_CONFLICT_BUFFERPIN: u32 = 12;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ProcSignalReason::PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK"
)]
pub const ProcSignalReason_PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK: u32 = 13;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ProcSignalReason::PROCSIG_RECOVERY_CONFLICT_LAST"
)]
pub const ProcSignalReason_PROCSIG_RECOVERY_CONFLICT_LAST: u32 = 13;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ProcSignalReason::NUM_PROCSIGNALS")]
pub const ProcSignalReason_NUM_PROCSIGNALS: u32 = 14;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ProcWaitStatus::PROC_WAIT_STATUS_OK")]
pub const ProcWaitStatus_PROC_WAIT_STATUS_OK: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ProcWaitStatus::PROC_WAIT_STATUS_WAITING")]
pub const ProcWaitStatus_PROC_WAIT_STATUS_WAITING: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ProcWaitStatus::PROC_WAIT_STATUS_ERROR")]
pub const ProcWaitStatus_PROC_WAIT_STATUS_ERROR: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ProcessUtilityContext::PROCESS_UTILITY_TOPLEVEL"
)]
pub const ProcessUtilityContext_PROCESS_UTILITY_TOPLEVEL: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ProcessUtilityContext::PROCESS_UTILITY_QUERY"
)]
pub const ProcessUtilityContext_PROCESS_UTILITY_QUERY: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ProcessUtilityContext::PROCESS_UTILITY_QUERY_NONATOMIC"
)]
pub const ProcessUtilityContext_PROCESS_UTILITY_QUERY_NONATOMIC: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ProcessUtilityContext::PROCESS_UTILITY_SUBCOMMAND"
)]
pub const ProcessUtilityContext_PROCESS_UTILITY_SUBCOMMAND: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ProcessingMode::BootstrapProcessing")]
pub const ProcessingMode_BootstrapProcessing: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ProcessingMode::InitProcessing")]
pub const ProcessingMode_InitProcessing: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ProcessingMode::NormalProcessing")]
pub const ProcessingMode_NormalProcessing: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ProgressCommandType::PROGRESS_COMMAND_INVALID"
)]
pub const ProgressCommandType_PROGRESS_COMMAND_INVALID: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ProgressCommandType::PROGRESS_COMMAND_VACUUM"
)]
pub const ProgressCommandType_PROGRESS_COMMAND_VACUUM: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ProgressCommandType::PROGRESS_COMMAND_ANALYZE"
)]
pub const ProgressCommandType_PROGRESS_COMMAND_ANALYZE: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ProgressCommandType::PROGRESS_COMMAND_CLUSTER"
)]
pub const ProgressCommandType_PROGRESS_COMMAND_CLUSTER: u32 = 3;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ProgressCommandType::PROGRESS_COMMAND_CREATE_INDEX"
)]
pub const ProgressCommandType_PROGRESS_COMMAND_CREATE_INDEX: u32 = 4;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ProgressCommandType::PROGRESS_COMMAND_BASEBACKUP"
)]
pub const ProgressCommandType_PROGRESS_COMMAND_BASEBACKUP: u32 = 5;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ProgressCommandType::PROGRESS_COMMAND_COPY"
)]
pub const ProgressCommandType_PROGRESS_COMMAND_COPY: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PruneReason::PRUNE_ON_ACCESS")]
pub const PruneReason_PRUNE_ON_ACCESS: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PruneReason::PRUNE_VACUUM_SCAN")]
pub const PruneReason_PRUNE_VACUUM_SCAN: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PruneReason::PRUNE_VACUUM_CLEANUP")]
pub const PruneReason_PRUNE_VACUUM_CLEANUP: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PublicationObjSpecType::PUBLICATIONOBJ_TABLE"
)]
pub const PublicationObjSpecType_PUBLICATIONOBJ_TABLE: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PublicationObjSpecType::PUBLICATIONOBJ_TABLES_IN_SCHEMA"
)]
pub const PublicationObjSpecType_PUBLICATIONOBJ_TABLES_IN_SCHEMA: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PublicationObjSpecType::PUBLICATIONOBJ_TABLES_IN_CUR_SCHEMA"
)]
pub const PublicationObjSpecType_PUBLICATIONOBJ_TABLES_IN_CUR_SCHEMA: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::PublicationObjSpecType::PUBLICATIONOBJ_CONTINUATION"
)]
pub const PublicationObjSpecType_PUBLICATIONOBJ_CONTINUATION: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PublicationPartOpt::PUBLICATION_PART_ROOT")]
pub const PublicationPartOpt_PUBLICATION_PART_ROOT: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PublicationPartOpt::PUBLICATION_PART_LEAF")]
pub const PublicationPartOpt_PUBLICATION_PART_LEAF: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::PublicationPartOpt::PUBLICATION_PART_ALL")]
pub const PublicationPartOpt_PUBLICATION_PART_ALL: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::QuerySource::QSRC_ORIGINAL")]
pub const QuerySource_QSRC_ORIGINAL: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::QuerySource::QSRC_PARSER")]
pub const QuerySource_QSRC_PARSER: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::QuerySource::QSRC_INSTEAD_RULE")]
pub const QuerySource_QSRC_INSTEAD_RULE: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::QuerySource::QSRC_QUAL_INSTEAD_RULE")]
pub const QuerySource_QSRC_QUAL_INSTEAD_RULE: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::QuerySource::QSRC_NON_INSTEAD_RULE")]
pub const QuerySource_QSRC_NON_INSTEAD_RULE: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RTEKind::RTE_RELATION")]
pub const RTEKind_RTE_RELATION: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RTEKind::RTE_SUBQUERY")]
pub const RTEKind_RTE_SUBQUERY: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RTEKind::RTE_JOIN")]
pub const RTEKind_RTE_JOIN: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RTEKind::RTE_FUNCTION")]
pub const RTEKind_RTE_FUNCTION: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RTEKind::RTE_TABLEFUNC")]
pub const RTEKind_RTE_TABLEFUNC: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RTEKind::RTE_VALUES")]
pub const RTEKind_RTE_VALUES: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RTEKind::RTE_CTE")]
pub const RTEKind_RTE_CTE: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RTEKind::RTE_NAMEDTUPLESTORE")]
pub const RTEKind_RTE_NAMEDTUPLESTORE: u32 = 7;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RTEKind::RTE_RESULT")]
pub const RTEKind_RTE_RESULT: u32 = 8;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RVROption::RVR_MISSING_OK")]
pub const RVROption_RVR_MISSING_OK: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RVROption::RVR_NOWAIT")]
pub const RVROption_RVR_NOWAIT: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RVROption::RVR_SKIP_LOCKED")]
pub const RVROption_RVR_SKIP_LOCKED: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RawParseMode::RAW_PARSE_DEFAULT")]
pub const RawParseMode_RAW_PARSE_DEFAULT: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RawParseMode::RAW_PARSE_TYPE_NAME")]
pub const RawParseMode_RAW_PARSE_TYPE_NAME: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RawParseMode::RAW_PARSE_PLPGSQL_EXPR")]
pub const RawParseMode_RAW_PARSE_PLPGSQL_EXPR: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RawParseMode::RAW_PARSE_PLPGSQL_ASSIGN1")]
pub const RawParseMode_RAW_PARSE_PLPGSQL_ASSIGN1: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RawParseMode::RAW_PARSE_PLPGSQL_ASSIGN2")]
pub const RawParseMode_RAW_PARSE_PLPGSQL_ASSIGN2: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RawParseMode::RAW_PARSE_PLPGSQL_ASSIGN3")]
pub const RawParseMode_RAW_PARSE_PLPGSQL_ASSIGN3: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ReadBufferMode::RBM_NORMAL")]
pub const ReadBufferMode_RBM_NORMAL: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ReadBufferMode::RBM_ZERO_AND_LOCK")]
pub const ReadBufferMode_RBM_ZERO_AND_LOCK: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ReadBufferMode::RBM_ZERO_AND_CLEANUP_LOCK")]
pub const ReadBufferMode_RBM_ZERO_AND_CLEANUP_LOCK: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ReadBufferMode::RBM_ZERO_ON_ERROR")]
pub const ReadBufferMode_RBM_ZERO_ON_ERROR: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ReadBufferMode::RBM_NORMAL_NO_LOG")]
pub const ReadBufferMode_RBM_NORMAL_NO_LOG: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RecoveryPauseState::RECOVERY_NOT_PAUSED")]
pub const RecoveryPauseState_RECOVERY_NOT_PAUSED: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::RecoveryPauseState::RECOVERY_PAUSE_REQUESTED"
)]
pub const RecoveryPauseState_RECOVERY_PAUSE_REQUESTED: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RecoveryPauseState::RECOVERY_PAUSED")]
pub const RecoveryPauseState_RECOVERY_PAUSED: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RecoveryState::RECOVERY_STATE_CRASH")]
pub const RecoveryState_RECOVERY_STATE_CRASH: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RecoveryState::RECOVERY_STATE_ARCHIVE")]
pub const RecoveryState_RECOVERY_STATE_ARCHIVE: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RecoveryState::RECOVERY_STATE_DONE")]
pub const RecoveryState_RECOVERY_STATE_DONE: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::RecoveryTargetAction::RECOVERY_TARGET_ACTION_PAUSE"
)]
pub const RecoveryTargetAction_RECOVERY_TARGET_ACTION_PAUSE: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::RecoveryTargetAction::RECOVERY_TARGET_ACTION_PROMOTE"
)]
pub const RecoveryTargetAction_RECOVERY_TARGET_ACTION_PROMOTE: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::RecoveryTargetAction::RECOVERY_TARGET_ACTION_SHUTDOWN"
)]
pub const RecoveryTargetAction_RECOVERY_TARGET_ACTION_SHUTDOWN: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::RecoveryTargetTimeLineGoal::RECOVERY_TARGET_TIMELINE_CONTROLFILE"
)]
pub const RecoveryTargetTimeLineGoal_RECOVERY_TARGET_TIMELINE_CONTROLFILE: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::RecoveryTargetTimeLineGoal::RECOVERY_TARGET_TIMELINE_LATEST"
)]
pub const RecoveryTargetTimeLineGoal_RECOVERY_TARGET_TIMELINE_LATEST: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::RecoveryTargetTimeLineGoal::RECOVERY_TARGET_TIMELINE_NUMERIC"
)]
pub const RecoveryTargetTimeLineGoal_RECOVERY_TARGET_TIMELINE_NUMERIC: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RecoveryTargetType::RECOVERY_TARGET_UNSET")]
pub const RecoveryTargetType_RECOVERY_TARGET_UNSET: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RecoveryTargetType::RECOVERY_TARGET_XID")]
pub const RecoveryTargetType_RECOVERY_TARGET_XID: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RecoveryTargetType::RECOVERY_TARGET_TIME")]
pub const RecoveryTargetType_RECOVERY_TARGET_TIME: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RecoveryTargetType::RECOVERY_TARGET_NAME")]
pub const RecoveryTargetType_RECOVERY_TARGET_NAME: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RecoveryTargetType::RECOVERY_TARGET_LSN")]
pub const RecoveryTargetType_RECOVERY_TARGET_LSN: u32 = 4;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::RecoveryTargetType::RECOVERY_TARGET_IMMEDIATE"
)]
pub const RecoveryTargetType_RECOVERY_TARGET_IMMEDIATE: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ReindexObjectType::REINDEX_OBJECT_INDEX")]
pub const ReindexObjectType_REINDEX_OBJECT_INDEX: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ReindexObjectType::REINDEX_OBJECT_TABLE")]
pub const ReindexObjectType_REINDEX_OBJECT_TABLE: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ReindexObjectType::REINDEX_OBJECT_SCHEMA")]
pub const ReindexObjectType_REINDEX_OBJECT_SCHEMA: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ReindexObjectType::REINDEX_OBJECT_SYSTEM")]
pub const ReindexObjectType_REINDEX_OBJECT_SYSTEM: u32 = 3;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ReindexObjectType::REINDEX_OBJECT_DATABASE"
)]
pub const ReindexObjectType_REINDEX_OBJECT_DATABASE: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RelOptKind::RELOPT_BASEREL")]
pub const RelOptKind_RELOPT_BASEREL: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RelOptKind::RELOPT_JOINREL")]
pub const RelOptKind_RELOPT_JOINREL: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RelOptKind::RELOPT_OTHER_MEMBER_REL")]
pub const RelOptKind_RELOPT_OTHER_MEMBER_REL: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RelOptKind::RELOPT_OTHER_JOINREL")]
pub const RelOptKind_RELOPT_OTHER_JOINREL: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RelOptKind::RELOPT_UPPER_REL")]
pub const RelOptKind_RELOPT_UPPER_REL: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RelOptKind::RELOPT_OTHER_UPPER_REL")]
pub const RelOptKind_RELOPT_OTHER_UPPER_REL: u32 = 5;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ReorderBufferChangeType::REORDER_BUFFER_CHANGE_INSERT"
)]
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_INSERT: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ReorderBufferChangeType::REORDER_BUFFER_CHANGE_UPDATE"
)]
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_UPDATE: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ReorderBufferChangeType::REORDER_BUFFER_CHANGE_DELETE"
)]
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_DELETE: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ReorderBufferChangeType::REORDER_BUFFER_CHANGE_MESSAGE"
)]
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_MESSAGE: u32 = 3;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ReorderBufferChangeType::REORDER_BUFFER_CHANGE_INVALIDATION"
)]
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_INVALIDATION: u32 = 4;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ReorderBufferChangeType::REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT"
)]
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT: u32 = 5;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ReorderBufferChangeType::REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID"
)]
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID: u32 = 6;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ReorderBufferChangeType::REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID"
)]
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID: u32 = 7;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ReorderBufferChangeType::REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT"
)]
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT: u32 = 8;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ReorderBufferChangeType::REORDER_BUFFER_CHANGE_INTERNAL_SPEC_CONFIRM"
)]
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_INTERNAL_SPEC_CONFIRM: u32 = 9;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ReorderBufferChangeType::REORDER_BUFFER_CHANGE_INTERNAL_SPEC_ABORT"
)]
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_INTERNAL_SPEC_ABORT: u32 = 10;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ReorderBufferChangeType::REORDER_BUFFER_CHANGE_TRUNCATE"
)]
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_TRUNCATE: u32 = 11;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ReplicationKind::REPLICATION_KIND_PHYSICAL"
)]
pub const ReplicationKind_REPLICATION_KIND_PHYSICAL: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ReplicationKind::REPLICATION_KIND_LOGICAL")]
pub const ReplicationKind_REPLICATION_KIND_LOGICAL: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ReplicationSlotInvalidationCause::RS_INVAL_NONE"
)]
pub const ReplicationSlotInvalidationCause_RS_INVAL_NONE: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ReplicationSlotInvalidationCause::RS_INVAL_WAL_REMOVED"
)]
pub const ReplicationSlotInvalidationCause_RS_INVAL_WAL_REMOVED: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ReplicationSlotInvalidationCause::RS_INVAL_HORIZON"
)]
pub const ReplicationSlotInvalidationCause_RS_INVAL_HORIZON: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ReplicationSlotInvalidationCause::RS_INVAL_WAL_LEVEL"
)]
pub const ReplicationSlotInvalidationCause_RS_INVAL_WAL_LEVEL: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ReplicationSlotPersistency::RS_PERSISTENT")]
pub const ReplicationSlotPersistency_RS_PERSISTENT: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ReplicationSlotPersistency::RS_EPHEMERAL")]
pub const ReplicationSlotPersistency_RS_EPHEMERAL: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ReplicationSlotPersistency::RS_TEMPORARY")]
pub const ReplicationSlotPersistency_RS_TEMPORARY: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ResourceReleasePhase::RESOURCE_RELEASE_BEFORE_LOCKS"
)]
pub const ResourceReleasePhase_RESOURCE_RELEASE_BEFORE_LOCKS: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ResourceReleasePhase::RESOURCE_RELEASE_LOCKS"
)]
pub const ResourceReleasePhase_RESOURCE_RELEASE_LOCKS: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ResourceReleasePhase::RESOURCE_RELEASE_AFTER_LOCKS"
)]
pub const ResourceReleasePhase_RESOURCE_RELEASE_AFTER_LOCKS: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RmgrIds::RM_XLOG_ID")]
pub const RmgrIds_RM_XLOG_ID: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RmgrIds::RM_XACT_ID")]
pub const RmgrIds_RM_XACT_ID: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RmgrIds::RM_SMGR_ID")]
pub const RmgrIds_RM_SMGR_ID: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RmgrIds::RM_CLOG_ID")]
pub const RmgrIds_RM_CLOG_ID: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RmgrIds::RM_DBASE_ID")]
pub const RmgrIds_RM_DBASE_ID: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RmgrIds::RM_TBLSPC_ID")]
pub const RmgrIds_RM_TBLSPC_ID: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RmgrIds::RM_MULTIXACT_ID")]
pub const RmgrIds_RM_MULTIXACT_ID: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RmgrIds::RM_RELMAP_ID")]
pub const RmgrIds_RM_RELMAP_ID: u32 = 7;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RmgrIds::RM_STANDBY_ID")]
pub const RmgrIds_RM_STANDBY_ID: u32 = 8;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RmgrIds::RM_HEAP2_ID")]
pub const RmgrIds_RM_HEAP2_ID: u32 = 9;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RmgrIds::RM_HEAP_ID")]
pub const RmgrIds_RM_HEAP_ID: u32 = 10;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RmgrIds::RM_BTREE_ID")]
pub const RmgrIds_RM_BTREE_ID: u32 = 11;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RmgrIds::RM_HASH_ID")]
pub const RmgrIds_RM_HASH_ID: u32 = 12;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RmgrIds::RM_GIN_ID")]
pub const RmgrIds_RM_GIN_ID: u32 = 13;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RmgrIds::RM_GIST_ID")]
pub const RmgrIds_RM_GIST_ID: u32 = 14;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RmgrIds::RM_SEQ_ID")]
pub const RmgrIds_RM_SEQ_ID: u32 = 15;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RmgrIds::RM_SPGIST_ID")]
pub const RmgrIds_RM_SPGIST_ID: u32 = 16;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RmgrIds::RM_BRIN_ID")]
pub const RmgrIds_RM_BRIN_ID: u32 = 17;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RmgrIds::RM_COMMIT_TS_ID")]
pub const RmgrIds_RM_COMMIT_TS_ID: u32 = 18;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RmgrIds::RM_REPLORIGIN_ID")]
pub const RmgrIds_RM_REPLORIGIN_ID: u32 = 19;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RmgrIds::RM_GENERIC_ID")]
pub const RmgrIds_RM_GENERIC_ID: u32 = 20;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RmgrIds::RM_LOGICALMSG_ID")]
pub const RmgrIds_RM_LOGICALMSG_ID: u32 = 21;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RmgrIds::RM_NEXT_ID")]
pub const RmgrIds_RM_NEXT_ID: u32 = 22;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RoleSpecType::ROLESPEC_CSTRING")]
pub const RoleSpecType_ROLESPEC_CSTRING: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RoleSpecType::ROLESPEC_CURRENT_ROLE")]
pub const RoleSpecType_ROLESPEC_CURRENT_ROLE: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RoleSpecType::ROLESPEC_CURRENT_USER")]
pub const RoleSpecType_ROLESPEC_CURRENT_USER: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RoleSpecType::ROLESPEC_SESSION_USER")]
pub const RoleSpecType_ROLESPEC_SESSION_USER: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RoleSpecType::ROLESPEC_PUBLIC")]
pub const RoleSpecType_ROLESPEC_PUBLIC: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RoleStmtType::ROLESTMT_ROLE")]
pub const RoleStmtType_ROLESTMT_ROLE: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RoleStmtType::ROLESTMT_USER")]
pub const RoleStmtType_ROLESTMT_USER: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RoleStmtType::ROLESTMT_GROUP")]
pub const RoleStmtType_ROLESTMT_GROUP: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RowCompareType::ROWCOMPARE_LT")]
pub const RowCompareType_ROWCOMPARE_LT: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RowCompareType::ROWCOMPARE_LE")]
pub const RowCompareType_ROWCOMPARE_LE: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RowCompareType::ROWCOMPARE_EQ")]
pub const RowCompareType_ROWCOMPARE_EQ: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RowCompareType::ROWCOMPARE_GE")]
pub const RowCompareType_ROWCOMPARE_GE: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RowCompareType::ROWCOMPARE_GT")]
pub const RowCompareType_ROWCOMPARE_GT: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RowCompareType::ROWCOMPARE_NE")]
pub const RowCompareType_ROWCOMPARE_NE: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RowMarkType::ROW_MARK_EXCLUSIVE")]
pub const RowMarkType_ROW_MARK_EXCLUSIVE: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RowMarkType::ROW_MARK_NOKEYEXCLUSIVE")]
pub const RowMarkType_ROW_MARK_NOKEYEXCLUSIVE: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RowMarkType::ROW_MARK_SHARE")]
pub const RowMarkType_ROW_MARK_SHARE: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RowMarkType::ROW_MARK_KEYSHARE")]
pub const RowMarkType_ROW_MARK_KEYSHARE: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RowMarkType::ROW_MARK_REFERENCE")]
pub const RowMarkType_ROW_MARK_REFERENCE: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::RowMarkType::ROW_MARK_COPY")]
pub const RowMarkType_ROW_MARK_COPY: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SQLValueFunctionOp::SVFOP_CURRENT_DATE")]
pub const SQLValueFunctionOp_SVFOP_CURRENT_DATE: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SQLValueFunctionOp::SVFOP_CURRENT_TIME")]
pub const SQLValueFunctionOp_SVFOP_CURRENT_TIME: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SQLValueFunctionOp::SVFOP_CURRENT_TIME_N")]
pub const SQLValueFunctionOp_SVFOP_CURRENT_TIME_N: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::SQLValueFunctionOp::SVFOP_CURRENT_TIMESTAMP"
)]
pub const SQLValueFunctionOp_SVFOP_CURRENT_TIMESTAMP: u32 = 3;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::SQLValueFunctionOp::SVFOP_CURRENT_TIMESTAMP_N"
)]
pub const SQLValueFunctionOp_SVFOP_CURRENT_TIMESTAMP_N: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SQLValueFunctionOp::SVFOP_LOCALTIME")]
pub const SQLValueFunctionOp_SVFOP_LOCALTIME: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SQLValueFunctionOp::SVFOP_LOCALTIME_N")]
pub const SQLValueFunctionOp_SVFOP_LOCALTIME_N: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SQLValueFunctionOp::SVFOP_LOCALTIMESTAMP")]
pub const SQLValueFunctionOp_SVFOP_LOCALTIMESTAMP: u32 = 7;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::SQLValueFunctionOp::SVFOP_LOCALTIMESTAMP_N"
)]
pub const SQLValueFunctionOp_SVFOP_LOCALTIMESTAMP_N: u32 = 8;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SQLValueFunctionOp::SVFOP_CURRENT_ROLE")]
pub const SQLValueFunctionOp_SVFOP_CURRENT_ROLE: u32 = 9;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SQLValueFunctionOp::SVFOP_CURRENT_USER")]
pub const SQLValueFunctionOp_SVFOP_CURRENT_USER: u32 = 10;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SQLValueFunctionOp::SVFOP_USER")]
pub const SQLValueFunctionOp_SVFOP_USER: u32 = 11;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SQLValueFunctionOp::SVFOP_SESSION_USER")]
pub const SQLValueFunctionOp_SVFOP_SESSION_USER: u32 = 12;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SQLValueFunctionOp::SVFOP_CURRENT_CATALOG")]
pub const SQLValueFunctionOp_SVFOP_CURRENT_CATALOG: u32 = 13;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SQLValueFunctionOp::SVFOP_CURRENT_SCHEMA")]
pub const SQLValueFunctionOp_SVFOP_CURRENT_SCHEMA: u32 = 14;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ScanDirection::BackwardScanDirection")]
pub const ScanDirection_BackwardScanDirection: i32 = -1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ScanDirection::NoMovementScanDirection")]
pub const ScanDirection_NoMovementScanDirection: i32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ScanDirection::ForwardScanDirection")]
pub const ScanDirection_ForwardScanDirection: i32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ScanOptions::SO_TYPE_SEQSCAN")]
pub const ScanOptions_SO_TYPE_SEQSCAN: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ScanOptions::SO_TYPE_BITMAPSCAN")]
pub const ScanOptions_SO_TYPE_BITMAPSCAN: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ScanOptions::SO_TYPE_SAMPLESCAN")]
pub const ScanOptions_SO_TYPE_SAMPLESCAN: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ScanOptions::SO_TYPE_TIDSCAN")]
pub const ScanOptions_SO_TYPE_TIDSCAN: u32 = 8;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ScanOptions::SO_TYPE_TIDRANGESCAN")]
pub const ScanOptions_SO_TYPE_TIDRANGESCAN: u32 = 16;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ScanOptions::SO_TYPE_ANALYZE")]
pub const ScanOptions_SO_TYPE_ANALYZE: u32 = 32;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ScanOptions::SO_ALLOW_STRAT")]
pub const ScanOptions_SO_ALLOW_STRAT: u32 = 64;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ScanOptions::SO_ALLOW_SYNC")]
pub const ScanOptions_SO_ALLOW_SYNC: u32 = 128;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ScanOptions::SO_ALLOW_PAGEMODE")]
pub const ScanOptions_SO_ALLOW_PAGEMODE: u32 = 256;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ScanOptions::SO_TEMP_SNAPSHOT")]
pub const ScanOptions_SO_TEMP_SNAPSHOT: u32 = 512;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ScanOptions::SO_NEED_TUPLES")]
pub const ScanOptions_SO_NEED_TUPLES: u32 = 1024;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SessionBackupState::SESSION_BACKUP_NONE")]
pub const SessionBackupState_SESSION_BACKUP_NONE: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::SessionBackupState::SESSION_BACKUP_RUNNING"
)]
pub const SessionBackupState_SESSION_BACKUP_RUNNING: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SessionEndType::DISCONNECT_NOT_YET")]
pub const SessionEndType_DISCONNECT_NOT_YET: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SessionEndType::DISCONNECT_NORMAL")]
pub const SessionEndType_DISCONNECT_NORMAL: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SessionEndType::DISCONNECT_CLIENT_EOF")]
pub const SessionEndType_DISCONNECT_CLIENT_EOF: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SessionEndType::DISCONNECT_FATAL")]
pub const SessionEndType_DISCONNECT_FATAL: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SessionEndType::DISCONNECT_KILLED")]
pub const SessionEndType_DISCONNECT_KILLED: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SetFunctionReturnMode::SFRM_ValuePerCall")]
pub const SetFunctionReturnMode_SFRM_ValuePerCall: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SetFunctionReturnMode::SFRM_Materialize")]
pub const SetFunctionReturnMode_SFRM_Materialize: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::SetFunctionReturnMode::SFRM_Materialize_Random"
)]
pub const SetFunctionReturnMode_SFRM_Materialize_Random: u32 = 4;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::SetFunctionReturnMode::SFRM_Materialize_Preferred"
)]
pub const SetFunctionReturnMode_SFRM_Materialize_Preferred: u32 = 8;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SetOpCmd::SETOPCMD_INTERSECT")]
pub const SetOpCmd_SETOPCMD_INTERSECT: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SetOpCmd::SETOPCMD_INTERSECT_ALL")]
pub const SetOpCmd_SETOPCMD_INTERSECT_ALL: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SetOpCmd::SETOPCMD_EXCEPT")]
pub const SetOpCmd_SETOPCMD_EXCEPT: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SetOpCmd::SETOPCMD_EXCEPT_ALL")]
pub const SetOpCmd_SETOPCMD_EXCEPT_ALL: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SetOpStrategy::SETOP_SORTED")]
pub const SetOpStrategy_SETOP_SORTED: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SetOpStrategy::SETOP_HASHED")]
pub const SetOpStrategy_SETOP_HASHED: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SetOperation::SETOP_NONE")]
pub const SetOperation_SETOP_NONE: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SetOperation::SETOP_UNION")]
pub const SetOperation_SETOP_UNION: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SetOperation::SETOP_INTERSECT")]
pub const SetOperation_SETOP_INTERSECT: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SetOperation::SETOP_EXCEPT")]
pub const SetOperation_SETOP_EXCEPT: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SetQuantifier::SET_QUANTIFIER_DEFAULT")]
pub const SetQuantifier_SET_QUANTIFIER_DEFAULT: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SetQuantifier::SET_QUANTIFIER_ALL")]
pub const SetQuantifier_SET_QUANTIFIER_ALL: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SetQuantifier::SET_QUANTIFIER_DISTINCT")]
pub const SetQuantifier_SET_QUANTIFIER_DISTINCT: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SharedBitmapState::BM_INITIAL")]
pub const SharedBitmapState_BM_INITIAL: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SharedBitmapState::BM_INPROGRESS")]
pub const SharedBitmapState_BM_INPROGRESS: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SharedBitmapState::BM_FINISHED")]
pub const SharedBitmapState_BM_FINISHED: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::SharedDependencyType::SHARED_DEPENDENCY_OWNER"
)]
pub const SharedDependencyType_SHARED_DEPENDENCY_OWNER: u32 = 111;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::SharedDependencyType::SHARED_DEPENDENCY_ACL"
)]
pub const SharedDependencyType_SHARED_DEPENDENCY_ACL: u32 = 97;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::SharedDependencyType::SHARED_DEPENDENCY_INITACL"
)]
pub const SharedDependencyType_SHARED_DEPENDENCY_INITACL: u32 = 105;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::SharedDependencyType::SHARED_DEPENDENCY_POLICY"
)]
pub const SharedDependencyType_SHARED_DEPENDENCY_POLICY: u32 = 114;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::SharedDependencyType::SHARED_DEPENDENCY_TABLESPACE"
)]
pub const SharedDependencyType_SHARED_DEPENDENCY_TABLESPACE: u32 = 116;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::SharedDependencyType::SHARED_DEPENDENCY_INVALID"
)]
pub const SharedDependencyType_SHARED_DEPENDENCY_INVALID: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SnapshotType::SNAPSHOT_MVCC")]
pub const SnapshotType_SNAPSHOT_MVCC: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SnapshotType::SNAPSHOT_SELF")]
pub const SnapshotType_SNAPSHOT_SELF: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SnapshotType::SNAPSHOT_ANY")]
pub const SnapshotType_SNAPSHOT_ANY: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SnapshotType::SNAPSHOT_TOAST")]
pub const SnapshotType_SNAPSHOT_TOAST: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SnapshotType::SNAPSHOT_DIRTY")]
pub const SnapshotType_SNAPSHOT_DIRTY: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SnapshotType::SNAPSHOT_HISTORIC_MVCC")]
pub const SnapshotType_SNAPSHOT_HISTORIC_MVCC: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SnapshotType::SNAPSHOT_NON_VACUUMABLE")]
pub const SnapshotType_SNAPSHOT_NON_VACUUMABLE: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SortByDir::SORTBY_DEFAULT")]
pub const SortByDir_SORTBY_DEFAULT: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SortByDir::SORTBY_ASC")]
pub const SortByDir_SORTBY_ASC: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SortByDir::SORTBY_DESC")]
pub const SortByDir_SORTBY_DESC: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SortByDir::SORTBY_USING")]
pub const SortByDir_SORTBY_USING: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SortByNulls::SORTBY_NULLS_DEFAULT")]
pub const SortByNulls_SORTBY_NULLS_DEFAULT: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SortByNulls::SORTBY_NULLS_FIRST")]
pub const SortByNulls_SORTBY_NULLS_FIRST: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SortByNulls::SORTBY_NULLS_LAST")]
pub const SortByNulls_SORTBY_NULLS_LAST: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::StdRdOptIndexCleanup::STDRD_OPTION_VACUUM_INDEX_CLEANUP_AUTO"
)]
pub const StdRdOptIndexCleanup_STDRD_OPTION_VACUUM_INDEX_CLEANUP_AUTO: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::StdRdOptIndexCleanup::STDRD_OPTION_VACUUM_INDEX_CLEANUP_OFF"
)]
pub const StdRdOptIndexCleanup_STDRD_OPTION_VACUUM_INDEX_CLEANUP_OFF: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::StdRdOptIndexCleanup::STDRD_OPTION_VACUUM_INDEX_CLEANUP_ON"
)]
pub const StdRdOptIndexCleanup_STDRD_OPTION_VACUUM_INDEX_CLEANUP_ON: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SubLinkType::EXISTS_SUBLINK")]
pub const SubLinkType_EXISTS_SUBLINK: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SubLinkType::ALL_SUBLINK")]
pub const SubLinkType_ALL_SUBLINK: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SubLinkType::ANY_SUBLINK")]
pub const SubLinkType_ANY_SUBLINK: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SubLinkType::ROWCOMPARE_SUBLINK")]
pub const SubLinkType_ROWCOMPARE_SUBLINK: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SubLinkType::EXPR_SUBLINK")]
pub const SubLinkType_EXPR_SUBLINK: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SubLinkType::MULTIEXPR_SUBLINK")]
pub const SubLinkType_MULTIEXPR_SUBLINK: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SubLinkType::ARRAY_SUBLINK")]
pub const SubLinkType_ARRAY_SUBLINK: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SubLinkType::CTE_SUBLINK")]
pub const SubLinkType_CTE_SUBLINK: u32 = 7;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SubXactEvent::SUBXACT_EVENT_START_SUB")]
pub const SubXactEvent_SUBXACT_EVENT_START_SUB: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SubXactEvent::SUBXACT_EVENT_COMMIT_SUB")]
pub const SubXactEvent_SUBXACT_EVENT_COMMIT_SUB: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SubXactEvent::SUBXACT_EVENT_ABORT_SUB")]
pub const SubXactEvent_SUBXACT_EVENT_ABORT_SUB: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::SubXactEvent::SUBXACT_EVENT_PRE_COMMIT_SUB"
)]
pub const SubXactEvent_SUBXACT_EVENT_PRE_COMMIT_SUB: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SubqueryScanStatus::SUBQUERY_SCAN_UNKNOWN")]
pub const SubqueryScanStatus_SUBQUERY_SCAN_UNKNOWN: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SubqueryScanStatus::SUBQUERY_SCAN_TRIVIAL")]
pub const SubqueryScanStatus_SUBQUERY_SCAN_TRIVIAL: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::SubqueryScanStatus::SUBQUERY_SCAN_NONTRIVIAL"
)]
pub const SubqueryScanStatus_SUBQUERY_SCAN_NONTRIVIAL: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SyncCommitLevel::SYNCHRONOUS_COMMIT_OFF")]
pub const SyncCommitLevel_SYNCHRONOUS_COMMIT_OFF: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::SyncCommitLevel::SYNCHRONOUS_COMMIT_LOCAL_FLUSH"
)]
pub const SyncCommitLevel_SYNCHRONOUS_COMMIT_LOCAL_FLUSH: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::SyncCommitLevel::SYNCHRONOUS_COMMIT_REMOTE_WRITE"
)]
pub const SyncCommitLevel_SYNCHRONOUS_COMMIT_REMOTE_WRITE: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::SyncCommitLevel::SYNCHRONOUS_COMMIT_REMOTE_FLUSH"
)]
pub const SyncCommitLevel_SYNCHRONOUS_COMMIT_REMOTE_FLUSH: u32 = 3;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::SyncCommitLevel::SYNCHRONOUS_COMMIT_REMOTE_APPLY"
)]
pub const SyncCommitLevel_SYNCHRONOUS_COMMIT_REMOTE_APPLY: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SyncRequestHandler::SYNC_HANDLER_MD")]
pub const SyncRequestHandler_SYNC_HANDLER_MD: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SyncRequestHandler::SYNC_HANDLER_CLOG")]
pub const SyncRequestHandler_SYNC_HANDLER_CLOG: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::SyncRequestHandler::SYNC_HANDLER_COMMIT_TS"
)]
pub const SyncRequestHandler_SYNC_HANDLER_COMMIT_TS: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::SyncRequestHandler::SYNC_HANDLER_MULTIXACT_OFFSET"
)]
pub const SyncRequestHandler_SYNC_HANDLER_MULTIXACT_OFFSET: u32 = 3;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::SyncRequestHandler::SYNC_HANDLER_MULTIXACT_MEMBER"
)]
pub const SyncRequestHandler_SYNC_HANDLER_MULTIXACT_MEMBER: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SyncRequestHandler::SYNC_HANDLER_NONE")]
pub const SyncRequestHandler_SYNC_HANDLER_NONE: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SyncRequestType::SYNC_REQUEST")]
pub const SyncRequestType_SYNC_REQUEST: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SyncRequestType::SYNC_UNLINK_REQUEST")]
pub const SyncRequestType_SYNC_UNLINK_REQUEST: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SyncRequestType::SYNC_FORGET_REQUEST")]
pub const SyncRequestType_SYNC_FORGET_REQUEST: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SyncRequestType::SYNC_FILTER_REQUEST")]
pub const SyncRequestType_SYNC_FILTER_REQUEST: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::AMNAME")]
pub const SysCacheIdentifier_AMNAME: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::AMOPOPID")]
pub const SysCacheIdentifier_AMOPOPID: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::AMOPSTRATEGY")]
pub const SysCacheIdentifier_AMOPSTRATEGY: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::AMPROCNUM")]
pub const SysCacheIdentifier_AMPROCNUM: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::ATTNAME")]
pub const SysCacheIdentifier_ATTNAME: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::ATTNUM")]
pub const SysCacheIdentifier_ATTNUM: u32 = 7;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::AUTHMEMMEMROLE")]
pub const SysCacheIdentifier_AUTHMEMMEMROLE: u32 = 8;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::AUTHMEMROLEMEM")]
pub const SysCacheIdentifier_AUTHMEMROLEMEM: u32 = 9;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::AUTHNAME")]
pub const SysCacheIdentifier_AUTHNAME: u32 = 10;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::CASTSOURCETARGET")]
pub const SysCacheIdentifier_CASTSOURCETARGET: u32 = 12;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::CLAAMNAMENSP")]
pub const SysCacheIdentifier_CLAAMNAMENSP: u32 = 13;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::COLLNAMEENCNSP")]
pub const SysCacheIdentifier_COLLNAMEENCNSP: u32 = 15;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::CONDEFAULT")]
pub const SysCacheIdentifier_CONDEFAULT: u32 = 17;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::CONNAMENSP")]
pub const SysCacheIdentifier_CONNAMENSP: u32 = 18;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::DEFACLROLENSPOBJ")]
pub const SysCacheIdentifier_DEFACLROLENSPOBJ: u32 = 22;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::EVENTTRIGGERNAME")]
pub const SysCacheIdentifier_EVENTTRIGGERNAME: u32 = 25;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::SysCacheIdentifier::FOREIGNDATAWRAPPERNAME"
)]
pub const SysCacheIdentifier_FOREIGNDATAWRAPPERNAME: u32 = 27;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::FOREIGNSERVERNAME")]
pub const SysCacheIdentifier_FOREIGNSERVERNAME: u32 = 29;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::FOREIGNTABLEREL")]
pub const SysCacheIdentifier_FOREIGNTABLEREL: u32 = 31;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::INDEXRELID")]
pub const SysCacheIdentifier_INDEXRELID: u32 = 32;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::LANGNAME")]
pub const SysCacheIdentifier_LANGNAME: u32 = 33;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::NAMESPACENAME")]
pub const SysCacheIdentifier_NAMESPACENAME: u32 = 35;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::OPERNAMENSP")]
pub const SysCacheIdentifier_OPERNAMENSP: u32 = 37;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::OPFAMILYAMNAMENSP")]
pub const SysCacheIdentifier_OPFAMILYAMNAMENSP: u32 = 39;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::PARAMETERACLNAME")]
pub const SysCacheIdentifier_PARAMETERACLNAME: u32 = 41;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::PARTRELID")]
pub const SysCacheIdentifier_PARTRELID: u32 = 43;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::PROCNAMEARGSNSP")]
pub const SysCacheIdentifier_PROCNAMEARGSNSP: u32 = 44;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::PUBLICATIONNAME")]
pub const SysCacheIdentifier_PUBLICATIONNAME: u32 = 46;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::PUBLICATIONNAMESPACE")]
pub const SysCacheIdentifier_PUBLICATIONNAMESPACE: u32 = 47;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::SysCacheIdentifier::PUBLICATIONNAMESPACEMAP"
)]
pub const SysCacheIdentifier_PUBLICATIONNAMESPACEMAP: u32 = 48;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::PUBLICATIONREL")]
pub const SysCacheIdentifier_PUBLICATIONREL: u32 = 50;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::PUBLICATIONRELMAP")]
pub const SysCacheIdentifier_PUBLICATIONRELMAP: u32 = 51;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::RANGEMULTIRANGE")]
pub const SysCacheIdentifier_RANGEMULTIRANGE: u32 = 52;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::RANGETYPE")]
pub const SysCacheIdentifier_RANGETYPE: u32 = 53;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::RELNAMENSP")]
pub const SysCacheIdentifier_RELNAMENSP: u32 = 54;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::REPLORIGIDENT")]
pub const SysCacheIdentifier_REPLORIGIDENT: u32 = 56;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::REPLORIGNAME")]
pub const SysCacheIdentifier_REPLORIGNAME: u32 = 57;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::RULERELNAME")]
pub const SysCacheIdentifier_RULERELNAME: u32 = 58;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::SEQRELID")]
pub const SysCacheIdentifier_SEQRELID: u32 = 59;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::STATEXTNAMENSP")]
pub const SysCacheIdentifier_STATEXTNAMENSP: u32 = 61;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::STATRELATTINH")]
pub const SysCacheIdentifier_STATRELATTINH: u32 = 63;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::SUBSCRIPTIONNAME")]
pub const SysCacheIdentifier_SUBSCRIPTIONNAME: u32 = 64;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::SUBSCRIPTIONRELMAP")]
pub const SysCacheIdentifier_SUBSCRIPTIONRELMAP: u32 = 66;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::TRFTYPELANG")]
pub const SysCacheIdentifier_TRFTYPELANG: u32 = 69;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::TSCONFIGMAP")]
pub const SysCacheIdentifier_TSCONFIGMAP: u32 = 70;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::TSCONFIGNAMENSP")]
pub const SysCacheIdentifier_TSCONFIGNAMENSP: u32 = 71;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::TSDICTNAMENSP")]
pub const SysCacheIdentifier_TSDICTNAMENSP: u32 = 73;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::TSPARSERNAMENSP")]
pub const SysCacheIdentifier_TSPARSERNAMENSP: u32 = 75;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::TSTEMPLATENAMENSP")]
pub const SysCacheIdentifier_TSTEMPLATENAMENSP: u32 = 77;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::TYPENAMENSP")]
pub const SysCacheIdentifier_TYPENAMENSP: u32 = 79;
#[deprecated(since = "0.12.0", note = "you want pg_sys::SysCacheIdentifier::USERMAPPINGUSERSERVER")]
pub const SysCacheIdentifier_USERMAPPINGUSERSERVER: u32 = 82;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TM_Result::TM_Ok")]
pub const TM_Result_TM_Ok: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TM_Result::TM_Invisible")]
pub const TM_Result_TM_Invisible: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TM_Result::TM_SelfModified")]
pub const TM_Result_TM_SelfModified: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TM_Result::TM_Updated")]
pub const TM_Result_TM_Updated: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TM_Result::TM_Deleted")]
pub const TM_Result_TM_Deleted: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TM_Result::TM_BeingModified")]
pub const TM_Result_TM_BeingModified: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TM_Result::TM_WouldBlock")]
pub const TM_Result_TM_WouldBlock: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TSTernaryValue::TS_NO")]
pub const TSTernaryValue_TS_NO: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TSTernaryValue::TS_YES")]
pub const TSTernaryValue_TS_YES: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TSTernaryValue::TS_MAYBE")]
pub const TSTernaryValue_TS_MAYBE: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TU_UpdateIndexes::TU_None")]
pub const TU_UpdateIndexes_TU_None: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TU_UpdateIndexes::TU_All")]
pub const TU_UpdateIndexes_TU_All: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TU_UpdateIndexes::TU_Summarizing")]
pub const TU_UpdateIndexes_TU_Summarizing: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TableFuncType::TFT_XMLTABLE")]
pub const TableFuncType_TFT_XMLTABLE: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TableFuncType::TFT_JSON_TABLE")]
pub const TableFuncType_TFT_JSON_TABLE: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::TableLikeOption::CREATE_TABLE_LIKE_COMMENTS"
)]
pub const TableLikeOption_CREATE_TABLE_LIKE_COMMENTS: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::TableLikeOption::CREATE_TABLE_LIKE_COMPRESSION"
)]
pub const TableLikeOption_CREATE_TABLE_LIKE_COMPRESSION: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::TableLikeOption::CREATE_TABLE_LIKE_CONSTRAINTS"
)]
pub const TableLikeOption_CREATE_TABLE_LIKE_CONSTRAINTS: u32 = 4;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::TableLikeOption::CREATE_TABLE_LIKE_DEFAULTS"
)]
pub const TableLikeOption_CREATE_TABLE_LIKE_DEFAULTS: u32 = 8;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::TableLikeOption::CREATE_TABLE_LIKE_GENERATED"
)]
pub const TableLikeOption_CREATE_TABLE_LIKE_GENERATED: u32 = 16;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::TableLikeOption::CREATE_TABLE_LIKE_IDENTITY"
)]
pub const TableLikeOption_CREATE_TABLE_LIKE_IDENTITY: u32 = 32;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::TableLikeOption::CREATE_TABLE_LIKE_INDEXES"
)]
pub const TableLikeOption_CREATE_TABLE_LIKE_INDEXES: u32 = 64;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::TableLikeOption::CREATE_TABLE_LIKE_STATISTICS"
)]
pub const TableLikeOption_CREATE_TABLE_LIKE_STATISTICS: u32 = 128;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::TableLikeOption::CREATE_TABLE_LIKE_STORAGE"
)]
pub const TableLikeOption_CREATE_TABLE_LIKE_STORAGE: u32 = 256;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TableLikeOption::CREATE_TABLE_LIKE_ALL")]
pub const TableLikeOption_CREATE_TABLE_LIKE_ALL: u32 = 2147483647;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::TempNamespaceStatus::TEMP_NAMESPACE_NOT_TEMP"
)]
pub const TempNamespaceStatus_TEMP_NAMESPACE_NOT_TEMP: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TempNamespaceStatus::TEMP_NAMESPACE_IDLE")]
pub const TempNamespaceStatus_TEMP_NAMESPACE_IDLE: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::TempNamespaceStatus::TEMP_NAMESPACE_IN_USE"
)]
pub const TempNamespaceStatus_TEMP_NAMESPACE_IN_USE: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TrackFunctionsLevel::TRACK_FUNC_OFF")]
pub const TrackFunctionsLevel_TRACK_FUNC_OFF: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TrackFunctionsLevel::TRACK_FUNC_PL")]
pub const TrackFunctionsLevel_TRACK_FUNC_PL: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TrackFunctionsLevel::TRACK_FUNC_ALL")]
pub const TrackFunctionsLevel_TRACK_FUNC_ALL: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TransactionStmtKind::TRANS_STMT_BEGIN")]
pub const TransactionStmtKind_TRANS_STMT_BEGIN: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TransactionStmtKind::TRANS_STMT_START")]
pub const TransactionStmtKind_TRANS_STMT_START: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TransactionStmtKind::TRANS_STMT_COMMIT")]
pub const TransactionStmtKind_TRANS_STMT_COMMIT: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TransactionStmtKind::TRANS_STMT_ROLLBACK")]
pub const TransactionStmtKind_TRANS_STMT_ROLLBACK: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TransactionStmtKind::TRANS_STMT_SAVEPOINT")]
pub const TransactionStmtKind_TRANS_STMT_SAVEPOINT: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TransactionStmtKind::TRANS_STMT_RELEASE")]
pub const TransactionStmtKind_TRANS_STMT_RELEASE: u32 = 5;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::TransactionStmtKind::TRANS_STMT_ROLLBACK_TO"
)]
pub const TransactionStmtKind_TRANS_STMT_ROLLBACK_TO: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TransactionStmtKind::TRANS_STMT_PREPARE")]
pub const TransactionStmtKind_TRANS_STMT_PREPARE: u32 = 7;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::TransactionStmtKind::TRANS_STMT_COMMIT_PREPARED"
)]
pub const TransactionStmtKind_TRANS_STMT_COMMIT_PREPARED: u32 = 8;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::TransactionStmtKind::TRANS_STMT_ROLLBACK_PREPARED"
)]
pub const TransactionStmtKind_TRANS_STMT_ROLLBACK_PREPARED: u32 = 9;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::TuplesortMethod::SORT_TYPE_STILL_IN_PROGRESS"
)]
pub const TuplesortMethod_SORT_TYPE_STILL_IN_PROGRESS: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TuplesortMethod::SORT_TYPE_TOP_N_HEAPSORT")]
pub const TuplesortMethod_SORT_TYPE_TOP_N_HEAPSORT: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TuplesortMethod::SORT_TYPE_QUICKSORT")]
pub const TuplesortMethod_SORT_TYPE_QUICKSORT: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TuplesortMethod::SORT_TYPE_EXTERNAL_SORT")]
pub const TuplesortMethod_SORT_TYPE_EXTERNAL_SORT: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TuplesortMethod::SORT_TYPE_EXTERNAL_MERGE")]
pub const TuplesortMethod_SORT_TYPE_EXTERNAL_MERGE: u32 = 8;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TuplesortSpaceType::SORT_SPACE_TYPE_DISK")]
pub const TuplesortSpaceType_SORT_SPACE_TYPE_DISK: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::TuplesortSpaceType::SORT_SPACE_TYPE_MEMORY"
)]
pub const TuplesortSpaceType_SORT_SPACE_TYPE_MEMORY: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TypeFuncClass::TYPEFUNC_SCALAR")]
pub const TypeFuncClass_TYPEFUNC_SCALAR: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TypeFuncClass::TYPEFUNC_COMPOSITE")]
pub const TypeFuncClass_TYPEFUNC_COMPOSITE: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TypeFuncClass::TYPEFUNC_COMPOSITE_DOMAIN")]
pub const TypeFuncClass_TYPEFUNC_COMPOSITE_DOMAIN: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TypeFuncClass::TYPEFUNC_RECORD")]
pub const TypeFuncClass_TYPEFUNC_RECORD: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::TypeFuncClass::TYPEFUNC_OTHER")]
pub const TypeFuncClass_TYPEFUNC_OTHER: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::UniquePathMethod::UNIQUE_PATH_NOOP")]
pub const UniquePathMethod_UNIQUE_PATH_NOOP: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::UniquePathMethod::UNIQUE_PATH_HASH")]
pub const UniquePathMethod_UNIQUE_PATH_HASH: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::UniquePathMethod::UNIQUE_PATH_SORT")]
pub const UniquePathMethod_UNIQUE_PATH_SORT: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::UpperRelationKind::UPPERREL_SETOP")]
pub const UpperRelationKind_UPPERREL_SETOP: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::UpperRelationKind::UPPERREL_PARTIAL_GROUP_AGG"
)]
pub const UpperRelationKind_UPPERREL_PARTIAL_GROUP_AGG: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::UpperRelationKind::UPPERREL_GROUP_AGG")]
pub const UpperRelationKind_UPPERREL_GROUP_AGG: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::UpperRelationKind::UPPERREL_WINDOW")]
pub const UpperRelationKind_UPPERREL_WINDOW: u32 = 3;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::UpperRelationKind::UPPERREL_PARTIAL_DISTINCT"
)]
pub const UpperRelationKind_UPPERREL_PARTIAL_DISTINCT: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::UpperRelationKind::UPPERREL_DISTINCT")]
pub const UpperRelationKind_UPPERREL_DISTINCT: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::UpperRelationKind::UPPERREL_ORDERED")]
pub const UpperRelationKind_UPPERREL_ORDERED: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::UpperRelationKind::UPPERREL_FINAL")]
pub const UpperRelationKind_UPPERREL_FINAL: u32 = 7;
#[deprecated(since = "0.12.0", note = "you want pg_sys::VacOptValue::VACOPTVALUE_UNSPECIFIED")]
pub const VacOptValue_VACOPTVALUE_UNSPECIFIED: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::VacOptValue::VACOPTVALUE_AUTO")]
pub const VacOptValue_VACOPTVALUE_AUTO: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::VacOptValue::VACOPTVALUE_DISABLED")]
pub const VacOptValue_VACOPTVALUE_DISABLED: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::VacOptValue::VACOPTVALUE_ENABLED")]
pub const VacOptValue_VACOPTVALUE_ENABLED: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::VariableSetKind::VAR_SET_VALUE")]
pub const VariableSetKind_VAR_SET_VALUE: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::VariableSetKind::VAR_SET_DEFAULT")]
pub const VariableSetKind_VAR_SET_DEFAULT: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::VariableSetKind::VAR_SET_CURRENT")]
pub const VariableSetKind_VAR_SET_CURRENT: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::VariableSetKind::VAR_SET_MULTI")]
pub const VariableSetKind_VAR_SET_MULTI: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::VariableSetKind::VAR_RESET")]
pub const VariableSetKind_VAR_RESET: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::VariableSetKind::VAR_RESET_ALL")]
pub const VariableSetKind_VAR_RESET_ALL: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ViewCheckOption::NO_CHECK_OPTION")]
pub const ViewCheckOption_NO_CHECK_OPTION: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ViewCheckOption::LOCAL_CHECK_OPTION")]
pub const ViewCheckOption_LOCAL_CHECK_OPTION: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::ViewCheckOption::CASCADED_CHECK_OPTION")]
pub const ViewCheckOption_CASCADED_CHECK_OPTION: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ViewOptCheckOption::VIEW_OPTION_CHECK_OPTION_NOT_SET"
)]
pub const ViewOptCheckOption_VIEW_OPTION_CHECK_OPTION_NOT_SET: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ViewOptCheckOption::VIEW_OPTION_CHECK_OPTION_LOCAL"
)]
pub const ViewOptCheckOption_VIEW_OPTION_CHECK_OPTION_LOCAL: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::ViewOptCheckOption::VIEW_OPTION_CHECK_OPTION_CASCADED"
)]
pub const ViewOptCheckOption_VIEW_OPTION_CHECK_OPTION_CASCADED: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::VolatileFunctionStatus::VOLATILITY_UNKNOWN"
)]
pub const VolatileFunctionStatus_VOLATILITY_UNKNOWN: u32 = 0;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::VolatileFunctionStatus::VOLATILITY_VOLATILE"
)]
pub const VolatileFunctionStatus_VOLATILITY_VOLATILE: u32 = 1;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::VolatileFunctionStatus::VOLATILITY_NOVOLATILE"
)]
pub const VolatileFunctionStatus_VOLATILITY_NOVOLATILE: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WALAvailability::WALAVAIL_INVALID_LSN")]
pub const WALAvailability_WALAVAIL_INVALID_LSN: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WALAvailability::WALAVAIL_RESERVED")]
pub const WALAvailability_WALAVAIL_RESERVED: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WALAvailability::WALAVAIL_EXTENDED")]
pub const WALAvailability_WALAVAIL_EXTENDED: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WALAvailability::WALAVAIL_UNRESERVED")]
pub const WALAvailability_WALAVAIL_UNRESERVED: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WALAvailability::WALAVAIL_REMOVED")]
pub const WALAvailability_WALAVAIL_REMOVED: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WCOKind::WCO_VIEW_CHECK")]
pub const WCOKind_WCO_VIEW_CHECK: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WCOKind::WCO_RLS_INSERT_CHECK")]
pub const WCOKind_WCO_RLS_INSERT_CHECK: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WCOKind::WCO_RLS_UPDATE_CHECK")]
pub const WCOKind_WCO_RLS_UPDATE_CHECK: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WCOKind::WCO_RLS_CONFLICT_CHECK")]
pub const WCOKind_WCO_RLS_CONFLICT_CHECK: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WCOKind::WCO_RLS_MERGE_UPDATE_CHECK")]
pub const WCOKind_WCO_RLS_MERGE_UPDATE_CHECK: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WCOKind::WCO_RLS_MERGE_DELETE_CHECK")]
pub const WCOKind_WCO_RLS_MERGE_DELETE_CHECK: u32 = 5;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventActivity::WAIT_EVENT_ARCHIVER_MAIN"
)]
pub const WaitEventActivity_WAIT_EVENT_ARCHIVER_MAIN: u32 = 83886080;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventActivity::WAIT_EVENT_AUTOVACUUM_MAIN"
)]
pub const WaitEventActivity_WAIT_EVENT_AUTOVACUUM_MAIN: u32 = 83886081;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventActivity::WAIT_EVENT_BGWRITER_HIBERNATE"
)]
pub const WaitEventActivity_WAIT_EVENT_BGWRITER_HIBERNATE: u32 = 83886082;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventActivity::WAIT_EVENT_BGWRITER_MAIN"
)]
pub const WaitEventActivity_WAIT_EVENT_BGWRITER_MAIN: u32 = 83886083;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventActivity::WAIT_EVENT_CHECKPOINTER_MAIN"
)]
pub const WaitEventActivity_WAIT_EVENT_CHECKPOINTER_MAIN: u32 = 83886084;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventActivity::WAIT_EVENT_LOGICAL_APPLY_MAIN"
)]
pub const WaitEventActivity_WAIT_EVENT_LOGICAL_APPLY_MAIN: u32 = 83886085;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventActivity::WAIT_EVENT_LOGICAL_LAUNCHER_MAIN"
)]
pub const WaitEventActivity_WAIT_EVENT_LOGICAL_LAUNCHER_MAIN: u32 = 83886086;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventActivity::WAIT_EVENT_LOGICAL_PARALLEL_APPLY_MAIN"
)]
pub const WaitEventActivity_WAIT_EVENT_LOGICAL_PARALLEL_APPLY_MAIN: u32 = 83886087;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventActivity::WAIT_EVENT_RECOVERY_WAL_STREAM"
)]
pub const WaitEventActivity_WAIT_EVENT_RECOVERY_WAL_STREAM: u32 = 83886088;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventActivity::WAIT_EVENT_REPLICATION_SLOTSYNC_MAIN"
)]
pub const WaitEventActivity_WAIT_EVENT_REPLICATION_SLOTSYNC_MAIN: u32 = 83886089;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventActivity::WAIT_EVENT_REPLICATION_SLOTSYNC_SHUTDOWN"
)]
pub const WaitEventActivity_WAIT_EVENT_REPLICATION_SLOTSYNC_SHUTDOWN: u32 = 83886090;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventActivity::WAIT_EVENT_SYSLOGGER_MAIN"
)]
pub const WaitEventActivity_WAIT_EVENT_SYSLOGGER_MAIN: u32 = 83886091;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventActivity::WAIT_EVENT_WAL_RECEIVER_MAIN"
)]
pub const WaitEventActivity_WAIT_EVENT_WAL_RECEIVER_MAIN: u32 = 83886092;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventActivity::WAIT_EVENT_WAL_SENDER_MAIN"
)]
pub const WaitEventActivity_WAIT_EVENT_WAL_SENDER_MAIN: u32 = 83886093;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventActivity::WAIT_EVENT_WAL_SUMMARIZER_WAL"
)]
pub const WaitEventActivity_WAIT_EVENT_WAL_SUMMARIZER_WAL: u32 = 83886094;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventActivity::WAIT_EVENT_WAL_WRITER_MAIN"
)]
pub const WaitEventActivity_WAIT_EVENT_WAL_WRITER_MAIN: u32 = 83886095;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventBufferPin::WAIT_EVENT_BUFFER_PIN")]
pub const WaitEventBufferPin_WAIT_EVENT_BUFFER_PIN: u32 = 67108864;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventClient::WAIT_EVENT_CLIENT_READ")]
pub const WaitEventClient_WAIT_EVENT_CLIENT_READ: u32 = 100663296;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventClient::WAIT_EVENT_CLIENT_WRITE")]
pub const WaitEventClient_WAIT_EVENT_CLIENT_WRITE: u32 = 100663297;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventClient::WAIT_EVENT_GSS_OPEN_SERVER"
)]
pub const WaitEventClient_WAIT_EVENT_GSS_OPEN_SERVER: u32 = 100663298;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventClient::WAIT_EVENT_LIBPQWALRECEIVER_CONNECT"
)]
pub const WaitEventClient_WAIT_EVENT_LIBPQWALRECEIVER_CONNECT: u32 = 100663299;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventClient::WAIT_EVENT_LIBPQWALRECEIVER_RECEIVE"
)]
pub const WaitEventClient_WAIT_EVENT_LIBPQWALRECEIVER_RECEIVE: u32 = 100663300;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventClient::WAIT_EVENT_SSL_OPEN_SERVER"
)]
pub const WaitEventClient_WAIT_EVENT_SSL_OPEN_SERVER: u32 = 100663301;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventClient::WAIT_EVENT_WAIT_FOR_STANDBY_CONFIRMATION"
)]
pub const WaitEventClient_WAIT_EVENT_WAIT_FOR_STANDBY_CONFIRMATION: u32 = 100663302;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventClient::WAIT_EVENT_WAL_SENDER_WAIT_FOR_WAL"
)]
pub const WaitEventClient_WAIT_EVENT_WAL_SENDER_WAIT_FOR_WAL: u32 = 100663303;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventClient::WAIT_EVENT_WAL_SENDER_WRITE_DATA"
)]
pub const WaitEventClient_WAIT_EVENT_WAL_SENDER_WRITE_DATA: u32 = 100663304;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_BASEBACKUP_READ")]
pub const WaitEventIO_WAIT_EVENT_BASEBACKUP_READ: u32 = 167772160;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_BASEBACKUP_SYNC")]
pub const WaitEventIO_WAIT_EVENT_BASEBACKUP_SYNC: u32 = 167772161;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_BASEBACKUP_WRITE")]
pub const WaitEventIO_WAIT_EVENT_BASEBACKUP_WRITE: u32 = 167772162;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_BUFFILE_READ")]
pub const WaitEventIO_WAIT_EVENT_BUFFILE_READ: u32 = 167772163;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_BUFFILE_TRUNCATE")]
pub const WaitEventIO_WAIT_EVENT_BUFFILE_TRUNCATE: u32 = 167772164;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_BUFFILE_WRITE")]
pub const WaitEventIO_WAIT_EVENT_BUFFILE_WRITE: u32 = 167772165;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_CONTROL_FILE_READ")]
pub const WaitEventIO_WAIT_EVENT_CONTROL_FILE_READ: u32 = 167772166;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_CONTROL_FILE_SYNC")]
pub const WaitEventIO_WAIT_EVENT_CONTROL_FILE_SYNC: u32 = 167772167;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_CONTROL_FILE_SYNC_UPDATE"
)]
pub const WaitEventIO_WAIT_EVENT_CONTROL_FILE_SYNC_UPDATE: u32 = 167772168;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_CONTROL_FILE_WRITE"
)]
pub const WaitEventIO_WAIT_EVENT_CONTROL_FILE_WRITE: u32 = 167772169;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_CONTROL_FILE_WRITE_UPDATE"
)]
pub const WaitEventIO_WAIT_EVENT_CONTROL_FILE_WRITE_UPDATE: u32 = 167772170;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_COPY_FILE_READ")]
pub const WaitEventIO_WAIT_EVENT_COPY_FILE_READ: u32 = 167772171;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_COPY_FILE_WRITE")]
pub const WaitEventIO_WAIT_EVENT_COPY_FILE_WRITE: u32 = 167772172;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_DATA_FILE_EXTEND")]
pub const WaitEventIO_WAIT_EVENT_DATA_FILE_EXTEND: u32 = 167772173;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_DATA_FILE_FLUSH")]
pub const WaitEventIO_WAIT_EVENT_DATA_FILE_FLUSH: u32 = 167772174;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_DATA_FILE_IMMEDIATE_SYNC"
)]
pub const WaitEventIO_WAIT_EVENT_DATA_FILE_IMMEDIATE_SYNC: u32 = 167772175;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_DATA_FILE_PREFETCH"
)]
pub const WaitEventIO_WAIT_EVENT_DATA_FILE_PREFETCH: u32 = 167772176;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_DATA_FILE_READ")]
pub const WaitEventIO_WAIT_EVENT_DATA_FILE_READ: u32 = 167772177;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_DATA_FILE_SYNC")]
pub const WaitEventIO_WAIT_EVENT_DATA_FILE_SYNC: u32 = 167772178;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_DATA_FILE_TRUNCATE"
)]
pub const WaitEventIO_WAIT_EVENT_DATA_FILE_TRUNCATE: u32 = 167772179;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_DATA_FILE_WRITE")]
pub const WaitEventIO_WAIT_EVENT_DATA_FILE_WRITE: u32 = 167772180;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_DSM_ALLOCATE")]
pub const WaitEventIO_WAIT_EVENT_DSM_ALLOCATE: u32 = 167772181;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_DSM_FILL_ZERO_WRITE"
)]
pub const WaitEventIO_WAIT_EVENT_DSM_FILL_ZERO_WRITE: u32 = 167772182;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_LOCK_FILE_ADDTODATADIR_READ"
)]
pub const WaitEventIO_WAIT_EVENT_LOCK_FILE_ADDTODATADIR_READ: u32 = 167772183;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_LOCK_FILE_ADDTODATADIR_SYNC"
)]
pub const WaitEventIO_WAIT_EVENT_LOCK_FILE_ADDTODATADIR_SYNC: u32 = 167772184;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_LOCK_FILE_ADDTODATADIR_WRITE"
)]
pub const WaitEventIO_WAIT_EVENT_LOCK_FILE_ADDTODATADIR_WRITE: u32 = 167772185;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_LOCK_FILE_CREATE_READ"
)]
pub const WaitEventIO_WAIT_EVENT_LOCK_FILE_CREATE_READ: u32 = 167772186;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_LOCK_FILE_CREATE_SYNC"
)]
pub const WaitEventIO_WAIT_EVENT_LOCK_FILE_CREATE_SYNC: u32 = 167772187;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_LOCK_FILE_CREATE_WRITE"
)]
pub const WaitEventIO_WAIT_EVENT_LOCK_FILE_CREATE_WRITE: u32 = 167772188;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_LOCK_FILE_RECHECKDATADIR_READ"
)]
pub const WaitEventIO_WAIT_EVENT_LOCK_FILE_RECHECKDATADIR_READ: u32 = 167772189;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_LOGICAL_REWRITE_CHECKPOINT_SYNC"
)]
pub const WaitEventIO_WAIT_EVENT_LOGICAL_REWRITE_CHECKPOINT_SYNC: u32 = 167772190;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_LOGICAL_REWRITE_MAPPING_SYNC"
)]
pub const WaitEventIO_WAIT_EVENT_LOGICAL_REWRITE_MAPPING_SYNC: u32 = 167772191;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_LOGICAL_REWRITE_MAPPING_WRITE"
)]
pub const WaitEventIO_WAIT_EVENT_LOGICAL_REWRITE_MAPPING_WRITE: u32 = 167772192;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_LOGICAL_REWRITE_SYNC"
)]
pub const WaitEventIO_WAIT_EVENT_LOGICAL_REWRITE_SYNC: u32 = 167772193;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_LOGICAL_REWRITE_TRUNCATE"
)]
pub const WaitEventIO_WAIT_EVENT_LOGICAL_REWRITE_TRUNCATE: u32 = 167772194;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_LOGICAL_REWRITE_WRITE"
)]
pub const WaitEventIO_WAIT_EVENT_LOGICAL_REWRITE_WRITE: u32 = 167772195;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_RELATION_MAP_READ")]
pub const WaitEventIO_WAIT_EVENT_RELATION_MAP_READ: u32 = 167772196;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_RELATION_MAP_REPLACE"
)]
pub const WaitEventIO_WAIT_EVENT_RELATION_MAP_REPLACE: u32 = 167772197;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_RELATION_MAP_WRITE"
)]
pub const WaitEventIO_WAIT_EVENT_RELATION_MAP_WRITE: u32 = 167772198;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_REORDER_BUFFER_READ"
)]
pub const WaitEventIO_WAIT_EVENT_REORDER_BUFFER_READ: u32 = 167772199;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_REORDER_BUFFER_WRITE"
)]
pub const WaitEventIO_WAIT_EVENT_REORDER_BUFFER_WRITE: u32 = 167772200;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_REORDER_LOGICAL_MAPPING_READ"
)]
pub const WaitEventIO_WAIT_EVENT_REORDER_LOGICAL_MAPPING_READ: u32 = 167772201;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_REPLICATION_SLOT_READ"
)]
pub const WaitEventIO_WAIT_EVENT_REPLICATION_SLOT_READ: u32 = 167772202;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_REPLICATION_SLOT_RESTORE_SYNC"
)]
pub const WaitEventIO_WAIT_EVENT_REPLICATION_SLOT_RESTORE_SYNC: u32 = 167772203;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_REPLICATION_SLOT_SYNC"
)]
pub const WaitEventIO_WAIT_EVENT_REPLICATION_SLOT_SYNC: u32 = 167772204;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_REPLICATION_SLOT_WRITE"
)]
pub const WaitEventIO_WAIT_EVENT_REPLICATION_SLOT_WRITE: u32 = 167772205;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_SLRU_FLUSH_SYNC")]
pub const WaitEventIO_WAIT_EVENT_SLRU_FLUSH_SYNC: u32 = 167772206;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_SLRU_READ")]
pub const WaitEventIO_WAIT_EVENT_SLRU_READ: u32 = 167772207;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_SLRU_SYNC")]
pub const WaitEventIO_WAIT_EVENT_SLRU_SYNC: u32 = 167772208;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_SLRU_WRITE")]
pub const WaitEventIO_WAIT_EVENT_SLRU_WRITE: u32 = 167772209;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_SNAPBUILD_READ")]
pub const WaitEventIO_WAIT_EVENT_SNAPBUILD_READ: u32 = 167772210;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_SNAPBUILD_SYNC")]
pub const WaitEventIO_WAIT_EVENT_SNAPBUILD_SYNC: u32 = 167772211;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_SNAPBUILD_WRITE")]
pub const WaitEventIO_WAIT_EVENT_SNAPBUILD_WRITE: u32 = 167772212;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_TIMELINE_HISTORY_FILE_SYNC"
)]
pub const WaitEventIO_WAIT_EVENT_TIMELINE_HISTORY_FILE_SYNC: u32 = 167772213;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_TIMELINE_HISTORY_FILE_WRITE"
)]
pub const WaitEventIO_WAIT_EVENT_TIMELINE_HISTORY_FILE_WRITE: u32 = 167772214;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_TIMELINE_HISTORY_READ"
)]
pub const WaitEventIO_WAIT_EVENT_TIMELINE_HISTORY_READ: u32 = 167772215;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_TIMELINE_HISTORY_SYNC"
)]
pub const WaitEventIO_WAIT_EVENT_TIMELINE_HISTORY_SYNC: u32 = 167772216;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_TIMELINE_HISTORY_WRITE"
)]
pub const WaitEventIO_WAIT_EVENT_TIMELINE_HISTORY_WRITE: u32 = 167772217;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_TWOPHASE_FILE_READ"
)]
pub const WaitEventIO_WAIT_EVENT_TWOPHASE_FILE_READ: u32 = 167772218;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_TWOPHASE_FILE_SYNC"
)]
pub const WaitEventIO_WAIT_EVENT_TWOPHASE_FILE_SYNC: u32 = 167772219;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_TWOPHASE_FILE_WRITE"
)]
pub const WaitEventIO_WAIT_EVENT_TWOPHASE_FILE_WRITE: u32 = 167772220;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_VERSION_FILE_SYNC")]
pub const WaitEventIO_WAIT_EVENT_VERSION_FILE_SYNC: u32 = 167772221;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_VERSION_FILE_WRITE"
)]
pub const WaitEventIO_WAIT_EVENT_VERSION_FILE_WRITE: u32 = 167772222;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_WALSENDER_TIMELINE_HISTORY_READ"
)]
pub const WaitEventIO_WAIT_EVENT_WALSENDER_TIMELINE_HISTORY_READ: u32 = 167772223;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_WAL_BOOTSTRAP_SYNC"
)]
pub const WaitEventIO_WAIT_EVENT_WAL_BOOTSTRAP_SYNC: u32 = 167772224;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_WAL_BOOTSTRAP_WRITE"
)]
pub const WaitEventIO_WAIT_EVENT_WAL_BOOTSTRAP_WRITE: u32 = 167772225;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_WAL_COPY_READ")]
pub const WaitEventIO_WAIT_EVENT_WAL_COPY_READ: u32 = 167772226;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_WAL_COPY_SYNC")]
pub const WaitEventIO_WAIT_EVENT_WAL_COPY_SYNC: u32 = 167772227;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_WAL_COPY_WRITE")]
pub const WaitEventIO_WAIT_EVENT_WAL_COPY_WRITE: u32 = 167772228;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_WAL_INIT_SYNC")]
pub const WaitEventIO_WAIT_EVENT_WAL_INIT_SYNC: u32 = 167772229;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_WAL_INIT_WRITE")]
pub const WaitEventIO_WAIT_EVENT_WAL_INIT_WRITE: u32 = 167772230;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_WAL_READ")]
pub const WaitEventIO_WAIT_EVENT_WAL_READ: u32 = 167772231;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_WAL_SUMMARY_READ")]
pub const WaitEventIO_WAIT_EVENT_WAL_SUMMARY_READ: u32 = 167772232;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_WAL_SUMMARY_WRITE")]
pub const WaitEventIO_WAIT_EVENT_WAL_SUMMARY_WRITE: u32 = 167772233;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_WAL_SYNC")]
pub const WaitEventIO_WAIT_EVENT_WAL_SYNC: u32 = 167772234;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIO::WAIT_EVENT_WAL_SYNC_METHOD_ASSIGN"
)]
pub const WaitEventIO_WAIT_EVENT_WAL_SYNC_METHOD_ASSIGN: u32 = 167772235;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIO::WAIT_EVENT_WAL_WRITE")]
pub const WaitEventIO_WAIT_EVENT_WAL_WRITE: u32 = 167772236;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_APPEND_READY")]
pub const WaitEventIPC_WAIT_EVENT_APPEND_READY: u32 = 134217728;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_ARCHIVE_CLEANUP_COMMAND"
)]
pub const WaitEventIPC_WAIT_EVENT_ARCHIVE_CLEANUP_COMMAND: u32 = 134217729;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_ARCHIVE_COMMAND")]
pub const WaitEventIPC_WAIT_EVENT_ARCHIVE_COMMAND: u32 = 134217730;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_BACKEND_TERMINATION"
)]
pub const WaitEventIPC_WAIT_EVENT_BACKEND_TERMINATION: u32 = 134217731;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_BACKUP_WAIT_WAL_ARCHIVE"
)]
pub const WaitEventIPC_WAIT_EVENT_BACKUP_WAIT_WAL_ARCHIVE: u32 = 134217732;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_BGWORKER_SHUTDOWN"
)]
pub const WaitEventIPC_WAIT_EVENT_BGWORKER_SHUTDOWN: u32 = 134217733;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_BGWORKER_STARTUP")]
pub const WaitEventIPC_WAIT_EVENT_BGWORKER_STARTUP: u32 = 134217734;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_BTREE_PAGE")]
pub const WaitEventIPC_WAIT_EVENT_BTREE_PAGE: u32 = 134217735;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_BUFFER_IO")]
pub const WaitEventIPC_WAIT_EVENT_BUFFER_IO: u32 = 134217736;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_CHECKPOINT_DELAY_COMPLETE"
)]
pub const WaitEventIPC_WAIT_EVENT_CHECKPOINT_DELAY_COMPLETE: u32 = 134217737;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_CHECKPOINT_DELAY_START"
)]
pub const WaitEventIPC_WAIT_EVENT_CHECKPOINT_DELAY_START: u32 = 134217738;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_CHECKPOINT_DONE")]
pub const WaitEventIPC_WAIT_EVENT_CHECKPOINT_DONE: u32 = 134217739;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_CHECKPOINT_START")]
pub const WaitEventIPC_WAIT_EVENT_CHECKPOINT_START: u32 = 134217740;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_EXECUTE_GATHER")]
pub const WaitEventIPC_WAIT_EVENT_EXECUTE_GATHER: u32 = 134217741;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_HASH_BATCH_ALLOCATE"
)]
pub const WaitEventIPC_WAIT_EVENT_HASH_BATCH_ALLOCATE: u32 = 134217742;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_HASH_BATCH_ELECT")]
pub const WaitEventIPC_WAIT_EVENT_HASH_BATCH_ELECT: u32 = 134217743;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_HASH_BATCH_LOAD")]
pub const WaitEventIPC_WAIT_EVENT_HASH_BATCH_LOAD: u32 = 134217744;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_HASH_BUILD_ALLOCATE"
)]
pub const WaitEventIPC_WAIT_EVENT_HASH_BUILD_ALLOCATE: u32 = 134217745;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_HASH_BUILD_ELECT")]
pub const WaitEventIPC_WAIT_EVENT_HASH_BUILD_ELECT: u32 = 134217746;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_HASH_BUILD_HASH_INNER"
)]
pub const WaitEventIPC_WAIT_EVENT_HASH_BUILD_HASH_INNER: u32 = 134217747;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_HASH_BUILD_HASH_OUTER"
)]
pub const WaitEventIPC_WAIT_EVENT_HASH_BUILD_HASH_OUTER: u32 = 134217748;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_HASH_GROW_BATCHES_DECIDE"
)]
pub const WaitEventIPC_WAIT_EVENT_HASH_GROW_BATCHES_DECIDE: u32 = 134217749;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_HASH_GROW_BATCHES_ELECT"
)]
pub const WaitEventIPC_WAIT_EVENT_HASH_GROW_BATCHES_ELECT: u32 = 134217750;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_HASH_GROW_BATCHES_FINISH"
)]
pub const WaitEventIPC_WAIT_EVENT_HASH_GROW_BATCHES_FINISH: u32 = 134217751;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_HASH_GROW_BATCHES_REALLOCATE"
)]
pub const WaitEventIPC_WAIT_EVENT_HASH_GROW_BATCHES_REALLOCATE: u32 = 134217752;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_HASH_GROW_BATCHES_REPARTITION"
)]
pub const WaitEventIPC_WAIT_EVENT_HASH_GROW_BATCHES_REPARTITION: u32 = 134217753;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_HASH_GROW_BUCKETS_ELECT"
)]
pub const WaitEventIPC_WAIT_EVENT_HASH_GROW_BUCKETS_ELECT: u32 = 134217754;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_HASH_GROW_BUCKETS_REALLOCATE"
)]
pub const WaitEventIPC_WAIT_EVENT_HASH_GROW_BUCKETS_REALLOCATE: u32 = 134217755;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_HASH_GROW_BUCKETS_REINSERT"
)]
pub const WaitEventIPC_WAIT_EVENT_HASH_GROW_BUCKETS_REINSERT: u32 = 134217756;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_LOGICAL_APPLY_SEND_DATA"
)]
pub const WaitEventIPC_WAIT_EVENT_LOGICAL_APPLY_SEND_DATA: u32 = 134217757;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_LOGICAL_PARALLEL_APPLY_STATE_CHANGE"
)]
pub const WaitEventIPC_WAIT_EVENT_LOGICAL_PARALLEL_APPLY_STATE_CHANGE: u32 = 134217758;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_LOGICAL_SYNC_DATA"
)]
pub const WaitEventIPC_WAIT_EVENT_LOGICAL_SYNC_DATA: u32 = 134217759;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_LOGICAL_SYNC_STATE_CHANGE"
)]
pub const WaitEventIPC_WAIT_EVENT_LOGICAL_SYNC_STATE_CHANGE: u32 = 134217760;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_MESSAGE_QUEUE_INTERNAL"
)]
pub const WaitEventIPC_WAIT_EVENT_MESSAGE_QUEUE_INTERNAL: u32 = 134217761;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_MESSAGE_QUEUE_PUT_MESSAGE"
)]
pub const WaitEventIPC_WAIT_EVENT_MESSAGE_QUEUE_PUT_MESSAGE: u32 = 134217762;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_MESSAGE_QUEUE_RECEIVE"
)]
pub const WaitEventIPC_WAIT_EVENT_MESSAGE_QUEUE_RECEIVE: u32 = 134217763;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_MESSAGE_QUEUE_SEND"
)]
pub const WaitEventIPC_WAIT_EVENT_MESSAGE_QUEUE_SEND: u32 = 134217764;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_MULTIXACT_CREATION"
)]
pub const WaitEventIPC_WAIT_EVENT_MULTIXACT_CREATION: u32 = 134217765;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_PARALLEL_BITMAP_SCAN"
)]
pub const WaitEventIPC_WAIT_EVENT_PARALLEL_BITMAP_SCAN: u32 = 134217766;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_PARALLEL_CREATE_INDEX_SCAN"
)]
pub const WaitEventIPC_WAIT_EVENT_PARALLEL_CREATE_INDEX_SCAN: u32 = 134217767;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_PARALLEL_FINISH")]
pub const WaitEventIPC_WAIT_EVENT_PARALLEL_FINISH: u32 = 134217768;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_PROCARRAY_GROUP_UPDATE"
)]
pub const WaitEventIPC_WAIT_EVENT_PROCARRAY_GROUP_UPDATE: u32 = 134217769;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_PROC_SIGNAL_BARRIER"
)]
pub const WaitEventIPC_WAIT_EVENT_PROC_SIGNAL_BARRIER: u32 = 134217770;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_PROMOTE")]
pub const WaitEventIPC_WAIT_EVENT_PROMOTE: u32 = 134217771;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_RECOVERY_CONFLICT_SNAPSHOT"
)]
pub const WaitEventIPC_WAIT_EVENT_RECOVERY_CONFLICT_SNAPSHOT: u32 = 134217772;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_RECOVERY_CONFLICT_TABLESPACE"
)]
pub const WaitEventIPC_WAIT_EVENT_RECOVERY_CONFLICT_TABLESPACE: u32 = 134217773;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_RECOVERY_END_COMMAND"
)]
pub const WaitEventIPC_WAIT_EVENT_RECOVERY_END_COMMAND: u32 = 134217774;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_RECOVERY_PAUSE")]
pub const WaitEventIPC_WAIT_EVENT_RECOVERY_PAUSE: u32 = 134217775;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_REPLICATION_ORIGIN_DROP"
)]
pub const WaitEventIPC_WAIT_EVENT_REPLICATION_ORIGIN_DROP: u32 = 134217776;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_REPLICATION_SLOT_DROP"
)]
pub const WaitEventIPC_WAIT_EVENT_REPLICATION_SLOT_DROP: u32 = 134217777;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_RESTORE_COMMAND")]
pub const WaitEventIPC_WAIT_EVENT_RESTORE_COMMAND: u32 = 134217778;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_SAFE_SNAPSHOT")]
pub const WaitEventIPC_WAIT_EVENT_SAFE_SNAPSHOT: u32 = 134217779;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_SYNC_REP")]
pub const WaitEventIPC_WAIT_EVENT_SYNC_REP: u32 = 134217780;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_WAL_RECEIVER_EXIT"
)]
pub const WaitEventIPC_WAIT_EVENT_WAL_RECEIVER_EXIT: u32 = 134217781;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_WAL_RECEIVER_WAIT_START"
)]
pub const WaitEventIPC_WAIT_EVENT_WAL_RECEIVER_WAIT_START: u32 = 134217782;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_WAL_SUMMARY_READY"
)]
pub const WaitEventIPC_WAIT_EVENT_WAL_SUMMARY_READY: u32 = 134217783;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventIPC::WAIT_EVENT_XACT_GROUP_UPDATE"
)]
pub const WaitEventIPC_WAIT_EVENT_XACT_GROUP_UPDATE: u32 = 134217784;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventTimeout::WAIT_EVENT_BASE_BACKUP_THROTTLE"
)]
pub const WaitEventTimeout_WAIT_EVENT_BASE_BACKUP_THROTTLE: u32 = 150994944;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventTimeout::WAIT_EVENT_CHECKPOINT_WRITE_DELAY"
)]
pub const WaitEventTimeout_WAIT_EVENT_CHECKPOINT_WRITE_DELAY: u32 = 150994945;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventTimeout::WAIT_EVENT_PG_SLEEP")]
pub const WaitEventTimeout_WAIT_EVENT_PG_SLEEP: u32 = 150994946;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventTimeout::WAIT_EVENT_RECOVERY_APPLY_DELAY"
)]
pub const WaitEventTimeout_WAIT_EVENT_RECOVERY_APPLY_DELAY: u32 = 150994947;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventTimeout::WAIT_EVENT_RECOVERY_RETRIEVE_RETRY_INTERVAL"
)]
pub const WaitEventTimeout_WAIT_EVENT_RECOVERY_RETRIEVE_RETRY_INTERVAL: u32 = 150994948;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventTimeout::WAIT_EVENT_REGISTER_SYNC_REQUEST"
)]
pub const WaitEventTimeout_WAIT_EVENT_REGISTER_SYNC_REQUEST: u32 = 150994949;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventTimeout::WAIT_EVENT_SPIN_DELAY")]
pub const WaitEventTimeout_WAIT_EVENT_SPIN_DELAY: u32 = 150994950;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WaitEventTimeout::WAIT_EVENT_VACUUM_DELAY")]
pub const WaitEventTimeout_WAIT_EVENT_VACUUM_DELAY: u32 = 150994951;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventTimeout::WAIT_EVENT_VACUUM_TRUNCATE"
)]
pub const WaitEventTimeout_WAIT_EVENT_VACUUM_TRUNCATE: u32 = 150994952;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WaitEventTimeout::WAIT_EVENT_WAL_SUMMARIZER_ERROR"
)]
pub const WaitEventTimeout_WAIT_EVENT_WAL_SUMMARIZER_ERROR: u32 = 150994953;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WalCompression::WAL_COMPRESSION_NONE")]
pub const WalCompression_WAL_COMPRESSION_NONE: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WalCompression::WAL_COMPRESSION_PGLZ")]
pub const WalCompression_WAL_COMPRESSION_PGLZ: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WalCompression::WAL_COMPRESSION_LZ4")]
pub const WalCompression_WAL_COMPRESSION_LZ4: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WalCompression::WAL_COMPRESSION_ZSTD")]
pub const WalCompression_WAL_COMPRESSION_ZSTD: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WalLevel::WAL_LEVEL_MINIMAL")]
pub const WalLevel_WAL_LEVEL_MINIMAL: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WalLevel::WAL_LEVEL_REPLICA")]
pub const WalLevel_WAL_LEVEL_REPLICA: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WalLevel::WAL_LEVEL_LOGICAL")]
pub const WalLevel_WAL_LEVEL_LOGICAL: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WalRcvExecStatus::WALRCV_ERROR")]
pub const WalRcvExecStatus_WALRCV_ERROR: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WalRcvExecStatus::WALRCV_OK_COMMAND")]
pub const WalRcvExecStatus_WALRCV_OK_COMMAND: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WalRcvExecStatus::WALRCV_OK_TUPLES")]
pub const WalRcvExecStatus_WALRCV_OK_TUPLES: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WalRcvExecStatus::WALRCV_OK_COPY_IN")]
pub const WalRcvExecStatus_WALRCV_OK_COPY_IN: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WalRcvExecStatus::WALRCV_OK_COPY_OUT")]
pub const WalRcvExecStatus_WALRCV_OK_COPY_OUT: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WalRcvExecStatus::WALRCV_OK_COPY_BOTH")]
pub const WalRcvExecStatus_WALRCV_OK_COPY_BOTH: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WalRcvState::WALRCV_STOPPED")]
pub const WalRcvState_WALRCV_STOPPED: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WalRcvState::WALRCV_STARTING")]
pub const WalRcvState_WALRCV_STARTING: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WalRcvState::WALRCV_STREAMING")]
pub const WalRcvState_WALRCV_STREAMING: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WalRcvState::WALRCV_WAITING")]
pub const WalRcvState_WALRCV_WAITING: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WalRcvState::WALRCV_RESTARTING")]
pub const WalRcvState_WALRCV_RESTARTING: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WalRcvState::WALRCV_STOPPING")]
pub const WalRcvState_WALRCV_STOPPING: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WalSyncMethod::WAL_SYNC_METHOD_FSYNC")]
pub const WalSyncMethod_WAL_SYNC_METHOD_FSYNC: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WalSyncMethod::WAL_SYNC_METHOD_FDATASYNC")]
pub const WalSyncMethod_WAL_SYNC_METHOD_FDATASYNC: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WalSyncMethod::WAL_SYNC_METHOD_OPEN")]
pub const WalSyncMethod_WAL_SYNC_METHOD_OPEN: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WalSyncMethod::WAL_SYNC_METHOD_FSYNC_WRITETHROUGH"
)]
pub const WalSyncMethod_WAL_SYNC_METHOD_FSYNC_WRITETHROUGH: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WalSyncMethod::WAL_SYNC_METHOD_OPEN_DSYNC")]
pub const WalSyncMethod_WAL_SYNC_METHOD_OPEN_DSYNC: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WindowAggStatus::WINDOWAGG_DONE")]
pub const WindowAggStatus_WINDOWAGG_DONE: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WindowAggStatus::WINDOWAGG_RUN")]
pub const WindowAggStatus_WINDOWAGG_RUN: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::WindowAggStatus::WINDOWAGG_PASSTHROUGH")]
pub const WindowAggStatus_WINDOWAGG_PASSTHROUGH: u32 = 2;
#[deprecated(
    since = "0.12.0",
    note = "you want pg_sys::WindowAggStatus::WINDOWAGG_PASSTHROUGH_STRICT"
)]
pub const WindowAggStatus_WINDOWAGG_PASSTHROUGH_STRICT: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XLTW_Oper::XLTW_None")]
pub const XLTW_Oper_XLTW_None: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XLTW_Oper::XLTW_Update")]
pub const XLTW_Oper_XLTW_Update: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XLTW_Oper::XLTW_Delete")]
pub const XLTW_Oper_XLTW_Delete: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XLTW_Oper::XLTW_Lock")]
pub const XLTW_Oper_XLTW_Lock: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XLTW_Oper::XLTW_LockUpdated")]
pub const XLTW_Oper_XLTW_LockUpdated: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XLTW_Oper::XLTW_InsertIndex")]
pub const XLTW_Oper_XLTW_InsertIndex: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XLTW_Oper::XLTW_InsertIndexUnique")]
pub const XLTW_Oper_XLTW_InsertIndexUnique: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XLTW_Oper::XLTW_FetchUpdated")]
pub const XLTW_Oper_XLTW_FetchUpdated: u32 = 7;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XLTW_Oper::XLTW_RecheckExclusionConstr")]
pub const XLTW_Oper_XLTW_RecheckExclusionConstr: u32 = 8;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XLogPageReadResult::XLREAD_SUCCESS")]
pub const XLogPageReadResult_XLREAD_SUCCESS: i32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XLogPageReadResult::XLREAD_FAIL")]
pub const XLogPageReadResult_XLREAD_FAIL: i32 = -1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XLogPageReadResult::XLREAD_WOULDBLOCK")]
pub const XLogPageReadResult_XLREAD_WOULDBLOCK: i32 = -2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XLogRedoAction::BLK_NEEDS_REDO")]
pub const XLogRedoAction_BLK_NEEDS_REDO: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XLogRedoAction::BLK_DONE")]
pub const XLogRedoAction_BLK_DONE: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XLogRedoAction::BLK_RESTORED")]
pub const XLogRedoAction_BLK_RESTORED: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XLogRedoAction::BLK_NOTFOUND")]
pub const XLogRedoAction_BLK_NOTFOUND: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XactEvent::XACT_EVENT_COMMIT")]
pub const XactEvent_XACT_EVENT_COMMIT: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XactEvent::XACT_EVENT_PARALLEL_COMMIT")]
pub const XactEvent_XACT_EVENT_PARALLEL_COMMIT: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XactEvent::XACT_EVENT_ABORT")]
pub const XactEvent_XACT_EVENT_ABORT: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XactEvent::XACT_EVENT_PARALLEL_ABORT")]
pub const XactEvent_XACT_EVENT_PARALLEL_ABORT: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XactEvent::XACT_EVENT_PREPARE")]
pub const XactEvent_XACT_EVENT_PREPARE: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XactEvent::XACT_EVENT_PRE_COMMIT")]
pub const XactEvent_XACT_EVENT_PRE_COMMIT: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XactEvent::XACT_EVENT_PARALLEL_PRE_COMMIT")]
pub const XactEvent_XACT_EVENT_PARALLEL_PRE_COMMIT: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XactEvent::XACT_EVENT_PRE_PREPARE")]
pub const XactEvent_XACT_EVENT_PRE_PREPARE: u32 = 7;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XmlExprOp::IS_XMLCONCAT")]
pub const XmlExprOp_IS_XMLCONCAT: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XmlExprOp::IS_XMLELEMENT")]
pub const XmlExprOp_IS_XMLELEMENT: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XmlExprOp::IS_XMLFOREST")]
pub const XmlExprOp_IS_XMLFOREST: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XmlExprOp::IS_XMLPARSE")]
pub const XmlExprOp_IS_XMLPARSE: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XmlExprOp::IS_XMLPI")]
pub const XmlExprOp_IS_XMLPI: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XmlExprOp::IS_XMLROOT")]
pub const XmlExprOp_IS_XMLROOT: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XmlExprOp::IS_XMLSERIALIZE")]
pub const XmlExprOp_IS_XMLSERIALIZE: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XmlExprOp::IS_DOCUMENT")]
pub const XmlExprOp_IS_DOCUMENT: u32 = 7;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XmlOptionType::XMLOPTION_DOCUMENT")]
pub const XmlOptionType_XMLOPTION_DOCUMENT: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::XmlOptionType::XMLOPTION_CONTENT")]
pub const XmlOptionType_XMLOPTION_CONTENT: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::__pid_type::F_OWNER_TID")]
pub const __pid_type_F_OWNER_TID: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::__pid_type::F_OWNER_PID")]
pub const __pid_type_F_OWNER_PID: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::__pid_type::F_OWNER_PGRP")]
pub const __pid_type_F_OWNER_PGRP: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::__pid_type::F_OWNER_GID")]
pub const __pid_type_F_OWNER_GID: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::__socket_type::SOCK_STREAM")]
pub const __socket_type_SOCK_STREAM: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::__socket_type::SOCK_DGRAM")]
pub const __socket_type_SOCK_DGRAM: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::__socket_type::SOCK_RAW")]
pub const __socket_type_SOCK_RAW: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::__socket_type::SOCK_RDM")]
pub const __socket_type_SOCK_RDM: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::__socket_type::SOCK_SEQPACKET")]
pub const __socket_type_SOCK_SEQPACKET: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::__socket_type::SOCK_DCCP")]
pub const __socket_type_SOCK_DCCP: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::__socket_type::SOCK_PACKET")]
pub const __socket_type_SOCK_PACKET: u32 = 10;
#[deprecated(since = "0.12.0", note = "you want pg_sys::__socket_type::SOCK_CLOEXEC")]
pub const __socket_type_SOCK_CLOEXEC: u32 = 524288;
#[deprecated(since = "0.12.0", note = "you want pg_sys::__socket_type::SOCK_NONBLOCK")]
pub const __socket_type_SOCK_NONBLOCK: u32 = 2048;
#[deprecated(since = "0.12.0", note = "you want pg_sys::dsm_op::DSM_OP_CREATE")]
pub const dsm_op_DSM_OP_CREATE: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::dsm_op::DSM_OP_ATTACH")]
pub const dsm_op_DSM_OP_ATTACH: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::dsm_op::DSM_OP_DETACH")]
pub const dsm_op_DSM_OP_DETACH: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::dsm_op::DSM_OP_DESTROY")]
pub const dsm_op_DSM_OP_DESTROY: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::jbvType::jbvNull")]
pub const jbvType_jbvNull: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::jbvType::jbvString")]
pub const jbvType_jbvString: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::jbvType::jbvNumeric")]
pub const jbvType_jbvNumeric: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::jbvType::jbvBool")]
pub const jbvType_jbvBool: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::jbvType::jbvArray")]
pub const jbvType_jbvArray: u32 = 16;
#[deprecated(since = "0.12.0", note = "you want pg_sys::jbvType::jbvObject")]
pub const jbvType_jbvObject: u32 = 17;
#[deprecated(since = "0.12.0", note = "you want pg_sys::jbvType::jbvBinary")]
pub const jbvType_jbvBinary: u32 = 18;
#[deprecated(since = "0.12.0", note = "you want pg_sys::jbvType::jbvDatetime")]
pub const jbvType_jbvDatetime: u32 = 32;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_SQL_ASCII")]
pub const pg_enc_PG_SQL_ASCII: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_EUC_JP")]
pub const pg_enc_PG_EUC_JP: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_EUC_CN")]
pub const pg_enc_PG_EUC_CN: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_EUC_KR")]
pub const pg_enc_PG_EUC_KR: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_EUC_TW")]
pub const pg_enc_PG_EUC_TW: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_EUC_JIS_2004")]
pub const pg_enc_PG_EUC_JIS_2004: u32 = 5;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_UTF8")]
pub const pg_enc_PG_UTF8: u32 = 6;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_MULE_INTERNAL")]
pub const pg_enc_PG_MULE_INTERNAL: u32 = 7;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_LATIN1")]
pub const pg_enc_PG_LATIN1: u32 = 8;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_LATIN2")]
pub const pg_enc_PG_LATIN2: u32 = 9;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_LATIN3")]
pub const pg_enc_PG_LATIN3: u32 = 10;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_LATIN4")]
pub const pg_enc_PG_LATIN4: u32 = 11;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_LATIN5")]
pub const pg_enc_PG_LATIN5: u32 = 12;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_LATIN6")]
pub const pg_enc_PG_LATIN6: u32 = 13;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_LATIN7")]
pub const pg_enc_PG_LATIN7: u32 = 14;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_LATIN8")]
pub const pg_enc_PG_LATIN8: u32 = 15;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_LATIN9")]
pub const pg_enc_PG_LATIN9: u32 = 16;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_LATIN10")]
pub const pg_enc_PG_LATIN10: u32 = 17;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_WIN1256")]
pub const pg_enc_PG_WIN1256: u32 = 18;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_WIN1258")]
pub const pg_enc_PG_WIN1258: u32 = 19;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_WIN866")]
pub const pg_enc_PG_WIN866: u32 = 20;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_WIN874")]
pub const pg_enc_PG_WIN874: u32 = 21;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_KOI8R")]
pub const pg_enc_PG_KOI8R: u32 = 22;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_WIN1251")]
pub const pg_enc_PG_WIN1251: u32 = 23;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_WIN1252")]
pub const pg_enc_PG_WIN1252: u32 = 24;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_ISO_8859_5")]
pub const pg_enc_PG_ISO_8859_5: u32 = 25;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_ISO_8859_6")]
pub const pg_enc_PG_ISO_8859_6: u32 = 26;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_ISO_8859_7")]
pub const pg_enc_PG_ISO_8859_7: u32 = 27;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_ISO_8859_8")]
pub const pg_enc_PG_ISO_8859_8: u32 = 28;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_WIN1250")]
pub const pg_enc_PG_WIN1250: u32 = 29;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_WIN1253")]
pub const pg_enc_PG_WIN1253: u32 = 30;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_WIN1254")]
pub const pg_enc_PG_WIN1254: u32 = 31;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_WIN1255")]
pub const pg_enc_PG_WIN1255: u32 = 32;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_WIN1257")]
pub const pg_enc_PG_WIN1257: u32 = 33;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_KOI8U")]
pub const pg_enc_PG_KOI8U: u32 = 34;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_SJIS")]
pub const pg_enc_PG_SJIS: u32 = 35;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_BIG5")]
pub const pg_enc_PG_BIG5: u32 = 36;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_GBK")]
pub const pg_enc_PG_GBK: u32 = 37;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_UHC")]
pub const pg_enc_PG_UHC: u32 = 38;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_GB18030")]
pub const pg_enc_PG_GB18030: u32 = 39;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_JOHAB")]
pub const pg_enc_PG_JOHAB: u32 = 40;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::PG_SHIFT_JIS_2004")]
pub const pg_enc_PG_SHIFT_JIS_2004: u32 = 41;
#[deprecated(since = "0.12.0", note = "you want pg_sys::pg_enc::_PG_LAST_ENCODING_")]
pub const pg_enc__PG_LAST_ENCODING_: u32 = 42;
#[deprecated(since = "0.12.0", note = "you want pg_sys::relopt_kind::RELOPT_KIND_LOCAL")]
pub const relopt_kind_RELOPT_KIND_LOCAL: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::relopt_kind::RELOPT_KIND_HEAP")]
pub const relopt_kind_RELOPT_KIND_HEAP: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::relopt_kind::RELOPT_KIND_TOAST")]
pub const relopt_kind_RELOPT_KIND_TOAST: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::relopt_kind::RELOPT_KIND_BTREE")]
pub const relopt_kind_RELOPT_KIND_BTREE: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::relopt_kind::RELOPT_KIND_HASH")]
pub const relopt_kind_RELOPT_KIND_HASH: u32 = 8;
#[deprecated(since = "0.12.0", note = "you want pg_sys::relopt_kind::RELOPT_KIND_GIN")]
pub const relopt_kind_RELOPT_KIND_GIN: u32 = 16;
#[deprecated(since = "0.12.0", note = "you want pg_sys::relopt_kind::RELOPT_KIND_GIST")]
pub const relopt_kind_RELOPT_KIND_GIST: u32 = 32;
#[deprecated(since = "0.12.0", note = "you want pg_sys::relopt_kind::RELOPT_KIND_ATTRIBUTE")]
pub const relopt_kind_RELOPT_KIND_ATTRIBUTE: u32 = 64;
#[deprecated(since = "0.12.0", note = "you want pg_sys::relopt_kind::RELOPT_KIND_TABLESPACE")]
pub const relopt_kind_RELOPT_KIND_TABLESPACE: u32 = 128;
#[deprecated(since = "0.12.0", note = "you want pg_sys::relopt_kind::RELOPT_KIND_SPGIST")]
pub const relopt_kind_RELOPT_KIND_SPGIST: u32 = 256;
#[deprecated(since = "0.12.0", note = "you want pg_sys::relopt_kind::RELOPT_KIND_VIEW")]
pub const relopt_kind_RELOPT_KIND_VIEW: u32 = 512;
#[deprecated(since = "0.12.0", note = "you want pg_sys::relopt_kind::RELOPT_KIND_BRIN")]
pub const relopt_kind_RELOPT_KIND_BRIN: u32 = 1024;
#[deprecated(since = "0.12.0", note = "you want pg_sys::relopt_kind::RELOPT_KIND_PARTITIONED")]
pub const relopt_kind_RELOPT_KIND_PARTITIONED: u32 = 2048;
#[deprecated(since = "0.12.0", note = "you want pg_sys::relopt_kind::RELOPT_KIND_LAST_DEFAULT")]
pub const relopt_kind_RELOPT_KIND_LAST_DEFAULT: u32 = 2048;
#[deprecated(since = "0.12.0", note = "you want pg_sys::relopt_kind::RELOPT_KIND_MAX")]
pub const relopt_kind_RELOPT_KIND_MAX: u32 = 1073741824;
#[deprecated(since = "0.12.0", note = "you want pg_sys::relopt_type::RELOPT_TYPE_BOOL")]
pub const relopt_type_RELOPT_TYPE_BOOL: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::relopt_type::RELOPT_TYPE_INT")]
pub const relopt_type_RELOPT_TYPE_INT: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::relopt_type::RELOPT_TYPE_REAL")]
pub const relopt_type_RELOPT_TYPE_REAL: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::relopt_type::RELOPT_TYPE_ENUM")]
pub const relopt_type_RELOPT_TYPE_ENUM: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::relopt_type::RELOPT_TYPE_STRING")]
pub const relopt_type_RELOPT_TYPE_STRING: u32 = 4;
#[deprecated(since = "0.12.0", note = "you want pg_sys::shm_mq_result::SHM_MQ_SUCCESS")]
pub const shm_mq_result_SHM_MQ_SUCCESS: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::shm_mq_result::SHM_MQ_WOULD_BLOCK")]
pub const shm_mq_result_SHM_MQ_WOULD_BLOCK: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::shm_mq_result::SHM_MQ_DETACHED")]
pub const shm_mq_result_SHM_MQ_DETACHED: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::subxids_array_status::SUBXIDS_IN_ARRAY")]
pub const subxids_array_status_SUBXIDS_IN_ARRAY: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::subxids_array_status::SUBXIDS_MISSING")]
pub const subxids_array_status_SUBXIDS_MISSING: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::subxids_array_status::SUBXIDS_IN_SUBTRANS")]
pub const subxids_array_status_SUBXIDS_IN_SUBTRANS: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::tuplehash_status::tuplehash_SH_EMPTY")]
pub const tuplehash_status_tuplehash_SH_EMPTY: u32 = 0;
#[deprecated(since = "0.12.0", note = "you want pg_sys::tuplehash_status::tuplehash_SH_IN_USE")]
pub const tuplehash_status_tuplehash_SH_IN_USE: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::vartag_external::VARTAG_INDIRECT")]
pub const vartag_external_VARTAG_INDIRECT: u32 = 1;
#[deprecated(since = "0.12.0", note = "you want pg_sys::vartag_external::VARTAG_EXPANDED_RO")]
pub const vartag_external_VARTAG_EXPANDED_RO: u32 = 2;
#[deprecated(since = "0.12.0", note = "you want pg_sys::vartag_external::VARTAG_EXPANDED_RW")]
pub const vartag_external_VARTAG_EXPANDED_RW: u32 = 3;
#[deprecated(since = "0.12.0", note = "you want pg_sys::vartag_external::VARTAG_ONDISK")]
pub const vartag_external_VARTAG_ONDISK: u32 = 18;
impl pg_sys::seal::Sealed for A_ArrayExpr {}
impl pg_sys::PgNode for A_ArrayExpr {}
impl ::core::fmt::Display for A_ArrayExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for A_Const {}
impl pg_sys::PgNode for A_Const {}
impl ::core::fmt::Display for A_Const {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for A_Expr {}
impl pg_sys::PgNode for A_Expr {}
impl ::core::fmt::Display for A_Expr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for A_Indices {}
impl pg_sys::PgNode for A_Indices {}
impl ::core::fmt::Display for A_Indices {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for A_Indirection {}
impl pg_sys::PgNode for A_Indirection {}
impl ::core::fmt::Display for A_Indirection {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for A_Star {}
impl pg_sys::PgNode for A_Star {}
impl ::core::fmt::Display for A_Star {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AccessPriv {}
impl pg_sys::PgNode for AccessPriv {}
impl ::core::fmt::Display for AccessPriv {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Agg {}
impl pg_sys::PgNode for Agg {}
impl ::core::fmt::Display for Agg {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AggInfo {}
impl pg_sys::PgNode for AggInfo {}
impl ::core::fmt::Display for AggInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AggPath {}
impl pg_sys::PgNode for AggPath {}
impl ::core::fmt::Display for AggPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AggState {}
impl pg_sys::PgNode for AggState {}
impl ::core::fmt::Display for AggState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AggTransInfo {}
impl pg_sys::PgNode for AggTransInfo {}
impl ::core::fmt::Display for AggTransInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Aggref {}
impl pg_sys::PgNode for Aggref {}
impl ::core::fmt::Display for Aggref {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Alias {}
impl pg_sys::PgNode for Alias {}
impl ::core::fmt::Display for Alias {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterCollationStmt {}
impl pg_sys::PgNode for AlterCollationStmt {}
impl ::core::fmt::Display for AlterCollationStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterDatabaseRefreshCollStmt {}
impl pg_sys::PgNode for AlterDatabaseRefreshCollStmt {}
impl ::core::fmt::Display for AlterDatabaseRefreshCollStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterDatabaseSetStmt {}
impl pg_sys::PgNode for AlterDatabaseSetStmt {}
impl ::core::fmt::Display for AlterDatabaseSetStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterDatabaseStmt {}
impl pg_sys::PgNode for AlterDatabaseStmt {}
impl ::core::fmt::Display for AlterDatabaseStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterDefaultPrivilegesStmt {}
impl pg_sys::PgNode for AlterDefaultPrivilegesStmt {}
impl ::core::fmt::Display for AlterDefaultPrivilegesStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterDomainStmt {}
impl pg_sys::PgNode for AlterDomainStmt {}
impl ::core::fmt::Display for AlterDomainStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterEnumStmt {}
impl pg_sys::PgNode for AlterEnumStmt {}
impl ::core::fmt::Display for AlterEnumStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterEventTrigStmt {}
impl pg_sys::PgNode for AlterEventTrigStmt {}
impl ::core::fmt::Display for AlterEventTrigStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterExtensionContentsStmt {}
impl pg_sys::PgNode for AlterExtensionContentsStmt {}
impl ::core::fmt::Display for AlterExtensionContentsStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterExtensionStmt {}
impl pg_sys::PgNode for AlterExtensionStmt {}
impl ::core::fmt::Display for AlterExtensionStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterFdwStmt {}
impl pg_sys::PgNode for AlterFdwStmt {}
impl ::core::fmt::Display for AlterFdwStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterForeignServerStmt {}
impl pg_sys::PgNode for AlterForeignServerStmt {}
impl ::core::fmt::Display for AlterForeignServerStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterFunctionStmt {}
impl pg_sys::PgNode for AlterFunctionStmt {}
impl ::core::fmt::Display for AlterFunctionStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterObjectDependsStmt {}
impl pg_sys::PgNode for AlterObjectDependsStmt {}
impl ::core::fmt::Display for AlterObjectDependsStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterObjectSchemaStmt {}
impl pg_sys::PgNode for AlterObjectSchemaStmt {}
impl ::core::fmt::Display for AlterObjectSchemaStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterOpFamilyStmt {}
impl pg_sys::PgNode for AlterOpFamilyStmt {}
impl ::core::fmt::Display for AlterOpFamilyStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterOperatorStmt {}
impl pg_sys::PgNode for AlterOperatorStmt {}
impl ::core::fmt::Display for AlterOperatorStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterOwnerStmt {}
impl pg_sys::PgNode for AlterOwnerStmt {}
impl ::core::fmt::Display for AlterOwnerStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterPolicyStmt {}
impl pg_sys::PgNode for AlterPolicyStmt {}
impl ::core::fmt::Display for AlterPolicyStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterPublicationStmt {}
impl pg_sys::PgNode for AlterPublicationStmt {}
impl ::core::fmt::Display for AlterPublicationStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterReplicationSlotCmd {}
impl pg_sys::PgNode for AlterReplicationSlotCmd {}
impl ::core::fmt::Display for AlterReplicationSlotCmd {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterRoleSetStmt {}
impl pg_sys::PgNode for AlterRoleSetStmt {}
impl ::core::fmt::Display for AlterRoleSetStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterRoleStmt {}
impl pg_sys::PgNode for AlterRoleStmt {}
impl ::core::fmt::Display for AlterRoleStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterSeqStmt {}
impl pg_sys::PgNode for AlterSeqStmt {}
impl ::core::fmt::Display for AlterSeqStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterStatsStmt {}
impl pg_sys::PgNode for AlterStatsStmt {}
impl ::core::fmt::Display for AlterStatsStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterSubscriptionStmt {}
impl pg_sys::PgNode for AlterSubscriptionStmt {}
impl ::core::fmt::Display for AlterSubscriptionStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterSystemStmt {}
impl pg_sys::PgNode for AlterSystemStmt {}
impl ::core::fmt::Display for AlterSystemStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterTSConfigurationStmt {}
impl pg_sys::PgNode for AlterTSConfigurationStmt {}
impl ::core::fmt::Display for AlterTSConfigurationStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterTSDictionaryStmt {}
impl pg_sys::PgNode for AlterTSDictionaryStmt {}
impl ::core::fmt::Display for AlterTSDictionaryStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterTableCmd {}
impl pg_sys::PgNode for AlterTableCmd {}
impl ::core::fmt::Display for AlterTableCmd {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterTableMoveAllStmt {}
impl pg_sys::PgNode for AlterTableMoveAllStmt {}
impl ::core::fmt::Display for AlterTableMoveAllStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterTableSpaceOptionsStmt {}
impl pg_sys::PgNode for AlterTableSpaceOptionsStmt {}
impl ::core::fmt::Display for AlterTableSpaceOptionsStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterTableStmt {}
impl pg_sys::PgNode for AlterTableStmt {}
impl ::core::fmt::Display for AlterTableStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterTypeStmt {}
impl pg_sys::PgNode for AlterTypeStmt {}
impl ::core::fmt::Display for AlterTypeStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterUserMappingStmt {}
impl pg_sys::PgNode for AlterUserMappingStmt {}
impl ::core::fmt::Display for AlterUserMappingStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlternativeSubPlan {}
impl pg_sys::PgNode for AlternativeSubPlan {}
impl ::core::fmt::Display for AlternativeSubPlan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Append {}
impl pg_sys::PgNode for Append {}
impl ::core::fmt::Display for Append {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AppendPath {}
impl pg_sys::PgNode for AppendPath {}
impl ::core::fmt::Display for AppendPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AppendRelInfo {}
impl pg_sys::PgNode for AppendRelInfo {}
impl ::core::fmt::Display for AppendRelInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AppendState {}
impl pg_sys::PgNode for AppendState {}
impl ::core::fmt::Display for AppendState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ArrayCoerceExpr {}
impl pg_sys::PgNode for ArrayCoerceExpr {}
impl ::core::fmt::Display for ArrayCoerceExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ArrayExpr {}
impl pg_sys::PgNode for ArrayExpr {}
impl ::core::fmt::Display for ArrayExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BaseBackupCmd {}
impl pg_sys::PgNode for BaseBackupCmd {}
impl ::core::fmt::Display for BaseBackupCmd {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BitString {}
impl pg_sys::PgNode for BitString {}
impl ::core::fmt::Display for BitString {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BitmapAnd {}
impl pg_sys::PgNode for BitmapAnd {}
impl ::core::fmt::Display for BitmapAnd {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BitmapAndPath {}
impl pg_sys::PgNode for BitmapAndPath {}
impl ::core::fmt::Display for BitmapAndPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BitmapAndState {}
impl pg_sys::PgNode for BitmapAndState {}
impl ::core::fmt::Display for BitmapAndState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BitmapHeapPath {}
impl pg_sys::PgNode for BitmapHeapPath {}
impl ::core::fmt::Display for BitmapHeapPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BitmapHeapScan {}
impl pg_sys::PgNode for BitmapHeapScan {}
impl ::core::fmt::Display for BitmapHeapScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BitmapHeapScanState {}
impl pg_sys::PgNode for BitmapHeapScanState {}
impl ::core::fmt::Display for BitmapHeapScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BitmapIndexScan {}
impl pg_sys::PgNode for BitmapIndexScan {}
impl ::core::fmt::Display for BitmapIndexScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BitmapIndexScanState {}
impl pg_sys::PgNode for BitmapIndexScanState {}
impl ::core::fmt::Display for BitmapIndexScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BitmapOr {}
impl pg_sys::PgNode for BitmapOr {}
impl ::core::fmt::Display for BitmapOr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BitmapOrPath {}
impl pg_sys::PgNode for BitmapOrPath {}
impl ::core::fmt::Display for BitmapOrPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BitmapOrState {}
impl pg_sys::PgNode for BitmapOrState {}
impl ::core::fmt::Display for BitmapOrState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Bitmapset {}
impl pg_sys::PgNode for Bitmapset {}
impl ::core::fmt::Display for Bitmapset {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BoolExpr {}
impl pg_sys::PgNode for BoolExpr {}
impl ::core::fmt::Display for BoolExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Boolean {}
impl pg_sys::PgNode for Boolean {}
impl ::core::fmt::Display for Boolean {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BooleanTest {}
impl pg_sys::PgNode for BooleanTest {}
impl ::core::fmt::Display for BooleanTest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BufferHeapTupleTableSlot {}
impl pg_sys::PgNode for BufferHeapTupleTableSlot {}
impl ::core::fmt::Display for BufferHeapTupleTableSlot {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CTECycleClause {}
impl pg_sys::PgNode for CTECycleClause {}
impl ::core::fmt::Display for CTECycleClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CTESearchClause {}
impl pg_sys::PgNode for CTESearchClause {}
impl ::core::fmt::Display for CTESearchClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CallContext {}
impl pg_sys::PgNode for CallContext {}
impl ::core::fmt::Display for CallContext {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CallStmt {}
impl pg_sys::PgNode for CallStmt {}
impl ::core::fmt::Display for CallStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CaseExpr {}
impl pg_sys::PgNode for CaseExpr {}
impl ::core::fmt::Display for CaseExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CaseTestExpr {}
impl pg_sys::PgNode for CaseTestExpr {}
impl ::core::fmt::Display for CaseTestExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CaseWhen {}
impl pg_sys::PgNode for CaseWhen {}
impl ::core::fmt::Display for CaseWhen {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CheckPointStmt {}
impl pg_sys::PgNode for CheckPointStmt {}
impl ::core::fmt::Display for CheckPointStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ClosePortalStmt {}
impl pg_sys::PgNode for ClosePortalStmt {}
impl ::core::fmt::Display for ClosePortalStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ClusterStmt {}
impl pg_sys::PgNode for ClusterStmt {}
impl ::core::fmt::Display for ClusterStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CoalesceExpr {}
impl pg_sys::PgNode for CoalesceExpr {}
impl ::core::fmt::Display for CoalesceExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CoerceToDomain {}
impl pg_sys::PgNode for CoerceToDomain {}
impl ::core::fmt::Display for CoerceToDomain {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CoerceToDomainValue {}
impl pg_sys::PgNode for CoerceToDomainValue {}
impl ::core::fmt::Display for CoerceToDomainValue {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CoerceViaIO {}
impl pg_sys::PgNode for CoerceViaIO {}
impl ::core::fmt::Display for CoerceViaIO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CollateClause {}
impl pg_sys::PgNode for CollateClause {}
impl ::core::fmt::Display for CollateClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CollateExpr {}
impl pg_sys::PgNode for CollateExpr {}
impl ::core::fmt::Display for CollateExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ColumnDef {}
impl pg_sys::PgNode for ColumnDef {}
impl ::core::fmt::Display for ColumnDef {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ColumnRef {}
impl pg_sys::PgNode for ColumnRef {}
impl ::core::fmt::Display for ColumnRef {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CommentStmt {}
impl pg_sys::PgNode for CommentStmt {}
impl ::core::fmt::Display for CommentStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CommonTableExpr {}
impl pg_sys::PgNode for CommonTableExpr {}
impl ::core::fmt::Display for CommonTableExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CompositeTypeStmt {}
impl pg_sys::PgNode for CompositeTypeStmt {}
impl ::core::fmt::Display for CompositeTypeStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Const {}
impl pg_sys::PgNode for Const {}
impl ::core::fmt::Display for Const {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Constraint {}
impl pg_sys::PgNode for Constraint {}
impl ::core::fmt::Display for Constraint {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ConstraintsSetStmt {}
impl pg_sys::PgNode for ConstraintsSetStmt {}
impl ::core::fmt::Display for ConstraintsSetStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ConvertRowtypeExpr {}
impl pg_sys::PgNode for ConvertRowtypeExpr {}
impl ::core::fmt::Display for ConvertRowtypeExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CopyStmt {}
impl pg_sys::PgNode for CopyStmt {}
impl ::core::fmt::Display for CopyStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateAmStmt {}
impl pg_sys::PgNode for CreateAmStmt {}
impl ::core::fmt::Display for CreateAmStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateCastStmt {}
impl pg_sys::PgNode for CreateCastStmt {}
impl ::core::fmt::Display for CreateCastStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateConversionStmt {}
impl pg_sys::PgNode for CreateConversionStmt {}
impl ::core::fmt::Display for CreateConversionStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateDomainStmt {}
impl pg_sys::PgNode for CreateDomainStmt {}
impl ::core::fmt::Display for CreateDomainStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateEnumStmt {}
impl pg_sys::PgNode for CreateEnumStmt {}
impl ::core::fmt::Display for CreateEnumStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateEventTrigStmt {}
impl pg_sys::PgNode for CreateEventTrigStmt {}
impl ::core::fmt::Display for CreateEventTrigStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateExtensionStmt {}
impl pg_sys::PgNode for CreateExtensionStmt {}
impl ::core::fmt::Display for CreateExtensionStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateFdwStmt {}
impl pg_sys::PgNode for CreateFdwStmt {}
impl ::core::fmt::Display for CreateFdwStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateForeignServerStmt {}
impl pg_sys::PgNode for CreateForeignServerStmt {}
impl ::core::fmt::Display for CreateForeignServerStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateForeignTableStmt {}
impl pg_sys::PgNode for CreateForeignTableStmt {}
impl ::core::fmt::Display for CreateForeignTableStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateFunctionStmt {}
impl pg_sys::PgNode for CreateFunctionStmt {}
impl ::core::fmt::Display for CreateFunctionStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateOpClassItem {}
impl pg_sys::PgNode for CreateOpClassItem {}
impl ::core::fmt::Display for CreateOpClassItem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateOpClassStmt {}
impl pg_sys::PgNode for CreateOpClassStmt {}
impl ::core::fmt::Display for CreateOpClassStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateOpFamilyStmt {}
impl pg_sys::PgNode for CreateOpFamilyStmt {}
impl ::core::fmt::Display for CreateOpFamilyStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreatePLangStmt {}
impl pg_sys::PgNode for CreatePLangStmt {}
impl ::core::fmt::Display for CreatePLangStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreatePolicyStmt {}
impl pg_sys::PgNode for CreatePolicyStmt {}
impl ::core::fmt::Display for CreatePolicyStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreatePublicationStmt {}
impl pg_sys::PgNode for CreatePublicationStmt {}
impl ::core::fmt::Display for CreatePublicationStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateRangeStmt {}
impl pg_sys::PgNode for CreateRangeStmt {}
impl ::core::fmt::Display for CreateRangeStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateReplicationSlotCmd {}
impl pg_sys::PgNode for CreateReplicationSlotCmd {}
impl ::core::fmt::Display for CreateReplicationSlotCmd {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateRoleStmt {}
impl pg_sys::PgNode for CreateRoleStmt {}
impl ::core::fmt::Display for CreateRoleStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateSchemaStmt {}
impl pg_sys::PgNode for CreateSchemaStmt {}
impl ::core::fmt::Display for CreateSchemaStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateSeqStmt {}
impl pg_sys::PgNode for CreateSeqStmt {}
impl ::core::fmt::Display for CreateSeqStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateStatsStmt {}
impl pg_sys::PgNode for CreateStatsStmt {}
impl ::core::fmt::Display for CreateStatsStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateStmt {}
impl pg_sys::PgNode for CreateStmt {}
impl ::core::fmt::Display for CreateStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateSubscriptionStmt {}
impl pg_sys::PgNode for CreateSubscriptionStmt {}
impl ::core::fmt::Display for CreateSubscriptionStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateTableAsStmt {}
impl pg_sys::PgNode for CreateTableAsStmt {}
impl ::core::fmt::Display for CreateTableAsStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateTableSpaceStmt {}
impl pg_sys::PgNode for CreateTableSpaceStmt {}
impl ::core::fmt::Display for CreateTableSpaceStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateTransformStmt {}
impl pg_sys::PgNode for CreateTransformStmt {}
impl ::core::fmt::Display for CreateTransformStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateTrigStmt {}
impl pg_sys::PgNode for CreateTrigStmt {}
impl ::core::fmt::Display for CreateTrigStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateUserMappingStmt {}
impl pg_sys::PgNode for CreateUserMappingStmt {}
impl ::core::fmt::Display for CreateUserMappingStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreatedbStmt {}
impl pg_sys::PgNode for CreatedbStmt {}
impl ::core::fmt::Display for CreatedbStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CteScan {}
impl pg_sys::PgNode for CteScan {}
impl ::core::fmt::Display for CteScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CteScanState {}
impl pg_sys::PgNode for CteScanState {}
impl ::core::fmt::Display for CteScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CurrentOfExpr {}
impl pg_sys::PgNode for CurrentOfExpr {}
impl ::core::fmt::Display for CurrentOfExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CustomPath {}
impl pg_sys::PgNode for CustomPath {}
impl ::core::fmt::Display for CustomPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CustomScan {}
impl pg_sys::PgNode for CustomScan {}
impl ::core::fmt::Display for CustomScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CustomScanState {}
impl pg_sys::PgNode for CustomScanState {}
impl ::core::fmt::Display for CustomScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DeallocateStmt {}
impl pg_sys::PgNode for DeallocateStmt {}
impl ::core::fmt::Display for DeallocateStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DeclareCursorStmt {}
impl pg_sys::PgNode for DeclareCursorStmt {}
impl ::core::fmt::Display for DeclareCursorStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DefElem {}
impl pg_sys::PgNode for DefElem {}
impl ::core::fmt::Display for DefElem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DefineStmt {}
impl pg_sys::PgNode for DefineStmt {}
impl ::core::fmt::Display for DefineStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DeleteStmt {}
impl pg_sys::PgNode for DeleteStmt {}
impl ::core::fmt::Display for DeleteStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DiscardStmt {}
impl pg_sys::PgNode for DiscardStmt {}
impl ::core::fmt::Display for DiscardStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DoStmt {}
impl pg_sys::PgNode for DoStmt {}
impl ::core::fmt::Display for DoStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DomainConstraintState {}
impl pg_sys::PgNode for DomainConstraintState {}
impl ::core::fmt::Display for DomainConstraintState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DropOwnedStmt {}
impl pg_sys::PgNode for DropOwnedStmt {}
impl ::core::fmt::Display for DropOwnedStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DropReplicationSlotCmd {}
impl pg_sys::PgNode for DropReplicationSlotCmd {}
impl ::core::fmt::Display for DropReplicationSlotCmd {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DropRoleStmt {}
impl pg_sys::PgNode for DropRoleStmt {}
impl ::core::fmt::Display for DropRoleStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DropStmt {}
impl pg_sys::PgNode for DropStmt {}
impl ::core::fmt::Display for DropStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DropSubscriptionStmt {}
impl pg_sys::PgNode for DropSubscriptionStmt {}
impl ::core::fmt::Display for DropSubscriptionStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DropTableSpaceStmt {}
impl pg_sys::PgNode for DropTableSpaceStmt {}
impl ::core::fmt::Display for DropTableSpaceStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DropUserMappingStmt {}
impl pg_sys::PgNode for DropUserMappingStmt {}
impl ::core::fmt::Display for DropUserMappingStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DropdbStmt {}
impl pg_sys::PgNode for DropdbStmt {}
impl ::core::fmt::Display for DropdbStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for EState {}
impl pg_sys::PgNode for EState {}
impl ::core::fmt::Display for EState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for EquivalenceClass {}
impl pg_sys::PgNode for EquivalenceClass {}
impl ::core::fmt::Display for EquivalenceClass {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for EquivalenceMember {}
impl pg_sys::PgNode for EquivalenceMember {}
impl ::core::fmt::Display for EquivalenceMember {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ErrorSaveContext {}
impl pg_sys::PgNode for ErrorSaveContext {}
impl ::core::fmt::Display for ErrorSaveContext {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for EventTriggerData {}
impl pg_sys::PgNode for EventTriggerData {}
impl ::core::fmt::Display for EventTriggerData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ExecuteStmt {}
impl pg_sys::PgNode for ExecuteStmt {}
impl ::core::fmt::Display for ExecuteStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ExplainStmt {}
impl pg_sys::PgNode for ExplainStmt {}
impl ::core::fmt::Display for ExplainStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Expr {}
impl pg_sys::PgNode for Expr {}
impl ::core::fmt::Display for Expr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ExprContext {}
impl pg_sys::PgNode for ExprContext {}
impl ::core::fmt::Display for ExprContext {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ExprState {}
impl pg_sys::PgNode for ExprState {}
impl ::core::fmt::Display for ExprState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ExtensibleNode {}
impl pg_sys::PgNode for ExtensibleNode {}
impl ::core::fmt::Display for ExtensibleNode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for FdwRoutine {}
impl pg_sys::PgNode for FdwRoutine {}
impl ::core::fmt::Display for FdwRoutine {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for FetchStmt {}
impl pg_sys::PgNode for FetchStmt {}
impl ::core::fmt::Display for FetchStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for FieldSelect {}
impl pg_sys::PgNode for FieldSelect {}
impl ::core::fmt::Display for FieldSelect {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for FieldStore {}
impl pg_sys::PgNode for FieldStore {}
impl ::core::fmt::Display for FieldStore {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Float {}
impl pg_sys::PgNode for Float {}
impl ::core::fmt::Display for Float {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ForeignKeyCacheInfo {}
impl pg_sys::PgNode for ForeignKeyCacheInfo {}
impl ::core::fmt::Display for ForeignKeyCacheInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ForeignKeyOptInfo {}
impl pg_sys::PgNode for ForeignKeyOptInfo {}
impl ::core::fmt::Display for ForeignKeyOptInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ForeignPath {}
impl pg_sys::PgNode for ForeignPath {}
impl ::core::fmt::Display for ForeignPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ForeignScan {}
impl pg_sys::PgNode for ForeignScan {}
impl ::core::fmt::Display for ForeignScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ForeignScanState {}
impl pg_sys::PgNode for ForeignScanState {}
impl ::core::fmt::Display for ForeignScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for FromExpr {}
impl pg_sys::PgNode for FromExpr {}
impl ::core::fmt::Display for FromExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for FuncCall {}
impl pg_sys::PgNode for FuncCall {}
impl ::core::fmt::Display for FuncCall {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for FuncExpr {}
impl pg_sys::PgNode for FuncExpr {}
impl ::core::fmt::Display for FuncExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for FunctionParameter {}
impl pg_sys::PgNode for FunctionParameter {}
impl ::core::fmt::Display for FunctionParameter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for FunctionScan {}
impl pg_sys::PgNode for FunctionScan {}
impl ::core::fmt::Display for FunctionScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for FunctionScanState {}
impl pg_sys::PgNode for FunctionScanState {}
impl ::core::fmt::Display for FunctionScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Gather {}
impl pg_sys::PgNode for Gather {}
impl ::core::fmt::Display for Gather {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for GatherMerge {}
impl pg_sys::PgNode for GatherMerge {}
impl ::core::fmt::Display for GatherMerge {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for GatherMergePath {}
impl pg_sys::PgNode for GatherMergePath {}
impl ::core::fmt::Display for GatherMergePath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for GatherMergeState {}
impl pg_sys::PgNode for GatherMergeState {}
impl ::core::fmt::Display for GatherMergeState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for GatherPath {}
impl pg_sys::PgNode for GatherPath {}
impl ::core::fmt::Display for GatherPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for GatherState {}
impl pg_sys::PgNode for GatherState {}
impl ::core::fmt::Display for GatherState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for GrantRoleStmt {}
impl pg_sys::PgNode for GrantRoleStmt {}
impl ::core::fmt::Display for GrantRoleStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for GrantStmt {}
impl pg_sys::PgNode for GrantStmt {}
impl ::core::fmt::Display for GrantStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Group {}
impl pg_sys::PgNode for Group {}
impl ::core::fmt::Display for Group {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for GroupByOrdering {}
impl pg_sys::PgNode for GroupByOrdering {}
impl ::core::fmt::Display for GroupByOrdering {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for GroupPath {}
impl pg_sys::PgNode for GroupPath {}
impl ::core::fmt::Display for GroupPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for GroupResultPath {}
impl pg_sys::PgNode for GroupResultPath {}
impl ::core::fmt::Display for GroupResultPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for GroupState {}
impl pg_sys::PgNode for GroupState {}
impl ::core::fmt::Display for GroupState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for GroupingFunc {}
impl pg_sys::PgNode for GroupingFunc {}
impl ::core::fmt::Display for GroupingFunc {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for GroupingSet {}
impl pg_sys::PgNode for GroupingSet {}
impl ::core::fmt::Display for GroupingSet {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for GroupingSetData {}
impl pg_sys::PgNode for GroupingSetData {}
impl ::core::fmt::Display for GroupingSetData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for GroupingSetsPath {}
impl pg_sys::PgNode for GroupingSetsPath {}
impl ::core::fmt::Display for GroupingSetsPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Hash {}
impl pg_sys::PgNode for Hash {}
impl ::core::fmt::Display for Hash {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for HashJoin {}
impl pg_sys::PgNode for HashJoin {}
impl ::core::fmt::Display for HashJoin {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for HashJoinState {}
impl pg_sys::PgNode for HashJoinState {}
impl ::core::fmt::Display for HashJoinState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for HashPath {}
impl pg_sys::PgNode for HashPath {}
impl ::core::fmt::Display for HashPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for HashState {}
impl pg_sys::PgNode for HashState {}
impl ::core::fmt::Display for HashState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for HeapTupleTableSlot {}
impl pg_sys::PgNode for HeapTupleTableSlot {}
impl ::core::fmt::Display for HeapTupleTableSlot {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IdentifySystemCmd {}
impl pg_sys::PgNode for IdentifySystemCmd {}
impl ::core::fmt::Display for IdentifySystemCmd {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ImportForeignSchemaStmt {}
impl pg_sys::PgNode for ImportForeignSchemaStmt {}
impl ::core::fmt::Display for ImportForeignSchemaStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IncrementalSort {}
impl pg_sys::PgNode for IncrementalSort {}
impl ::core::fmt::Display for IncrementalSort {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IncrementalSortPath {}
impl pg_sys::PgNode for IncrementalSortPath {}
impl ::core::fmt::Display for IncrementalSortPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IncrementalSortState {}
impl pg_sys::PgNode for IncrementalSortState {}
impl ::core::fmt::Display for IncrementalSortState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IndexAmRoutine {}
impl pg_sys::PgNode for IndexAmRoutine {}
impl ::core::fmt::Display for IndexAmRoutine {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IndexClause {}
impl pg_sys::PgNode for IndexClause {}
impl ::core::fmt::Display for IndexClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IndexElem {}
impl pg_sys::PgNode for IndexElem {}
impl ::core::fmt::Display for IndexElem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IndexInfo {}
impl pg_sys::PgNode for IndexInfo {}
impl ::core::fmt::Display for IndexInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IndexOnlyScan {}
impl pg_sys::PgNode for IndexOnlyScan {}
impl ::core::fmt::Display for IndexOnlyScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IndexOnlyScanState {}
impl pg_sys::PgNode for IndexOnlyScanState {}
impl ::core::fmt::Display for IndexOnlyScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IndexOptInfo {}
impl pg_sys::PgNode for IndexOptInfo {}
impl ::core::fmt::Display for IndexOptInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IndexPath {}
impl pg_sys::PgNode for IndexPath {}
impl ::core::fmt::Display for IndexPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IndexScan {}
impl pg_sys::PgNode for IndexScan {}
impl ::core::fmt::Display for IndexScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IndexScanState {}
impl pg_sys::PgNode for IndexScanState {}
impl ::core::fmt::Display for IndexScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IndexStmt {}
impl pg_sys::PgNode for IndexStmt {}
impl ::core::fmt::Display for IndexStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for InferClause {}
impl pg_sys::PgNode for InferClause {}
impl ::core::fmt::Display for InferClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for InferenceElem {}
impl pg_sys::PgNode for InferenceElem {}
impl ::core::fmt::Display for InferenceElem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for InlineCodeBlock {}
impl pg_sys::PgNode for InlineCodeBlock {}
impl ::core::fmt::Display for InlineCodeBlock {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for InsertStmt {}
impl pg_sys::PgNode for InsertStmt {}
impl ::core::fmt::Display for InsertStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Integer {}
impl pg_sys::PgNode for Integer {}
impl ::core::fmt::Display for Integer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IntoClause {}
impl pg_sys::PgNode for IntoClause {}
impl ::core::fmt::Display for IntoClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Join {}
impl pg_sys::PgNode for Join {}
impl ::core::fmt::Display for Join {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JoinDomain {}
impl pg_sys::PgNode for JoinDomain {}
impl ::core::fmt::Display for JoinDomain {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JoinExpr {}
impl pg_sys::PgNode for JoinExpr {}
impl ::core::fmt::Display for JoinExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JoinPath {}
impl pg_sys::PgNode for JoinPath {}
impl ::core::fmt::Display for JoinPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JoinState {}
impl pg_sys::PgNode for JoinState {}
impl ::core::fmt::Display for JoinState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonAggConstructor {}
impl pg_sys::PgNode for JsonAggConstructor {}
impl ::core::fmt::Display for JsonAggConstructor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonArgument {}
impl pg_sys::PgNode for JsonArgument {}
impl ::core::fmt::Display for JsonArgument {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonArrayAgg {}
impl pg_sys::PgNode for JsonArrayAgg {}
impl ::core::fmt::Display for JsonArrayAgg {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonArrayConstructor {}
impl pg_sys::PgNode for JsonArrayConstructor {}
impl ::core::fmt::Display for JsonArrayConstructor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonArrayQueryConstructor {}
impl pg_sys::PgNode for JsonArrayQueryConstructor {}
impl ::core::fmt::Display for JsonArrayQueryConstructor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonBehavior {}
impl pg_sys::PgNode for JsonBehavior {}
impl ::core::fmt::Display for JsonBehavior {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonConstructorExpr {}
impl pg_sys::PgNode for JsonConstructorExpr {}
impl ::core::fmt::Display for JsonConstructorExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonExpr {}
impl pg_sys::PgNode for JsonExpr {}
impl ::core::fmt::Display for JsonExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonFormat {}
impl pg_sys::PgNode for JsonFormat {}
impl ::core::fmt::Display for JsonFormat {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonFuncExpr {}
impl pg_sys::PgNode for JsonFuncExpr {}
impl ::core::fmt::Display for JsonFuncExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonIsPredicate {}
impl pg_sys::PgNode for JsonIsPredicate {}
impl ::core::fmt::Display for JsonIsPredicate {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonKeyValue {}
impl pg_sys::PgNode for JsonKeyValue {}
impl ::core::fmt::Display for JsonKeyValue {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonObjectAgg {}
impl pg_sys::PgNode for JsonObjectAgg {}
impl ::core::fmt::Display for JsonObjectAgg {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonObjectConstructor {}
impl pg_sys::PgNode for JsonObjectConstructor {}
impl ::core::fmt::Display for JsonObjectConstructor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonOutput {}
impl pg_sys::PgNode for JsonOutput {}
impl ::core::fmt::Display for JsonOutput {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonParseExpr {}
impl pg_sys::PgNode for JsonParseExpr {}
impl ::core::fmt::Display for JsonParseExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonReturning {}
impl pg_sys::PgNode for JsonReturning {}
impl ::core::fmt::Display for JsonReturning {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonScalarExpr {}
impl pg_sys::PgNode for JsonScalarExpr {}
impl ::core::fmt::Display for JsonScalarExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonSerializeExpr {}
impl pg_sys::PgNode for JsonSerializeExpr {}
impl ::core::fmt::Display for JsonSerializeExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonTable {}
impl pg_sys::PgNode for JsonTable {}
impl ::core::fmt::Display for JsonTable {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonTableColumn {}
impl pg_sys::PgNode for JsonTableColumn {}
impl ::core::fmt::Display for JsonTableColumn {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonTablePath {}
impl pg_sys::PgNode for JsonTablePath {}
impl ::core::fmt::Display for JsonTablePath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonTablePathScan {}
impl pg_sys::PgNode for JsonTablePathScan {}
impl ::core::fmt::Display for JsonTablePathScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonTablePathSpec {}
impl pg_sys::PgNode for JsonTablePathSpec {}
impl ::core::fmt::Display for JsonTablePathSpec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonTablePlan {}
impl pg_sys::PgNode for JsonTablePlan {}
impl ::core::fmt::Display for JsonTablePlan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonTableSiblingJoin {}
impl pg_sys::PgNode for JsonTableSiblingJoin {}
impl ::core::fmt::Display for JsonTableSiblingJoin {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonValueExpr {}
impl pg_sys::PgNode for JsonValueExpr {}
impl ::core::fmt::Display for JsonValueExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JunkFilter {}
impl pg_sys::PgNode for JunkFilter {}
impl ::core::fmt::Display for JunkFilter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Limit {}
impl pg_sys::PgNode for Limit {}
impl ::core::fmt::Display for Limit {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for LimitPath {}
impl pg_sys::PgNode for LimitPath {}
impl ::core::fmt::Display for LimitPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for LimitState {}
impl pg_sys::PgNode for LimitState {}
impl ::core::fmt::Display for LimitState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for List {}
impl pg_sys::PgNode for List {}
impl ::core::fmt::Display for List {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ListenStmt {}
impl pg_sys::PgNode for ListenStmt {}
impl ::core::fmt::Display for ListenStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for LoadStmt {}
impl pg_sys::PgNode for LoadStmt {}
impl ::core::fmt::Display for LoadStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for LockRows {}
impl pg_sys::PgNode for LockRows {}
impl ::core::fmt::Display for LockRows {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for LockRowsPath {}
impl pg_sys::PgNode for LockRowsPath {}
impl ::core::fmt::Display for LockRowsPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for LockRowsState {}
impl pg_sys::PgNode for LockRowsState {}
impl ::core::fmt::Display for LockRowsState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for LockStmt {}
impl pg_sys::PgNode for LockStmt {}
impl ::core::fmt::Display for LockStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for LockingClause {}
impl pg_sys::PgNode for LockingClause {}
impl ::core::fmt::Display for LockingClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Material {}
impl pg_sys::PgNode for Material {}
impl ::core::fmt::Display for Material {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MaterialPath {}
impl pg_sys::PgNode for MaterialPath {}
impl ::core::fmt::Display for MaterialPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MaterialState {}
impl pg_sys::PgNode for MaterialState {}
impl ::core::fmt::Display for MaterialState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Memoize {}
impl pg_sys::PgNode for Memoize {}
impl ::core::fmt::Display for Memoize {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MemoizePath {}
impl pg_sys::PgNode for MemoizePath {}
impl ::core::fmt::Display for MemoizePath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MemoizeState {}
impl pg_sys::PgNode for MemoizeState {}
impl ::core::fmt::Display for MemoizeState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MemoryContextData {}
impl pg_sys::PgNode for MemoryContextData {}
impl ::core::fmt::Display for MemoryContextData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MergeAction {}
impl pg_sys::PgNode for MergeAction {}
impl ::core::fmt::Display for MergeAction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MergeActionState {}
impl pg_sys::PgNode for MergeActionState {}
impl ::core::fmt::Display for MergeActionState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MergeAppend {}
impl pg_sys::PgNode for MergeAppend {}
impl ::core::fmt::Display for MergeAppend {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MergeAppendPath {}
impl pg_sys::PgNode for MergeAppendPath {}
impl ::core::fmt::Display for MergeAppendPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MergeAppendState {}
impl pg_sys::PgNode for MergeAppendState {}
impl ::core::fmt::Display for MergeAppendState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MergeJoin {}
impl pg_sys::PgNode for MergeJoin {}
impl ::core::fmt::Display for MergeJoin {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MergeJoinState {}
impl pg_sys::PgNode for MergeJoinState {}
impl ::core::fmt::Display for MergeJoinState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MergePath {}
impl pg_sys::PgNode for MergePath {}
impl ::core::fmt::Display for MergePath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MergeStmt {}
impl pg_sys::PgNode for MergeStmt {}
impl ::core::fmt::Display for MergeStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MergeSupportFunc {}
impl pg_sys::PgNode for MergeSupportFunc {}
impl ::core::fmt::Display for MergeSupportFunc {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MergeWhenClause {}
impl pg_sys::PgNode for MergeWhenClause {}
impl ::core::fmt::Display for MergeWhenClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MinMaxAggInfo {}
impl pg_sys::PgNode for MinMaxAggInfo {}
impl ::core::fmt::Display for MinMaxAggInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MinMaxAggPath {}
impl pg_sys::PgNode for MinMaxAggPath {}
impl ::core::fmt::Display for MinMaxAggPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MinMaxExpr {}
impl pg_sys::PgNode for MinMaxExpr {}
impl ::core::fmt::Display for MinMaxExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MinimalTupleTableSlot {}
impl pg_sys::PgNode for MinimalTupleTableSlot {}
impl ::core::fmt::Display for MinimalTupleTableSlot {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ModifyTable {}
impl pg_sys::PgNode for ModifyTable {}
impl ::core::fmt::Display for ModifyTable {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ModifyTablePath {}
impl pg_sys::PgNode for ModifyTablePath {}
impl ::core::fmt::Display for ModifyTablePath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ModifyTableState {}
impl pg_sys::PgNode for ModifyTableState {}
impl ::core::fmt::Display for ModifyTableState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MultiAssignRef {}
impl pg_sys::PgNode for MultiAssignRef {}
impl ::core::fmt::Display for MultiAssignRef {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for NamedArgExpr {}
impl pg_sys::PgNode for NamedArgExpr {}
impl ::core::fmt::Display for NamedArgExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for NamedTuplestoreScan {}
impl pg_sys::PgNode for NamedTuplestoreScan {}
impl ::core::fmt::Display for NamedTuplestoreScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for NamedTuplestoreScanState {}
impl pg_sys::PgNode for NamedTuplestoreScanState {}
impl ::core::fmt::Display for NamedTuplestoreScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for NestLoop {}
impl pg_sys::PgNode for NestLoop {}
impl ::core::fmt::Display for NestLoop {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for NestLoopParam {}
impl pg_sys::PgNode for NestLoopParam {}
impl ::core::fmt::Display for NestLoopParam {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for NestLoopState {}
impl pg_sys::PgNode for NestLoopState {}
impl ::core::fmt::Display for NestLoopState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for NestPath {}
impl pg_sys::PgNode for NestPath {}
impl ::core::fmt::Display for NestPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for NextValueExpr {}
impl pg_sys::PgNode for NextValueExpr {}
impl ::core::fmt::Display for NextValueExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Node {}
impl pg_sys::PgNode for Node {}
impl ::core::fmt::Display for Node {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for NotifyStmt {}
impl pg_sys::PgNode for NotifyStmt {}
impl ::core::fmt::Display for NotifyStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for NullTest {}
impl pg_sys::PgNode for NullTest {}
impl ::core::fmt::Display for NullTest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ObjectWithArgs {}
impl pg_sys::PgNode for ObjectWithArgs {}
impl ::core::fmt::Display for ObjectWithArgs {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for OnConflictClause {}
impl pg_sys::PgNode for OnConflictClause {}
impl ::core::fmt::Display for OnConflictClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for OnConflictExpr {}
impl pg_sys::PgNode for OnConflictExpr {}
impl ::core::fmt::Display for OnConflictExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for OnConflictSetState {}
impl pg_sys::PgNode for OnConflictSetState {}
impl ::core::fmt::Display for OnConflictSetState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for OpExpr {}
impl pg_sys::PgNode for OpExpr {}
impl ::core::fmt::Display for OpExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for OuterJoinClauseInfo {}
impl pg_sys::PgNode for OuterJoinClauseInfo {}
impl ::core::fmt::Display for OuterJoinClauseInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PLAssignStmt {}
impl pg_sys::PgNode for PLAssignStmt {}
impl ::core::fmt::Display for PLAssignStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Param {}
impl pg_sys::PgNode for Param {}
impl ::core::fmt::Display for Param {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ParamPathInfo {}
impl pg_sys::PgNode for ParamPathInfo {}
impl ::core::fmt::Display for ParamPathInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ParamRef {}
impl pg_sys::PgNode for ParamRef {}
impl ::core::fmt::Display for ParamRef {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PartitionBoundSpec {}
impl pg_sys::PgNode for PartitionBoundSpec {}
impl ::core::fmt::Display for PartitionBoundSpec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PartitionCmd {}
impl pg_sys::PgNode for PartitionCmd {}
impl ::core::fmt::Display for PartitionCmd {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PartitionElem {}
impl pg_sys::PgNode for PartitionElem {}
impl ::core::fmt::Display for PartitionElem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PartitionPruneInfo {}
impl pg_sys::PgNode for PartitionPruneInfo {}
impl ::core::fmt::Display for PartitionPruneInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PartitionPruneStep {}
impl pg_sys::PgNode for PartitionPruneStep {}
impl ::core::fmt::Display for PartitionPruneStep {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PartitionPruneStepCombine {}
impl pg_sys::PgNode for PartitionPruneStepCombine {}
impl ::core::fmt::Display for PartitionPruneStepCombine {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PartitionPruneStepOp {}
impl pg_sys::PgNode for PartitionPruneStepOp {}
impl ::core::fmt::Display for PartitionPruneStepOp {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PartitionRangeDatum {}
impl pg_sys::PgNode for PartitionRangeDatum {}
impl ::core::fmt::Display for PartitionRangeDatum {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PartitionSpec {}
impl pg_sys::PgNode for PartitionSpec {}
impl ::core::fmt::Display for PartitionSpec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PartitionedRelPruneInfo {}
impl pg_sys::PgNode for PartitionedRelPruneInfo {}
impl ::core::fmt::Display for PartitionedRelPruneInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Path {}
impl pg_sys::PgNode for Path {}
impl ::core::fmt::Display for Path {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PathKey {}
impl pg_sys::PgNode for PathKey {}
impl ::core::fmt::Display for PathKey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PathTarget {}
impl pg_sys::PgNode for PathTarget {}
impl ::core::fmt::Display for PathTarget {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PlaceHolderInfo {}
impl pg_sys::PgNode for PlaceHolderInfo {}
impl ::core::fmt::Display for PlaceHolderInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PlaceHolderVar {}
impl pg_sys::PgNode for PlaceHolderVar {}
impl ::core::fmt::Display for PlaceHolderVar {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Plan {}
impl pg_sys::PgNode for Plan {}
impl ::core::fmt::Display for Plan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PlanInvalItem {}
impl pg_sys::PgNode for PlanInvalItem {}
impl ::core::fmt::Display for PlanInvalItem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PlanRowMark {}
impl pg_sys::PgNode for PlanRowMark {}
impl ::core::fmt::Display for PlanRowMark {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PlanState {}
impl pg_sys::PgNode for PlanState {}
impl ::core::fmt::Display for PlanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PlannedStmt {}
impl pg_sys::PgNode for PlannedStmt {}
impl ::core::fmt::Display for PlannedStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PlannerGlobal {}
impl pg_sys::PgNode for PlannerGlobal {}
impl ::core::fmt::Display for PlannerGlobal {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PlannerInfo {}
impl pg_sys::PgNode for PlannerInfo {}
impl ::core::fmt::Display for PlannerInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PlannerParamItem {}
impl pg_sys::PgNode for PlannerParamItem {}
impl ::core::fmt::Display for PlannerParamItem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PrepareStmt {}
impl pg_sys::PgNode for PrepareStmt {}
impl ::core::fmt::Display for PrepareStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ProjectSet {}
impl pg_sys::PgNode for ProjectSet {}
impl ::core::fmt::Display for ProjectSet {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ProjectSetPath {}
impl pg_sys::PgNode for ProjectSetPath {}
impl ::core::fmt::Display for ProjectSetPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ProjectSetState {}
impl pg_sys::PgNode for ProjectSetState {}
impl ::core::fmt::Display for ProjectSetState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ProjectionInfo {}
impl pg_sys::PgNode for ProjectionInfo {}
impl ::core::fmt::Display for ProjectionInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ProjectionPath {}
impl pg_sys::PgNode for ProjectionPath {}
impl ::core::fmt::Display for ProjectionPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PublicationObjSpec {}
impl pg_sys::PgNode for PublicationObjSpec {}
impl ::core::fmt::Display for PublicationObjSpec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PublicationTable {}
impl pg_sys::PgNode for PublicationTable {}
impl ::core::fmt::Display for PublicationTable {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Query {}
impl pg_sys::PgNode for Query {}
impl ::core::fmt::Display for Query {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RTEPermissionInfo {}
impl pg_sys::PgNode for RTEPermissionInfo {}
impl ::core::fmt::Display for RTEPermissionInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RangeFunction {}
impl pg_sys::PgNode for RangeFunction {}
impl ::core::fmt::Display for RangeFunction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RangeSubselect {}
impl pg_sys::PgNode for RangeSubselect {}
impl ::core::fmt::Display for RangeSubselect {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RangeTableFunc {}
impl pg_sys::PgNode for RangeTableFunc {}
impl ::core::fmt::Display for RangeTableFunc {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RangeTableFuncCol {}
impl pg_sys::PgNode for RangeTableFuncCol {}
impl ::core::fmt::Display for RangeTableFuncCol {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RangeTableSample {}
impl pg_sys::PgNode for RangeTableSample {}
impl ::core::fmt::Display for RangeTableSample {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RangeTblEntry {}
impl pg_sys::PgNode for RangeTblEntry {}
impl ::core::fmt::Display for RangeTblEntry {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RangeTblFunction {}
impl pg_sys::PgNode for RangeTblFunction {}
impl ::core::fmt::Display for RangeTblFunction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RangeTblRef {}
impl pg_sys::PgNode for RangeTblRef {}
impl ::core::fmt::Display for RangeTblRef {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RangeVar {}
impl pg_sys::PgNode for RangeVar {}
impl ::core::fmt::Display for RangeVar {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RawStmt {}
impl pg_sys::PgNode for RawStmt {}
impl ::core::fmt::Display for RawStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ReadReplicationSlotCmd {}
impl pg_sys::PgNode for ReadReplicationSlotCmd {}
impl ::core::fmt::Display for ReadReplicationSlotCmd {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ReassignOwnedStmt {}
impl pg_sys::PgNode for ReassignOwnedStmt {}
impl ::core::fmt::Display for ReassignOwnedStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RecursiveUnion {}
impl pg_sys::PgNode for RecursiveUnion {}
impl ::core::fmt::Display for RecursiveUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RecursiveUnionPath {}
impl pg_sys::PgNode for RecursiveUnionPath {}
impl ::core::fmt::Display for RecursiveUnionPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RecursiveUnionState {}
impl pg_sys::PgNode for RecursiveUnionState {}
impl ::core::fmt::Display for RecursiveUnionState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RefreshMatViewStmt {}
impl pg_sys::PgNode for RefreshMatViewStmt {}
impl ::core::fmt::Display for RefreshMatViewStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ReindexStmt {}
impl pg_sys::PgNode for ReindexStmt {}
impl ::core::fmt::Display for ReindexStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RelOptInfo {}
impl pg_sys::PgNode for RelOptInfo {}
impl ::core::fmt::Display for RelOptInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RelabelType {}
impl pg_sys::PgNode for RelabelType {}
impl ::core::fmt::Display for RelabelType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RenameStmt {}
impl pg_sys::PgNode for RenameStmt {}
impl ::core::fmt::Display for RenameStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ReplicaIdentityStmt {}
impl pg_sys::PgNode for ReplicaIdentityStmt {}
impl ::core::fmt::Display for ReplicaIdentityStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ResTarget {}
impl pg_sys::PgNode for ResTarget {}
impl ::core::fmt::Display for ResTarget {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RestrictInfo {}
impl pg_sys::PgNode for RestrictInfo {}
impl ::core::fmt::Display for RestrictInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Result {}
impl pg_sys::PgNode for Result {}
impl ::core::fmt::Display for Result {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ResultRelInfo {}
impl pg_sys::PgNode for ResultRelInfo {}
impl ::core::fmt::Display for ResultRelInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ResultState {}
impl pg_sys::PgNode for ResultState {}
impl ::core::fmt::Display for ResultState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ReturnSetInfo {}
impl pg_sys::PgNode for ReturnSetInfo {}
impl ::core::fmt::Display for ReturnSetInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ReturnStmt {}
impl pg_sys::PgNode for ReturnStmt {}
impl ::core::fmt::Display for ReturnStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RoleSpec {}
impl pg_sys::PgNode for RoleSpec {}
impl ::core::fmt::Display for RoleSpec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RollupData {}
impl pg_sys::PgNode for RollupData {}
impl ::core::fmt::Display for RollupData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RowCompareExpr {}
impl pg_sys::PgNode for RowCompareExpr {}
impl ::core::fmt::Display for RowCompareExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RowExpr {}
impl pg_sys::PgNode for RowExpr {}
impl ::core::fmt::Display for RowExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RowIdentityVarInfo {}
impl pg_sys::PgNode for RowIdentityVarInfo {}
impl ::core::fmt::Display for RowIdentityVarInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RowMarkClause {}
impl pg_sys::PgNode for RowMarkClause {}
impl ::core::fmt::Display for RowMarkClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RuleStmt {}
impl pg_sys::PgNode for RuleStmt {}
impl ::core::fmt::Display for RuleStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SQLValueFunction {}
impl pg_sys::PgNode for SQLValueFunction {}
impl ::core::fmt::Display for SQLValueFunction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SampleScan {}
impl pg_sys::PgNode for SampleScan {}
impl ::core::fmt::Display for SampleScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SampleScanState {}
impl pg_sys::PgNode for SampleScanState {}
impl ::core::fmt::Display for SampleScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ScalarArrayOpExpr {}
impl pg_sys::PgNode for ScalarArrayOpExpr {}
impl ::core::fmt::Display for ScalarArrayOpExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Scan {}
impl pg_sys::PgNode for Scan {}
impl ::core::fmt::Display for Scan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ScanState {}
impl pg_sys::PgNode for ScanState {}
impl ::core::fmt::Display for ScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SecLabelStmt {}
impl pg_sys::PgNode for SecLabelStmt {}
impl ::core::fmt::Display for SecLabelStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SelectStmt {}
impl pg_sys::PgNode for SelectStmt {}
impl ::core::fmt::Display for SelectStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SeqScan {}
impl pg_sys::PgNode for SeqScan {}
impl ::core::fmt::Display for SeqScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SeqScanState {}
impl pg_sys::PgNode for SeqScanState {}
impl ::core::fmt::Display for SeqScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SetExprState {}
impl pg_sys::PgNode for SetExprState {}
impl ::core::fmt::Display for SetExprState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SetOp {}
impl pg_sys::PgNode for SetOp {}
impl ::core::fmt::Display for SetOp {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SetOpPath {}
impl pg_sys::PgNode for SetOpPath {}
impl ::core::fmt::Display for SetOpPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SetOpState {}
impl pg_sys::PgNode for SetOpState {}
impl ::core::fmt::Display for SetOpState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SetOperationStmt {}
impl pg_sys::PgNode for SetOperationStmt {}
impl ::core::fmt::Display for SetOperationStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SetToDefault {}
impl pg_sys::PgNode for SetToDefault {}
impl ::core::fmt::Display for SetToDefault {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SinglePartitionSpec {}
impl pg_sys::PgNode for SinglePartitionSpec {}
impl ::core::fmt::Display for SinglePartitionSpec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Sort {}
impl pg_sys::PgNode for Sort {}
impl ::core::fmt::Display for Sort {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SortBy {}
impl pg_sys::PgNode for SortBy {}
impl ::core::fmt::Display for SortBy {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SortGroupClause {}
impl pg_sys::PgNode for SortGroupClause {}
impl ::core::fmt::Display for SortGroupClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SortPath {}
impl pg_sys::PgNode for SortPath {}
impl ::core::fmt::Display for SortPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SortState {}
impl pg_sys::PgNode for SortState {}
impl ::core::fmt::Display for SortState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SpecialJoinInfo {}
impl pg_sys::PgNode for SpecialJoinInfo {}
impl ::core::fmt::Display for SpecialJoinInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for StartReplicationCmd {}
impl pg_sys::PgNode for StartReplicationCmd {}
impl ::core::fmt::Display for StartReplicationCmd {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for StatisticExtInfo {}
impl pg_sys::PgNode for StatisticExtInfo {}
impl ::core::fmt::Display for StatisticExtInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for StatsElem {}
impl pg_sys::PgNode for StatsElem {}
impl ::core::fmt::Display for StatsElem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for String {}
impl pg_sys::PgNode for String {}
impl ::core::fmt::Display for String {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SubLink {}
impl pg_sys::PgNode for SubLink {}
impl ::core::fmt::Display for SubLink {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SubPlan {}
impl pg_sys::PgNode for SubPlan {}
impl ::core::fmt::Display for SubPlan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SubPlanState {}
impl pg_sys::PgNode for SubPlanState {}
impl ::core::fmt::Display for SubPlanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SubqueryScan {}
impl pg_sys::PgNode for SubqueryScan {}
impl ::core::fmt::Display for SubqueryScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SubqueryScanPath {}
impl pg_sys::PgNode for SubqueryScanPath {}
impl ::core::fmt::Display for SubqueryScanPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SubqueryScanState {}
impl pg_sys::PgNode for SubqueryScanState {}
impl ::core::fmt::Display for SubqueryScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SubscriptingRef {}
impl pg_sys::PgNode for SubscriptingRef {}
impl ::core::fmt::Display for SubscriptingRef {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SupportRequestCost {}
impl pg_sys::PgNode for SupportRequestCost {}
impl ::core::fmt::Display for SupportRequestCost {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SupportRequestIndexCondition {}
impl pg_sys::PgNode for SupportRequestIndexCondition {}
impl ::core::fmt::Display for SupportRequestIndexCondition {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SupportRequestOptimizeWindowClause {}
impl pg_sys::PgNode for SupportRequestOptimizeWindowClause {}
impl ::core::fmt::Display for SupportRequestOptimizeWindowClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SupportRequestRows {}
impl pg_sys::PgNode for SupportRequestRows {}
impl ::core::fmt::Display for SupportRequestRows {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SupportRequestSelectivity {}
impl pg_sys::PgNode for SupportRequestSelectivity {}
impl ::core::fmt::Display for SupportRequestSelectivity {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SupportRequestSimplify {}
impl pg_sys::PgNode for SupportRequestSimplify {}
impl ::core::fmt::Display for SupportRequestSimplify {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SupportRequestWFuncMonotonic {}
impl pg_sys::PgNode for SupportRequestWFuncMonotonic {}
impl ::core::fmt::Display for SupportRequestWFuncMonotonic {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TableAmRoutine {}
impl pg_sys::PgNode for TableAmRoutine {}
impl ::core::fmt::Display for TableAmRoutine {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TableFunc {}
impl pg_sys::PgNode for TableFunc {}
impl ::core::fmt::Display for TableFunc {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TableFuncScan {}
impl pg_sys::PgNode for TableFuncScan {}
impl ::core::fmt::Display for TableFuncScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TableFuncScanState {}
impl pg_sys::PgNode for TableFuncScanState {}
impl ::core::fmt::Display for TableFuncScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TableLikeClause {}
impl pg_sys::PgNode for TableLikeClause {}
impl ::core::fmt::Display for TableLikeClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TableSampleClause {}
impl pg_sys::PgNode for TableSampleClause {}
impl ::core::fmt::Display for TableSampleClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TargetEntry {}
impl pg_sys::PgNode for TargetEntry {}
impl ::core::fmt::Display for TargetEntry {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TidPath {}
impl pg_sys::PgNode for TidPath {}
impl ::core::fmt::Display for TidPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TidRangePath {}
impl pg_sys::PgNode for TidRangePath {}
impl ::core::fmt::Display for TidRangePath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TidRangeScan {}
impl pg_sys::PgNode for TidRangeScan {}
impl ::core::fmt::Display for TidRangeScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TidRangeScanState {}
impl pg_sys::PgNode for TidRangeScanState {}
impl ::core::fmt::Display for TidRangeScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TidScan {}
impl pg_sys::PgNode for TidScan {}
impl ::core::fmt::Display for TidScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TidScanState {}
impl pg_sys::PgNode for TidScanState {}
impl ::core::fmt::Display for TidScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TimeLineHistoryCmd {}
impl pg_sys::PgNode for TimeLineHistoryCmd {}
impl ::core::fmt::Display for TimeLineHistoryCmd {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TransactionStmt {}
impl pg_sys::PgNode for TransactionStmt {}
impl ::core::fmt::Display for TransactionStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TriggerData {}
impl pg_sys::PgNode for TriggerData {}
impl ::core::fmt::Display for TriggerData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TriggerTransition {}
impl pg_sys::PgNode for TriggerTransition {}
impl ::core::fmt::Display for TriggerTransition {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TruncateStmt {}
impl pg_sys::PgNode for TruncateStmt {}
impl ::core::fmt::Display for TruncateStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TupleTableSlot {}
impl pg_sys::PgNode for TupleTableSlot {}
impl ::core::fmt::Display for TupleTableSlot {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TypeCast {}
impl pg_sys::PgNode for TypeCast {}
impl ::core::fmt::Display for TypeCast {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TypeName {}
impl pg_sys::PgNode for TypeName {}
impl ::core::fmt::Display for TypeName {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Unique {}
impl pg_sys::PgNode for Unique {}
impl ::core::fmt::Display for Unique {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for UniquePath {}
impl pg_sys::PgNode for UniquePath {}
impl ::core::fmt::Display for UniquePath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for UniqueState {}
impl pg_sys::PgNode for UniqueState {}
impl ::core::fmt::Display for UniqueState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for UnlistenStmt {}
impl pg_sys::PgNode for UnlistenStmt {}
impl ::core::fmt::Display for UnlistenStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for UpdateStmt {}
impl pg_sys::PgNode for UpdateStmt {}
impl ::core::fmt::Display for UpdateStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for UploadManifestCmd {}
impl pg_sys::PgNode for UploadManifestCmd {}
impl ::core::fmt::Display for UploadManifestCmd {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for UpperUniquePath {}
impl pg_sys::PgNode for UpperUniquePath {}
impl ::core::fmt::Display for UpperUniquePath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for VacuumRelation {}
impl pg_sys::PgNode for VacuumRelation {}
impl ::core::fmt::Display for VacuumRelation {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for VacuumStmt {}
impl pg_sys::PgNode for VacuumStmt {}
impl ::core::fmt::Display for VacuumStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ValuesScan {}
impl pg_sys::PgNode for ValuesScan {}
impl ::core::fmt::Display for ValuesScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ValuesScanState {}
impl pg_sys::PgNode for ValuesScanState {}
impl ::core::fmt::Display for ValuesScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Var {}
impl pg_sys::PgNode for Var {}
impl ::core::fmt::Display for Var {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for VariableSetStmt {}
impl pg_sys::PgNode for VariableSetStmt {}
impl ::core::fmt::Display for VariableSetStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for VariableShowStmt {}
impl pg_sys::PgNode for VariableShowStmt {}
impl ::core::fmt::Display for VariableShowStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ViewStmt {}
impl pg_sys::PgNode for ViewStmt {}
impl ::core::fmt::Display for ViewStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for VirtualTupleTableSlot {}
impl pg_sys::PgNode for VirtualTupleTableSlot {}
impl ::core::fmt::Display for VirtualTupleTableSlot {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for WindowAgg {}
impl pg_sys::PgNode for WindowAgg {}
impl ::core::fmt::Display for WindowAgg {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for WindowAggPath {}
impl pg_sys::PgNode for WindowAggPath {}
impl ::core::fmt::Display for WindowAggPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for WindowAggState {}
impl pg_sys::PgNode for WindowAggState {}
impl ::core::fmt::Display for WindowAggState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for WindowClause {}
impl pg_sys::PgNode for WindowClause {}
impl ::core::fmt::Display for WindowClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for WindowDef {}
impl pg_sys::PgNode for WindowDef {}
impl ::core::fmt::Display for WindowDef {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for WindowFunc {}
impl pg_sys::PgNode for WindowFunc {}
impl ::core::fmt::Display for WindowFunc {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for WindowFuncExprState {}
impl pg_sys::PgNode for WindowFuncExprState {}
impl ::core::fmt::Display for WindowFuncExprState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for WindowFuncRunCondition {}
impl pg_sys::PgNode for WindowFuncRunCondition {}
impl ::core::fmt::Display for WindowFuncRunCondition {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for WithCheckOption {}
impl pg_sys::PgNode for WithCheckOption {}
impl ::core::fmt::Display for WithCheckOption {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for WithClause {}
impl pg_sys::PgNode for WithClause {}
impl ::core::fmt::Display for WithClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for WorkTableScan {}
impl pg_sys::PgNode for WorkTableScan {}
impl ::core::fmt::Display for WorkTableScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for WorkTableScanState {}
impl pg_sys::PgNode for WorkTableScanState {}
impl ::core::fmt::Display for WorkTableScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for XmlExpr {}
impl pg_sys::PgNode for XmlExpr {}
impl ::core::fmt::Display for XmlExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for XmlSerialize {}
impl pg_sys::PgNode for XmlSerialize {}
impl ::core::fmt::Display for XmlSerialize {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
