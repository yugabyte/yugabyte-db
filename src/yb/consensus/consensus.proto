// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
//
//
// The following only applies to changes made to this file as part of YugaByte development.
//
// Portions Copyright (c) YugaByte, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.  You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distributed under the License
// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
// or implied.  See the License for the specific language governing permissions and limitations
// under the License.
//
syntax = "proto2";

package yb.consensus;

option java_package = "org.yb.consensus";

import "yb/common/common_net.proto";
import "yb/common/opid.proto";
import "yb/common/wire_protocol.proto";
import "yb/consensus/consensus_types.proto";
import "yb/consensus/metadata.proto";
import "yb/rpc/lightweight_message.proto";
import "yb/tablet/operations.proto";
import "yb/tserver/backup.proto";
import "yb/tserver/tserver_types.proto";

// ===========================================================================
//  External Consensus Messages
// ===========================================================================

// The transaction driver type: indicates whether a transaction is
// being executed on a leader or a replica.
enum DriverType {
  UNKNOWN_DRIVER = 0;
  LEADER = 1;
  REPLICA = 2;
}

// A configuration change request for the tablet with 'tablet_id'.
// This message is dynamically generated by the leader when AddServer() or
// RemoveServer() is called, and is what gets replicated to the log.
message ChangeConfigRecordPB {
  required bytes tablet_id = 1;

  // The old committed configuration config for verification purposes.
  required RaftConfigPB old_config = 2;

  // The new configuration to set the configuration to.
  required RaftConfigPB new_config = 3;
}

// A configuration change request for the tablet with 'tablet_id'.
// These requests are restricted to one-by-one operations, as specified in
// Diego Ongaro's Raft PhD thesis.
// This is the RPC request, but it does not end up in the log.
// See also ChangeConfigRecordPB.
message ChangeConfigRequestPB {
  // UUID of server this request is addressed to.
  optional bytes dest_uuid = 4;

  required bytes tablet_id = 1;

  // The type of config change requested.
  // This field must be specified, but is left as optional due to being an enum.
  optional ChangeConfigType type = 2;

  // The peer to add or remove.
  // When 'type' == ADD_SERVER, both the permanent_uuid and last_known_addr
  // fields must be set. For REMOVE_SERVER, either the permanent_uuid field or
  // last_known_addr should be set - 'use_host' is for using the latter.
  optional RaftPeerPB server = 3;

  // The OpId index of the committed config to replace.
  // This optional parameter is here to provide an atomic (compare-and-swap)
  // ChangeConfig operation. The ChangeConfig() operation will fail if this
  // parameter is specified and the committed config does not have a matching
  // opid_index. See also the definition of RaftConfigPB.
  optional int64 cas_config_opid_index = 5;

  // For REMOVE case, when this is set, we assume that the peer is dead and will not
  // affect the quorum anymore. So we skip checking/using its server uuid and remove
  // it based on the ip/port info from 'server'.
  optional bool use_host = 6 [default = false];
}

// The configuration change response. If any immediate error occurred
// the 'error' field is set with it.
message ChangeConfigResponsePB {
  optional tserver.TabletServerErrorPB error = 1;

  // The hybrid_time chosen by the server for this change config operation.
  // TODO: At the time of writing, this field is never set in the response.
  // TODO: Propagate signed hybrid_times. See KUDU-611.
  optional fixed64 hybrid_time = 2;
}

// Required by HistoryCutoffOperation.
message HistoryCutoffPB {
  option (yb.rpc.lightweight_message).force_arena = true;
  // History cutoff of all the tables of this tablet.
  // On the master, this field is used for the sys catalog table.
  // For cotables i.e. ysql system tables, the cotables_cutoff_ht field
  // is used. On tservers, this field is used everywhere i.e. for both
  // colocated and non-colocated tables. In such cases, the
  // cotables_cutoff_ht is invalid.
  optional fixed64 primary_cutoff_ht = 1;
  // Set only on the master for cotables.
  optional fixed64 cotables_cutoff_ht = 2;
}

// A Replicate message, sent to replicas by leader to indicate this operation must be stored in the
// write-ahead log.
message ReplicateMsg {
  // The Raft operation ID (term and index) being replicated.

  required OpIdPB id = 1;

  // The hybrid time assigned to this message.
  required fixed64 hybrid_time = 2;

  // A counter that is forever increasing in a tablet (like hybrid time). Used for list indexing.
  optional int64 monotonic_counter = 9;

  required OperationType op_type = 4;
  optional tablet.WritePB write = 5 [(yb.rpc.lightweight_field).pointer = true];
  optional tablet.ChangeMetadataRequestPB change_metadata_request = 6
      [(yb.rpc.lightweight_field).pointer = true];
  optional tablet.TransactionStatePB transaction_state = 10
      [(yb.rpc.lightweight_field).pointer = true];
  optional tserver.TabletSnapshotOpRequestPB snapshot_request = 11
      [(yb.rpc.lightweight_field).pointer = true];
  optional tablet.TruncatePB truncate = 12 [(yb.rpc.lightweight_field).pointer = true];
  optional tablet.SplitTabletRequestPB split_request = 14
      [(yb.rpc.lightweight_field).pointer = true];
  optional ChangeConfigRecordPB change_config_record = 7
      [(yb.rpc.lightweight_field).pointer = true];
  optional HistoryCutoffPB history_cutoff = 13 [(yb.rpc.lightweight_field).pointer = true];
  optional AutoFlagsConfigPB auto_flags_config = 15
      [(yb.rpc.lightweight_field).pointer = true];
  optional tablet.CloneTabletRequestPB clone_tablet = 16
      [(yb.rpc.lightweight_field).pointer = true];

  // The Raft operation ID known to the leader to be committed at the time this message was sent.
  // This is used during tablet bootstrap for RocksDB-backed tables.
  optional OpIdPB committed_op_id = 8;

  optional NoOpRequestPB noop_request = 999;
}

// ===========================================================================
//  Internal Consensus Messages and State
// ===========================================================================

// NoOp requests, mostly used in tests.
message NoOpRequestPB {
 // Allows to set a dummy payload, for tests.
 optional bytes payload_for_tests = 1;
}

// NoOp responses, mostly used in tests.
message NoOpResponsePB {
   // Allows to set a dummy payload, for tests.
   optional bytes payload_for_tests = 1;
}

message PerOpErrorPB {
  // The id of the operation that failed in the other peer.
  required OpIdPB id = 1;
  // The Status explaining why the operation failed.
  required AppStatusPB status = 2;
}

// Status message received in the peer responses.
message ConsensusStatusPB {

  // The last message received (and replicated) by the peer.
  required OpIdPB last_received = 1;

  // The id of the last op that was replicated by the current leader.
  // This doesn't necessarily mean that the term of this op equals the current
  // term, since the current leader may be replicating ops from a prior term.
  // Unset if none currently received.
  //
  // In the case where there is a log matching property error
  // (PRECEDING_ENTRY_DIDNT_MATCH), this field is important and may still be
  // set, since the leader queue uses this field in conjuction with
  // last_received to decide on the next id to send to the follower.
  optional OpIdPB last_received_current_leader = 4;

  // The last committed index that is known to the peer.
  optional int64 last_committed_idx = 2;

  // The last operation applied by the peer.
  optional OpIdPB last_applied = 5;

  // When the last request failed for some consensus related (internal) reason.
  // In some cases the error will have a specific code that the caller will
  // have to handle in certain ways.
  optional ConsensusErrorPB error = 3;
}

// A request from a candidate peer that wishes to become leader of
// the configuration serving tablet with 'tablet_id'.
// See RAFT sec. 5.2.
message VoteRequestPB {
  // UUID of server this request is addressed to.
  optional bytes dest_uuid = 6;

  // Identifies the tablet configuration a the vote is being requested for.
  required string tablet_id = 1;

  // The uuid of the sending peer.
  required bytes candidate_uuid = 2;

  // The term we are requesting a vote for.
  // If this term is higher than the callee's term, the callee will update its
  // own term to match, and if it is the current leader it will step down.
  required int64 candidate_term = 3;

  // The candidate node status so that the voter node can
  // decide whether to vote for it as LEADER.
  //
  // In particular, this includes the last OpId persisted in the candidate's
  // log, which corresponds to the lastLogIndex and lastLogTerm fields in Raft.
  // A replica must vote no for a candidate that has an OpId lower than them.
  required ConsensusStatusPB candidate_status = 4;

  // Normally, replicas will deny a vote with a LEADER_IS_ALIVE error if
  // they are a leader or recently heard from a leader. This is to prevent
  // partitioned nodes from disturbing liveness. If this flag is true,
  // peers will vote even if they think a leader is alive. This can be used
  // for example to force a faster leader hand-off rather than waiting for
  // the election timer to expire.
  optional bool ignore_live_leader = 5 [ default = false ];

  // true if it is pre-election request and state of voter should not be changed.
  optional bool preelection = 7;
}

// A response from a replica to a leader election request.
message VoteResponsePB {
  // The uuid of the node sending the reply.
  optional bytes responder_uuid = 1;

  // The term of the node sending the reply.
  // Allows the candidate to update itself if it is behind.
  optional int64 responder_term = 2;

  // True if this peer voted for the caller, false otherwise.
  optional bool vote_granted = 3;

  // An upper bound on the remainder of the old leader's lease that the new leader has to wait out
  // before it can start serving read and write requests.
  optional int32 remaining_leader_lease_duration_ms = 4;

  // UUID of node that has lease.
  optional bytes leader_lease_uuid = 7;

  // An upper bound on the deadline of the old hybrid time leader's lease that the new leader has
  // to wait out before it can start serving read and write requests.
  // Contains only physical part of hybrid time.
  optional fixed64 leader_ht_lease_expiration = 5;

  // UUID of node that has ht lease.
  optional bytes leader_ht_lease_uuid = 8;

  // true if it is response to pre-election request.
  optional bool preelection = 6;

  // TODO: Migrate ConsensusService to the AppStatusPB RPC style and merge these errors.
  // Error message from the consensus implementation.
  optional ConsensusErrorPB consensus_error = 998;

  // A generic error message (such as tablet not found).
  optional tserver.TabletServerErrorPB error = 999;
}

// A consensus request message, the basic unit of a consensus round.
message ConsensusRequestPB {
  // UUID of server this request is addressed to.
  optional bytes dest_uuid = 7;

  required string tablet_id = 1;

  // The uuid of the peer making the call.
  required bytes caller_uuid = 2;

  // The caller's term. As only leaders can send messages,
  // replicas will accept all messages as long as the term
  // is equal to or higher than the last term they know about.
  // If a leader receives a request with a term higher than its own,
  // it will step down and enter FOLLOWER state (see Raft sec. 5.1).
  required int64 caller_term = 3;

  // The id of the operation immediately preceding the first
  // operation in 'ops'. If the replica is receiving 'ops' for
  // the first time 'preceding_id' must match the replica's
  // last operation.
  //
  // This must be set if 'ops' is non-empty.
  optional OpIdPB preceding_id = 4;

  // The id of the last committed operation in the configuration. This is the
  // id of the last operation the leader deemed committed from a consensus
  // standpoint (not the last operation the leader applied).
  //
  // Raft calls this field 'leaderCommit'.
  required OpIdPB committed_op_id = 5;

  // Sequence of operations to be replicated by this peer.
  // These will be committed when committed_index advances above their
  // respective OpIds. In some cases committed_index can indicate that
  // these operations are already committed, in which case they will be
  // committed during the same request.
  repeated ReplicateMsg ops = 6;

  // Leader lease duration in milliseconds. A leader is not allowed to serve up-to-date reads
  // until it is able to replicate a lease extension. A new leader cannot assume its
  // responsibilities until this amount time has definitely passed since the old leader sent the
  // consensus request. Due to potential clock skew, we are not sending a timestamp, but an amount
  // of time followers have to wait.
  optional int32 leader_lease_duration_ms = 8;

  // Leader lease expiration, physical part of hybrid time. A new leader cannot add new
  // entries to RAFT log until hybrid time passes this expiration.
  optional fixed64 ht_lease_expiration = 9;

  // Safe time measured on the leader at the time this request was generated.
  optional fixed64 propagated_safe_time = 10;

  // Hybrid time on the leader when this request was generated.
  optional fixed64 propagated_hybrid_time = 11;

  // If enabled, a trace will be collected for this RPC and returned in the response.
  optional bool trace_requested = 12;
}

message ConsensusResponsePB {
  // The uuid of the peer making the response.
  optional bytes responder_uuid = 1;

  // The current term of the peer making the response.
  // This is used to update the caller (and make it step down if it is
  // out of date).
  optional int64 responder_term = 2;

  // The current consensus status of the receiver peer.
  optional ConsensusStatusPB status = 3;

  // A generic error message (such as tablet not found), per operation
  // error messages are sent along with the consensus status.
  optional tserver.TabletServerErrorPB error = 999;

  // Number of SST files in this follower regular db.
  optional int64 num_sst_files = 5;

  // Hybrid time on the follower when this request was processed.
  optional fixed64 propagated_hybrid_time = 6;

  // The trace for the RPC as a string, returned only if requested.
  optional string trace_buffer = 7;
}

message MultiRaftConsensusRequestPB {
  repeated ConsensusRequestPB consensus_request = 1;
}

message MultiRaftConsensusResponsePB {
  repeated ConsensusResponsePB consensus_response = 1;
}

// A message reflecting the status of an in-flight transaction.
message OperationStatusPB {
  required OpIdPB op_id = 1;
  required OperationType operation_type = 2;
  // Time the transaction has been in flight.
  required int64 running_for_micros = 3;
  // Quick human-readable description (e.g., ToString() output).
  required string description = 4;

  // If tracing is enabled when viewing the transaction, the trace
  // buffer is copied here.
  optional string trace_buffer = 6;
}

message GetNodeInstanceRequestPB {
}

message GetNodeInstanceResponsePB {
  optional NodeInstancePB node_instance = 1;
  optional ServerRegistrationPB registration = 2;
}

// Message that makes the local peer run leader election to be elected leader.
// Assumes that a tablet with 'tablet_id' exists.
message RunLeaderElectionRequestPB {
  // UUID of server this request is addressed to.
  optional bytes dest_uuid = 2;

  // the id of the tablet
  required bytes tablet_id = 1;

  // The id of the last operation the current leader has committed to its log.
  // When specified, the peer must wait till the operation has been committed
  // to its log before starting the election to be qualified as a leader.
  optional OpIdPB committed_index = 3;

  // UUID of old leader, that requested this election.
  // If we lost election, we would notify originator about this fact.
  // So it would reset its withold timeout and try to become a leader again.
  optional bytes originator_uuid = 4;

  optional bool suppress_vote_request = 5;

  optional bool initial_election = 6;
}

message RunLeaderElectionResponsePB {
  // A generic error message (such as tablet not found).
  optional tserver.TabletServerErrorPB error = 1;
}

message LeaderElectionLostRequestPB {
  // UUID of server this request is addressed to.
  // It is originator_uuid from RunLeaderElectionRequestPB
  optional bytes dest_uuid = 1;

  // the id of the tablet
  optional bytes tablet_id = 2;

  // UUID of server that lost election
  optional bytes election_lost_by_uuid = 3;
}

message LeaderElectionLostResponsePB {
  // A generic error message (such as tablet not found).
  optional tserver.TabletServerErrorPB error = 1;
}

message LeaderStepDownRequestPB {
  // UUID of server this request is addressed to.
  optional bytes dest_uuid = 2;

  // The id of the tablet.
  required bytes tablet_id = 1;

  // UUID of the server that should run the election to become the new leader.
  optional bytes new_leader_uuid = 3;

  // Used in tests to ignore check for new leader conditions.
  optional bool force_step_down = 4;

  // If new_leader_uuid is not specified, the current leader will attempt
  // to gracefully transfer leadership to another peer. Setting this flag
  // disables that behavior.
  optional bool disable_graceful_transition = 5;

}

message LeaderStepDownResponsePB {
  // A generic error message (such as tablet not found).
  optional tserver.TabletServerErrorPB error = 1;

  // Time in milliseconds since previous election failure with the same intended ("protege") leader.
  // This is used to track the remaining amount of time during which the load balancer should not
  // attempt to ask (any) leader of this tablet to step down in favor of the same peer.
  optional int64 time_since_election_failure_ms = 2;
}

message GetLastOpIdRequestPB {
  // UUID of server this request is addressed to.
  optional bytes dest_uuid = 2;

  // the id of the tablet
  required bytes tablet_id = 1;

  // Whether to return the last-received or last-committed OpId.
  optional OpIdType opid_type = 3 [ default = RECEIVED_OPID ];

  optional OperationType op_type = 4;
}

message GetLastOpIdResponsePB {
  optional OpIdPB opid = 1;
    // A generic error message (such as tablet not found).
  optional tserver.TabletServerErrorPB error = 2;
}

message GetConsensusStateRequestPB {
  // UUID of server this request is addressed to.
  optional bytes dest_uuid = 2;

  // The id of the tablet.
  required bytes tablet_id = 1;

  // Whether to fetch the committed or active consensus state.
  optional ConsensusConfigType type = 3 [ default = CONSENSUS_CONFIG_COMMITTED ];
}

message GetConsensusStateResponsePB {
  optional ConsensusStatePB cstate = 1;

  // A generic error message (such as tablet not found).
  optional tserver.TabletServerErrorPB error = 2;

  // Allows returning the leader lease status in the same RPC. Useful for waiting for the leader
  // to be allowed to serve requests.
  optional LeaderLeaseStatus leader_lease_status = 3;
}

message StartRemoteBootstrapRequestPB {
  // UUID of server this request is addressed to.
  optional bytes dest_uuid = 5;

  required bytes tablet_id = 1;

  optional bytes split_parent_tablet_id = 8;

  // Identification for the host we are bootstrapping from.
  required bytes bootstrap_source_peer_uuid = 2;
  repeated HostPortPB bootstrap_source_private_addr = 3;
  repeated HostPortPB bootstrap_source_broadcast_addr = 6;
  optional CloudInfoPB bootstrap_source_cloud_info = 7;

  // The caller's term. In the case that the target of this request has a
  // TOMBSTONED replica with a term higher than this one, the request will fail.
  optional int64 caller_term = 4 [ default = -1 ];

  // When the remote bootstrap request is served by a closest follower to the
  // new peer, the new peer needs to update the leader on progessing the log
  // anchor.
  optional bool is_served_by_tablet_leader = 9 [ default = true ];
  optional bytes tablet_leader_peer_uuid = 10;
  repeated HostPortPB tablet_leader_private_addr = 11;
  repeated HostPortPB tablet_leader_broadcast_addr = 12;
  optional CloudInfoPB tablet_leader_cloud_info = 13;

  // If this tablet was created by cloning, the sequence number of the operation that created it and
  // the clone source tablet's id. This is used to reject RBS requests if the source tablet is
  // present on the destination and has not applied the clone yet.
  optional uint32 clone_source_seq_no = 14;
  optional string clone_source_tablet_id = 15;
}

message StartRemoteBootstrapResponsePB {
  optional tserver.TabletServerErrorPB error = 1;
}

// An unsafe change configuration request for the tablet with 'tablet_id'.
message UnsafeChangeConfigRequestPB {
  // UUID of server this request is addressed to.
  optional bytes dest_uuid = 1;
  required bytes tablet_id = 2;

  // Sender identification, it could be a static string as well.
  required bytes caller_id = 3;

  // The raft config sent to destination server.
  // Only the 'permanent_uuid' of each peer in the config is
  // required (address-related information is ignored by the server).
  // The peers specified in the 'new_config' are required to be a
  // subset of (or equal to) the peers in the committed config on the
  // destination replica.
  required RaftConfigPB new_config = 4;
}

// The unsafe change configuration response. 'error' field is set if operation failed.
message UnsafeChangeConfigResponsePB {
  optional tserver.TabletServerErrorPB error = 1;
}

message ChangeAutoFlagsConfigOpResponsePB {
  optional tserver.TabletServerErrorPB error = 1;
}

// Retryable requests.
message ReplicatedRetryableRequestRangePB {
  optional int64 first_id = 1;
  optional int64 last_id = 2;
  optional OpIdPB min_op_id = 3;
  optional uint64 min_time = 4;
  optional uint64 max_time = 5;
}

message ClientReplicatedRetryableRequestRangesPB {
  optional fixed64 client_id1 = 1;
  optional fixed64 client_id2 = 2;
  repeated ReplicatedRetryableRequestRangePB range = 3;
}

message TabletBootstrapStatePB {
  optional OpIdPB last_op_id = 1;
  repeated ClientReplicatedRetryableRequestRangesPB client_requests = 2;

  reserved 3;

  optional fixed64 min_replay_txn_start_ht = 4;
}

// A Raft implementation.
service ConsensusService {
  // Analogous to AppendEntries in Raft, but only used for followers.
  rpc UpdateConsensus(ConsensusRequestPB) returns (ConsensusResponsePB) {
    option (yb.rpc.lightweight_method).sides = BOTH;
  };

  // Similar to UpdateConsensus but takes a batch of ConsensusRequestPB
  // and returns a batch of ConsensusResponsePB.
  rpc MultiRaftUpdateConsensus(MultiRaftConsensusRequestPB) returns (MultiRaftConsensusResponsePB);

  // RequestVote() from Raft.
  rpc RequestConsensusVote(VoteRequestPB) returns (VoteResponsePB);

  // Implements all of the one-by-one config change operations, including
  // AddServer() and RemoveServer() from the Raft specification, as well as
  // an operation to change the role of a server between VOTER and PRE_VOTER.
  // An OK response means the operation was successful.
  rpc ChangeConfig(ChangeConfigRequestPB) returns (ChangeConfigResponsePB);

  // Implements unsafe config change operation for manual recovery use cases.
  rpc UnsafeChangeConfig(UnsafeChangeConfigRequestPB) returns (UnsafeChangeConfigResponsePB);

  rpc GetNodeInstance(GetNodeInstanceRequestPB) returns (GetNodeInstanceResponsePB);

  // Force this node to run a leader election.
  rpc RunLeaderElection(RunLeaderElectionRequestPB) returns (RunLeaderElectionResponsePB);

  // Notify originator about lost election, so it could reset its timeout.
  rpc LeaderElectionLost(LeaderElectionLostRequestPB) returns (LeaderElectionLostResponsePB);

  // Force this node to step down as leader.
  rpc LeaderStepDown(LeaderStepDownRequestPB) returns (LeaderStepDownResponsePB);

  // Get the latest committed or received opid on the server.
  rpc GetLastOpId(GetLastOpIdRequestPB) returns (GetLastOpIdResponsePB);

  // Returns the committed Consensus state.
  rpc GetConsensusState(GetConsensusStateRequestPB) returns (GetConsensusStateResponsePB);

  // Instruct this server to remotely bootstrap a tablet from another host.
  rpc StartRemoteBootstrap(StartRemoteBootstrapRequestPB) returns (StartRemoteBootstrapResponsePB);
}
