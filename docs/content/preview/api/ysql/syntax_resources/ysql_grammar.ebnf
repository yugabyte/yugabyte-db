(* 'ABORT' *)
abort = 'ABORT' [ 'TRANSACTION' | 'WORK' ] ;

(* 'ALTER' 'DATABASE' *)
alter_database =
  'ALTER' 'DATABASE' name ( [ [ 'WITH' ]  alter_database_option { alter_database_option } ]
                        | 'RENAME' 'TO' name
                        | 'OWNER' 'TO' ( new_owner | 'CURRENT_USER' | 'SESSION_USER' )
                        | 'SET' run_time_parameter ( 'TO' | '=' ) ( value | 'DEFAULT' )
                        | 'SET' run_time_parameter 'FROM' 'CURRENT'
                        | 'RESET' run_time_parameter
                        | 'RESET' 'ALL' ) ;

alter_database_option =
  ( 'ALLOW_CONNECTIONS' allowconn | 'CONNECTION' 'LIMIT' connlimit | 'IS_TEMPLATE' istemplate ) ;

allowconn = ( 'TRUE' | 'FALSE' );
istemplate = ( 'TRUE' | 'FALSE' );
connlimit = int_literal ;

(* 'ALTER' 'DEFAULT' 'PRIVILEGES' *)
alter_default_priv = 'ALTER' 'DEFAULT' 'PRIVILEGES'
                      [ 'FOR' ( 'ROLE' | 'USER' ) role_name { ',' role_name } ] \
                      [ 'IN' 'SCHEMA' schema_name { ',' schema_name } ]
                      abbr_grant_or_revoke ;

abbr_grant_or_revoke = a_grant_table |
                       a_grant_seq |
                       a_grant_func |
                       a_grant_type |
                       a_grant_schema |
                       a_revoke_table |
                       a_revoke_seq |
                       a_revoke_func |
                       a_revoke_type |
                       a_revoke_schema ;

a_grant_table = 'GRANT' ( grant_table_priv { ',' grant_table_priv } | 'ALL' [ 'PRIVILEGES' ] )
                'ON' 'TABLES'
                'TO' grantee_role { ',' grantee_role } \
                [ 'WITH' 'GRANT' 'OPTION' ] ;

grant_table_priv = 'SELECT' | 'INSERT' | 'UPDATE' | 'DELETE' | 'TRUNCATE' | 'REFERENCES' | 'TRIGGER' ;

a_grant_seq = 'GRANT' ( grant_seq_priv { ',' grant_seq_priv } | 'ALL' [ 'PRIVILEGES' ] )
              'ON' 'SEQUENCES'
              'TO' grantee_role { ',' grantee_role } \
              [ 'WITH' 'GRANT' 'OPTION' ] ;

grant_seq_priv = 'USAGE' | 'SELECT' | 'UPDATE' ;

a_grant_func = 'GRANT' ( 'EXECUTE' | 'ALL' [ 'PRIVILEGES' ] )
               'ON' ( 'FUNCTIONS' | 'ROUTINES' )
               'TO' grantee_role { ',' grantee_role } \
             [ 'WITH' 'GRANT' 'OPTION' ] ;

a_grant_type = 'GRANT' ( 'USAGE' | 'ALL' [ 'PRIVILEGES' ] )
               'ON' 'TYPES'
               'TO' grantee_role { ',' grantee_role } \
               [ 'WITH' 'GRANT' 'OPTION' ] ;

a_grant_schema = 'GRANT' ( 'USAGE' | 'CREATE' | 'ALL' [ 'PRIVILEGES' ] )
                 'ON' 'SCHEMAS'
                 'TO' grantee_role { ',' grantee_role } \
                 [ 'WITH' 'GRANT' 'OPTION' ] ;

a_revoke_table = 'REVOKE' [ 'GRANT' 'OPTION' 'FOR' ]
                 ( grant_table_priv { ',' grant_table_priv } | 'ALL' [ 'PRIVILEGES' ] )
                'ON' 'TABLES' \
                'FROM' grantee_role { ',' grantee_role }
                [ 'CASCADE' | 'RESTRICT' ] ;

a_revoke_seq = 'REVOKE' [ 'GRANT' 'OPTION' 'FOR' ]
               ( grant_seq_priv { ',' grant_seq_priv } | 'ALL' [ 'PRIVILEGES' ] )
               'ON' 'SEQUENCES' \
               'FROM' grantee_role { ',' grantee_role }
               [ 'CASCADE' | 'RESTRICT' ] ;

a_revoke_func = 'REVOKE' [ 'GRANT' 'OPTION' 'FOR' ]
                ( 'EXECUTE' | 'ALL' [ 'PRIVILEGES' ] )
                'ON' ( 'FUNCTIONS' | 'ROUTINES' ) \
                'FROM' grantee_role { ',' grantee_role }
                [ 'CASCADE' | 'RESTRICT' ] ;

a_revoke_type = 'REVOKE' [ 'GRANT' 'OPTION' 'FOR' ]
                ( 'USAGE' | 'ALL' [ 'PRIVILEGES' ] )
                'ON' 'TYPES' \
                'FROM' grantee_role { ',' grantee_role }
                [ 'CASCADE' | 'RESTRICT' ] ;

a_revoke_schema = 'REVOKE' [ 'GRANT' 'OPTION' 'FOR' ]
                  ( 'USAGE' | 'CREATE' | 'ALL' [ 'PRIVILEGES' ] )
                  'ON' 'SCHEMAS' \
                  'FROM' grantee_role { ',' grantee_role }
                  [ 'CASCADE' | 'RESTRICT' ] ;

(* 'ALTER' 'DOMAIN' *)
alter_domain_default = 'ALTER' 'DOMAIN' name
    ( 'SET' 'DEFAULT' expression | 'DROP' 'DEFAULT' ) ;

alter_domain_rename = 'ALTER' 'DOMAIN' name
    'RENAME' 'TO' name ;

(* 'ALTER' 'FUNCTION' *)
alter_function = 'ALTER' 'FUNCTION' subprogram_name '(' [ subprogram_signature ] ')' \
                 ( special_fn_and_proc_attribute |
                 ( ( alterable_fn_and_proc_attribute | alterable_fn_only_attribute ) { ( alterable_fn_and_proc_attribute | alterable_fn_only_attribute ) } ['RESTRICT'] ) ) ;

special_fn_and_proc_attribute = (
    'RENAME' 'TO' subprogram_name
    | ( 'OWNER' 'TO' ( role_name | 'CURRENT_ROLE' | 'CURRENT_USER' | 'SESSION_USER' ) )
    | 'SET' 'SCHEMA' schema_name
    | ['NO'] 'DEPENDS' 'ON' 'EXTENSION' extension_name ) ;

(* 'ALTER' 'FOREIGN' 'DATA' 'WRAPPER' *)
alter_foreign_data_wrapper = 'ALTER' 'FOREIGN' 'DATA' 'WRAPPER' fdw_name \
                             [ 'HANDLER' handler_name | 'NO' 'HANDLER' ] \
                             [ 'VALIDATOR' validator_name | 'NO' 'VALIDATOR' ] \
                             [ 'OPTIONS' '(' alter_fdw_options ')'] \
                             [ 'OWNER' 'TO' new_owner ] \
                             [ 'RENAME' 'TO' new_name ] ;

(* 'ALTER' 'FOREIGN' 'TABLE' *)
alter_foreign_table = 'ALTER' 'FOREIGN' 'TABLE' [ 'IF' 'EXISTS' ] table_name
                      alter_foreign_table_action { ',' alter_foreign_table_action } ;

alter_foreign_table_action =
  ( 'ADD' [ 'COLUMN' ] column_name data_type [ 'COLLATE' collation] [ alter_column_constraint { alter_column_constraint } ]
    | 'RENAME' 'TO' table_name
    | 'DROP' [ 'COLUMN' ] column_name [ 'RESTRICT' | 'CASCADE' ]
    | 'OWNER' 'TO' new_owner
    | 'OPTIONS' '(' alter_fdw_options ')' ) ;


(* 'ALTER' 'GROUP' *)
alter_group = 'ALTER' 'GROUP' role_specification ( 'ADD' | 'DROP' ) 'USER' role_name { ',' role_name } ;

alter_group_rename = 'ALTER' 'GROUP' role_name 'RENAME' 'TO' new_role_name ;

(* 'ALTER' 'POLICY' *)
alter_policy = 'ALTER' 'POLICY' name 'ON' table_name
               [ 'TO' ( role_name | 'PUBLIC' | 'CURRENT_USER' | 'SESSION_USER' )
                 { ',' ( role_name | 'PUBLIC' | 'CURRENT_USER' | 'SESSION_USER' ) } ] \
               [ 'USING' '(' using_expression ')' ]
               [ 'WITH' 'CHECK' '(' check_expression ')' ] ;

alter_policy_rename = 'ALTER' 'POLICY' name 'ON' table_name 'RENAME' 'TO' new_name ;

(* 'ALTER' 'PROCEDURE' *)
alter_procedure = 'ALTER' 'PROCEDURE' subprogram_name '(' [ subprogram_signature ] ')' \
                 ( special_fn_and_proc_attribute |
                   ( alterable_fn_and_proc_attribute { alterable_fn_and_proc_attribute } ['RESTRICT'] ) ) ;

(* 'ALTER' 'ROLE' *)
alter_role = 'ALTER' 'ROLE' role_specification [ [ 'WITH' ] alter_role_option { ',' alter_role_option } ] ;

alter_role_option = 'SUPERUSER'
              | 'NOSUPERUSER'
              | 'CREATEDB'
              | 'NOCREATEDB'
              | 'CREATEROLE'
              | 'NOCREATEROLE'
              | 'INHERIT'
              | 'NOINHERIT'
              | 'LOGIN'
              | 'NOLOGIN'
              | 'CONNECTION' 'LIMIT' connlimit
              | [ 'ENCRYPTED' ] 'PASSWORD' ''' password '''
              | 'PASSWORD' 'NULL'
              | 'VALID' 'UNTIL' ''' timestamp ''' ;

role_specification = role_name
                     | 'CURRENT_USER'
                     | 'SESSION_USER' ;

alter_role_rename = 'ALTER' 'ROLE' role_name 'RENAME' 'TO' new_role_name ;

new_role_name = name ;

alter_role_config = 'ALTER' 'ROLE' ( role_specification | 'ALL' ) [ 'IN' 'DATABASE' database_name ] config_setting ;

config_setting = 'SET' config_param ( 'TO' | '=' ) ( config_value | 'DEFAULT' )
                 | 'SET' config_param 'FROM' 'CURRENT'
                 | 'RESET' config_param
                 | 'RESET' 'ALL' ;

config_param = text_literal ;
config_value = text_literal ;

(* 'ALTER' 'SEQUENCE' *)
alter_sequence = 'ALTER' 'SEQUENCE' [ 'IF' 'EXISTS' ] sequence_name alter_sequence_options ;

alter_sequence_options = [ 'AS' seq_data_type ]  \
                           [ 'INCREMENT' [ 'BY' ] int_literal ]  \
                           [ 'MINVALUE' int_literal | 'NO' 'MINVALUE' ]  \
                           [ 'MAXVALUE' int_literal | 'NO' 'MAXVALUE' ]  \
                           [ 'START' [ 'WITH' ] int_literal ]  \
                           [ 'RESTART' [ [ 'WITH' ] int_literal ] ]  \
                           [ 'CACHE' int_literal ]  \
                           [ [ 'NO' ] 'CYCLE' ]  \
                           [ 'OWNED BY' table_name '.' column_name | 'NONE' ] ;

seq_data_type = ( 'smallint' | 'integer' | 'bigint' ) ;

(* 'ALTER' 'SERVER' *) 
alter_server = 'ALTER' 'SERVER' server_name 
               [ 'VERSION' server_version ] \
               [ 'OPTIONS' '(' alter_fdw_options ')' ]
               [ 'OWNER' 'TO' new_owner ] ;

server_name = name ;
server_version = name ;

(* 'ALTER' 'TABLE' *)
alter_table = 'ALTER' 'TABLE' [ 'IF' 'EXISTS' ] table_expr
                        alter_table_action { ',' alter_table_action } ;

alter_table_action =
  ( 'ADD' [ 'COLUMN' ] [ 'IF' 'NOT' 'EXISTS' ] column_name data_type [ alter_column_constraint { alter_column_constraint } ]
    | 'RENAME' 'TO' table_name
    | 'DROP' [ 'COLUMN' ] [ 'IF' 'EXISTS' ] column_name [ 'RESTRICT' | 'CASCADE' ]
    | 'ALTER' [ 'COLUMN' ] column_name [ 'SET DATA' ]
      'TYPE' data_type [ 'COLLATE' collation ] [ 'USING' expression ]
    | 'ADD' alter_table_constraint
    | 'DROP' 'CONSTRAINT' constraint_name [ 'RESTRICT' | 'CASCADE' ]
    | 'RENAME' [ 'COLUMN' ] column_name 'TO' column_name
    | 'RENAME' 'CONSTRAINT' constraint_name 'TO' constraint_name
    | 'DISABLE' 'ROW' 'LEVEL' 'SECURITY'
    | 'ENABLE' 'ROW' 'LEVEL' 'SECURITY'
    | 'FORCE' 'ROW' 'LEVEL' 'SECURITY'
    | 'SET' 'TABLESPACE' tablespace_name
    | 'NO' 'FORCE' 'ROW' 'LEVEL' 'SECURITY' ) ;

alter_table_constraint = [ 'CONSTRAINT' constraint_name ] \
                         ( 'CHECK' '(' expression ')' |
                           'UNIQUE' '(' column_names ')' index_parameters |
                           'FOREIGN' 'KEY' '(' column_names ')' references_clause ) \
                         [ 'DEFERRABLE' | 'NOT' 'DEFERRABLE' ] [ 'INITIALLY' 'DEFERRED' | 'INITIALLY' 'IMMEDIATE' ] ;

alter_column_constraint = [ 'CONSTRAINT' constraint_name ] \
                          (  'NOT' 'NULL' |
                             'NULL' |
                             'CHECK' '(' expression ')' |
                             'DEFAULT' expression |
                             'UNIQUE' index_parameters |
                             references_clause )
                          [ 'DEFERRABLE' | 'NOT' 'DEFERRABLE' ] [ 'INITIALLY' 'DEFERRED' | 'INITIALLY' 'IMMEDIATE' ] ;

(* 'ALTER' 'INDEX' *)
alter_index = 'ALTER' 'INDEX' [ 'IF' 'EXISTS' ] index_name
                        alter_index_action { ',' alter_index_action } ;

alter_index_action =
  ( 'RENAME' 'TO' new_name
    | 'ALTER' [ 'COLUMN' ] column_number 'SET STATISTICS' integer
    | 'SET' 'TABLESPACE' tablespace_name ) ;


(* 'ALTER' 'MATERIALIZED' 'VIEW' *)
alter_materialized_view = 'ALTER' 'MATERIALIZED' 'VIEW' [ 'IF' 'EXISTS' ] matview_name
                        alter_materialized_view_action { ',' alter_materialized_view_action } ;

alter_materialized_view_action =
  ( 'RENAME' 'TO' new_name
    | 'SET' 'TABLESPACE' tablespace_name ) ;

(* 'ALTER' 'SCHEMA' *)
alter_schema = 'ALTER' 'SCHEMA' schema_name (
                'RENAME' 'TO' new_name |
                'OWNER' 'TO' (new_owner | 'CURRENT_USER' | 'SESSION_USER') ) ;

(* 'ALTER' 'USER' *)
alter_user = 'ALTER' 'USER' role_specification [ [ 'WITH' ] alter_role_option { ',' alter_role_option } ] ;

alter_user_rename = 'ALTER' 'USER' role_name 'RENAME' 'TO' new_role_name ;

alter_user_config = 'ALTER' 'USER' ( role_specification | 'ALL' ) [ 'IN' 'DATABASE' database_name ] config_setting ;

(* 'ANALYZE' *)
analyze = 'ANALYZE' [ 'VERBOSE' ] [ table_and_columns { ',' table_and_columns } ] ;

table_and_columns = table_name [ '(' column_name { ',' column_name } ')' ] ;

(* 'BEGIN' *)
begin = 'BEGIN' [ 'TRANSACTION' | 'WORK' ] { transaction_mode } ;

(* 'CALL' *)

call_procedure = 'CALL' subprogram_name '(' [ actual_arg { ',' actual_arg } ] ')' ;

actual_arg = [ formal_arg '=>' ] expression ;

(* 'COMMENT' *)
comment_on = 'COMMENT' 'ON' (
  'ACCESS' 'METHOD' access_method_name |
  'AGGREGATE' aggregate_name '(' aggregate_signature ')' |
  'CAST' '(' source_type 'AS' target_type ')' |
  'COLLATION' object_name |
  'COLUMN' relation_name '.' column_name |
  'CONSTRAINT' constraint_name 'ON' table_name |
  'CONSTRAINT' constraint_name 'ON' 'DOMAIN' domain_name |
  'CONVERSION' object_name |
  'DATABASE' object_name |
  'DOMAIN' object_name |
  'EXTENSION' object_name |
  'EVENT' 'TRIGGER' object_name |
  'FOREIGN' 'DATA' 'WRAPPER' object_name |
  'FOREIGN' 'TABLE' object_name |
  'FUNCTION' subprogram_name '(' [ subprogram_signature ] ')'|
  'INDEX' object_name |
  'LARGE' 'OBJECT' large_object_oid |
  'MATERIALIZED' 'VIEW' object_name |
  'OPERATOR' operator_name '(' operator_signature ')' |
  'OPERATOR' 'CLASS' object_name 'USING' index_method |
  'OPERATOR' 'FAMILY' object_name 'USING' index_method |
  'POLICY' policy_name 'ON' table_name |
  [ 'PROCEDURAL' ] 'LANGUAGE' object_name |
  'PROCEDURE' subprogram_name '(' [ subprogram_signature ] ')' |
  'PUBLICATION' object_name |
  'ROLE' object_name |
  'ROUTINE' subprogram_name '(' [ subprogram_signature ] ')' |
  'RULE' rule_name 'ON' table_name |
  'SCHEMA' object_name |
  'SEQUENCE' object_name |
  'SERVER' object_name |
  'STATISTICS' object_name |
  'SUBSCRIPTION' object_name |
  'TABLE' object_name |
  'TABLESPACE' object_name |
  'TEXT' 'SEARCH' 'CONFIGURATION' object_name |
  'TEXT' 'SEARCH' 'DICTIONARY' object_name |
  'TEXT' 'SEARCH' 'PARSER' object_name |
  'TEXT' 'SEARCH' 'TEMPLATE' object_name |
  (* 'TRANSFORM' 'FOR' type_name 'LANGUAGE' lang_name | bllewell: n/a except with implementation langauges like C *)
  'TRIGGER' trigger_name 'ON' table_name |
  'TYPE' object_name |
  'VIEW' object_name
) 'IS' ( text_literal | 'NULL' ) ;

(* 'COMMIT' 'TRANSACTION' *)
commit = 'COMMIT' [ 'TRANSACTION' | 'WORK' ] ;

(* 'COPY' *)
copy_from = 'COPY' table_name [ '(' column_name { ',' column_name } ')' ] \
            'FROM' ( 'filename' | 'PROGRAM' 'command' | 'STDIN' ) \
             [ [ 'WITH' ] '(' copy_option { ',' copy_option } ')' ] ;

copy_to = 'COPY' ( table_name [ '(' column_names ')' ] | subquery ) \
          'TO' ( 'filename' | 'PROGRAM' 'command' | 'STDOUT' ) \
          [ [ 'WITH' ] '(' copy_option { ',' copy_option } ')' ] ;

copy_option =
  ( 'FORMAT' format_name
    | 'OIDS' [ boolean ]
    | 'FREEZE' [ boolean ]
    | 'DELIMITER' 'delimiter_character'
    | 'NULL' 'null_string'
    | 'HEADER' [ boolean ]
    | 'QUOTE' 'quote_character'
    | 'ESCAPE' 'escape_character'
    | 'FORCE_QUOTE' ( '(' column_names ')' | '*' )
    | 'FORCE_NOT_NULL' '(' column_names ')'
    | 'FORCE_NULL' '(' column_names ')'
    | 'ENCODING' 'encoding_name'
    | 'ROWS_PER_TRANSACTION' int_literal
    | 'DISABLE_FK_CHECK'
    | 'REPLACE'
    | 'SKIP' int_literal ) ;

format_name = text_literal ;

subquery = [ '(' { ',' '(' } ] ( select | values ) [ ')' { ',' ')' } ] ;

(* 'CREATE' 'AGGREGATE' *)
create_aggregate = create_aggregate_normal
                 | create_aggregate_order_by
                 | create_aggregate_old ;

create_aggregate_normal = 'CREATE' 'AGGREGATE' aggregate_name
                          '(' ( aggregate_arg { ',' aggregate_arg } | '*' ) ')' \
                          '(' 'SFUNC' '=' sfunc ',' 'STYPE' '=' state_data_type
                          { ',' aggregate_normal_option } ')' ;

create_aggregate_order_by = 'CREATE' 'AGGREGATE' aggregate_name
                            '(' [ aggregate_arg { ',' aggregate_arg } ]
                            'ORDER' 'BY' aggregate_arg { ',' aggregate_arg } ')' \
                            '(' 'SFUNC' '=' sfunc ',' 'STYPE' '=' state_data_type
                            { ',' aggregate_order_by_option } ')' ;

create_aggregate_old = 'CREATE' 'AGGREGATE' aggregate_name
                       '(' 'BASETYPE' '=' base_type ',' \
                       'SFUNC' '=' sfunc ','
                       'STYPE' '=' state_data_type
                       { ',' aggregate_old_option } ')' ;

aggregate_arg = [ aggregate_arg_mode ] [ formal_arg ] arg_type ;

aggregate_normal_option = 'SSPACE' '=' state_data_size
                        | 'FINALFUNC' '=' ffunc
                        | 'FINALFUNC_EXTRA'
                        | 'FINALFUNC_MODIFY' '=' ( 'READ_ONLY' | 'SHAREABLE' | 'READ_WRITE' )
                        | 'COMBINEFUNC' '=' combinefunc
                        | 'SERIALFUNC' '=' serialfunc
                        | 'DESERIALFUNC' '=' deserialfunc
                        | 'INITCOND' '=' initial_condition
                        | 'MSFUNC' '=' msfunc
                        | 'MINVFUNC' '=' minvfunc
                        | 'MSTYPE' '=' mstate_data_type
                        | 'MSSPACE' '=' mstate_data_size
                        | 'MFINALFUNC' '=' mffunc
                        | 'MFINALFUNC_EXTRA'
                        | 'MFINALFUNC_MODIFY' '=' ( 'READ_ONLY' | 'SHAREABLE' | 'READ_WRITE' )
                        | 'MINITCOND' '=' minitial_condition
                        | 'SORTOP' '=' sort_operator
                        | 'PARALLEL' '=' ( 'SAFE' | 'RESTRICTED' | 'UNSAFE' ) ;

aggregate_order_by_option = 'SSPACE' '=' state_data_size
                          | 'FINALFUNC' '=' ffunc
                          | 'FINALFUNC_EXTRA'
                          | 'FINALFUNC_MODIFY' '=' ( 'READ_ONLY' | 'SHAREABLE' | 'READ_WRITE' )
                          | 'INITCOND' '=' initial_condition
                          | 'PARALLEL' '=' ( 'SAFE' | 'RESTRICTED' | 'UNSAFE' )
                          | 'HYPOTHETICAL' ;

aggregate_old_option = 'SSPACE' '=' state_data_size
                     | 'FINALFUNC' '=' ffunc
                     | 'FINALFUNC_EXTRA'
                     | 'FINALFUNC_MODIFY' '=' ( 'READ_ONLY' | 'SHAREABLE' | 'READ_WRITE' )
                     | 'COMBINEFUNC' '=' combinefunc
                     | 'SERIALFUNC' '=' serialfunc
                     | 'DESERIALFUNC' '=' deserialfunc
                     | 'INITCOND' '=' initial_condition
                     | 'MSFUNC' '=' msfunc
                     | 'MINVFUNC' '=' minvfunc
                     | 'MSTYPE' '=' mstate_data_type
                     | 'MSSPACE' '=' mstate_data_size
                     | 'MFINALFUNC' '=' mffunc
                     | 'MFINALFUNC_EXTRA'
                     | 'MFINALFUNC_MODIFY' '=' ( 'READ_ONLY' | 'SHAREABLE' | 'READ_WRITE' )
                     | 'MINITCOND' '=' minitial_condition
                     | 'SORTOP' '=' sort_operator ;

(* 'CREATE' 'CAST' *)
create_cast = create_cast_with_function
            | create_cast_without_function
            | create_cast_with_inout ;

create_cast_with_function = 'CREATE' 'CAST' '(' cast_signature ')' 'WITH' 'FUNCTION' \
                            subprogram_name [ '(' subprogram_signature ')' ]
                            [ 'AS' 'ASSIGNMENT' | 'AS' 'IMPLICIT' ] ;

create_cast_without_function = 'CREATE' 'CAST' '(' cast_signature ')'
                               'WITHOUT' 'FUNCTION'
                               [ 'AS' 'ASSIGNMENT' | 'AS' 'IMPLICIT' ] ;

create_cast_with_inout = 'CREATE' 'CAST' '(' cast_signature ')'
                         'WITH' 'INOUT'
                         [ 'AS' 'ASSIGNMENT' | 'AS' 'IMPLICIT' ] ;

cast_signature = source_type 'AS' target_type ;

(* 'CREATE' 'DATABASE' *)
create_database = 'CREATE' 'DATABASE' name [ create_database_options ] ;

create_database_options =  [ 'WITH' ] [ 'OWNER' [ '=' ] user_name ]  \
                             [ 'TEMPLATE' [ '=' ] template_name ]  \
                             [ 'ENCODING' [ '=' ] encoding ]  \
                             [ 'LC_COLLATE' [ '=' ] lc_collate ]  \
                             [ 'LC_CTYPE' [ '=' ] lc_ctype ]  \
                             [ 'ALLOW_CONNECTIONS' [ '=' ] allowconn ]  \
                             [ 'CONNECTION' 'LIMIT' [ '=' ] connlimit ]  \
                             [ 'IS_TEMPLATE' [ '=' ] istemplate ] \
                             [ 'COLOCATION' [ '=' ] ('true' | 'false') ] ;

user_name = name ;
template_name = name ;
encoding = text_literal ;
lc_collate = text_literal ;
lc_ctype = text_literal ;

create_domain = 'CREATE' 'DOMAIN' name [ 'AS' ] data_type
    [ 'DEFAULT' expression ]
    [ { domain_constraint } ] ;

domain_constraint = [ 'CONSTRAINT' constraint_name ]
    ( 'NOT' 'NULL' | 'NULL' | 'CHECK' '(' expression ')' ) ;

(* 'CREATE' 'EXTENSION' *)
create_extension = 'CREATE' 'EXTENSION' [ 'IF' 'NOT' 'EXISTS' ] extension_name \
                   [ 'WITH' ] [ 'SCHEMA' schema_name ]
                   [ 'VERSION' version ]
                   [ 'CASCADE' ] ;

(* 'CREATE' 'FUNCTION' *)
create_function =  'CREATE' [ 'OR' 'REPLACE' ] 'FUNCTION'
                   subprogram_name '(' [ arg_decl_with_dflt { ',' arg_decl_with_dflt } ] ')' \
                   ( 'RETURNS' data_type
                   | 'RETURNS' 'TABLE' '(' ( column_name data_type ) { ',' ( column_name data_type ) } ')' ) \
                   ( unalterable_fn_attribute | alterable_fn_only_attribute | alterable_fn_and_proc_attribute )
                   { ( unalterable_fn_attribute | alterable_fn_only_attribute | alterable_fn_and_proc_attribute ) } ;

arg_decl_with_dflt = arg_decl [ ( 'DEFAULT' | '=' ) expression ] ;

arg_decl = [ formal_arg ] [ arg_mode ] arg_type ;

subprogram_signature = arg_decl { ',' arg_decl } ;

fn_invocation = subprogram_name '(' [ actual_arg { ',' actual_arg } ] ')' ;

subprogram_call_signature = arg_type { ',' arg_type } ;

(* | ( 'TRANSFORM' ( 'FOR' 'TYPE' type_name ) { ',' ( 'FOR' 'TYPE' type_name ) } bllewell: n/a except with implementation langauges like C *)
unalterable_fn_attribute = 'WINDOW' | 'LANGUAGE' lang_name | 'AS' subprogram_implementation ;

lang_name = 'SQL' | 'PLPGSQL' | 'C' ;

subprogram_implementation = "'" sql_stmt_list "'" |"'" plpgsql_block_stmt "'" | ( "'" obj_file"'" [ ',' "'" link_symbol "'" ] ) ;

obj_file = text_literal ;
link_symbol = text_literal ;

sql_stmt_list = sql_stmt ';' { sql_stmt ';' } ;

alterable_fn_and_proc_attribute =  ( 
                      'SET' run_time_parameter ( 'TO' value | '=' value | 'FROM' 'CURRENT' )
                      | 'RESET' run_time_parameter
                      | 'RESET' 'ALL'
                      | [ 'EXTERNAL' ] 'SECURITY' ( 'INVOKER' | 'DEFINER' )
                      ) ;

alterable_fn_only_attribute =  ( volatility
                      | on_null_input
                      | 'PARALLEL' parallel_mode
                      | [ 'NOT' ] 'LEAKPROOF'
                      | 'COST' int_literal
                      | 'ROWS' int_literal
                      ) ;

volatility = ( 'IMMUTABLE' | 'STABLE' | 'VOLATILE' ) ;

on_null_input = ('CALLED' 'ON' 'NULL' 'INPUT' | 'RETURNS' 'NULL' 'ON' 'NULL' 'INPUT' | 'STRICT' ) ;

parallel_mode = ( 'UNSAFE' | 'RESTRICTED' | 'SAFE' );

(* 'CREATE' 'FOREIGN' 'DATA' 'WRAPPER' *)
create_foreign_data_wrapper = 'CREATE' 'FOREIGN' 'DATA' 'WRAPPER' fdw_name \
                              [ 'HANDLER' handler_name | 'NO' 'HANDLER' ]
                              [ 'VALIDATOR' validator_name | 'NO' 'VALIDATOR' ]
                              [ 'OPTIONS' '(' fdw_options ')' ] ;

(* 'CREATE' 'FOREIGN' 'TABLE' *)
create_foreign_table = 'CREATE' 'FOREIGN' 'TABLE' ['IF' 'NOT' 'EXISTS'] table_name
                       '(' [ foreign_table_elem { ',' foreign_table_elem } ] ')' \
                       'SERVER' server_name
                       [ 'OPTIONS' '(' fdw_options ')' ] ;

foreign_table_elem = ( column_name data_type 
              [ 'OPTIONS' '(' fdw_options ')' ]
              [ 'COLLATE' collation ]
              [ column_constraint { column_constraint } ] ) | table_constraint ;

(* 'CREATE' 'GROUP' *)
create_group = 'CREATE' 'GROUP' role_name [ [ 'WITH' ] role_option { ',' role_option } ] ;

(* 'CREATE' 'INDEX' *)
create_index = 'CREATE' [ 'UNIQUE' ] 'INDEX' [ 'CONCURRENTLY' | 'NONCONCURRENTLY' ] \
               [ [ 'IF' 'NOT' 'EXISTS' ] name ] 'ON' [ 'ONLY' ] table_name \
               [ 'USING' access_method_name ]
               '(' index_elem { ',' index_elem } ')' \
               [ 'INCLUDE' '(' column_name { ',' column_name } ')' ] \
               [ 'TABLESPACE' tablespace_name ] \
               [ 'SPLIT' ( 'INTO' int_literal 'TABLETS'
                      | 'AT' 'VALUES' '(' split_row { ',' split_row } ')' ) ]
               [ 'WHERE' boolean_expression ] ;

tablespace_name = name ;

index_elem = ( column_name | '(' expression ')' ) [ operator_class_name ]
             [ 'HASH' | 'ASC' | 'DESC' ] [ 'NULLS' ( 'FIRST' | 'LAST' ) ] ;

(* 'CREATE' 'MATERIALIZED 'VIEW' *)
create_matview = 'CREATE' 'MATERIALIZED' 'VIEW' [ 'IF' 'NOT' 'EXISTS' ] \
                           matview_name [ '(' column_name { ',' column_name } ')' ] \
                           [ 'WITH' '(' storage_parameters ')' ] \
                           [ 'TABLESPACE' tablespace_name ] \
                           'AS' subquery [ 'WITH' [ 'NO' ] 'DATA' ] ;

(* 'CREATE' 'OPERATOR' *)
create_operator = 'CREATE' 'OPERATOR' operator_name \
                  '(' ( 'FUNCTION' '=' subprogram_name | 'PROCEDURE' '=' subprogram_name )
                  { ',' operator_option } ')' ;

operator_option = 'LEFTARG' '=' left_type
                | 'RIGHTARG' '=' right_type
                | 'COMMUTATOR' '=' com_op
                | 'NEGATOR' '=' neg_op
                | 'RESTRICT' '=' res_proc
                | 'JOIN' '=' join_proc
                | 'HASHES'
                | 'MERGES' ;

(* 'CREATE' 'OPERATOR' 'CLASS' *)
create_operator_class = 'CREATE' 'OPERATOR' 'CLASS' operator_class_name [ 'DEFAULT' ]
                        'FOR' 'TYPE' data_type \
                        'USING' index_method 'AS' operator_class_as { ',' operator_class_as } ;

operator_class_as = 'OPERATOR' strategy_number operator_name [ '(' operator_signature ')' ]
                    [ 'FOR' 'SEARCH' ]
                  | 'FUNCTION' support_number [ '(' op_type { ',' op_type } ')' ]
                    subprogram_name '(' subprogram_signature ')'
                  | 'STORAGE' storage_type ;

(* 'CREATE' 'POLICY' *)
create_policy = 'CREATE' 'POLICY' name 'ON' table_name
                [ 'AS' ( 'PERMISSIVE' | 'RESTRICTIVE' ) ] \
                [ 'FOR' ( 'ALL' | 'SELECT' | 'INSERT' | 'UPDATE' | 'DELETE' ) ]
                [ 'TO' ( role_name | 'PUBLIC' | 'CURRENT_USER' | 'SESSION_USER' )
                  { ',' ( role_name | 'PUBLIC' | 'CURRENT_USER' | 'SESSION_USER' ) } ] \
                [ 'USING' '(' using_expression ')' ]
                [ 'WITH' 'CHECK' '(' check_expression ')' ] ;

(* 'CREATE' 'PROCEDURE' *)
create_procedure =  'CREATE' [ 'OR' 'REPLACE' ] 'PROCEDURE'
                    subprogram_name '(' [ arg_decl_with_dflt { ',' arg_decl_with_dflt } ] ')' \
                    ( unalterable_proc_attribute | alterable_fn_and_proc_attribute )
                    { ( unalterable_proc_attribute |  alterable_fn_and_proc_attribute ) } ;

(* ( 'TRANSFORM' ( 'FOR' 'TYPE' type_name ) { ',' ( 'FOR' 'TYPE' type_name ) } bllewell: n/a except with implementation langauges like C *)
unalterable_proc_attribute = 'LANGUAGE' lang_name | 'AS' subprogram_implementation ;

(* 'CREATE' 'RULE' *)
create_rule = 'CREATE' [ 'OR' 'REPLACE' ] 'RULE' rule_name 'AS' 'ON' rule_event 'TO' table_name \
              [ 'WHERE' boolean_expression ]
              'DO' [ 'ALSO' | 'INSTEAD' ]
              ( 'NOTHING'
              | command
              | '(' command { ';' command } ')' ) ;

rule_event = 'SELECT' | 'INSERT' | 'UPDATE' | 'DELETE' ;

command = 'SELECT' | 'INSERT' | 'UPDATE' | 'DELETE' | 'NOTIFY' ;

(* 'CREATE' 'ROLE' *)
create_role = 'CREATE' 'ROLE' role_name [ [ 'WITH' ] role_option { ',' role_option } ] ;

role_option = 'SUPERUSER'
              | 'NOSUPERUSER'
              | 'CREATEDB'
              | 'NOCREATEDB'
              | 'CREATEROLE'
              | 'NOCREATEROLE'
              | 'INHERIT'
              | 'NOINHERIT'
              | 'LOGIN'
              | 'NOLOGIN'
              | 'CONNECTION' 'LIMIT' connlimit
              | [ 'ENCRYPTED' ] 'PASSWORD' ''' password '''
              | 'PASSWORD' 'NULL'
              | 'VALID' 'UNTIL' ''' timestamp '''
              | 'IN' 'ROLE' role_name { ',' role_name }
              | 'IN' 'GROUP' role_name { ',' role_name }
              | 'ROLE' role_name { ',' role_name }
              | 'ADMIN' role_name { ',' role_name }
              | 'USER' role_name { ',' role_name }
              | 'SYSID' uid ;

password = text_literal ;
timestamp = '<DateTime Literal>' ;
uid = text_literal ;

(* 'CREATE' 'SCHEMA' *)
create_schema_name = 'CREATE' 'SCHEMA' [ 'IF' 'NOT' 'EXISTS' ] schema_name
                       [ 'AUTHORIZATION' role_specification ] ;

create_schema_role = 'CREATE' 'SCHEMA' [ 'IF' 'NOT' 'EXISTS']
                       'AUTHORIZATION' role_specification ;

(* 'CREATE' 'SEQUENCE' *)
create_sequence = 'CREATE' [ 'TEMPORARY' | 'TEMP' ] 'SEQUENCE' [ 'IF' 'NOT' 'EXISTS' ] sequence_name  sequence_options ;

sequence_name = qualified_name ;

sequence_options = [ 'INCREMENT' [ 'BY' ] int_literal ] \
                     [ 'MINVALUE' int_literal | 'NO' 'MINVALUE' ]
                     [ 'MAXVALUE' int_literal | 'NO' 'MAXVALUE' ]
                     [ 'START' [ 'WITH' ] int_literal ] \
                     [ 'CACHE' positive_int_literal ]
                     [ [ 'NO' ] 'CYCLE' ] ;

(* 'CREATE' 'SERVER' *)
create_server = 'CREATE' 'SERVER' [ 'IF' 'NOT' 'EXISTS' ] server_name \
                [ 'TYPE' server_type ] [ 'VERSION' server_version ] \
                'FOREIGN' 'DATA' 'WRAPPER' fdw_name
                [ 'OPTIONS' '(' fdw_options ')' ] ;

server_type = text_literal ;


(* 'CREATE' 'TABLESPACE' *)
create_tablespace = 'CREATE' 'TABLESPACE' tablespace_name
                 [ 'WITH' '(' ( 'tablespace_option' '=' value { ',' 'tablespace_option' '=' value }) ')'];

(* 'DROP' 'TABLESPACE' *)
drop_tablespace = 'DROP' 'TABLESPACE' [ 'IF' 'EXISTS' ] tablespace_name;



(* 'CREATE' 'TABLE' *)
create_table = 'CREATE' [ 'TEMPORARY' | 'TEMP' ] 'TABLE' [ 'IF' 'NOT' 'EXISTS' ] table_name
                 '(' [ table_elem { ',' table_elem } ] ')'  \
                 [ 'WITH' '(' ( 'COLOCATION' '=' ('true' | 'false') | storage_parameters ) ')'
                      | 'WITHOUT' 'OIDS' ] \
                 [ 'TABLESPACE' tablespace_name ]
                 [ 'SPLIT' ( 'INTO' positive_int_literal 'TABLETS'
                      | 'AT' 'VALUES' '(' split_row { ',' split_row } ')' ) ] ;

split_row = '(' column_value { ',' column_value } ')';

table_elem = ( column_name data_type [ column_constraint { column_constraint } ] ) | table_constraint ;

column_constraint = [ 'CONSTRAINT' constraint_name ]
                      (  'NOT' 'NULL'
                         | 'NULL'
                         | 'CHECK' '(' expression ')'
                         | 'DEFAULT' expression
                         | 'GENERATED' ('ALWAYS' | 'BY DEFAULT') 'AS' 'IDENTITY' [ ( sequence_options ) ]
                         | 'UNIQUE' index_parameters
                         | 'PRIMARY' 'KEY'
                         | references_clause ) \
                      [ 'DEFERRABLE' | 'NOT' 'DEFERRABLE' ] [ 'INITIALLY' 'DEFERRED' | 'INITIALLY' 'IMMEDIATE' ] ;

table_constraint = [ 'CONSTRAINT' constraint_name ]
                     ( 'CHECK' '(' expression ')'
                       | 'UNIQUE' '(' column_names ')' index_parameters
                       | 'PRIMARY' 'KEY' '(' key_columns ')'
                       | 'FOREIGN' 'KEY' '(' column_names ')' references_clause )  \
                     [ 'DEFERRABLE' | 'NOT' 'DEFERRABLE' ] [ 'INITIALLY' 'DEFERRED' | 'INITIALLY' 'IMMEDIATE' ] ;

key_columns = hash_columns [ ',' range_columns ]
              | range_columns ;

hash_columns = column_name [ 'HASH' ]
                | '(' column_name { ',' column_name } ')' 'HASH' ;

range_columns = ( column_name ( 'ASC' | 'DESC' ) ) { ','  ( column_name ( 'ASC' | 'DESC' ) ) } ;

references_clause = 'REFERENCES' table_name [ ( column_name { ',' column_name } ) ]
                      [ 'MATCH' 'FULL' | 'MATCH' 'PARTIAL' | 'MATCH' 'SIMPLE' ] \
                      [ 'ON' 'DELETE' key_action ] [ 'ON' 'UPDATE' key_action ] ;

key_action = 'NO' 'ACTION' | 'RESTRICT' | 'CASCADE' | 'SET' 'NULL' | 'SET' 'DEFAULT' ;

storage_parameters = storage_parameter { ',' storage_parameter } ;

storage_parameter = param_name [ '=' param_value] ;

index_parameters = [ 'INCLUDE' '(' column_names ')' ]
                     [ 'WITH' '(' storage_parameters ')' ] \
                     [ 'USING' 'INDEX' 'TABLESPACE' tablespace_name ] ;

(* 'CREATE' 'TABLE' 'AS' *)
create_table_as = 'CREATE' [ 'TEMPORARY' | 'TEMP' ] 'TABLE' [ 'IF' 'NOT' 'EXISTS' ] \
                           table_name [ '(' column_name { ',' column_name } ')' ] \
                           'AS' subquery [ 'WITH' [ 'NO' ] 'DATA' ] ;


(* CREATE TRIGGER *)
create_trigger = 'CREATE' 'TRIGGER' name
                  ( 'BEFORE' | 'AFTER' | 'INSTEAD' 'OF' ) ( event { 'OR' event } )
                      'ON' table_name
                      [ 'FROM' table_name ] \
                      [ 'NOT' 'DEFERRABLE' ]
                      [ 'FOR' [ 'EACH' ] ( 'ROW' | 'STATEMENT' ) ]
                      [ 'WHEN' '(' boolean_expression ')' ] \
                      'EXECUTE' ( 'FUNCTION' | 'PROCEDURE' ) subprogram_name '(' [ subprogram_signature ] ')' ;

event = ( 'INSERT' | 'UPDATE' [ 'OF' column_name { ',' column_name } ] | 'DELETE' | 'TRUNCATE' ) ;

(* 'CREATE' 'TYPE' *)
create_type = ( create_composite_type |
                create_enum_type  |
                create_range_type |
                create_shell_type |
                create_base_type );

create_composite_type = 'CREATE' 'TYPE' type_name 'AS'
                          '(' [ composite_type_elem { ',' composite_type_elem } ] ')' ;

create_enum_type = 'CREATE' 'TYPE' type_name 'AS' 'ENUM'
                     '(' [ name { ',' name } ] ')' ;

create_range_type = 'CREATE' 'TYPE' type_name 'AS' 'RANGE' \
                      '(' 'SUBTYPE' '=' subtype { ',' range_type_option } ')' ;

create_shell_type = 'CREATE' 'TYPE' type_name ;

create_base_type = 'CREATE' 'TYPE' type_name '(' \
                   'INPUT' '=' input_function ',' \
                   'OUTPUT' '=' output_function { ',' base_type_option } \
                   ')' ;

composite_type_elem = attribute_name data_type [ 'COLLATE' collation ] ;

range_type_option = 'SUBTYPE_OPCLASS' '=' subtype_operator_class
                      | 'COLLATION' '=' collation
                      | 'CANONICAL' '=' canonical_function
                      | 'SUBTYPE_DIFF' '=' subtype_diff_function ;

base_type_option = 'RECEIVE' '=' receive_function
                     | 'SEND' '=' send_function
                     | 'TYPMOD_IN' '=' type_modifier_input_function
                     | 'TYPMOD_OUT' '=' type_modifier_output_function
                     | 'INTERNALLENGTH' '=' ( internallength | 'VARIABLE' )
                     | 'PASSEDBYVALUE'
                     | 'ALIGNMENT' '=' alignment
                     | 'STORAGE' '=' storage
                     | 'LIKE' '=' like_type
                     | 'CATEGORY' '=' category
                     | 'PREFERRED' '=' ( 'TRUE' | 'FALSE' )
                     | 'DEFAULT' '=' default_type_value
                     | 'ELEMENT' '=' element
                     | 'DELIMITER' '=' delimiter
                     | 'COLLATABLE' '=' ( 'TRUE' | 'FALSE' ) ;

(* 'CREATE' 'USER' *)
create_user = 'CREATE' 'USER' role_name [ [ 'WITH' ] role_option { ',' role_option } ] ;

(* 'CREATE' 'USER' 'MAPPING' *)
create_user_mapping = 'CREATE' 'USER' 'MAPPING' [ 'IF' 'NOT' 'EXISTS' ] \
                      'FOR' user 'SERVER' server_name \
                      [ 'OPTIONS' '(' fdw_options ')' ] ;

user = ( user_name
       | 'USER'
       | 'CURRENT_USER'
       | 'PUBLIC' ) ;

(* 'CREATE' 'VIEW' *)
create_view = 'CREATE' [ 'OR' 'REPLACE' ] [ 'TEMPORARY' | 'TEMP' ] 'VIEW' qualified_name \
              [ '(' column_name { ',' column_name } ')' ] 'AS' select ;


(* 'DEALLOCATE' *)
deallocate = 'DEALLOCATE' [ 'PREPARE' ] ( name | 'ALL' ) ;

(* 'DECLARE' *)
declare = 'DECLARE' cursor_name [ 'BINARY' ] [ 'INSENSITIVE' ] [ [ 'NO' ] 'SCROLL' ] \
          'CURSOR' [ ( 'WITH' | 'WITHOUT' ) 'HOLD' ] 'FOR' subquery ;

cursor_name = name ;

(* 'MOVE' *)
move = 'MOVE' [ move_to_one_row | move_over_many_rows ] [ 'FROM' | 'IN' ] name ;

move_to_one_row     =  ( 'FIRST' | 'LAST' | 'ABSOLUTE' int_literal |
                         'NEXT' | 'FORWARD' | 'PRIOR' | 'BACKWARD' | 'RELATIVE' int_literal ) ;

move_over_many_rows =  ( 'ALL' | 'FORWARD' 'ALL' | 'FORWARD' int_literal | int_literal |
                         'BACKWARD' 'ALL' | 'BACKWARD' int_literal ) ;

(* 'FETCH' *)
fetch = 'FETCH' [ fetch_one_row | fetch_many_rows ] [ 'FROM' | 'IN' ] name ;

fetch_one_row   =  ( 'FIRST' | 'LAST' | 'ABSOLUTE' int_literal |
                     'NEXT' | 'FORWARD' | 'PRIOR' | 'BACKWARD' | 'RELATIVE' int_literal ) ;

fetch_many_rows =  ( 'ALL' | 'FORWARD' 'ALL' | 'FORWARD' int_literal | int_literal |
                     'BACKWARD' 'ALL' | 'BACKWARD' int_literal ) ;

(* 'CLOSE' *)
close = 'CLOSE' ( name | 'ALL' ) ;

(* 'DELETE' *)
delete = [ with_clause ] \
         'DELETE' 'FROM' table_expr [ [ 'AS' ] alias ] \
         [ 'WHERE' boolean_expression | 'WHERE' 'CURRENT' 'OF' cursor_name ] \
         [ returning_clause ] ;

alias = name ;

returning_clause = 'RETURNING' ( '*' | ( output_expression [ [ 'AS' ] output_name ] )
                                         { ',' ( output_expression [ [ 'AS' ] output_name ] ) } ) ;

returning_expression = output_expression [ [ 'AS' ] output_name ] ;

output_expression = expression ;
output_name = name ;

(* 'DO' *)
do = 'DO' "'" plpgsql_block_stmt "'";

(* 'DROP' 'AGGREGATE' *)
drop_aggregate = 'DROP' 'AGGREGATE' [ 'IF' 'EXISTS' ] ( aggregate_name '(' aggregate_signature ')' )
                 { ',' ( aggregate_name '(' aggregate_signature ')' ) }
                 [ 'CASCADE' | 'RESTRICT' ] ;

aggregate_signature = '*'
                    | aggregate_arg { ',' aggregate_arg }
                    | [ aggregate_arg { ',' aggregate_arg } ]
                      'ORDER' 'BY' aggregate_arg { ',' aggregate_arg } ;

(* 'DROP' 'CAST' *)
drop_cast = 'DROP' 'CAST' [ 'IF' 'EXISTS' ] '(' cast_signature ')' [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'DATABASE' *)
drop_database = 'DROP' 'DATABASE' [ 'IF' 'EXISTS' ] database_name ;

(* 'DROP' 'SCHEMA' *)
drop_schema = 'DROP' 'SCHEMA' [ 'IF' 'EXISTS' ] schema_name { ',' schema_name } [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'DOMAIN' *)
drop_domain = 'DROP' 'DOMAIN' [ 'IF' 'EXISTS' ] name { ',' name }  [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'EXTENSION' *)
drop_extension = 'DROP' 'EXTENSION' [ 'IF' 'EXISTS' ]
                 extension_name { ',' extension_name }
                 [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'FOREIGN' 'DATA' 'WRAPPER' *)
drop_foreign_data_wrapper = 'DROP' 'FOREIGN' 'DATA' 'WRAPPER' [ 'IF' 'EXISTS' ] fdw_name
                            [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'FOREIGN' 'TABLE' *)
drop_foreign_table = 'DROP' 'FOREIGN' 'TABLE' [ 'IF' 'EXISTS' ] table_name
                     [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'FUNCTION' *)
drop_function = 'DROP' 'FUNCTION' [ 'IF' 'EXISTS' ] \
                        ( subprogram_name '(' [ subprogram_signature ] ')' )
                  { ',' ( subprogram_name '(' [ subprogram_signature ] ')' ) }
                  [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'GROUP' *)
drop_group = 'DROP' 'GROUP' [ 'IF' 'EXISTS' ] role_name { ',' role_name } ;

(* 'DROP' 'MATERIALIZED' 'VIEW' *)
drop_matview = 'DROP' 'MATERIALIZED' 'VIEW' [ 'IF' 'EXISTS' ] matview_name \
               [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'OPERATOR' *)
drop_operator = 'DROP' 'OPERATOR' [ 'IF' 'EXISTS' ] ( operator_name '(' operator_signature ')' )
                { ',' ( operator_name '(' operator_signature ')' ) }
                [ 'CASCADE' | 'RESTRICT' ] ;

operator_signature = ( left_type | 'NONE' ) ',' ( right_type | 'NONE' ) ;

(* 'DROP' 'OPERATOR' 'CLASS' *)
drop_operator_class = 'DROP' 'OPERATOR' 'CLASS' [ 'IF' 'EXISTS' ] operator_class_name
                      'USING' index_method [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'POLICY' *)
drop_policy = 'DROP' 'POLICY' [ 'IF' 'EXISTS' ] name 'ON' table_name [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'PROCEDURE' *)
drop_procedure = 'DROP' 'PROCEDURE' [ 'IF' 'EXISTS' ] \
                        ( subprogram_name '(' [ subprogram_signature ] ')' )
                  { ',' ( subprogram_name '(' [ subprogram_signature ] ')' ) }
                  [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'ROLE' *)
drop_role = 'DROP' 'ROLE' [ 'IF' 'EXISTS' ] role_name { ',' role_name } ;

(* 'DROP' 'RULE' *)
drop_rule = 'DROP' 'RULE' [ 'IF' 'EXISTS' ] rule_name 'ON' table_name [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'SEQUENCE' *)
drop_sequence = 'DROP' 'SEQUENCE' [ 'IF' 'EXISTS' ] sequence_name [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'OWNED' *)
drop_owned = 'DROP' 'OWNED' 'BY' role_specification { ',' role_specification }
            [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'SERVER' *)
drop_server = 'DROP' 'SERVER' [ 'IF' 'EXISTS' ] server_name [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'TABLE' *)
drop_table = 'DROP' 'TABLE' [ 'IF' 'EXISTS' ] table_name { ',' table_name}
                  [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'INDEX' *)
drop_index = 'DROP' 'INDEX' [ 'IF' 'EXISTS' ] index_name [ 'CASCADE' | 'RESTRICT' ] ;

index_name = name ;

(* 'DROP' 'TYPE' *)
drop_type = 'DROP' 'TYPE' [ 'IF' 'EXISTS' ] type_name { ',' type_name }
              [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'USER' *)
drop_user = 'DROP' 'USER' [ 'IF' 'EXISTS' ] role_name { ',' role_name } ;

(* 'DROP' 'TRIGGER' *)
drop_trigger = 'DROP' 'TRIGGER' [ 'IF' 'EXISTS' ] name 'ON' table_name [ 'CASCADE' | 'RESTRICT' ] ;

(* 'END' 'TRANSACTION' *)
end = 'END' [ 'TRANSACTION' | 'WORK' ] ;

(* 'EXECUTE' *)
execute_statement = 'EXECUTE' name [ '(' expression { ',' expression } ')' ] ;

(* 'EXPLAIN' *)
explain = 'EXPLAIN' [ ( [ 'ANALYZE' ] [ 'VERBOSE' ] ) | '(' option { ',' option } ')' ] sql_stmt ;

option = 'ANALYZE' [ boolean ]
           | 'BUFFERS' [ boolean ]
           | 'COSTS' [ boolean ]
           | 'DEBUG' [boolean]
           | 'DIST' [boolean]
           | 'FORMAT' ( 'TEXT' | 'XML' | 'JSON' | 'YAML' ) ;
           | 'SUMMARY' [ boolean ]
           | 'TIMING' [ boolean ]
           | 'VERBOSE' [ boolean ]

(* 'GRANT' *)
grant = ( grant_table |
         grant_table_col |
         grant_seq |
         grant_db |
         grant_domain |
         grant_schema |
         grant_type |
         grant_role ) ;


grant_table = 'GRANT'
              ( ( 'SELECT' | 'INSERT' | 'UPDATE' | 'DELETE' | 'TRUNCATE' | 'REFERENCES' | 'TRIGGER' ) { ',' ( 'SELECT' | 'INSERT' | 'UPDATE' | 'DELETE' | 'TRUNCATE' | 'REFERENCES' | 'TRIGGER' ) } |
              'ALL' [ 'PRIVILEGES' ] ) \
              'ON' ( [ 'TABLE' ] table_name { ',' table_name } | 'ALL' 'TABLES' 'IN' 'SCHEMA' schema_name { ',' schema_name } ) \
              'TO' grantee_role { ',' grantee_role } [ 'WITH' 'GRANT' 'OPTION' ] ;

grant_table_col = 'GRANT' ( ( 'SELECT' | 'INSERT' | 'UPDATE' | 'REFERENCES' ) '(' column_names ')' | 'ALL' [ 'PRIVILEGES' ] '(' column_names ')' ) \
                  'ON' ( [ 'TABLE' ] table_name { ',' table_name } ) \
                  'TO' grantee_role { ',' grantee_role } \
                  [ 'WITH' 'GRANT' 'OPTION' ] ;

grant_seq = 'GRANT' ( ( 'USAGE' | 'SELECT' | 'UPDATE' ) { ',' ( 'USAGE' | 'SELECT' | 'UPDATE' ) }  | 'ALL' [ 'PRIVILEGES' ] ) \
            'ON' ( 'SEQUENCE' sequence_name { ',' sequence_name } | 'ALL' 'SEQUENCES' 'IN' 'SCHEMA' schema_name { ',' schema_name } ) \
            'TO' grantee_role { ',' grantee_role } \
            [ 'WITH' 'GRANT' 'OPTION' ] ;

grant_db = 'GRANT' ( ( 'CREATE' | 'CONNECT' | 'TEMPORARY' | 'TEMP' ) { ',' ( 'CREATE' | 'CONNECT' | 'TEMPORARY' | 'TEMP' ) }  | 'ALL' [ 'PRIVILEGES' ] ) \
           'ON' 'DATABASE' database_name { ',' database_name } \
           'TO' grantee_role { ',' grantee_role } [ 'WITH' 'GRANT' 'OPTION' ] ;

grant_domain = 'GRANT' ( 'USAGE' | 'ALL' [ 'PRIVILEGES' ] ) \
               'ON' 'DOMAIN' domain_name { ',' domain_name } \
               'TO' grantee_role { ',' grantee_role } \
               [ 'WITH' 'GRANT' 'OPTION' ] ;

grant_schema = 'GRANT' ( ( 'CREATE' | 'USAGE' ) { ',' ( 'CREATE' | 'USAGE' ) } | 'ALL' [ 'PRIVILEGES' ] ) \
                'ON' 'SCHEMA' schema_name { ',' schema_name } \
                'TO' grantee_role { ',' grantee_role } \
                [ 'WITH' 'GRANT' 'OPTION' ] ;

grant_type = 'GRANT' ( 'USAGE' | 'ALL' [ 'PRIVILEGES' ] ) \
             'ON' 'TYPE' type_name { ',' type_name } \
             'TO' grantee_role { ',' grantee_role } \
             [ 'WITH' 'GRANT' 'OPTION' ] ;

grant_role = 'GRANT' role_name { ',' role_name } 'TO' role_name { ',' grantee_role } \
             [ 'WITH' 'ADMIN' 'OPTION' ] ;

grantee_role = [ 'GROUP' ] role_name
  | 'PUBLIC'
  | 'CURRENT_USER'
  | 'SESSION_USER' ;

(* 'IMPORT' 'FOREIGN' 'SCHEMA' *)
import_foreign_schema = 'IMPORT' 'FOREIGN' 'SCHEMA' remote_schema \
                        [ ( 'LIMIT' 'TO' | 'EXCEPT' ) '(' table_name {, table_name} ')' ] \
                        'FROM' 'SERVER' server_name 'INTO' local_schema \
                        [ 'OPTIONS' '(' fdw_options ')' ] ;
                        
remote_schema = text_literal ;

local_schema = text_literal ;

(* 'INSERT' *)

insert = [ with_clause ] \
         'INSERT' 'INTO' table_name [ 'AS' alias ] [ '(' column_names ')' ] \
         [ 'OVERRIDING' { 'SYSTEM' | 'USER' } 'VALUE' ]
         ( ( 'DEFAULT' 'VALUES' ) |
             'VALUES' '(' column_values ')' { ',' '(' column_values ')' } |
             subquery ) \
         [ 'ON' 'CONFLICT' [ conflict_target ] conflict_action ] \
         [ returning_clause ] ;

column_values = ( expression | 'DEFAULT' ) { ',' ( expression | 'DEFAULT' ) } ;


conflict_target = '(' ( column_name | expression ) { ',' ( column_name | expression ) } ')'  [ 'WHERE' boolean_expression ] | 'ON' 'CONSTRAINT' constraint_name ;

conflict_action = 'DO' 'NOTHING' | 'DO' 'UPDATE' 'SET' update_item { ',' update_item } [ 'WHERE' boolean_expression ] ;


(* 'LOCK' *)
lock_table = 'LOCK' [ 'TABLE' ]
                      ( ( table_expr ) { ',' ( table_expr ) } )
                      [ 'IN' lockmode 'MODE' ] [ 'NOWAIT' ] ;

lockmode = ( 'ACCESS' 'SHARE'
               | 'ROW' 'SHARE'
               | 'ROW' 'EXCLUSIVE'
               | 'SHARE' 'UPDATE' 'EXCLUSIVE'
               | 'SHARE'
               | 'SHARE' 'ROW' 'EXCLUSIVE'
               | 'EXCLUSIVE'
               | 'ACCESS' 'EXCLUSIVE' ) ;

(* 'PREPARE' *)
prepare_statement = 'PREPARE' name [ '(' data_type { ',' data_type } ')' ] 'AS' subquery ;

(* 'REASSIGN' 'OWNED' *)
reassign_owned = 'REASSIGN' 'OWNED' 'BY' role_specification { ',' role_specification }
                                    'TO' role_specification ;

(* 'REFRESH' 'MATERIALIZED' 'VIEW' *)
refresh_matview = 'REFRESH' 'MATERIALIZED' 'VIEW' [ 'CONCURRENTLY' ] \
                  matview_name [ 'WITH' [ 'NO' ] 'DATA' ] ;

(* 'RESET' *)
reset_stmt = 'RESET' ( run_time_parameter | 'ALL' ) ;

(* 'RESET' 'ROLE' *)
reset_role = 'RESET' 'ROLE' ;

(* 'RESET' 'SESSION' 'AUTHORIZATION' *)
reset_session_authorization = 'RESET' 'SESSION' 'AUTHORIZATION' ;

(* 'REVOKE' *)
revoke_table = 'REVOKE' [ 'GRANT' 'OPTION' 'FOR' ]
                     ( ( 'SELECT' | 'INSERT' | 'UPDATE' | 'DELETE' | 'TRUNCATE' | 'REFERENCES' | 'TRIGGER' )
                     { ',' ( 'SELECT' | 'INSERT' | 'UPDATE' | 'DELETE' | 'TRUNCATE' | 'REFERENCES' | 'TRIGGER' ) }
                      | 'ALL' [ 'PRIVILEGES' ] )  \
                     'ON' ( [ 'TABLE' ] table_name { ',' table_name }
                          | 'ALL' 'TABLES' 'IN' 'SCHEMA' schema_name { ',' schema_name } )  \
                     'FROM' ( [ 'GROUP' ] role_name | 'PUBLIC' ) { ',' ( [ 'GROUP' ] role_name | 'PUBLIC' ) }
                     [ 'CASCADE' | 'RESTRICT' ] ;

revoke_table_col = 'REVOKE' [ 'GRANT' 'OPTION' 'FOR' ]  \
                         ( ( 'SELECT' | 'INSERT' | 'UPDATE' | 'REFERENCES' ) '(' column_names ')'
                         { ',' '(' column_names ')' } | 'ALL' [ 'PRIVILEGES' ] '(' column_names ')' )  \
                         'ON' [ 'TABLE' ] table_name { ',' table_name }
                         'FROM' ( [ 'GROUP' ] role_name | 'PUBLIC' ) { ',' ( [ 'GROUP' ] role_name | 'PUBLIC' ) }
                         [ 'CASCADE' | 'RESTRICT' ] ;

revoke_seq = 'REVOKE' [ 'GRANT' 'OPTION' 'FOR' ]
                   ( ( 'USAGE' | 'SELECT' | 'UPDATE' ) { ',' ( 'USAGE' | 'SELECT' | 'UPDATE' ) }
                    | 'ALL' [ 'PRIVILEGES' ] )  \
                   'ON' ( 'SEQUENCE' sequence_name { ',' sequence_name }
                        | 'ALL' 'SEQUENCES' 'IN' 'SCHEMA' schema_name { ',' schema_name } )  \
                   'FROM' ( [ 'GROUP' ] role_name | 'PUBLIC' ) { ',' ( [ 'GROUP' ] role_name | 'PUBLIC' ) }
                   [ 'CASCADE' | 'RESTRICT' ] ;

revoke_db = 'REVOKE' [ 'GRANT' 'OPTION' 'FOR' ]
                  ( ( 'CREATE' | 'CONNECT' | 'TEMPORARY' | 'TEMP' ) { ',' ( 'CREATE' | 'CONNECT' | 'TEMPORARY' | 'TEMP' ) }
                   | 'ALL' [ 'PRIVILEGES' ] )
                  'ON' 'DATABASE' database_name { ',' database_name }  \
                  'FROM' ( [ 'GROUP' ] role_name | 'PUBLIC' ) { ',' ( [ 'GROUP' ] role_name | 'PUBLIC' ) }
                  [ 'CASCADE' | 'RESTRICT' ] ;

revoke_domain = 'REVOKE' [ 'GRANT' 'OPTION' 'FOR' ]
                      ( 'USAGE' | 'ALL' [ 'PRIVILEGES' ] )
                      'ON' 'DOMAIN' domain_name { ',' domain_name }  \
                      'FROM' ( [ 'GROUP' ] role_name | 'PUBLIC' ) { ',' ( [ 'GROUP' ] role_name | 'PUBLIC' ) }
                      [ 'CASCADE' | 'RESTRICT' ] ;

revoke_schema = 'REVOKE' [ 'GRANT' 'OPTION' 'FOR' ]
                      ( ( 'CREATE' | 'USAGE' ) { ',' ( 'CREATE' | 'USAGE' ) } | 'ALL' [ 'PRIVILEGES' ] )
                      'ON' 'SCHEMA' schema_name { ',' schema_name }  \
                      'FROM' ( [ 'GROUP' ] role_name | 'PUBLIC' ) { ',' ( [ 'GROUP' ] role_name | 'PUBLIC' ) }
                      [ 'CASCADE' | 'RESTRICT' ] ;

revoke_type = 'REVOKE' [ 'GRANT' 'OPTION' 'FOR' ]
                    ( 'USAGE' | 'ALL' [ 'PRIVILEGES' ] )
                    'ON' 'TYPE' type_name { ',' type_name }  \
                    'FROM' ( [ 'GROUP' ] role_name | 'PUBLIC' ) { ',' ( [ 'GROUP' ] role_name | 'PUBLIC' ) }
                    [ 'CASCADE' | 'RESTRICT' ] ;

revoke_role = 'REVOKE' [ 'ADMIN' 'OPTION' 'FOR' ]
                    role_name { ',' role_name } 'FROM' role_name { ',' role_name }
                    [ 'CASCADE' | 'RESTRICT' ] ;

(* 'ROLLBACK' *)
rollback = 'ROLLBACK' [ 'TRANSACTION' | 'WORK' ] ;

(* 'SELECT' *)
select = [with_clause] 'SELECT' select_list [trailing_select_clauses] ;

with_clause = 'WITH' [ 'RECURSIVE' ] ( common_table_expression { ',' common_table_expression } ) ;

select_list = [ 'ALL' | 'DISTINCT' [ 'ON' ( '(' expression { ',' expression } ')' ) ] ] \
              [ '*' | ( ( ( expression | fn_over_window | ordinary_aggregate_fn_invocation | within_group_aggregate_fn_invocation ) [ [ 'AS' ] name ] )
              { ',' ( ( expression | fn_over_window | ordinary_aggregate_fn_invocation | within_group_aggregate_fn_invocation ) [ [ 'AS' ] name ] ) } ) ] ;

trailing_select_clauses = [ 'FROM' ( from_item { ','  from_item } ) ] \
                          [ 'WHERE' boolean_expression ] \
                          [ 'GROUP' 'BY' ( grouping_element { ',' grouping_element } ) ] \
                          [ 'HAVING' ( boolean_expression ) ] \
                          [ 'WINDOW' ( ( name 'AS' window_definition ) { ',' ( name 'AS' window_definition ) } ) ] \
                          [ ( 'UNION' | 'INTERSECT' | 'EXCEPT' ) [ 'ALL' | 'DISTINCT' ] select ] \
                          [ 'ORDER' 'BY' ( order_expr { ',' order_expr } ) ] \
                          [ 'LIMIT' ( int_expression | 'ALL' ) ] \
                          [ 'OFFSET' int_expression [ 'ROW' | 'ROWS' ] ] \
                          [ 'FETCH' ( 'FIRST' | 'NEXT' ) int_expression ( 'ROW' | 'ROWS' ) 'ONLY' ] \
                          { 'FOR' ( 'UPDATE' | 'NO KEY UPDATE' | 'SHARE' | 'KEY SHARE' ) [ 'OF' table_name { ',' table_name} ] [ 'NOWAIT' | 'SKIP LOCKED' ] };

from_item = '<See https://www.postgresql.org/docs/11/sql-select.html>' ;

common_table_expression = cte_name [ '(' column_name { ',' column_name } ')' ] 'AS' '(' ( select | values | insert | update | delete ) ')' ;

select_expression = expression [ [ 'AS' ] name ] ;

order_expr = expression [ 'ASC' | 'DESC' | 'USING' operator_name ]
             [ 'NULLS' ( 'FIRST' | 'LAST' ) ] ;

(* 'SET' variable *)
set = 'SET' [ 'SESSION' | 'LOCAL' ]
        ( run_time_parameter ( 'TO' | '=' ) ( value | 'DEFAULT' )
          | 'TIME' 'ZONE' ( timezone | 'LOCAL' | 'DEFAULT' ) ) ;

timezone = text_literal ;

(* 'SET' 'CONSTRAINTS' *)
set_constraints = 'SET' 'CONSTRAINTS' ( 'ALL' | name { ',' name } ) ( 'DEFERRED' | 'IMMEDIATE' ) ;

(* 'SET' 'ROLE' *)
set_role = 'SET' [ 'SESSION' | 'LOCAL' ] 'ROLE' ( role_name | 'NONE' ) ;

(* 'SET' 'SESSION' 'AUTHORIZATION' *)
set_session_authorization = 'SET' [ 'SESSION' | 'LOCAL' ] 'SESSION' 'AUTHORIZATION' ( role_name | 'DEFAULT' ) ;

(* 'SET' 'TRANSACTION' *)
set_transaction = 'SET' 'TRANSACTION' transaction_mode { transaction_mode } ;

transaction_mode = isolation_level
                     | read_write_mode
                     | deferrable_mode ;

isolation_level = 'ISOLATION' 'LEVEL' ( 'READ' 'UNCOMMITTED'
                                       | 'READ' 'COMMITTED'
                                       | 'REPEATABLE' 'READ'
                                       | 'SERIALIZABLE' );

read_write_mode = 'READ' 'ONLY' | 'READ' 'WRITE' ;

deferrable_mode = [ 'NOT' ] 'DEFERRABLE' ;

(* 'SHOW' variable *)
show_stmt = 'SHOW' ( run_time_parameter | 'ALL' ) ;

(* 'SHOW' 'TRANSACTION' *)
show_transaction = 'SHOW' 'TRANSACTION' 'ISOLATION' 'LEVEL' ;

(* 'START' 'TRANSACTION' *)
start_transaction = 'START' 'TRANSACTION' { transaction_mode } ;

(* 'TRUNCATE' *)

truncate = 'TRUNCATE' [ 'TABLE' ] ( table_expr { ',' table_expr } ) [ 'CASCADE' | 'RESTRICT' ];

table_expr = [ 'ONLY' ] table_name [ '*' ] ;

(* 'UPDATE' *)
update = [ with_clause ] \
         'UPDATE' table_expr [ [ 'AS' ] alias ] \
         'SET' update_item { ',' update_item }
         (* [ 'FROM' from_list ] \ *)
         [ 'WHERE' boolean_expression | 'WHERE' 'CURRENT' 'OF' cursor_name ] \
         [ returning_clause ] ;

update_item = ( column_name '=' column_value
                  | '(' column_names ')' '=' [ 'ROW' ] '(' column_values ')'
                  | '(' column_names ')' '=' subquery ) ;

column_value = expression | 'DEFAULT' ;

(* 'VALUES' *)
values = 'VALUES' '(' expression_list ')' { ',' '(' expression_list ')' } \
            [ 'ORDER' 'BY' ( order_expr { ',' order_expr } ) ] \
            [ 'LIMIT' ( int_expression | 'ALL' ) ] \
            [ 'OFFSET' int_expression [ 'ROW' | 'ROWS' ] ] \
            [ 'FETCH' ( 'FIRST' | 'NEXT' ) int_expression ( 'ROW' | 'ROWS' ) 'ONLY' ] ;

expression_list = expression { ',' expression } ;


(* For the invocation of a window function, or an aggregate function, in conjunction with the OVER keyword.*)
(* And for the invocation of an aggregate function, in conjunction with the GROUP BY clause.*)

select_start = 'SELECT' [ 'ALL' | 'DISTINCT' [ 'ON' ( '(' expression { ',' expression } ')' ) ] ] \
               [ '*' | ( ( ( expression | fn_over_window | ordinary_aggregate_fn_invocation | within_group_aggregate_fn_invocation ) [ [ 'AS' ] name ] )
                   { ',' ( ( expression | fn_over_window | ordinary_aggregate_fn_invocation | within_group_aggregate_fn_invocation ) [ [ 'AS' ] name ] ) } ) ] ;

fn_over_window = name \
    '(' [ expression { ',' expression } | '*' ] \
    [ 'FILTER' '(' 'WHERE' ( boolean_expression ) ')' ] 'OVER' ( window_definition | name ) ;

ordinary_aggregate_fn_invocation = name \
    '(' ( ( [ 'ALL' | 'DISTINCT' ] expression { ',' expression } ) | '*' )
    [ 'ORDER' 'BY' order_expr { ',' order_expr } ] ')' \
    [ 'FILTER' '(' 'WHERE' boolean_expression ')' ] ;

within_group_aggregate_fn_invocation =  name \
    '(' ( expression { ',' expression } ) ')' \
    'WITHIN' 'GROUP' '(' 'ORDER' 'BY' order_expr { ',' order_expr } ')' \
    [ 'FILTER' '(' 'WHERE' boolean_expression ')' ] ;

window_clause = 'WINDOW' ( ( name 'AS' window_definition ) { ',' ( name 'AS' window_definition ) } ) ;

window_definition =
  '(' [ name ] \
      [ 'PARTITION' 'BY' order_expr { ',' order_expr } ] \
      [ 'ORDER' 'BY' order_expr { ',' order_expr } ] \
      [ frame_clause ] ')' ;

frame_clause =
  [ ( 'RANGE' | 'ROWS' | 'GROUPS' ) frame_bounds ] [ frame_exclusion ] ;

frame_bounds =
  ( frame_start | 'BETWEEN' frame_start 'AND' frame_end ) ;

frame_start = frame_bound ;

frame_end = frame_bound ;

frame_bound =
  ( 'UNBOUNDED' 'PRECEDING' |
    offset 'PRECEDING' |
    'CURRENT' 'ROW' |
    offset 'FOLLOWING' |
    'UNBOUNDED' 'FOLLOWING' ) ;

frame_exclusion =
  ( 'EXCLUDE' 'CURRENT' 'ROW' |
    'EXCLUDE' 'GROUP' |
    'EXCLUDE' 'TIES' |
    'EXCLUDE' 'NO' 'OTHERS' ) ;

offset = ( int_expression | numeric_expression | interval_expression ) ;

group_by_clause = 'GROUP' 'BY' ( grouping_element { ',' grouping_element } ) ;

grouping_element = '(' ')' | '(' expression { ',' expression } ')' | 'ROLLUP' '(' expression { ',' expression } ')' | 'CUBE' '(' expression { ',' expression } ')' | 'GROUPING' 'SETS' '(' grouping_element { ',' grouping_element } ')' ;

having_clause = 'HAVING' ( boolean_expression ) ;

(* Supporting rules *)
qualified_name = name { '.' name } ;
role_name = name ;
database_name = name ;
schema_name = name ;
table_name = qualified_name ;
cte_name = name ;
column_name = name ;
object_name = name ;
access_method_name = name ;
relation_name = qualified_name ;
aggregate_name = qualified_name ;
constraint_name = qualified_name ;
operator_name = qualified_name ;
policy_name = qualified_name ;
subprogram_name = qualified_name ;
rule_name = qualified_name ;
trigger_name = qualified_name ;
sql_stmt = '<SQL Statement>' ;

domain_name = qualified_name ;

index_method = text_literal ;

arg_mode = ( 'IN' | 'OUT' | 'INOUT' | 'VARIADIC' ) ;

formal_arg = name ;

arg_type = type_name ;

text_literal = '<Text Literal>' ;
int_literal = '<Integer Literal>' ;
positive_int_literal = '<Positive Integer Literal>' ;
non_neg_int_literal = '<Non-negative Integer Literal>' ;

numeric_literal = '<Numeric Literal>' ;

value = text_literal | numeric_literal | boolean ;

run_time_parameter = text_literal ;

large_object_oid = int_literal ;

left_type = ( qualified_name | 'NONE' ) ;
right_type = ( qualified_name | 'NONE' ) ;

name = '<Text Literal as specified in [Names and identifiers](../../names-and-identifiers/)>' ;

column_names = column_name { ',' column_name } ;

boolean_expression = expression ;
int_expression = expression ;
numeric_expression = expression ;
text_expression = expression ;
array_expression  = expression ;
interval_expression = expression ;
expression = '<expression>' ;

boolean = 'TRUE' | 'FALSE' ;

(* TODO(jason): change the below when issue #1557 is closed or closing *)
collation = ( '"default"' | '"C"' | '"POSIX"' | '"ucs_basic"' ) ;
type_name = qualified_name ;
attribute_name = name ;
data_type = type_name ;
subtype = type_name ;
operator_class_name = qualified_name ;
subtype_operator_class = operator_class_name ;
canonical_function = subprogram_name ;
subtype_diff_function = subprogram_name ;
input_function = subprogram_name ;
output_function = subprogram_name ;
receive_function = subprogram_name ;
send_function = subprogram_name ;
type_modifier_input_function = subprogram_name ;
type_modifier_output_function = subprogram_name ;
internallength = ( '-2' | '-1' | non_neg_int_literal ) ;
alignment = ( 'CHAR' | 'INT2' | 'INT4' | 'DOUBLE' ) ;
storage = ( 'PLAIN' | 'EXTERNAL' | 'EXTENDED' | 'MAIN' ) ;
like_type = type_name ;
category = '<character>' ;
default_type_value = '<default value for the type instance>' ;
element = type_name ;
delimiter = '<character>' ;
param_name = text_literal ;
param_value = text_literal ;
code = text_literal ;
aggregate_arg_mode = 'IN' | 'VARIADIC' ;
sfunc = subprogram_name ;
state_data_type = type_name ;
base_type = type_name ;
state_data_size = non_neg_int_literal ;
ffunc = subprogram_name ;
combinefunc = subprogram_name ;
serialfunc = subprogram_name ;
deserialfunc = subprogram_name ;
initial_condition = text_literal ;
msfunc = subprogram_name ;
minvfunc = subprogram_name ;
mstate_data_type = type_name ;
mstate_data_size = non_neg_int_literal ;
mffunc = subprogram_name ;
minitial_condition = text_literal ;
sort_operator = operator_name ;
source_type = type_name ;
target_type = type_name ;
com_op = operator_name ;
neg_op = operator_name ;
res_proc = subprogram_name ;
join_proc = subprogram_name ;
strategy_number = positive_int_literal ;
support_number = positive_int_literal ;
op_type = data_type ;
storage_type = data_type ;
using_expression = expression ;
check_expression = expression ;
new_name = name ;
version = text_literal ;
extension_name = name ;

matview_name = qualified_name ;

new_owner = name ;
fdw_options = option_and_name_value { ',' option_and_name_value } ;
option_and_name_value = option_name option_value ;
alter_fdw_options = alter_option_and_name_value { ',' alter_option_and_name_value } ;
alter_option_and_name_value = ('ADD' | 'SET' | 'DROP' ) option_and_name_value ;

fdw_name = text_literal ;
handler_name = text_literal ;
validator_name = '<DateTime Literal>' ;
option_name = text_literal ;
option_value = text_literal ;

(* 'SAVEPOINTS' *)
savepoint_create = ( 'SAVEPOINT' name ) ;

savepoint_release = ( 'RELEASE' [ 'SAVEPOINT' ] name ) ;

savepoint_rollback = ( 'ROLLBACK' ['WORK' | 'TRANSACTION' ] 'TO' [ 'SAVEPOINT' ] name ) ;

(* -------------------------------------------------------------------------------------------------------------------------------------- *)
(* PL/pgSQL language *)

(* 'Block statement' *)
plpgsql_block_stmt = [ '<<' label '>>' ] \
                     [ plpgsql_declaration_section ] \
                     plpgsql_executable_section \
                     [ plpgsql_exception_section ] 'END' [label] ';' ;

label = name ;

(* 'Declare section' *)
plpgsql_declaration_section = 'DECLARE' [ plpgsql_declaration { plpgsql_declaration } ] ;

plpgsql_declaration = ( plpgsql_regular_declaration | plpgsql_bound_refcursor_declaration );

plpgsql_regular_declaration = [variable] [ 'CONSTANT' ] [data_type] ['NOT' 'NULL' ]  [ ':=' expression ] ';' ;

variable = name ;

plpgsql_bound_refcursor_declaration = plpgsql_bound_refcursor_name [ [ 'NO' ] 'SCROLL' ] \
                                      'CURSOR' [ '(' plpgsql_cursor_arg { ',' plpgsql_cursor_arg } ')' ] \
                                      'FOR' subquery ';' ;

plpgsql_cursor_arg = formal_arg arg_type ;

(* 'Executable section' *)
plpgsql_executable_section = 'BEGIN' [ plpgsql_executable_stmt { plpgsql_executable_stmt } ] ;

(* 'Executable statement' *)
plpgsql_executable_stmt = ( plpgsql_basic_stmt | plpgsql_compound_stmt ) ;

(* 'Basic statement' *)
plpgsql_basic_stmt = (
    'NULL'                               | 
    plpgsql_assert_stmt                  |
    plpgsql_assignment_stmt              |
    plpgsql_close_cursor_stmt            |
    plpgsql_continue_stmt                |
    plpgsql_dynamic_sql_stmt             |
    plpgsql_exit_stmt                    |
    plpgsql_fetch_from_cursor_stmt       |
    plpgsql_get_diagnostics_stmt         |
    plpgsql_get_stacked_diagnostics_stmt |
    plpgsql_move_in_cursor_stmt          |
    plpgsql_open_cursor_stmt             |
    plpgsql_perform_stmt                 |
    plpgsql_raise_stmt                   |
    plpgsql_return_stmt                  |
    plpgsql_static_bare_sql_stmt         |
    plpgsql_static_dml_returning_stmt    |
    plpgsql_static_select_into_stmt
  ) ';' ;

(* 'ASSERT' *)
plpgsql_assert_stmt = 'ASSERT' boolean_expression [ ',' text_expression ] ;

(* PL/pgSQ Assignment Dtatement *)
plpgsql_assignment_stmt = ( variable | formal_arg ) ':=' expression ;

(* 'PL/pgSQL EXECUTE' *)
plpgsql_dynamic_sql_stmt = 'EXECUTE' text_expression [ 'INTO' [ 'STRICT' ] plpgsql_into_target { ',' plpgsql_into_target } ] [ 'USING' expression { ',' expression } ] ;

(* 'GET DIAGNOSTICS' *)
plpgsql_get_diagnostics_stmt = 'GET' [ 'CURRENT' ] 'DIAGNOSTICS' plpgsql_diagnostics_item { ',' plpgsql_diagnostics_item } ;

plpgsql_diagnostics_item = ( variable | formal_arg ) ( ':=' | '=' ) plpgsql_diagnostics_item_name ;

plpgsql_diagnostics_item_name = ( 'PG_CONTEXT' | 
                                  'ROW_COUNT'  |
                                  'RESULT_OID' ) ;

(* 'GET STACKED DIAGNOSTICS' *)
plpgsql_get_stacked_diagnostics_stmt = 'GET' 'STACKED' 'DIAGNOSTICS' plpgsql_stacked_diagnostics_item { ',' plpgsql_stacked_diagnostics_item } ;

plpgsql_stacked_diagnostics_item = ( variable | formal_arg ) ( ':=' | '=' ) plpgsql_stacked_diagnostics_item_name ;

plpgsql_stacked_diagnostics_item_name = ( 'RETURNED_SQLSTATE'    | 
                                  'MESSAGE_TEXT'         |
                                  'PG_EXCEPTION_DETAIL'  |
                                  'PG_EXCEPTION_HINT'    |
                                  'SCHEMA_NAME'          |
                                  'TABLE_NAME'           |
                                  'COLUMN_NAME'          |
                                  'PG_DATATYPE_NAME'     |
                                  'CONSTRAINT_NAME'      |
                                  'PG_EXCEPTION_CONTEXT' ) ;

(* 'RAISE' *)
plpgsql_raise_stmt = 'RAISE' [ plpgsql_raise_level ] [ plpgsql_raise_shortcut_for_exception_or_message ] \
  [ 'USING' plpgsql_raise_using_item { ',' plpgsql_raise_using_item } ] ;

plpgsql_raise_level = ( 'DEBUG'     |
                        'LOG'       |
                        'NOTICE'    |
                        'WARNING'   |
                        'EXCEPTION' |
                        'INFO'      ) ;

plpgsql_raise_shortcut_for_exception_or_message = ( 'SQLSTATE' errcode_literal | exception_name | message_literal [ text_expression {',' text_expression } ] ) ;

errcode_literal = text_literal ;
exception_name = name ;
message_literal = text_literal ;

plpgsql_raise_using_item = ( 'ERRCODE'    |
                             'MESSAGE'    |
                             'DETAIL'     |
                             'HINT'       |
                             'SCHEMA'     |
                             'TABLE'      |
                             'COLUMN'     |
                             'DATATYPE'   |
                             'CONSTRAINT' ) ( ':=' | '=' ) text_expression ;

plpgsql_static_bare_sql_stmt = sql_stmt ;

plpgsql_static_dml_returning_stmt = ( insert | update | delete ) returning_clause 'INTO' [ 'STRICT' ] plpgsql_into_target { ',' plpgsql_into_target } ;

plpgsql_static_select_into_stmt = [with_clause] 'SELECT' select_list 'INTO' [ 'STRICT' ] plpgsql_into_target { ',' plpgsql_into_target } [trailing_select_clauses] ;

plpgsql_into_target = ( variable | formal_arg ) ;

(* 'PL/pgSQL Open Cursor' *)
plpgsql_open_cursor_stmt = 'OPEN' plpgsql_refcursor_name [ [ 'NO' ] 'SCROLL' ] 'FOR' subquery ;

(* 'PL/pgSQL Fetch From Cursor' *)
plpgsql_fetch_from_cursor_stmt = 'FETCH' ( 'FIRST' | 'LAST' | 'ABSOLUTE' int_literal |
                                 'NEXT' | 'FORWARD' | 'PRIOR' | 'BACKWARD' |
                                 'RELATIVE' int_literal ) \
                                 [ 'FROM' | 'IN' ] name
                                 'INTO' plpgsql_into_target { ',' plpgsql_into_target } ;

(* 'PL/pgSQL Move In Cursor' *)
plpgsql_move_in_cursor_stmt = 'MOVE' [ move_to_one_row | move_over_many_rows ] [ 'FROM' | 'IN' ] plpgsql_refcursor_name ;

(* 'PL/pgSQL Close Cursor' *)
plpgsql_close_cursor_stmt = 'CLOSE' plpgsql_refcursor_name ;

plpgsql_refcursor_name = name ;

(* 'PERFORM' *)
plpgsql_perform_stmt = 'PERFORM' ( select_list [trailing_select_clauses] | '(' select ')' ) ;

(* 'RETURN' *)
plpgsql_return_stmt = 'RETURN' [ expression | 'NEXT' | 'NEW' | 'OLD' | 'NULL' ] ;

(* 'Compound statement' *)
plpgsql_compound_stmt = ( plpgsql_block_stmt | plpgsql_loop_stmt | plpgsql_if_stmt | plpgsql_case_stmt ) ';' ;

(* 'LOOP' *)
plpgsql_loop_stmt = [ '<<' label '>>' ] ( plpgsql_unbounded_loop_defn | plpgsql_bounded_loop_defn ) 'LOOP' \
                    [ plpgsql_executable_stmt { ',' plpgsql_executable_stmt } ] \
                    'END LOOP' [label] ;

plpgsql_unbounded_loop_defn = [ 'WHILE' boolean_expression ] ;


plpgsql_bounded_loop_defn = ( plpgsql_integer_for_loop_defn |
                              plpgsql_array_foreach_loop_defn |
                              plpgsql_query_for_loop_defn ) ;

plpgsql_integer_for_loop_defn = 'FOR' variable 'IN' \
                                [ 'REVERSE' ] int_expression '..' int_expression \
                                [ 'BY' int_expression ] ;

plpgsql_array_foreach_loop_defn = 'FOREACH' variable \
                                  [ 'SLICE' int_literal ]
                                  'IN' 'ARRAY' array_expression ;

plpgsql_query_for_loop_defn = 'FOR' variable [ variable { ',' variable } ] 'IN' \
                              ( subquery | plpgsql_bound_refcursor_name | plpgsql_dynamic_subquery ) ;

plpgsql_bound_refcursor_name = plpgsql_refcursor_name ;

plpgsql_dynamic_subquery = 'EXECUTE' text_expression [ 'USING' expression { ',' expression } ] ;

(* 'LOOP' and 'CONTINUE' *)
plpgsql_exit_stmt = 'EXIT' [ label] [ 'WHEN' boolean_expression ] ;

plpgsql_continue_stmt = 'CONTINUE' [ label] [ 'WHEN' boolean_expression ] ;

(* 'IF' *)
plpgsql_if_stmt = 'IF' guard_expression 'THEN' [ plpgsql_executable_stmt { plpgsql_executable_stmt } ] \
                  [ plpgsql_elsif_leg { plpgsql_elsif_leg } ] \
                  [ 'ELSE' [ plpgsql_executable_stmt { plpgsql_executable_stmt } ] ] \
                  'END' 'IF';

plpgsql_elsif_leg = ('ELSIF' | 'ELSEIF' ) guard_expression 'THEN' [ plpgsql_executable_stmt { plpgsql_executable_stmt } ] ;

guard_expression = boolean_expression ;

(* 'CASE' *)
plpgsql_case_stmt = ( plpgsql_searched_case_stmt | plpgsql_simple_case_stmt  ) ;

plpgsql_searched_case_stmt = 'CASE' \
                             plpgsql_searched_when_leg { plpgsql_searched_when_leg } \
                             [ 'ELSE' [ plpgsql_executable_stmt { plpgsql_executable_stmt } ] ] \
                             'END' 'CASE';

plpgsql_searched_when_leg = 'WHEN' guard_expression 'THEN' [ plpgsql_executable_stmt { plpgsql_executable_stmt } ] ;

plpgsql_simple_case_stmt = 'CASE' target_expression \
                           plpgsql_simple_when_leg { plpgsql_simple_when_leg } \
                           [ 'ELSE' [ plpgsql_executable_stmt { plpgsql_executable_stmt } ] ] \
                           'END' 'CASE';

plpgsql_simple_when_leg = 'WHEN' candidate_expression 'THEN' [ plpgsql_executable_stmt { plpgsql_executable_stmt } ] ;

target_expression = expression ;
candidate_expression = expression ;

(* 'Exception section' *)
plpgsql_exception_section = 'EXCEPTION' ( plpgsql_handler { plpgsql_handler } ) ;

plpgsql_handler = 'WHEN' ( plpgsql_handler_condition { 'OR' plpgsql_handler_condition } ) 'THEN' ( plpgsql_executable_stmt { plpgsql_executable_stmt } );

plpgsql_handler_condition = ( 'SQLSTATE' errcode_literal | exception_name | 'OTHERS' ) ;

(* -------------------------------------------------------------------------------------------------------------------------------------- *)
(*
  Notice that the "demo-2" rule uses ( ... ) redundantly.
  The two rules are semantically identical but they produce the different diagrams.
  The diagrams do express the same meaning but they are drawn using different conventions.
  Uncomment the two rule definitions and look at the end of the grammar diagrams file to
  see the two semantically equivalent, but differently drawn, diagrams.

  Make sure that you comment these out again before creating a Pull request.
*)

(*
demo-1-irrelevant-for-ysql-syntax = ( a 'K' b { ',' a 'K' b } ) ;

demo-2-irrelevant-for-ysql-syntax = ( ( a 'K' b ) { ',' ( a 'K' b ) } ) ;
*)
