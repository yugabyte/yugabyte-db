---
title: Architecture for Change data capture (CDC) in YugabyteDB
headerTitle: Change data capture (CDC)
linkTitle: Change data capture
description: Learn how YugabyteDB supports asynchronous replication of data changes (inserts, updates, and deletes) to external databases or applications.
tags:
  feature: early-access
menu:
  v2.18:
    parent: architecture-docdb-replication
    identifier: architecture-docdb-replication-cdc
    weight: 1160
type: docs
---

Change data capture (CDC) in YugabyteDB provides technology to ensure that any changes in data due to operations such as inserts, updates, and deletions are identified, captured, and automatically applied to another data repository instance, or made available for consumption by applications and other tools.

## Use cases

CDC is useful in a number of scenarios.

{{< note title="Note" >}}

In this document, the terms data center, cluster, and universe are used interchangeably. The assumption is made that each YugabyteDB universe is deployed in a single data center.

{{< /note >}}

### Microservice-oriented architectures

Some microservices require a stream of changes to the data and using CDC in YugabyteDB can provide consumable data changes to CDC subscribers.

### Asynchronous replication to remote systems

Remote systems may subscribe to a stream of data changes and then transform and consume the changes. Maintaining separate database instances for transactional and reporting purposes can be used to manage workload performance.

### Multiple data center strategies

Maintaining multiple data centers enables enterprises to provide the following:

* High availability (HA) — Redundant systems help ensure that your operations almost never fail.
* Geo-redundancy — Geographically-dispersed servers provide resiliency against catastrophic events and natural disasters.

### Compliance and auditing

Auditing and compliance requirements can require you to use CDC to maintain records of data changes.

## Process architecture

The following diagram depicts the CDC process architecture:

```goat
                        .-------------------------------------------.
                        |  Node 1                                   |
                        |  '----------------' '------------------'  |
                        |  |    YB-Master   | |    YB-TServer    |  |  CDC Service is stateless
   CDC Streams metadata |  |  (Stores CDC   | |  '-------------' |  |           |
  replicated with Raft  |  |   metadata)    | |  | CDC Service | |  |           |
           .----------> |  |                | |  .-------------. |  | <---------'
           |            |  .----------------. .------------------.  |
           |            '-------------------------------------------'
           |
           |
           |_______________________________________________
           |                                               |
           v                                               v
.-------------------------------------------.    .-------------------------------------------.
|  Node 2                                   |    |   Node 3                                  |
|  '----------------' '------------------'  |    |  '----------------' '------------------'  |
|  |    YB-Master   | |    YB-TServer    |  |    |  |    YB-Master   | |    YB-TServer    |  |
|  |  (Stores CDC   | |  '-------------' |  |    |  |  (Stores CDC   | |  '-------------' |  |
|  |   metadata)    | |  | CDC Service | |  |    |  |   metadata)    | |  | CDC Service | |  |
|  |                | |  .-------------. |  |    |  |                | |  .-------------. |  |
|  .----------------. .------------------.  |    |  .----------------. .------------------.  |
'-------------------------------------------'    '-------------------------------------------'
```

Every YB-TServer has a `CDC service` that is stateless. The main APIs provided by the CDC service are the following:

* `createCDCSDKStream` API for creating the stream on the database.
* `getChangesCDCSDK` API that can be used by the client to get the latest set of changes.

### CDC streams

Creating a new CDC stream returns a stream UUID. This is facilitated via the [yb-admin](../../../admin/yb-admin/#change-data-capture-cdc-commands) tool.

### Debezium

To consume the events generated by CDC, Debezium is used as the connector. Debezium is an open-source distributed platform that needs to be pointed at the database using the stream ID. For information on how to set up Debezium for YugabyteDB CDC, see [Debezium integration](/preview/integrations/cdc/debezium/).

### Pushing changes to external systems

Using the Debezium connector for YugabyteDB, changes are pushed from YugabyteDB to a Kafka topic, which can then be used by any end-user application for the processing and analysis of the records.

### CDC guarantees

CDC makes the following guarantees.

#### Per-tablet ordered delivery guarantee

All data changes for one row or multiple rows in the same tablet are received in the order in which they occur. Due to the distributed nature of the problem, however, there is no guarantee for the order across tablets.

Consider the following scenario:

* Two rows are being updated concurrently.
* These two rows belong to different tablets.
* The first row `row #1` was updated at time `t1`, and the second row `row #2` was updated at time `t2`.

In this case, it is possible for CDC to push the later update corresponding to `row #2` change to Kafka before pushing the earlier update, corresponding to `row #1`.

#### At-least-once delivery

Updates for rows are pushed at least once. With the at-least-once delivery, you never lose a message, however the message might be delivered to a CDC consumer more than once. This can happen in case of a tablet leader change, where the old leader already pushed changes to Kafka, but the latest pushed `op id` was not updated in the CDC metadata.

For example, a CDC client has received changes for a row at times `t1` and `t3`. It is possible for the client to receive those updates again.

#### No gaps in change stream

When you have received a change for a row for timestamp `t`, you do not receive a previously unseen change for that row from an earlier timestamp. This guarantees that receiving any change implies that all earlier changes have been received for a row.

{{< note title="Note" >}}

See [Change data capture](../../../explore/change-data-capture/) in Explore for more details and limitations.

{{< /note >}}
