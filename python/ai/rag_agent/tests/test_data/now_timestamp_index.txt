Here is the text with generic names and schema:

User A
May 30th at 1:49 PM

Hi - I'm seeing lots of slow queries where NOW() is part of an indexed condition.
Looking closer, when I trim it down to an index-only scan, they all have this in common:

SQL

create index my_index_on_date on my_table(indexed_date_col DESC);

explain (Analyze, dist)
SELECT indexed_date_col
FROM
    my_table tbl
WHERE
    indexed_date_col < now();
                                                                 QUERY PLAN
-----------------------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan using my_index_on_date on my_table tbl  (cost=27.03..713.64 rows=9149 width=8) (actual time=56.507..64.516 rows=8865 loops=1)
   Index Cond: (indexed_date_col < now())
   Rows Removed by Index Recheck: 59643
If I hard-code now() with its current value, we get a good plan without any recheck.

SQL

explain (Analyze, dist)
SELECT indexed_date_col
FROM
    my_table tbl
WHERE
    indexed_date_col < '2025-05-30 20:45:42.372935+00';
Why is it lossy if the index condition is now()? Is this an OurDB thing or a standard PostgreSQL thing? I raised this time back on a now() optimization which didn't impact me so much, but this application has now() everywhere and I can't index for it because of the recheck. (edited)

User A
May 30th at 1:50 PM

I tried a quick go at a simple DDL repro, but it didn't happen, so there's another variable I didn't spot. Just posting this for a quick peer check.

Developer B
May 30th at 2:25 PM

NOW() is a volatile function, and OurDB does not push down predicates with volatile functions. (edited)

User A
May 30th at 2:27 PM

Is it a PostgreSQL thing too, or an OurDB thing?

Developer B
May 30th at 2:28 PM

I am not sure. Does PostgreSQL give an index scan? If it does, it actually means index scan. But I doubt it, though.

Engineer C
May 30th at 2:28 PM

cc @Developer D for when you're back -- I think we're tracking this in general already.
It's definitely an OurDB limitation that we claim an Index Condition but don't honor it (the recheck ensures results are correct, but performance is affected). (edited)

User A
May 30th at 2:29 PM

Oh, it is us? In terms of doing something about it -- is it not happening within a few months? i.e., should I ask the user to make a sweeping change for now() across the application?

Engineer C
May 30th at 2:30 PM

Changing now() to be generated by the app should address this. I think some creative SQL rewrite to pre-compute now() could also work.

Developer B
May 30th at 2:31 PM

In terms of doing something about it -- is it not happening within a few months?

To clarify, the fix will change the explain plan from an index scan to a sequential scan. The performance will not be affected.

User A
May 30th at 2:32 PM

Oh, so it's a PostgreSQL thing that we will never index scan it properly.

Developer B
May 30th at 2:32 PM

changing now() to be generated by the app should address this. I think some creative SQL rewrite to pre-compute now() could also work.

Doing this is the right approach, IMO.

User A
May 30th at 2:32 PM

But OurDB lies a bit on the explain plan. Yes, if PostgreSQL does it, I have no issues telling them to change it. I was just trying to limit the things I am asking them to do, but if it's a PostgreSQL thing, then it's great.

Engineer C
May 30th at 2:32 PM

@Developer B -- Sorry I didn't read carefully, but I expect PostgreSQL does a real index scan here... @User A can you test? I believe we could make this an index scan eventually -- seems like a pretty basic case, basically pre-computing now() ourselves once. (edited)

User A
May 30th at 2:33 PM

Oh, I am logged into the customer's cluster. I tried a really basic DDL/DML repro in a container and it didn't reproduce it. I can try to dump the customer's table sometime to try the accurate reproduction. (edited)

Developer B
May 30th at 2:33 PM

I see. An index scan is obvious for col < constant type of conditions. But NOW() changes in value for each evaluation. I don't see how it can be an index scan. But good to verify.

Engineer C
May 30th at 2:34 PM

I think now() in PostgreSQL is the transaction start time, not really the current time, so it can be pre-computed. Also in PostgreSQL, the b-tree traversal can use custom comparators, not just values, but it's true maybe PostgreSQL does not optimize this either.

User A
May 30th at 2:34 PM

but NOW() changes in value for each evaluation.

Dumb me thinks it only has one evaluation. (edited)

Developer B
May 30th at 2:35 PM

I think now() in PostgreSQL is the transaction start time not really current time so it can be pre-computed.

Ah, that makes sense.

Engineer C
May 30th at 2:36 PM

It's marked as a non-immutable function, so technically as far as the planner knows, it can change for every evaluation. But implementation-wise, it's not the current time, so it could be pre-computed. But it is a bit tricky, which is why we did not get to it yet (e.g., not sure how it handles RC or savepoints). (edited)

User A
May 30th at 2:40 PM

Ok, got the dump and reproduced it on a container with OurDB. Trying PostgreSQL now.

Developer B
May 30th at 2:41 PM

This is what I get in PostgreSQL:

pbalivada=# explain SELECT indexed_date_col
pbalivada-# FROM my_table tbl
pbalivada-# WHERE indexed_date_col < NOW();
                                                QUERY PLAN
---------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on my_table tbl  (cost=6.92..22.28 rows=357 width=8)
   Recheck Cond: (indexed_date_col < now())
   ->  Bitmap Index Scan on idx_my_table_indexed_date_col  (cost=0.00..6.83 rows=357 width=0)
         Index Cond: (indexed_date_col < now())
(4 rows)
So, PostgreSQL is executing it as an index condition. As Engineer C mentioned, now() is a fixed value for the query. (edited)

User A
May 30th at 2:41 PM

In PostgreSQL:

postgres=# explain (Analyze)
SELECT indexed_date_col
FROM
    my_table tbl
WHERE
    indexed_date_col < now();
                                                            QUERY PLAN
---------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on my_table tbl  (cost=265.27..1621.81 rows=22836 width=8) (actual time=0.603..2.959 rows=8865 loops=1)
   Recheck Cond: (indexed_date_col < now())
   Heap Blocks: exact=1014
   ->  Bitmap Index Scan on my_index_on_date  (cost=0.00..259.56 rows=22836 width=0) (actual time=0.515..0.515 rows=8865 loops=1)
         Index Cond: (indexed_date_col < now())
 Planning Time: 6.069 ms
 Execution Time: 3.198 ms
(7 rows)
On OurDB:

                                                                QUERY PLAN
------------------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan using my_index_on_date on my_table tbl  (cost=0.00..5.15 rows=10 width=8) (actual time=12.906..14.150 rows=8865 loops=1)
   Index Cond: (indexed_date_col < now())
   Rows Removed by Index Recheck: 59643
   Heap Fetches: 0
   Storage Index Read Requests: 67
   Storage Index Read Execution Time: 6.963 ms
   Storage Index Rows Scanned: 68508
 Planning Time: 4.284 ms
 Execution Time: 14.621 ms
Hard-coding now() as a literal, PostgreSQL does the same plan as if it was now(). Okay, so it's a tricky optimization, so not any time soon. I will ask if they are up for doing a search in the codebase for now() and passing it in from the app instead. (edited)

Developer B
May 30th at 3:20 PM

It's marked as non-immutable function, so technically as far as the planner knows it can change for every evaluation.

PostgreSQL only prevents volatile functions from being pushed down to the index.

C

if (match_index_to_operand(leftop, indexcol, index) &&
    !bms_is_member(index_relid, rinfo->right_relids) &&
    !contain_volatile_functions(rightop))
NOW() is a stable function.

{ oid => '1299', descr => 'current transaction time',
  proname => 'now', provolatile => 's', prorettype => 'timestamptz',
  proargtypes => '', prosrc => 'now' },
OurDB only pushes down immutable functions (not stable functions - this is deliberate but perhaps an exception for NOW() can be made).

C

if (pg_proc->provolatile != PROVOLATILE_IMMUTABLE)
{
    result = false;
}
(edited)

User A
May 30th at 11:02 PM

That sounds like less work?

User A
May 30th at 11:12 PM

I guess I can’t be the first person to hit this en masse. What kind of things would we need to check to see if we pushdown now() as stable? (edited)

User A
May 31st at 2:45 AM

I guess this is a secret performance killer. Because PostgreSQL does okay with it, OurDB does many magnitudes times worse, and it's not immediately obvious why. If you don't do an index-only scan, it doesn't even tell you it's doing a recheck. And nobody will realize they need to move the logic to be handled by the app. (edited)

Developer B
Jun 1st at 11:40 AM

I guess I did write that Now() is volatile in a previous message. My bad!

Engineer C
Jun 1st at 1:19 PM

cc @Manager E on this thread for your information. I think the (upcoming) statistics on rows scanned vs rows returned would help show such cases as an anomaly.

Manager E
Jun 2nd at 6:33 AM

Are we planning on changing our code to make an exception for now()?
In the interim though, I guess the customer will have to change their code to precompute now() and pass it into the SQL statement?

Engineer C
Jun 2nd at 8:57 AM

are we planning on changing our code to make an exception for now()?

Yes -- cc @Developer D on the timeline.

In the interim though, I guess the customer will have to change their code to precompute now() and pass it into the SQL statement?

Yes, that's our typical recommendation -- generate the now() time from the app and pass the value into the SQL statement.

Manager E
Jun 2nd at 9:12 AM

I guess this issue with now() will be around as it will be a while before there is a version with the improvement, so I think it might be worthwhile adding a check for it in the Performance Advisor. Actually, it would be good to have a check for non-immutable functions in general. I ran into this issue myself with a load test I was running that used random() in the predicate filters and thus didn't use the index.
Is there an easy way we can check this from just the SQL statement itself? Should we just look for any function that's used in a predicate filter?

Developer D
Jun 2nd at 11:30 AM

are we planning on changing our code to make an exception for now()?
Yes -- cc @Developer D on timeline.

Currently, we do not have a concrete timeline, though definitely in the 2025.2 release. @Developer F plans to pick this one up but is currently lagging behind a few other items. Once they are able to start on that, they would be able to provide a more concrete timeline and backport possibilities.

User A
Jun 2nd at 11:38 AM

I hopefully persuaded the customer to make the code changes in the case for the reason of this post. Maybe 20 or 30 queries. Waiting for them to find time to do it. (edited)

Developer D
Jun 2nd at 11:43 AM

@User A: Which DB version is the customer currently running?

User A
Jun 2nd at 11:43 AM

2024.2 — LTS

Engineer G
Jul 1st at 11:38 AM

@User A, @Engineer C -- Surprisingly, I am not able to reproduce this.

SQL

DROP TABLE if exists another_table;

CREATE TABLE another_table (
    col1 VARCHAR PRIMARY KEY,
    col2 VARCHAR,
    date_col TIMESTAMPTZ NOT NULL);

CREATE INDEX another_index_on_date
      ON another_table (date_col ASC, col1 ASC) INCLUDE (col2);

-- insert 5000 days worth of rows
INSERT into another_table (SELECT 's-idx-' || idx,
                                   'prod-id' || idx,
                                   now() - make_interval(days => idx)
                            FROM generate_series(1, 5000) idx);

EXPLAIN (ANALYZE, DIST, DEBUG)
select
    ses.col1,
    ses.col2
from
    another_table as ses
where ses.date_col > now() - make_interval(days => 10);
If now() was evaluated for each row, I would have expected there to be ~5000 nexts. But this is what I see (1 seek and 9 nexts for the 9 rows in the result):

 Index Only Scan using another_index_on_date on another_table ses  (cost=0.00..15.75 rows=100 width=64) (actual time=0.215..0.234 rows=9 loops=1)
   Index Cond: (date_col > (now() - '10 days'::interval))
   Heap Fetches: 0
   Storage Index Read Requests: 1
   Storage Index Read Execution Time: 0.153 ms
   Storage Index Rows Scanned: 9
   Metric StorageEngine_number_db_seek: 1.000
   Metric StorageEngine_keys_found: 9.000
   ...
I am running 2024.1.0.0. I'll try using a newer build to see if it is a recent regression. (edited)
cc: @Engineer H

Engineer G
Jul 1st at 11:46 AM

I cannot reproduce in 2024.2.3.2 either. Meaning 2024.2.3.3 behavior looks fine also and doesn't seem to evaluate now() for each row. So not sure what's the difference between @User A’s test and mine. User A -- do you have the full script I can try locally? (edited)

User A
Jul 1st at 12:15 PM

SQL

CREATE TABLE public.my_table (
    id_col bigint NOT NULL PRIMARY KEY,
    user_id_col bigint NOT NULL,
    campaign_id integer NOT NULL,
    state character varying(20),
    created_at timestamp without time zone DEFAULT now(),
    category character varying(20),
    target_val numeric(20,2),
    progress_val numeric(20,2),
    activated_at timestamp without time zone,
    expires_at timestamp without time zone,
    amount numeric(20,2),
    partner_code character varying(255),
    indexed_date_col timestamp without time zone,
    updated_at timestamp without time zone DEFAULT now(),
    bonus_code character varying(25),
    offer_expired_at timestamp without time zone
);

-- \i my_table_data.sql -- (Assume data is loaded here)

set search_path to public ;

create index on my_table(indexed_date_col asc);

explain (Analyze, dist, debug)
SELECT indexed_date_col
FROM
    my_table tbl
WHERE
    indexed_date_col < now();
 Index Only Scan using my_table_indexed_date_col_idx on my_table tbl  (cost=0.00..5.15 rows=10 width=8) (actual time=2.120..23.145 rows=8909 loops=1)
   Index Cond: (indexed_date_col < now())
   Rows Removed by Index Recheck: 59599
   Heap Fetches: 0
   Storage Index Read Requests: 67
   Storage Index Read Execution Time: 11.807 ms
   Storage Index Rows Scanned: 68508
   ...
(edited)

Engineer C
Jul 1st at 12:20 PM

Just skimming -- did we try both timestamp (without time zone) and timestamptz types? now() returns timestamptz, so the timestamp type requires an extra cast. That seems like a difference above.

User A
Jul 1st at 12:23 PM

SQL

ALTER TABLE my_table ALTER COLUMN indexed_date_col SET DATA TYPE timestamptz;
ALTER TABLE

EXPLAIN (ANALYZE, DIST, DEBUG)
SELECT indexed_date_col
FROM
    my_table tbl
WHERE
    indexed_date_col < now();
                                                                              QUERY PLAN
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan using my_table_indexed_date_col_idx on my_table tbl  (cost=0.00..5.15 rows=10 width=8) (actual time=1.587..3.749 rows=8909 loops=1)
   Index Cond: (indexed_date_col < now())
   Heap Fetches: 0
   Storage Index Read Requests: 9
   Storage Index Read Execution Time: 1.841 ms
   Storage Index Rows Scanned: 8909
How are we able to pushdown now() with timestamptz when I thought our code is only pushing down immutable functions? (I'm not complaining)

Engineer C
Jul 1st at 12:35 PM

I'd guess we don't push it down; PostgreSQL just pre-computes it as it's safe in that case. But it does not in the case where it requires a cast. But it's just a guess -- I'm actually not sure what is happening.
cc @Developer D @Developer F for your information.

User A
Jul 1st at 12:36 PM

cc @Developer B

Developer B
Jul 1st at 12:58 PM

Interesting.

Engineer G
Jul 1st at 1:00 PM

@User A -- you are right. My test also shows the "non-performant" behavior if I change TIMESTAMPTZ to TIMESTAMP.

SQL

-- Using the same schema as before, but with TIMESTAMP
CREATE TABLE another_table (
    col1 VARCHAR PRIMARY KEY,
    col2 VARCHAR,
    date_col TIMESTAMP NOT NULL
);
-- ... (rest of the setup)
 Index Only Scan using another_index_on_date on another_table ses  (cost=0.00..15.75 rows=100 width=64) (actual time=5.658..5.663 rows=9 loops=1)
   Index Cond: (date_col > (now() - '10 days'::interval))
   Rows Removed by Index Recheck: 4991
   ...
   Storage Index Rows Scanned: 5000
Developer I
Jul 1st at 1:19 PM

That's a simple data type mismatch. The index condition is pushed down if the data type is the same:

SQL

EXPLAIN (ANALYZE, DIST)
select
    ses.col1,
    ses.col2
from
    another_table as ses
where ses.date_col > now()::timestamp - make_interval(days => 10);
                                                                           QUERY PLAN
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan using another_index_on_date on another_table ses  (cost=0.00..16.00 rows=100 width=64) (actual time=4.948..4.981 rows=9 loops=1)
   Index Cond: (date_col > ((now())::timestamp without time zone - '10 days'::interval))
   Heap Fetches: 0
   Storage Index Read Requests: 1
   Storage Index Read Execution Time: 4.077 ms
   Storage Index Rows Scanned: 9
   ...
That is partially our fault. PostgreSQL thinks timestamp and timestamptz are directly comparable, but the StorageEngine does not support that, so it wants the constant part to be timestamp as well.

Developer I
Jul 1st at 1:29 PM

Btw, just yesterday, me, @Developer D and @Developer F discussed timestamps and now() pushdown.
One takeaway was that it is dangerous to mix timestamp and timestamptz in a distributed system. Timestamps are assumed to be in the "system timezone" when converted to timestamptz, and that "system timezone" may be different on different nodes.

Developer B
Jul 1st at 1:31 PM

I printed the result of can_pushdown_function. We could be pushing down even though now() says we cannot.

2025-07-01 20:30:25.122 UTC [615421] LOG:  procname: timestamptz_lt, provolatile: i
2025-07-01 20:30:25.122 UTC [615421] STATEMENT:  explain select * from events_table where event_time_col < now();
2025-07-01 20:30:25.122 UTC [615421] LOG:  procname: timestamptz_lt, result: 1
2025-07-01 20:30:25.122 UTC [615421] LOG:  procname: now, provolatile: s
2025-07-01 20:30:25.122 UTC [615421] LOG:  procname: now, result: 0
Developer I
Jul 1st at 1:36 PM

Those are different types of pushdown. The can_pushdown_function is about storage filters. A filter is a PostgreSQL expression; some of them the StorageEngine can evaluate. The Index Condition is something directly supported (or not supported) by the index iterator. An Index Condition is generally converted to a data format the StorageEngine can understand.

Developer B
Jul 1st at 1:40 PM

I see. So, are we pushing this condition (event_time_col < now()) down as an index condition even though it wouldn't have been pushed down as a storage filter?

Developer I
Jul 1st at 1:45 PM

It is already a constant when in the Index Condition. We plan to support now() pushdown in storage filters by converting it into a constant too.

Developer B
Jul 1st at 1:45 PM

2025-07-01 20:44:33.529 UTC [630180] LOG:  pushable: 0
2025-07-01 20:44:33.529 UTC [630180] STATEMENT:  explain select * from events_table where event_time_col < now();
...
db=# explain select * from events_table where event_time_col < now();
                                    QUERY PLAN
--------------------------------------------------------------------------------
 Index Scan using idx_on_event_time on events_table  (cost=0.00..5.25 rows=10 width=560)
   Index Cond: (event_time_col < now())
Engineer J
Jul 1st at 1:46 PM

Could we convert to a constant timestamp when we detect it is part of a comparison with a timestamp variable? And at that point, use the session settings for timezone to convert to the right constant? cc: @Developer F

Developer I
Jul 1st at 1:48 PM

If we convert timestamptz to timestamp, we lose data. It does not sound like a good idea to deliberately lose data.

Engineer J
Jul 1st at 1:57 PM

I said "when we detect it is part of a comparison with a timestamp variable."

Developer I
Jul 1st at 2:16 PM

OK. Long answer.

db=# show TimeZone;
      TimeZone
---------------------
 America/Los_Angeles
(1 row)

db=# select now();
              now
-------------------------------
 2025-07-01 13:59:45.890591-07
(1 row)
The timestamptz value shown is 2025-07-01 20:59:45.890591+00 in UTC. If cast to timestamp, it is 2025-07-01 13:59:45.890591. If I have timestamp values in my database, who knows in what time zone they are? UTC or PDT or something else? If I don't care, in the cloud universe they are in UTC, on my laptop they are PDT. What if I subtract timestamp from timestamptz or vice versa to get an interval?

Developer B
Jul 1st at 2:20 PM

What happens today if I subtract timestamp from timestamptz?

Developer I
Jul 1st at 2:22 PM

Timestamp is assumed to be in the show TimeZone; timezone in the environment where the subtraction is evaluated.

Developer B
Jul 1st at 2:22 PM

The environment is the database backend that's executing the query, right?

Developer I
Jul 1st at 2:25 PM

In general, no. The expression event_time_col < '2025-07-01 13:59:45.890591-07' is pushable and is evaluated on some StorageEngine node.

Engineer G
Jul 1st at 2:30 PM

@Developer I --If "col" is a timestamp type, then is the PostgreSQL expression col > now() semantically equivalent to:
option (a) col::timestamptz > now() -- this one still generates an inefficient plan
or to:
option (b) col > now()::timestamp -- this one generates an efficient plan
Or do both options do the same thing semantically speaking?

Developer B
Jul 1st at 2:31 PM

Is col a range index column?

Developer I
Jul 1st at 2:33 PM

The StorageEngine index scan can't cast data in the column, so it will fall back to a SeqScan if you try col::timestamptz > now(). So col > now()::timestamp is pretty much the only option to leverage the index.

User K
Jul 1st at 2:37 PM

In general, no. The expression event_time_col < '2025-07-01 13:59:45.890591-07' is pushable and is evaluated on some StorageEngine node.

Doesn’t that mean the same query could return different results after a leader election if two nodes have different system timezones?

Developer I
Jul 1st at 2:37 PM

It does.

User K
Jul 1st at 2:38 PM

That’s horrible.

Developer I
Jul 1st at 2:38 PM

That's the reason to hate time.

Developer B
Jul 1st at 2:39 PM

IMO, we should assume the timezone of the database backend. Not ideal, but sounds like a better option. (edited)

Developer I
Jul 1st at 2:40 PM

Which database backend out of potentially thousands of them?

Developer B
Jul 1st at 2:41 PM

The database backend where the query lands. There is only a single node where the query lands. However, the data can reside on many nodes. Actually, I am curious how other distributed databases handle this scenario. (edited)

User K
Jul 1st at 2:44 PM

UTC or GTFO.

Developer I
Jul 1st at 2:50 PM

That's not a database's problem, fortunately. The DBA or application should take care of it.
If you are a multinational corporation or in one of the few nations spanning over multiple time zones - use timestamptz. The rest (most) of the world is probably OK with timestamp, just make sure all your nodes are on the same timezone. A catch - cloud nodes would have UTC by default, while workstations would have a local timezone. Plus, some smart folks will play with the set TimeZone command. Wanna be safe - use timestamptz.

Developer B
Jul 1st at 2:50 PM

Another distributed database does this apparently:

The difference between these two variants is that TIMESTAMPTZ uses the client's session time zone, while the other simply does not. This behavior extends to functions like now() and extract() on TIMESTAMPTZ values.
Each of their sessions has an associated timezone. I believe they can be changed by the user at the session level. Doesn't sound like a bad idea.

Engineer G
Jul 1st at 2:53 PM

@Developer B asked "is col a range index column?" -- my question is independent of whether the column even has an INDEX or not.
According to the PostgreSQL documentation:

"When comparing a timestamp without time zone to a timestamp with time zone, the former value is assumed to be given in the time zone specified by the TimeZone configuration parameter, and is rotated to UTC for comparison to the latter value (which is already in UTC internally)."

So, if col is timestamp, then col > now() is equivalent to:
col::timestamptz > now() (option A)
and not to
col > now()::timestamp (option B)
CC: @Engineer J. Doing the latter automatically will be lossy (as Developer I suggested). Please let me know if you meant something else.
Sounds like you were suggesting to do option (B) automatically, but that's not the correct translation of the original intent. Option (A) is. Unless we can prove that option (A) and (B) are semantically equivalent.

Developer D
Jul 1st at 3:29 PM

col::timestamptz > now() (option A)

This is what PostgreSQL does, i.e., converts the timestamp to timestamptz and then does the comparison (@Developer F brought this code up in an earlier discussion).

Unless we can prove that option (A) and (B) are semantically equivalent.

This is what we discussed earlier: convert the time returned by now() to timestamp based on the local session setting and use that as a constant for pushdown. This is murky waters as @Developer I mentioned. Though this discrepancy exists the other way as well if timestamp is converted to timestamptz and then used for comparison.
FYI: Developer F plans to write these details in a doc and share it, probably later in the week.

Developer I
Jul 2nd at 8:51 AM

SQL

db=# show TimeZone;
      TimeZone
---------------------
 America/Los_Angeles
(1 row)

db=# create function interval1(ts1 timestamp, ts2 timestamptz) returns interval as $$
db$# begin
db$#   return ts1::timestamptz - ts2;
db$# end;
db$# $$ language plpgsql;
CREATE FUNCTION
db=# create function interval2(ts1 timestamp, ts2 timestamptz) returns interval as $$
begin
  return ts1 - ts2::timestamp;
end;
$$ language plpgsql;
CREATE FUNCTION

db=# select interval1('2025-03-09 03:30:00', '2025-03-09 02:30:00-07');
 interval1
-----------
 01:00:00
(1 row)

db=# select interval2('2025-03-09 03:30:00', '2025-03-09 02:30:00-07');
 interval2
-----------
 02:00:00
(1 row)
Engineer G
Jul 2nd at 9:48 AM

Nice proof by example that option (A) and option (B) are not equal, @Developer I!
And since the PostgreSQL specification expects us to go with option (A), we can't do the change that Engineer J was suggesting to implicitly cast now() to now()::timestamp.

Developer F
Jul 2nd at 10:01 AM

Thanks @Developer I!
Out of curiosity though -- since that date doesn't exist due to DST, now() would technically never return it, right?

Developer I
Jul 2nd at 10:08 AM

Correct.