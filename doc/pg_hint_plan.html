<!DOCTYPE HTML PUBLIC "-//W3C//DTD html 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en_US">
<head>
<title>pg_hint_plan</title>
<!-- Uncoment after the tool has been hosted somewhere.
<link rel="home" title="pg_hint_plan" href="index.html">
-->
<link rel="stylesheet" type="text/css" href="style.css">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
<style type="text/css">
h2 { border-style:solid none none none; margin-top: 2em; }
h3 { margin-top: 2em; }
dt { margin-top: 0.5em; margin-bottom: 0.3em;}
pre { margin: 0 2em 0 2em; padding:0.3em; border-style: solid; border-width:0.1em; border-color: #97A69F; background-color: #DEFFEF; }
</style>
-->
</head>

<body>
<h1 id="pg_hint_plan">pg_hint_plan 1.2</h1>
<div class="navigation">
  <a href="pg_hint_plan-ja.html">pg_hint_plan</a>
</div>
<hr>

<div class="index">
<ol>
<li><a href="#name">Name</a></li>
<li><a href="#synopsis">Synopsis</a></li>
<li><a href="#description">Description</a>
<li><a href="#install">Installation</a></li>
<li><a href="#uninstall">Uninstallation</a></li>
<li><a href="#examples">Hint descriptions</a></li>
<li><a href="#hint_syntax">Hint syntax</a></li>
<li><a href="#restrictions">Restrictions</a></li>
<li><a href="#techniques">Techniques to hint on disired targets</a></li>
<li><a href="#errors">Errors of hints</a></li>
<li><a href="#func_limits">Functional limitations</a></li>
<li><a href="#requirement">Requirements</a></li>
<li><a href="#seealso">See Also</a></li>
<li><a href="hint_list.html">Appendix A. Hints list</a></li>
</div>

<h2 id="name">Name</h2>
<p>pg_hint_plan -- controls execution plan with hinting phrases in comment of special form.</p>

<h2 id="synopsis">Synopsis</h2>
<p>PostgreSQL uses cost based optimizer, which utilizes data statistics, not static rules. The planner (optimizer) esitimates costs of each possible execution plans for a SQL statement then the execution plan with the lowest cost finally be executed.  The planner does its best to select the best best execution plan, but not perfect, since it doesn't count some properties of the data, for example, correlation between columns.</p>
<p>pg_hint_plan makes it possible to tweak execution plans using so-called "hints", which are simple descriptions in the SQL comment of special form.</p>

<h2 id="description">Description</h2>

<h3 id="hint-rule">Basic Usage</h3>
<p>pg_hint_plan reads hinting phrases in a comment of special form given with the target SQL statement. The special form is beginning by the character sequence "/*+" and ends with "*/". Hint phrases are consists of hint name and following parameters enclosed by parentheses and delimited by spaces. Each hinting phrases can be delimited by new lines for readability.</p>

<p>In the example below , hash join is selected as the joning method and scanning pgbench_accounts by sequential scan method.</p>
<pre>
postgres=# /*+
postgres*#    <b><u>HashJoin(a b)</u></b>
postgres*#    <b><u>>SeqScan(a)</u></b>
postgres*#  */
postgres-# EXPLAIN SELECT *
postgres-#    FROM pgbench_branches b
postgres-#    JOIN pgbench_accounts a ON b.bid = a.bid
postgres-#   ORDER BY a.aid;
                                      QUERY PLAN
---------------------------------------------------------------------------------------
 Sort  (cost=31465.84..31715.84 rows=100000 width=197)
   Sort Key: a.aid
   ->  <b><u>Hash Join</u></b>  (cost=1.02..4016.02 rows=100000 width=197)
         Hash Cond: (a.bid = b.bid)
         ->  <b><u>Seq Scan on pgbench_accounts a</u></b>  (cost=0.00..2640.00 rows=100000 width=97)
         ->  Hash  (cost=1.01..1.01 rows=1 width=100)
               ->  Seq Scan on pgbench_branches b  (cost=0.00..1.01 rows=1 width=100)
(7 rows)

postgres=# </pre>

<h2 id="examples">Hint table</h2>
<p> The above section mentioned that
hints are placed in a comment with special form. This way of hinting
is inconvenient for certain cases where queries cannot be edited. For
such cases, hints can be placed in a special table named
"hint_plan.hints". The table consists of the following columns.</p>
<table>
<thead>
<tr>
<tr><th>column</th><th>description</th></tr>
</tr></thead>
<tbody>
<tr><td>id</td>
  <td>Unique number to identify a row for a hint. This column is filled automatically by sequence.</td></tr>
<tr><td>norm_query_string</td>
  <td>A pattern matches to the query to be hinted. Constants in the query have to be replace with '?' as in the following example. White space is significant in the pattern.</td></tr>
<tr><td>application_name</td>
  <td>The value of application_name of sessions to apply the hint. The hint in the example below applies to sessions connected from psql. An empty string means sessions of any application_name.</td></tr>
<tr><td>hints</td>
  <td>Hint phrase. This must be a series of hints excluding surrounding comment marks.</td></tr>
</tbody>
</table>

<p>The following example shows how to operate with the hint table.</p>
<pre>
<b>postgres=#</b> INSERT INTO hint_plan.hints(norm_query_string, application_name, hints)
<b>postgres-#</b>     VALUES (
<b>postgres(#</b>         'EXPLAIN (COSTS false) SELECT * FROM t1 WHERE t1.id = ?;',
<b>postgres(#</b>         '',
<b>postgres(#</b>         'SeqScan(t1)'
<b>postgres(#</b>     );
INSERT 0 1
<b>postgres=#</b> UPDATE hint_plan.hints
<b>postgres-#</b>    SET hints = 'IndexScan(t1)'
<b>postgres-#</b>  WHERE id = 1;
UPDATE 1
<b>postgres=#</b> DELETE FROM hint_plan.hints
<b>postgres-#</b>  WHERE id = 1;
DELETE 1
<b>postgres=#</b>
</pre>
<p>The hint tables is owned by the creator user and having the default previledges  at the time of creation.
during CREATE EXTENSION. Table hints are prioritized than comment hits.</p>

<h3 id="hint-group">The types of hints</h3>
<p>Hinting phrases are classified into six types based on what kind of object and how they can affect planning. Scaning methods, join methods, joining order, row number correction, parallel query and GUC setting. You will see the lists of hint phrases of each type in <a href="hint_list.html">Hint list</a>.</p>

<h4>Hints for scan methods </h4>
<p>Scan method hints enforce specific scanning method on the target table. pg_hint_plan recognizes the target table by alias names if any. They are 'SeqScan' , 'IndexScan' and so on in this kind of hint.</p>
<p>Scan hints are effective on ordinary tables, inheritance tables, UNLOGGED tables, temporary tables and  system catalogs. External(foreign) tables, table functions, VALUES clause, CTEs, views and subquiries are not affected.</p>
<pre>
<b>postgres=# /*+</b>
<b>postgres*#     SeqScan(t1)</b>
<b>postgres*#     IndexScan(t2 t2_pkey)</b>
<b>postgres*#  */</b>
<b>postgres-#</b> SELECT * FROM table1 t1 JOIN table table2 t2 ON (t1.key = t2.key);
</pre>


<h4>Hints for join methods</h4>
<p>Join method hints enforce the join methods of the joins involving specified tables. </p>
<p>This can affect on joins only on ordinary tables, inheritance tables, UNLOGGED tables, temporary tables, external (foreign) tables, system catalogs, table functions, VALUES command results and CTEs are allowed to be in the parameter list. But joins on views and sub query are not affected.</p>

<h4>Hint for joining order</h4>
<p> This hint "Leading" enforces the order of join on two or more tables. There are two ways of enforcing. One is enforcing specific order of joining but not restricting direction at each join level. Another enfoces join direction additionaly. Details are seen in the <a href="hint_list.html">hint list</a> table.</p>

<pre>
<b>postgres=# /*+</b>
<b>postgres*#     NestLoop(t1 t2)</b>
<b>postgres*#     MergeJoin(t1 t2 t3)</b>
<b>postgres*#     Leading(t1 t2 t3)</b>
<b>postgres*#  */</b>
<b>postgres-#</b> SELECT * FROM table1 t1
<b>postgres-#</b>     JOIN table table2 t2 ON (t1.key = t2.key)
<b>postgres-#</b>     JOIN table table3 t3 ON (t2.key = t3.key);
</pre>

<h4>Hint for row number correction</h4>
<p>This hint "Rows" corrects row number misestimation of joins that comes from restrictions of the planner. </p>

<pre>
<b>postgres=# /*+ Rows(a b #10) */</b> SELECT... ; Sets rows of join result to 10
<b>postgres=# /*+ Rows(a b +10) */</b> SELECT... ; Increments row number by 10
<b>postgres=# /*+ Rows(a b -10) */</b> SELECT... ; Subtracts 10 from the row number.
<b>postgres=# /*+ Rows(a b *10) */</b> SELECT... ; Makes the number 10 times larger.
</pre>

<h4>Hint for parallel plan</h4>
<p>This hint "Parallel" enforces parallel execution configuration on
scans. The third parameter specifies the strength of enfocement. "soft" means that pg_hint_plan only changes max_parallel_worker_per_gather and leave all others to planner. "hard" changes other planner parameters so as to forcibly apply the number. This can affect on ordinary tables, inheritnce parents, unlogged
tables and system catalogues. External tables, table functions, values clause, CTEs, views and subqueries are not affected. Internal tables of a view can be specified by its real name/alias as the target object. The following example shows that the query is enforced differently on each table.</p>

<pre>
<b>postgres=#</b> explain <b>/*+ Parallel(c1 3 hard) Parallel(c2 5 hard) */</b>
       SELECT c2.a FROM c1 JOIN c2 ON (c1.a = c2.a);
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Hash Join  (cost=2.86..11406.38 rows=101 width=4)
   Hash Cond: (c1.a = c2.a)
   ->  Gather  (cost=0.00..7652.13 rows=1000101 width=4)
         <b><u>Workers Planned: 3</u></b>
         ->  Parallel Seq Scan on <b><u>c1</u></b>  (cost=0.00..7652.13 rows=322613 width=4)
   ->  Hash  (cost=1.59..1.59 rows=101 width=4)
         ->  Gather  (cost=0.00..1.59 rows=101 width=4)
               <b><u>Workers Planned: 5</u></b>
               ->  Parallel Seq Scan on <b><u>c2</u></b>  (cost=0.00..1.59 rows=59 width=4)

<b>postgres=#</b> EXPLAIN <b>/*+ Parallel(tl 5 hard) */</b> SELECT sum(a) FROM tl;
                                    QUERY PLAN                                  
-----------------------------------------------------------------------------------
 <b><u>Finalize Aggregate</u></b>  (cost=693.02..693.03 rows=1 width=8)
   ->  Gather  (cost=693.00..693.01 rows=5 width=8)
         <b><u>Workers Planned: 5</u></b>
         ->  <b><u>Partial Aggregate</u></b>  (cost=693.00..693.01 rows=1 width=8)
               ->  Parallel Seq Scan on tl  (cost=0.00..643.00 rows=20000 width=4)
</pre>
</dd>


</pre>


<h4>GUC parameters temporarily setting</h4>
<p>'Set' hint changes GUC parameters just while planning. GUC parameter shown in <a href="http://www.postgresql.org/docs/current/static/runtime-config-query.html">Query Planning</a> can have the expected effects on planning unless any other hint conflicts with the planner method configuration parameters. The last one among hints on the same GUC parameter makes effect. <a href="#hint-GUC">GUC parameters for pg_hint_plan</a> are also settable by  this hint but it won't work as your expectation. See <a href="#restrictions">Restrictions</a> for details.</p>
<pre>
postgres=# <b>/*+ Set(random_page_cost 2.0) */</b>
postgres-# SELECT * FROM table1 t1 WHERE key = 'value';
...
</pre>

<h3 id="hint-GUC">GUC parameters for pg_hint_plan</h3>
<p>GUC parameters below affect the behavior of pg_hint_planpg_hint_plan.</p>
<table>
<thead>
<tr>
<tr><th>Parameter name</th><th>discription</th><th>Default</th></tr>
</tr></thead>
<tbody>
<tr><td>pg_hint_plan.enable_hint</td>
  <td>True enbles pg_hint_plan.</td><td>on</td></tr>
<tr><td>pg_hint_plan.enable_hint_table</td>
  <td>True enbles hinting by table. true or false.</td><td>off</td></tr>
<tr><td>pg_hint_plan.parse_messages</td>
  <td>Specifies the log level of hint parse error. Valid values are error, warning, notice, info, log, debug<n>.</td><td>INFO</td></tr>
<tr><td>pg_hint_plan.debug_print</td>
  <td>Controls debug print and verbosity. Valid vaiues are off, on, detailed and verbose.</td><td>off</td></tr>
<tr><td>pg_hint_plan.message_level</td>
  <td>Specifies message level of debug print. Valid values are error, warning, notice, info, log, debug<n>.</td><td>INFO</td></tr>
</tbody>
</table>

<h2 id="install">Installation</h2>
This section describes the installation steps.
<h3 id="build">building binary module</h3>
<p>Simplly run "make" in the top of the source tree, then "make install" as appropriate user. The PATH environment variable should be set properly for the target PostgreSQL for this process. </p>
<pre>
$ tar xzvf pg_hint_plan-1.x.x.tar.gz
$ cd pg_hint_plan-1.x.x
$ make
$ su
# make install
</pre>

<h3 id="hint-load">Loding pg_hint_plan</h3>
<p>Basically pg_hint_plan does not requires CREATE EXTENSION. Simplly loading it by LOAD command will activate it and of course you can load it globally by setting shared_preload_libraries in postgresql.conf. Or you might be interested in ALTER USER SET/ALTER DATABASE SET for automatic loading for specific sessions. 
<pre>
postgres=# LOAD 'pg_hint_plan';
LOAD
postgres=# </pre></p>

<p>Do CREATE EXTENSION and SET pg_hint_plan.enable_hint_tables TO on if you are planning to hint tables.</p>


<h2 id="uninstall">Unistallation</h2>
<p>"make uninstall" in the top directory of source tree will uninstall the installed files if you installed from the source tree and it is left available. </p>

<pre>
$ cd pg_hint_plan-1.x.x
$ su
# make uninstall
</pre>

<h2 id="hint_syntax">Details in hinting</h2>
<h3>Syntax and placement</h3>
<dd>pg_hint_plan reads hints from only the first block comment and any characters except alphabets, digits, spaces, underscores, commas and parentheses stops parsing immediately. In the following example HashJoin(a b) and SeqScan(a) are parsed as hints but IndexScan(a) and MergeJoin(a b) are not.

<pre>
<b>postgres=# /*+</b>
<b>postgres*#    HashJoin(a b)</b>
<b>postgres*#    SeqScan(a)</b>
<b>postgres*#  */</b>
<b>postgres-# /*+ IndexScan(a) */</b>
<b>postgres-#</b> EXPLAIN SELECT <b>/*+ MergeJoin(a b) */</b> *
<b>postgres-#</b>    FROM pgbench_branches b
<b>postgres-#</b>    JOIN pgbench_accounts a ON b.bid = a.bid
<b>postgres-#</b>   ORDER BY a.aid;
                                      QUERY PLAN
---------------------------------------------------------------------------------------
 Sort  (cost=31465.84..31715.84 rows=100000 width=197)
   Sort Key: a.aid
   ->  <b><u>Hash Join</u></b>  (cost=1.02..4016.02 rows=100000 width=197)
         Hash Cond: (a.bid = b.bid)
         ->  <b><u>Seq Scan on pgbench_accounts a</u></b>  (cost=0.00..2640.00 rows=100000 width=97)
         ->  Hash  (cost=1.01..1.01 rows=1 width=100)
               ->  Seq Scan on pgbench_branches b  (cost=0.00..1.01 rows=1 width=100)
(7 rows)

postgres=# </pre>
</dd>

<h3>Using with PL/pgSQL</h3>
<dd>pg_hint_plan works for queries in PL/pgSQL scripts with some restrictions.
<ul>
 <li>Hints affect only on the following kind of queires.
 <ul>
  <li>Queries that returns one row. (SELECT, INSERT, UPDATE and DELETE)</li>
  <li>Queries that returns multiple rows. (RETURN QUERY)</li>
  <li>Dynamic SQL statements. (EXECUTE)</li>
  <li>Cursor open. (OPEN)</li>
  <li>Loop over result of a query (FOR)</li>
 </ul>

 <li>A hint comment have to be placed after the first word in a query
     as the following since preceding comments are not sent as a part
     of the query.</li>
</ul>
<pre>
postgres=# CREATE FUNCTION hints_func(integer) RETURNS integer AS $$
postgres$# DECLARE
postgres$#     id  integer;
postgres$#     cnt integer;
postgres$# BEGIN
postgres$#     SELECT <b><u>/*+ NoIndexScan(a) */</u></b> aid
postgres$#         INTO id FROM pgbench_accounts a WHERE aid = $1;
postgres$#     SELECT <b><u>/*+ SeqScan(a) */</u></b> count(*)
postgres$#         INTO cnt FROM pgbench_accounts a;
postgres$#     RETURN id + cnt;
postgres$# END;
postgres$# $$ LANGUAGE plpgsql;
</pre>
</dd>

<h3>Letter case in a hinted object</h3>
<dd>Unlike the way PostgreSQL handles object names, pg_hint_plan compares bare object names in hints against the database internal object names in case sensitive way. Therefore an object name TBL in a hint matches only "TBL" in database and does not match any unquoted names like TBL, tbl or Tbl.
</dd>

<h3>Escaping special chacaters in object names</h3>
<dd>The objects as the hint parameter should be enclosed by double quotes if they includes parentheses, double quotes and white spaces. The escaping rule is the same as PostgreSQL.
</dd>

<h3>Distinction between multiple occurances of a table</h3>
<dd>pg_hint_plan identifies the target object by using aliases if
exists. This behavior is usable to point a specific occurance
among multiple occurances of one table.
<pre>
<b>postgres=# /*+ HashJoin(t1 t1) */</b>
<b>postgres-#</b> EXPLAIN SELECT * FROM s1.t1
<b>postgres-#</b> JOIN public.t1 ON (s1.t1.id=public.t1.id);
INFO:  hint syntax error at or near "HashJoin(t1 t1)"
<b><u>DETAIL:  Relation name "t1" is ambiguous.</u></b>
...
<b>postgres=# /*+ HashJoin(pt st) */</b>
<b>postgres-#</b> EXPLAIN SELECT * FROM s1.t1 st
<b>postgres-#</b> JOIN public.t1 pt ON (st.id=pt.id);
                             QUERY PLAN
---------------------------------------------------------------------
 <span class="strong">Hash Join</span>  (cost=64.00..1112.00 rows=28800 width=8)
   Hash Cond: (st.id = pt.id)
   ->  Seq Scan on t1 st  (cost=0.00..34.00 rows=2400 width=4)
   ->  Hash  (cost=34.00..34.00 rows=2400 width=4)
         ->  Seq Scan on t1 pt  (cost=0.00..34.00 rows=2400 width=4)
</pre>
</dd>

<h3>Underlying tables of views or rules</h3>
<dd>Hints are not applicable on views itself, but they can affect the
queries within if the object names match the object names in the
expanded query on the view. Assigning aliases to the tables in a view
enables them to be manipulated from outside the view.
<pre>
<b>postgres=#</b> CREATE VIEW v1 AS SELECT * FROM <b><u>t2</u></b>;
<b>postgres=#</b> EXPLAIN <b>/*+ HashJoin(t1 v1) */</b>
          SELECT * FROM t1 JOIN v1 ON (c1.a = v1.a);
                            QUERY PLAN                            
------------------------------------------------------------------
 Hash Join  (cost=3.27..18181.67 rows=101 width=8)
   Hash Cond: (t1.a = t2.a)
   ->  Seq Scan on t1  (cost=0.00..14427.01 rows=1000101 width=4)
   ->  Hash  (cost=2.01..2.01 rows=101 width=4)
         ->  Seq Scan on t2  (cost=0.00..2.01 rows=101 width=4)
</pre>
</dd>

<h3>Inheritance tables</h3>
<dd>Hints can point only the parent of an inheritance tables and the
hint affect all the inheritance. Hints simultaneously point directly
to children are not in effect.
</dd>

<h3>Hinting on multistatements</h3>
<dd>One multistatement can have exactly one hint comment and the hints affects all of the individual statement in the multistatement. Notice that the seemingly multistatement on the interactive interface of psql is internally a sequence of single statements so hints affects only on the statement just following.</dd>

<h3>VALUES expressions</h3>
<dd>VALUES expressions in FROM clause are named as *VALUES* internally
so it is hintable if it is the only VALUES in a query. Two or more
VALUES expressions in a query seems distinguishable looking its
explain result. But in reality it is mere a cosmetic and they are not
distinguisable.
<pre>
<b>postgres=# /*+ MergeJoin(*VALUES*_1 *VALUES*) */</b>
      EXPLAIN SELECT * FROM (VALUES (1, 1), (2, 2)) v (a, b)
      JOIN (VALUES (1, 5), (2, 8), (3, 4)) w (a, c) ON v.a = w.a;
INFO:  pg_hint_plan: hint syntax error at or near "MergeJoin(*VALUES*_1 *VALUES*) "
<b><u>DETAIL:  Relation name "*VALUES*" is ambiguous.</u></b>
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Hash Join  (cost=0.05..0.12 rows=2 width=16)
   Hash Cond: ("*VALUES*_1".column1 = "*VALUES*".column1)
   ->  Values Scan on "*VALUES*_1"  (cost=0.00..0.04 rows=3 width=8)
   ->  Hash  (cost=0.03..0.03 rows=2 width=8)
         ->  Values Scan on "*VALUES*"  (cost=0.00..0.03 rows=2 width=8)
</pre>
</dd>

<h3>Subqueries</h3>
<dd>
<p>Subqueries in the following context occasionally can be hinted using the
name "ANY_subquery".</p>
<pre>
IN (SELECT ... {<b>LIMIT | OFFSET</b> ...} ...)
= ANY (SELECT ... {<b>LIMIT | OFFSET</b> ...} ...)
= SOME (SELECT ... {<b>LIMIT | OFFSET</b> ...} ...)
</pre>
<p>For these syntaxes, planner internally assigns the name to the subquery when planning joins on tables including it, so join hints are applicable on such joins using the implicit name as the following.</p>
<pre>
<b>postgres=# /*+HashJoin(a1 ANY_subquery)*/</b>
<b>postgres=#</b> EXPLAIN SELECT *
<b>postgres=#</b>    FROM pgbench_accounts a1
<b>postgres=#</b>   WHERE aid IN (SELECT bid FROM pgbench_accounts a2 LIMIT 10);
                                         QUERY PLAN

---------------------------------------------------------------------------------------------
 <b><u>Hash Semi Join</u></b>  (cost=0.49..2903.00 rows=1 width=97)
   Hash Cond: (a1.aid = a2.bid)
   ->  Seq Scan on pgbench_accounts a1  (cost=0.00..2640.00 rows=100000 width=97)
   ->  Hash  (cost=0.36..0.36 rows=10 width=4)
         ->  Limit  (cost=0.00..0.26 rows=10 width=4)
               ->  Seq Scan on pgbench_accounts a2  (cost=0.00..2640.00 rows=100000 width=4)
</pre>
</dd>

<h3>Using IndexOnlyScan hint</h3>
<dd>An additional hint to enforce an index that can perform index only scan is required for IndexOnlyScan hint to work when any index that can not perform index only scan is also defined on the same table. </dd>

<h3>Behavior of NoIndexScan</h3>
<dd>NoIndexScan hint involes NoIndexOnlyScan.</dd>

<h3>Parallel hint and UNION</h3>
<dd>A UNION can run in parallel only when all underlying subqueries
are parallel-safe. Conversely enforcing parallel on any of
the subqueries let a parallel-executable UNION run in
parallel. Meanwhile, a parallel hint with zero workers hinhibits a scan
from executed in parallel.</dd>

<h3>Setting pg_hint_plan parameters by Set hints</h3>
<dd><p>pg_hint_plan paramters change the behavior of itself so some parameters doesn't work as expected.</p>
<ul>
<li>Hints to change enable_hint, enable_hint_tables are ignored even though they are reported as "used hints" in debug logs.</li>
<li>Setting debug_print and message_level works from midst of the processing of the target query.</li>
</ul>
</dd>


<h2 id="errors">Errors</h2>
<p>pg_hint_plan stops parsing on any error and uses hints already parsed on the most cases. Followings are the typical errors.</p>
<h3>Syntax errors </h3>
<p>Any syntactical errors or wrong hint names are reported as an syntax error. These errors are reported in the server log with the message level which specified by pg_hint_plan.message_level if pg_hint_plan.debug_print is on and aboves.</p>
<h3>Object misspecifications</h3>
<p>Object misspecifications results silent ingorance of the hints. This kind of error is reported as "not used hints" in the server log by the same condtion to syntax errors.</p>

<h3>Redundant or conflicting hints</h3>
<p>The last hint will be active when redundant hints or hints conflicting with each other. This kind of error is reported as "duplication hints" in the server log by the same condition to syntax errors.</p>

<h3>Nested comments</h3>
<p>Hint comment cannot include another block comment within. If pg_hint_plan finds it, differently from other erros, it stops parsing and abandans all hints already parsed. This kind of error is reported in the same manner as other errors. </p>

<h2 id="func_limits">Functional limitations</h2>
<h3>Influences of some of planner GUC parameters</h3>
<p>The planner does not try to consider joining order for FROM clause entries more than from_collapse_limit. pg_hint_plan cannot affect joining order as expected for the case.</p>

<h3>Cases that pg_hint_plan essentially does not work </h3>
<p>By the nature of pg_hint_plan, it cannot affect some cases that out of scope of the planner like following.</p>
<ul>
<li>FULL OUTER JOIN to use nested loop</li>
<li>To use indexes that does not have columns used in quals</li>
<li>To do TID scans for queries without ctid conditions</li>
</ul>

<h3>Queries in ECPG</h3>
<p>ECPG removes comments in queries written as embedded SQLs so hints cannot be passed form those queries. The only exception is that EXECUTE command passes given string unmodifed. Please consider hint tables for this case.</p>

<h3>Work with pg_stat_statements</h3>
<p>pg_stat_statements generates a query id ignoring comments. As the result the identical queires with different hints are summerized as the same query.</p>

<h2 id="requirement">Requirements</h2>
pg_hint_plan 1.2 requires PostgreSQL 9.6.
<dl>
<dt>PostgreSQL versions tested</dt>
  <dd>Version 9.6</dd>
<dt>OS versions tested</dt>
  <dd>RHEL 7.2</dd>
</dl>

<h2 id="seealso">See also</h2>
<h3 id="postgresql_document">PostgreSQL documents</h3>
<a href="http://www.postgresql.org/docs/current/static/sql-explain.html">EXPLAIN</a>
<a href="http://www.postgresql.org/docs/current/static/sql-set.html">SET</a>
<a href="http://www.postgresql.org/docs/current/static/runtime-config.html">Server Config</a>
<a href="http://www.postgresql.org/docs/current/static/parallel-plans.html">Parallel Plans</a>
<hr>

<div class="navigation">
  <a href="pg_hint_plan.html">pg_hint_plan</a>
</div>

<p class="footer">Copyright (c) 2012-2017, NIPPON TELEGRAPH AND TELEPHONE CORPORATION</p>
</body>
</html>
